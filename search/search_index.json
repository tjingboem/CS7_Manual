{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Csound 7 Manual Introduction!","text":"<p>This is a draft for a new introduction of the Canonical Csound Reference Manual, possibly replacing the Preface and the Overview of the old version.</p>"},{"location":"intro-copyright-notice/","title":"Copyright Notice","text":"<p>This version of the Csound Manual (\"The Canonical Csound Manual\") is released under the GNU Free Documentation Licence. Below are listed, for historical purposes, previous copyrights and requests for credit from previous authors.</p>"},{"location":"intro-copyright-notice/#previous-manual-copyright-notices","title":"Previous Manual Copyright Notices","text":"<p>Copyright (c) 1986, 1992 by the Massachusetts Institute of Technology. All rights reserved.</p> <p>Copyright (c) 2003 by Kevin Conder for modifications made to the Public Csound Reference Manual.</p> <p>Copyright 2004-2005 by Michael Gogins for modifications made to the Alternative Csound Reference Manual.</p>"},{"location":"intro-copyright-notice/#csound","title":"Csound","text":"<p>Csound is copyright 1991-2025 by Barry Vercoe, John ffitch and others.</p> <p>Csound is free software; you can redistribute them and/or modify them under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>Csound is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with Csound and CsoundAC; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</p>"},{"location":"intro-historic-preface/","title":"Historical Preface by Berry Vercoe","text":"<p>Realizing music by digital computer involves synthesizing audio signals with discrete points or samples representative of continuous waveforms. There are many ways to do this, each affording a different manner of control. Direct synthesis generates waveforms by sampling a stored function representing a single cycle; additive synthesis generates the many partials of a complex tone, each with its own loudness envelope; subtractive synthesis begins with a complex tone and filters it. Non-linear synthesis uses frequency modulation and waveshaping to give simple signals complex characteristics, while sampling and storage of a natural sound allows it to be used at will.</p> <p>Since comprehensive moment-by-moment specification of sound can be tedious, control is gained in two ways: 1) from the instruments in an orchestra, and 2) from the events within a score. An orchestra is really a computer program that can produce sound, while a score is a body of data which that program can react to. Whether a rise-time characteristic is a fixed constant in an instrument, or a variable of each note in the score, depends on how the user wants to control it.</p> <p>The instruments in a Csound orchestra (see Syntax of the Orchestra) are defined in a simple syntax that invokes complex audio processing routines. A score (see The Standard Numeric Score) passed to this orchestra contains numerically coded pitch and control information, in standard numeric score format. Although many users are content with this format, higher level score processing languages are often convenient.</p> <p>The programs making up the Csound system have a long history of development, beginning with the Music 4 program written at Bell Telephone Laboratories in the early 1960's by Max Mathews. That initiated the stored table concept and much of the terminology that has since enabled computer music researchers to communicate. Valuable additions were made at Princeton by the late Godfrey Winham in Music 4B; my own Music 360 (1968) was very indebted to his work. With Music 11 (1973) I took a different tack: the two distinct networks of control and audio signal processing stemmed from my intensive involvement in the preceding years in hardware synthesizer concepts and design. This division has been retained in Csound.</p> <p>Because it is written entirely in C, Csound is easily installed on any machine running Unix or C. At MIT it runs on VAX/DECstations under Ultrix 4.2, on SUNs under OS 4.1, SGI's under 5.0, on IBM PC's under DOS 6.2 and Windows 3.1, and on the Apple Macintosh under ThinkC 5.0. With this single language for defining the audio signal processing, and portable audio formats like AIFF and WAV, users can move easily from machine to machine.</p> <p>The 1991 version added phase vocoder, FOF, and spectral data types. 1992 saw MIDI converter and control units, enabling Csound to be run from MIDI score-files and external keyboards. In 1994 the sound analysis programs (lpc, pvoc) were integrated into the main load module, enabling all Csound processing to be run from a single executable, and Cscore could pass scores directly to the orchestra for iterative performance. The 1995 release introduced an expanded MIDI set with MIDI-based linseg, butterworth filters, granular synthesis, and an improved spectral-based pitch tracker. Of special importance was the addition of run-time event generating tools (Cscore and MIDI) allowing run-time sensing and response setups that enable interactive composition and experiment. It appeared that real-time software synthesis was now showing some real promise.</p>"},{"location":"intro-history-of-the-manual/","title":"History of the Canonical Csound Reference Manual","text":"<p>Csound is a unit generator-based, user-programmable computer music system. It was originally written by Barry Vercoe at the Massachusetts Institute of Technology in 1984 as the first C language version of this type of software. Since then, Csound has received numerous contributions from researchers, programmers and musicians from around the world.</p> <p>The initial version of this manual for early versions of Csound was started at MIT by Barry L. Vercoe and maintained there during the 1980's and start of the 1990's. Parts of the manual come from documents for programs like Music11 from the 1970's. This original manual was improved and worked on by Richard Boulanger, John ffitch, Jean Pich\u00e9 and Rasmus Ekman.</p> <p>This manual led to the Official Csound Reference Manual. Version 3.47 is still accessible at Cecilia's Sourceforge repository. Version 4.10, maintained by David M. Boothe, is accessible at MIT archive.</p> <p>A parallel version of the manual called the Alternative Csound Reference Manual, was developed by Kevin Conder using DocBook/SGML. This version later became the Canonical version.</p> <p>When Csound was licenced as LGPL by MIT in 2003, the manual was licenced GFDL and placed on Sourceforge along with the sources of Csound.</p> <p>In the winter of 2004, the Canonical Manual was converted to DocBook/XML by Steven Yi to allow for more people to be able to compile and maintain the manual.</p> <p>The manual is currently maintained by Fran\u00e7ois Pinot, Menno Knevel, Joachim Heintz and the core developers, with continuous contributions from the Csound Community. The French version of the manual is maintained by Fran\u00e7ois Pinot.</p> <p>The manual continues to be a community run project that depends on the contributions of developers and users to help refine the coverage and accuracy of its contents. All contributions are welcome and appreciated.</p> <p>This is a list of past contributions which is by no means complete. More information can be gathered from the Changelog file in the manual's sources repository. </p> <p>Mike Berry, Richard Boulanger, David M. Booth, Oeyvind Brandtsegg, Eli Breder, Andr\u00e9s Cabrera, Michael Casey, Michael Clark, Kevin Conder, Perry Cook, Sean Costello, Stefano Cucchi, Richard Dobson, Mark Dolson, Gareth Edwards, Rasmus Ekman, Dan Ellis, Tom Erbe, John ffitch, Bill Gardner, Michael Gogins, Joachim Heintz, Matt Ingalls, Richard Karpen, Menno Knevel, Anthony Kozar, Victor Lazzarini, Allan Lee, David Macintyre, Gabriel Maldonado, Max Mathews, Hans Mikelson, Peter Neub\u00e4cker, Peter Nix, Jean Pich\u00e9, Fran\u00e7ois Pinot, Ville Pulkki, Maurizio Umberto Puxeddu, John Ramsdell, Marc Resibois, Felipe Sateler, Rob Shaw, Paris Smaragdis, Greg Sullivan, Istvan Varga, Bill Verplank, Kevi Welsh, Robin Whittle, Steven Yi</p>"},{"location":"intro-whats-new-in-csound-7/","title":"What's new in Csound 7","text":"<p>Csound 7 brings major changes which offer new possibilities for users and modernize coding. Nevertheless Csound 7 keeps backwards compatibility: Despite new syntax features any valid Csound code from the past can be run without any code change.</p>"},{"location":"intro-whats-new-in-csound-7/#explicit-variable-types","title":"Explicit Variable Types","text":"<p>Variable names no longer have to start with <code>i</code>, <code>k</code>, <code>a</code> etc. to declare their data type implicitely. Instead any name (except existing opcodes or keywords) can be used, and the type declared explicitely:</p> Explicit Varaible Types<pre><code>maxamp@global:i = 0dbfs / 5\n\ninstr 1\n  freq:i = 444\n  ramp:k = linseg(maxamp,p3,0)\n  sound:a = poscil(ramp,freq)\n  outall(sound)\nendin\nschedule(1,0,2)\n</code></pre>"},{"location":"intro-whats-new-in-csound-7/#new-udo-syntax-and-pass-by-reference","title":"New UDO Syntax and Pass-by-reference","text":"<p>User Defined Opcodes now follow the syntax <code>opcode name(inargs):(outargs)</code>. </p> <pre><code>opcode myop(inval:i):(i)\n  xout(inval+1)\nendop\n\nopcode empty():void\n  puts(\"empty!\",1)\nendop\n\ninstr 1\n  print(myop(17))\n  empty()\nendin\nschedule(1,0,0)\n</code></pre> <p>Give example for pass-by-reference ...</p>"},{"location":"intro-whats-new-in-csound-7/#removed-limitations-for-functional-style","title":"Removed Limitations for Functional Style","text":"<p>Multiple output arguments can now be used in functional style, e.g.</p> <pre><code>nchnls = 2\ninstr 1\n  sig:a = rand(0dbfs/10)\n  aL,aR = pan2(sig,3/4)\n  out(aL,aR)\nendin\nschedule(1,0,1)\n</code></pre>"},{"location":"intro-whats-new-in-csound-7/#for-loop","title":"For-Loop","text":"<p>Is it going to happen??</p>"},{"location":"intro-whats-new-in-csound-7/#user-defined-types","title":"User-Defined Types","text":"<pre><code>struct MyType val0:i, val1:i\n\ninstr 1\ntestVal:MyType init 8, 88\nprint(testVal.val0)\nprint(testVal.val1)\nendin\nschedule(1,0,0)\n</code></pre>"},{"location":"invoke-cs-options-alphabetically/","title":"Csound options (flags) alphabetically","text":"<p>this should (except the introductory lines) straightaway use https://csound.com/manual/CommandFlags.html</p>"},{"location":"invoke-cs-options-by-category/","title":"Csound options (flags) by category","text":"<p>this should (except the introductory lines) straightaway use https://csound.com/manual/CommandFlagsCategory.html</p>"},{"location":"invoke-environment-variables/","title":"Environment variables","text":"<p>The following environment variables ARE AVAILABLE:</p> <ul> <li>SFDIR: Default directory for rendered sound files. Used if no full path is given for output sound files.  </li> <li>SSDIR: Default directory for input (source) audio and MIDI files. Used if no full path is given for sound files. May be used in conjunction with SFDIR to set separate input and output directories. Please note that MIDI files as well as audio files are also sought inside SSDIR.  </li> <li>SADIR: Default directory for analysis files. Used if no full path is given for analysis files.  </li> <li>SFOUTYP: Sets the default output file type. Currently only 'WAV', 'AIFF' and 'IRCAM' are valid. This flag is checked by the csound executable and the utilities and is used if no file output type is specified.  </li> <li>INCDIR: Include directory. Specifies the location of files used by #include statements.  </li> <li>OPCODE7DIR: Defines the location of csound opcode plugins for the single precision float (32-bit) version.  </li> <li>OPCODE7DIR64: Defines the location of csound opcode plugins for the double precision float (64-bit) version.  </li> <li>SNAPDIR: Is used by the FLTK widget opcodes when loading and saving snapshots (deprecated).  </li> <li>CSOUND7RC: Defines the csound resource (or configuration) file. A full path and filename containing csound flags must be specified. This variable defaults to .csound7rc if not present.  </li> <li>CSSTRNGS: In Csound 5.00 and later versions, the localisation of messages is controlled by two environment variables CSSTRNGS and CS_LANG, both of which are optional. CSSTRNGS points to a directory containing .xmg files.  </li> <li>CS_LANG: Selects a language for csound messages.  </li> <li>RAWWAVE_PATH: Is used by the STK opcodes to find the raw wave files. Only relevant if you are using STK wrapper opcodes like STKBowed or STKBrass.  </li> <li>CSNOSTOP: If this environment variable is set to \"yes\", then any graph displays are closed automatically at the end of performance (meaning that you possibly will not see much of them in the case of a short non-realtime render). Otherwise, you need to click \"Quit\" in the FLTK display window to exit, allowing for viewing the graphs even after the end of score is reached.  </li> <li>MFDIR: Default directory for MIDI files. Used if no full path is given for MIDI files. Please note that MIDI files are sought in SSDIR and SFDIR as well.  </li> <li>CS_OMIT_LIBS: Allows defining a list of plugin libraries that should be skipped. Libraries can be separated with commas, and don't require the \"lib\" prefix.</li> </ul> <p>The only mandatory environment variables are OPCODE7DIR and OPCODE7DIR64. It is very important to set them correctly, otherwise most of the opcodes will not be available. Make sure you set the path correctly depending on the precision of your binary. (Nowadays it will almost always be 64 bit, so OPCODE7DIR64.)</p> <p>Other environment variables which are not exclusive to Csound but which might be of importance are:</p> <ul> <li>PATH: The directory containing csound executables should be listed in this variable.  </li> <li>LADSPA_PATH and DSSI_PATH: These environment variables are required if you are using the dssi4cs (LADSPA and DSSI host) plug-in opcodes.  </li> <li>CSDOCDIR: Specifies the directory where the html help files are located. Though not used by Csound directly, this environment variable can help front-ends and editors (which implement it) to find the csound manual.</li> </ul> <p>Environment variables can be set as options by using the command line flag <code>--env:NAME=VALUE</code> or <code>--env:NAME+=VALUE</code>, where NAME is the environment variable name, and VALUE is its value. They can also be set in the configuration file .csound7rc.</p> <p>Note that this method of setting environment variables will not work for variables which are parsed before the command line arguments. SADIR, SSDIR, SFDIR, INCDIR, SNAPDIR, RAWWAVE_PATH, CSNOSTOP, SFOUTYP should work, but the following environment variables must be set on the system prior to running csound: OPCODE6DIR, OPCODE6DIR64, CSSTRINGS, and CS_LANG.</p>"},{"location":"invoke-how-csound-works/","title":"How Csound works","text":"<p>Csound processes and generates output using \"unit generators\" (ugens) called opcodes. These opcodes are used to define instruments in the orchestra. When you run Csound, the engine loads the base Opcodes, and the opcodes contained in separate loadable \"opcode libraries\" . It then interprets the orchestra (through the orchestra reader). The engine sets up an instrument processing chain, which then receives events from the score or in real-time. The processing chain uses the input/output modules to generate output. There are modules that can write to file, or generate real-time audio and/or midi output.</p> <p></p>"},{"location":"invoke-how-csound-works/#csounds-processing-buffers","title":"Csound's processing buffers","text":"<p>Csound processes audio in sample blocks called buffers. There are three separate buffer layers:</p> <p>spout = Csound's innermost software buffer, contains <code>ksmps</code> sample frames. Csound processes real-time control events once every ksmps sample frames.</p> <p>-b = Csound's intermediate software buffer (the \"software\" buffer), in sample frames. Should be (but does not need to be) Menno:??? Preferable or Usually ??? an integral multiple of ksmps (can be equal to ksmps, too). Once per ksmps sample frames, Csound copies spout to the -b buffer. Once per -b sample frames, Csound copies the -b buffer to the -B \"hardware\" buffer.</p> <p>-B = The sound card's internal buffer (the \"hardware\" buffer), in sample frames. Should be (and may need to be) ??? do not understand - delete this becuase confusing?? an integral multiple of -b. If Csound misses delivering a -b one time, the extra -b sample frames in -b are still there for the sound card to keep playing while Csound catches up. But they can be of the same size if you're willing to bet Csound can always keep up with the sound card.</p>"},{"location":"invoke-order-of-precedence/","title":"Order of precedence","text":"<p>There are five places where options for Csound performance may be set. They are processed in the following order:</p> <ol> <li>Csound's own defaults  </li> <li>File defined by the <code>CSOUND7RC</code> environment variable, or <code>.csound7rc</code> file in the HOME directory  </li> <li>A <code>.csound7rc</code> file in the current directory  </li> <li>The <code>&lt;CsOptions&gt;</code> tag in a <code>.csd</code> file  </li> <li>Passed on the Csound command line</li> </ol> <p>The later options in the list will override any earlier ones. As of version 5.01 of Csound, sample and control rate override flags (-r and -k) specified anywhere override sr, kr, and ksmps defined in the orchestra header.</p>"},{"location":"invoke-the-csd-file-format/","title":"The <code>.csd</code>file format","text":"<p>The Unified File Format enables the orchestra and score files, as well as command line flags, to be combined in one file. The file has the extension <code>.csd</code>.</p> <p>The file is a structured data file which uses markup language, similar to any SGML (Standard Generalized Markup Language) such as HTML. Start tags (<code>&lt;tag&gt;</code>) and end tags (<code>&lt;/tag&gt;</code>) are used to delimit the various elements. The file is saved as a text file.</p>"},{"location":"invoke-the-csd-file-format/#main-elements","title":"Main Elements","text":""},{"location":"invoke-the-csd-file-format/#enclosing-tag-csoundsynthesizer","title":"Enclosing tag <code>&lt;CsoundSynthesizer&gt;</code>","text":"<p>The first tag in the file must be the start tag <code>&lt;CsoundSynthesizer&gt;</code>. The last tag in the file must be the end tag <code>&lt;/CsoundSynthesizer&gt;</code>. This element is used to alert the csound compiler to the .csd format. All text before the start tag and after the end tag is ignored by Csound. The tag may also be spelled <code>&lt;CsoundSynthesiser&gt;</code>.</p>"},{"location":"invoke-the-csd-file-format/#options-csoptions","title":"Options <code>&lt;CsOptions&gt;</code>","text":"<p>Csound command line flags are put in the Options element. This section is delimited by the start tag <code>&lt;CsOptions&gt;</code> and the end tag <code>&lt;/CsOptions&gt;</code>. Lines beginning with <code>;</code> or <code>//</code> or <code>#</code> are treated as comments.</p> <p>If the Options element is missing, the default options will be used:</p> <p><code>-s -otest -b1024 -B1024 -m7 -P128</code></p>"},{"location":"invoke-the-csd-file-format/#orchestra-csinstruments","title":"Orchestra <code>&lt;CsInstruments&gt;</code>","text":"<p>The instrument definitions (orchestra) are put into the Instruments element. The statements and syntax in this section are identical to the Csound orchestra file, and have the same requirements. This Instruments Element is delimited with the start tag <code>&lt;CsInstruments&gt;</code> and the end tag <code>&lt;/CsInstruments&gt;</code>.</p> <p>Usually the <code>CsInstruments</code> tag starts with a declaration of the fundamental constants <code>sr</code> (sample rate, default 44100), <code>ksmps</code> (number of samples per control cycle, default 10, recommended 32 or 64), <code>nchnls</code> (number of channels, default 10) and <code>0dbfs</code> (amplitude value equal to zero dB full scale, default 32767, recommended 1). </p>"},{"location":"invoke-the-csd-file-format/#score-csscore","title":"Score <code>&lt;CsScore&gt;</code>","text":"<p>Csound score statements are put in the Score element. The statements and syntax in this section are identical to the Csound score file, and have the same requirements. The Score Element is delimited by the start tag <code>&lt;CsScore&gt;</code> and the end tag <code>&lt;/CsScore&gt;</code>.</p> <p>As an alternative Csound score, statements can also be generated by an external program using the CsScore scheme with an attribute bin. The lines upto the closing tag <code>&lt;/CsScore&gt;</code> are copied to a file and the external program named is called with that file name and the destination score file. The external program should create a standard Csound score.</p> <p>If the Score Element is missing, the score will be considered as being empty, thus causing Csound to run without a distinct termination.</p>"},{"location":"invoke-the-csd-file-format/#optional-elements","title":"Optional Elements","text":""},{"location":"invoke-the-csd-file-format/#included-base64-files-csfileb","title":"Included Base64 Files <code>&lt;CsFileB&gt;</code>","text":"<p>Base64-encoded files may be included with the tag <code>&lt;CsFileB filename=myfile&gt;</code>, where myfile is the name of the file to be included. The Base64-encoded data should be terminated with a <code>&lt;/CsFileB&gt;</code> tag. For encoding files, the <code>csb64enc</code> and <code>makecsd</code> utilities can be used. The file will be extracted to the current directory, and deleted at end of performance. If there is an already existing file with the same name, it is not overwritten, but an error will occur instead.</p> <p>Base64-encoded MIDI files may be included with the tag <code>&lt;CsMidifileB filename=myfile&gt;</code>, where myfile is the name of the file containing the MIDI information. There is no matching end tag. Note: using this tag is not recommended; use <code>&lt;CsFileB&gt;</code> instead.</p> <p>Base64-encoded sample files may be included with the tag <code>&lt;CsSampleB filename=myfile&gt;</code>, where myfile is the name of the file containing the sample. There is no matching end tag. Note: using this tag is not recommended; use <code>&lt;CsFileB&gt;</code> instead.</p>"},{"location":"invoke-the-csd-file-format/#included-unencoded-files-csfile","title":"Included Unencoded Files <code>&lt;CsFile&gt;</code>","text":"<p>Unencoded files may be included with the tag <code>&lt;CsFile filename=myfile&gt;</code>, where myfile is the name of the file to be included. The data should be terminated with a <code>&lt;/CsFile&gt;</code> tag alone on a line. The file will be extracted to the current directory, and deleted at end of performance. If there is an already existing file with the same name, it is not overwritten, but an error will occur instead.</p>"},{"location":"invoke-the-csd-file-format/#version-blocking-csversion","title":"Version Blocking <code>&lt;CsVersion&gt;</code>","text":"<p>Versions of Csound are blocked by placing one of the following statements between the start tag <code>&lt;CsVersion&gt;</code> and the end tag <code>&lt;/CsVersion&gt;</code>:</p> <p><code>Before #.#</code></p> <p>or</p> <p><code>After #.#</code></p> <p>where #.# is the requested Csound version number. The second statement may be written simply as:</p> <p><code>#.#</code></p>"},{"location":"invoke-the-csd-file-format/#licence-information-cslicence-or-cslicense","title":"Licence Information <code>&lt;CsLicence&gt;</code> or <code>&lt;CsLicense&gt;</code>","text":"<p>Licencing details can be included in between the start tag <code>&lt;CsLicence&gt;</code> and the end tag <code>&lt;/CsLicence&gt;</code>. There is no format for this information, any text is acceptable. This text will be printed by Csound to the console when the CSD is run.</p>"},{"location":"invoke-the-csd-file-format/#short-licence-information-csshortlicence-or-csshortlicense","title":"Short Licence Information <code>&lt;CsShortLicence&gt;</code> or <code>&lt;CsShortLicense&gt;</code>","text":"<p>From version 6.05 licencing details can be also included in between the start tag <code>&lt;CsShortLicence&gt;</code> and the end tag <code>&lt;/CsShortLicence&gt;</code>. This offers seven well-known licences, coded as as an integer.</p> <p>0: \"All rights reserved\" (default) 1: \"Creative Commons Attribution-NonCommercial-NoDerivatives (CC BY-NC-ND)\" 2: \"Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA)\" 3: \"Creative Commons Attribution-NonCommercial (CC BY-NC)\" 4: \"Creative Commons Attribution-NoDerivatives (CC BY-ND)\" 5: \"Creative Commons Attribution-ShareAlike (CC BY-SA)\" 6: \"Creative Commons Attribution-ShareAlike (CC BY)\" 7: \"Licenced under BSD\"</p>"},{"location":"invoke-the-csd-file-format/#embedded-html-html","title":"Embedded HTML <code>&lt;html&gt;</code>","text":"<p>Any valid HTML code can be embedded in the CSD file. This code should be structured exactly like an ordinary Web page. This code can contain any valid HTML, JavaScript, Cascading Style Sheet, WebGL, etc., etc. code.</p> <p>In some Csound front ends and programming environments, including at least CsoundQt or Csound for Android, this page will be parsed, executed, and displayed by a Web browser embedded in the environment. JavaScript code in this page will have access to a global csound object that implements the following functions, which are a selected subset of the Csound API. The names, data types, and uses of these functions are exactly the same as detailed in the Csound API Reference Manual.</p> <pre><code>[int] getVersion ();\ncompileOrc (orchestra_text);\n[double] evalCode (orchestra_expression);\nreadScore (score_text);\nsetControlChannel (channel_name, numeric_value);\n[double] getControlChannel (channel_name);\nmessage (message_string);\n[int] getSr ();\n[int] getKsmps ();\n[int] getNchnls ();\n// Not a part of the Csound API -- called by the environment to detect whether Csound is running.\n[int] isPlaying ();\n</code></pre>"},{"location":"invoke-the-csd-file-format/#cabbage-cabbage","title":"Cabbage <code>&lt;Cabbage&gt;</code>","text":"<p>This is a tag which is used by the Cabbage frontend for its Graphical User Interface.</p>"},{"location":"invoke-the-csound-command/","title":"The <code>csound</code> command","text":"<p>When Csound is installed, the command <code>csound</code> serves as a basic frontend which can be invoked from a Terminal or DOS window. The syntax is</p> <p><code>csound [options] .csd_file</code></p> <p>or </p> <p><code>csound [options] .orc_file .sco_file</code></p> <p>Rather than options the term flags is used frequently.</p> <p>This command will execute the file \"test.csd\" (located in the current directory) and write the audio output to the digital-to-analog converter in real time:</p> <p><code>csound -o dac test.csd</code></p> <p>This command will execute the file \"bla.csd\" in the parent directory and render the output to the 32-bit floating-point sound file \"bla.wav\":</p> <p><code>csound -o bla.wav -f ../bla.csd</code></p> <p>All options are listed in Options Alphabetically or Options by Category.</p>"},{"location":"misc-links/","title":"Links","text":"<p>The Csound Community Homepage is csound.com. We try to keep links updated there, so only few main links are given here.</p> <ul> <li>Download Page </li> <li>Get Help / Lists and Forums </li> <li>Csound FLOSS Manual </li> <li>Csound Sources </li> <li>Csound Manual Sources </li> <li>Csound API Documentation </li> <li>Csound API Examples</li> </ul>"},{"location":"misc-nomenclature/","title":"Nomenclature","text":"<p>Throughout this manual, opcodes are indicated in boldface and their argument and result mnemonics, when mentioned in the text, are given in italics. Argument names are generally mnemonic (amp, phs), and the result is usually denoted by the letter <code>r</code>. Both are preceded by a type qualifier <code>i</code>, <code>k</code>, <code>a</code>, or <code>x</code> (e.g. <code>kamp</code>, <code>iphs</code>, <code>ar</code>, <code>xphs</code>). The prefix <code>i</code> denotes scalar values valid at note init time; prefixes <code>k</code> or <code>a</code> denote control (scalar) and audio (vector) values, modified and referenced continuously throughout performance (i.e. at every control period while the instrument is active). Arguments are used at the prefix-listed times; results are created at their listed times, then remain available for use as inputs elsewhere. With few exceptions, argument rates may not exceed the rate of the result. The validity of inputs is defined by the following:</p> <ul> <li>arguments with prefix <code>i</code> must be valid at init time;  </li> <li>arguments with prefix <code>k</code> can be either control or init values (which remain valid);  </li> <li>arguments with prefix <code>a</code> must be audio vector inputs;  </li> <li>arguments with prefix <code>x</code> may be either vector or scalar (the compiler will distinguish).</li> </ul> <p>All arguments, unless otherwise stated, can be expressions whose results conform to the above. Most opcodes (such as <code>linen</code> and <code>oscili</code>) can be used in more than one mode, which one being determined by the prefix of the result symbol.</p> <p>Thoughout this manual, the term \"opcode\" is used to indicate a command that usually produces an a-, k-, i-rate output, and always forms the basis of a complete Csound orchestra statement. Items such as <code>+</code> or <code>sin(x)</code> or, <code>( a &gt;= b ? c : d)</code> are called \"operators\".</p>"},{"location":"misc-rt-audio/","title":"Real-Time Audio","text":"<p>content of https://csound.com/manual/UsingRealTime.html can go here</p>"},{"location":"misc-udp-server/","title":"UDP Server","text":"<p>the excellent https://csound.com/manual/udpserver.html goes here</p>"},{"location":"orc-data-types/","title":"Data Types and Variables","text":""},{"location":"orc-data-types/#implicit-types","title":"Implicit Types","text":"<p>Data types in Csound 6 and earlier were declared one of the characters i, k, a, S, w as first character of the variable name. This applied for local variables which are only valid in the scope of an instrument. For global variables these type specifiers were prefixed by the g character.</p> Local Global Data type Updated at Examples i gi number initalization (i-rate) <code>iFreq</code> <code>giTable</code> k gk number control cycle (k-rate) <code>kAmp</code> <code>gkCount</code> a ga number audio sample (a-rate) <code>aOut</code> <code>gaReverb</code> S gS string i-rate or k-rate <code>S_file</code> <code>gS_host</code> f gf spectral k-rate <code>fSig</code> <code>gfSig</code> w - spectral (old) k-rate - i[] gi[] array i-rate <code>iArr[]</code> <code>giArr[]</code> k[] gk[] array k-rate <code>kArr[]</code> <code>gkArr[]</code>"},{"location":"orc-data-types/#explicit-types","title":"Explicit Types","text":"<p>In Csound 7 the data type can be given explicitely, without being bound to the name. </p> <pre><code>nchnls  =   2\n0dbfs   =   1\n\ninstr 1\n  freq:i = 442\n  amp:k = linen:k(1,.1,p3,.1)\n  sine:a = poscil:a(.2,freq)\n  outch(1,sine*amp)\n  dB@global:i = -6\n  env@global:k = linseg(1,p3,0)\n  tri@global:a = vco2(.3,200)\nendin\nschedule(1,0,3)\n\ninstr 2\n  outch(2,tri*ampdb(dB)*env)\nendin\nschedule(2,0,3)\n</code></pre>"},{"location":"orc-data-types/#constants-and-reserved-symbols","title":"Constants and Reserved Symbols","text":"<p>Constants are available continuously and do not change in value. Usually they are connected with reserved symbols and written in the orchestra header:</p> <pre><code>sr = 44100\nksmps = 64\n0dbfs = 1\nnchnls = 2\n</code></pre>"},{"location":"orc-header-statements/","title":"Header Statements and Global Space","text":"<p>The Orchestra Header contains global information that applies to all instruments and defines aspects of Csound's output. It is sometimes referred to as instr 0, because it behaves as an instrument, but without k- or a-rate processing (i.e. only opcodes and instructions that work at i-rate are allowed).</p> <p>The most essential statements given in the orchestra header are:</p> <p><code>sr</code> the sample rate (default 44100) <code>ksmps</code> the number of samples for one control period (default 10) NOTE: It is recommended to specify <code>ksmps</code> and let Csound calculate <code>kr</code>. <code>ksmps</code> must be an integer and should usually be a power of two. <code>nchnls</code> the number of audio channels (default 1) NOTE: This refers to both, output and input channels. Use <code>nchnls_i</code> in case input and output do not have the same number of channels. <code>0dbfs</code> the number which serves as amplitude value for zero dB full scale (default 32768). NOTE: It is recommended to set <code>0dbfs</code> to 1 as this is the standard in all audio applications nowadays.</p> <p>A standard Csound header may look like this:</p> <pre><code>sr = 48000\nksmps = 32\nnchnls = 2\n0dbfs = 1\n</code></pre> <p>Other common header statements:</p> <p><code>nchnls_i</code> the number of input channels (if different from <code>nchnls</code>) <code>A4</code> the frequency set to pitch A4 (default 440) <code>seed</code> sets the global seed for most random generators NOTE: The syntax is <code>seed 0</code> or <code>seed(0)</code> but NOT <code>seed = 0</code> <code>massign</code> assigns incoming midi to a specific instrument <code>pgmassign</code> assigns a MIDI program number to a specific instrument <code>ctrlinit</code> sets the initial values for a set of MIDI controllers <code>ftgen</code> generates a function table</p> <p>The instrument header is part of the global space. This space continues between and after the instrument code, and is evaluated as a whole before any instrument is running. </p> <p>Typical statements in the global space other than the orchestra header are: - User Defined Opcode definitions - Macro definitions - <code>#include</code> statements for external files - setting or initializing global variables, e.g. <code>gaReverb init 0</code> - declaring software channels, e.g. <code>chn_k(\"watchdog\",3)</code> </p>"},{"location":"orc-instruments/","title":"Instruments","text":"<p>Instruments are the main building blocks in Csound. An instrument definition starts with the keyword <code>instr</code>, followed by a space, and a number or name. In case the numbers or names are separated by comma, the same instrument definition applies to different instrument numbers or names. The instrument definition ends with the keywor <code>endin</code>.</p> <pre><code>instr 10\n  puts(\"instrument 10\",1)\nendin\n\ninstr printme\n  puts(\"instrument 'printme'\",1)\nendin\n\ninstr Multiple, 2, 3\n  print(p1)\nendin\n</code></pre>"},{"location":"orc-instruments/#named-instruments","title":"Named Instruments","text":"<p>An instrument name may consist of any number of letters, digits, and the underscore (_) character, however, the first character must not be a digit. Optionally, the instrument name may be prefixed with the '+' character (see below), for example:</p> <p><code>instr +Reverb</code></p> <p>For all instrument names, a number is automatically assigned (note: if the message level (-m) is not zero, these numbers are printed to the console during orchestra compilation), following these rules:</p> <ul> <li>Any unused instrument numbers are taken up in ascending order, starting from 1.  </li> <li>The numbers are assigned in the order of instrument name definition, so named instruments that are defined later will always have a higher number (except if the '+' modifier is used).  </li> <li>If the instrument name was prefixed with '+', the assigned number will be higher than that of any of the (both numbered and named) other instruments without '+'. If there are multiple '+' instruments, the numbering of these will follow the order of definition, according to the above rule.</li> </ul> <p>Using '+' is mainly useful for global output or effect instruments, that must be performed after the other instruments.</p> <p>An example for instrument numbers:</p> <pre><code>instr 1, 2\nendin\n\ninstr Instr1\nendin\n\ninstr +Effect1, Instr2\nendin\n\ninstr 100, Instr3, +Effect2, Instr4, 5\nendin\n</code></pre> <p>In this example, the instrument numbers are assigned as follows:</p> <pre><code>Instr1:  3\nEffect1: 101\nInstr2:  4\nInstr3:  6\nEffect2: 102\nInstr4:  7\n</code></pre> <p>Named instruments can be called by using the name in double quotes (note: the '+' character should be omitted), e.g.</p> <p><code>i \"Effect1\" 0 60</code></p> <p>in the score, or</p> <p><code>schedule(\"Effect1\",0,60)</code></p> <p>in the orchestra code.</p>"},{"location":"orc-instruments/#order-of-execution","title":"Order of Execution","text":""},{"location":"orc-instruments/#initialization","title":"Initialization","text":"<p>Initializing the instrument code follows the order as written in the text, regardless any instrument number. This is an example which increments a global i-variable:</p> <pre><code>giVal = 0\n\ninstr 10\n  giVal += 1\n  print(giVal)\nendin\nschedule(10,0,1)\n\ninstr printme\n  giVal += 1\n  print(giVal)\nendin\nschedule(\"printme\",0,1)\n\ninstr Multiple, 2, 3\n  giVal += 1\n  print(giVal)\nendin\nschedule(\"Multiple\",0,1)\nschedule(2,0,1)\nschedule(3,0,1)\n</code></pre> <p>This returns (in assigning instrument number 1 to 'printme' and instrument number 4 to 'Multiple'):</p> <pre><code>instr 10:   giVal = 1.000\ninstr 1:    giVal = 2.000\ninstr 4:    giVal = 3.000\ninstr 2:    giVal = 4.000\ninstr 3:    giVal = 5.000\n</code></pre>"},{"location":"orc-instruments/#performance","title":"Performance","text":"<p>During performance the instruments are executed following their numbers (from low to high). This is an example which increments a global k-Variable:</p> <pre><code>gkVal init 0\n\ninstr 10\n  gkVal += 1\n  printk(0,gkVal)\n  turnoff\nendin\nschedule(10,0,1)\n\ninstr printme\n  gkVal += 1\n  printk(0,gkVal)\n  turnoff\nendin\nschedule(\"printme\",0,1)\n\ninstr Multiple, 2, 3\n  gkVal += 1\n  printk(0,gkVal)\n  turnoff\nendin\nschedule(\"Multiple\",0,1)\nschedule(2,0,1)\nschedule(3,0,1)\n</code></pre> <p>This returns (in assigning instrument number 1 to 'printme' and instrument number 4 to 'Multiple'):</p> <pre><code>instr 1:    time     0.00000:     1.00000\ninstr 2:    time     0.00000:     2.00000\ninstr 3:    time     0.00000:     3.00000\ninstr 4:    time     0.00000:     4.00000\ninstr 10:   time     0.00000:     5.00000\n</code></pre>"},{"location":"orc-instruments/#instances-and-events","title":"Instances and Events","text":"<p>Instrument code gets loaded into the audio engine as instances. Instances can be loaded simultaneously or sequentially without any predefined limit. </p> <p>Instances are called by events. These instrument events can originate from different sources: 1. The standard numeric score as in <code>i 1 0 1</code> 2. Orchestra opcodes as in <code>schedule(1,0,1)</code> 3. MIDI note-on messages. 4. Real-time input via keys, API or network.</p> <p>Note that a new instrument instance tries to re-use the memory allocation of an old instance. This might result in unexpected behaviour as the second instance continues where the first instance left:</p> <pre><code>instr 1\n  kVal = random:k(0,10)\n  prints(\"kVal initialized as %f\\n\",i(kVal))\n  printks(\"kVal rendered as %f\\n\",0,kVal)\n  turnoff\nendin\nschedule(1,0,1)\nschedule(1,1,1)\n</code></pre> <pre><code>kVal initialized as 0.000000\nkVal rendered as 8.828730\nkVal initialized as 8.828730\nkVal rendered as 2.913418\n</code></pre>"},{"location":"orc-instruments/#explicit-numbered-instances","title":"Explicit Numbered Instances","text":"<p>If an instrument is called with a fractional number, this number indicates a certain instance. This feature allows to treat different instances in a different way.</p> <pre><code>instr 1\n  print(p1)\n  if (p1 == 1.001) then\n    puts(\"hu\",1)\n  else\n    puts(\"ha\",1)  \n  endif\nendin\nschedule(1.001,0,1)\nschedule(1.002,1,1)\n\ninstr Two\n  print(p1)\n  if (p1 == 2.001) then\n    puts(\"ho\",1)\n  else\n    puts(\"hi\",1)  \n  endif\nendin\nschedule(\"Two.001\",2,1)\nschedule(\"Two.002\",3,1)\n</code></pre> <p>This returns:</p> <pre><code>instr 1:    p1 = 1.001\nhu\ninstr 1:    p1 = 1.002\nha\ninstr 2:    p1 = 2.001\nho\ninstr 2:    p1 = 2.002\nhi\n</code></pre>"},{"location":"orc-macros/","title":"Macros","text":"<p>Here the content of https://csound.com/manual/OrchMacros.html can be used.</p>"},{"location":"orc-traditional-functional-code/","title":"Traditional and Functional Code Style","text":"<p>Since Csound 6 it is possible to write Csound orchestra code in functional style. Csound 7 removed some limitations so that now both ways of Csound code can be used universally.</p> <p>The traditional way of writing Csound code has the output of an opcode left of the opcode name, separated by a space or tab. If there are several outputs, they are separated by commas. The input argument is written at the right hand side of the opcode name, separated by a space or tab. If there are several inputs, they are separated by commas.</p> <p><code>aLeft,aRight pan2 aSig,0.5</code></p> <p>The functional way of writing Csound code sets an equal sign between output(s) and opcode name, and puts the input argument(s) in parenthesis which follow the opcode name. The rate of the opcode (<code>i</code> or <code>k</code> or <code>a</code>) is specified after a colon which follows the opcode name.</p> <p><code>aLeft,aRight = pan2:a(aSig,0.5)</code></p> <p>In the case of <code>pan2</code> the <code>:a</code> can be omitted because <code>pan2</code> only has this a-rate version. Other opcodes have different rates so that specifying the rate is mandatory in Csound 6. </p> <pre><code>aSig = oscili:a(0.2,400)\nkSig = oscili:k(10,0.5)\n</code></pre> <p>In Csound 7, the parser selects the appropriate rate by the output variable so that this code is fine, too:</p> <pre><code>aSig = oscili(0.2,400)\nkSig = oscili(10,0.5)\n</code></pre>"},{"location":"orc-user-defined-opcodes/","title":"User Defined Opcodes (UDO)","text":"<p>User Defined Opcodes are functions written in Csound code. They are located in the global space of the orchestra code, or loaded in a text file via <code>#include</code>.</p> <p>The definition of a User Defined Opcode starts with the keyword <code>opcode</code> and ends with the keyword <code>endop</code>. The syntax and implementation of UDOs has changed in Csound 7; so there are two different syntax conventions which can be used.</p>"},{"location":"orc-user-defined-opcodes/#old-style-udo-definition","title":"Old style UDO definition","text":"<p>The implementation is described in detail in the manual page for <code>opcode</code> (link to that page).</p>"},{"location":"orc-user-defined-opcodes/#new-style-udo-definition","title":"New style UDO definition","text":"<p>User Defined Opcodes now follow the syntax <code>opcode name(inargs):(outargs)</code>. </p> <pre><code>opcode myop(inval:i):(i)\n  xout(inval+1)\nendop\n\nopcode empty():void\n  puts(\"empty!\",1)\nendop\n\ninstr 1\n  print(myop(17))\n  empty()\nendin\nschedule(1,0,0\n</code></pre> <p>Give example for pass-by-reference as difference to old style UDOs.</p>"},{"location":"control/clockctl/","title":"Clock Control","text":"<p>The opcodes to start and stop internal clocks are:</p> <ul> <li>clockoff</li> <li>clockon</li> </ul> <p>These clocks count CPU time. There are 32 independent clocks available. You can use the opcode readclock to read current values of a clock. See Time Reading for other timing opcodes.</p>"},{"location":"control/conditional/","title":"Conditional Values","text":"<p>The opcodes for conditional values are:</p> <ul> <li>==</li> <li>&gt;=</li> <li>&gt;</li> <li>&lt;</li> <li>&lt;=</li> <li>!=</li> </ul>"},{"location":"control/durctl/","title":"Duration Control Statements","text":"<p>The opcodes one can use to manipulate a note's duration are:</p> <ul> <li>ihold</li> <li>turnoff</li> <li>turnoff2</li> <li>turnoff3</li> <li>turnon</li> </ul> <p>For other realtime instrument control see Realtime Performance Control and Instrument Invocation.</p>"},{"location":"control/invocat/","title":"Instrument Invocation","text":"<p>The opcodes one can use to create score events from within a orchestra are:</p> <ul> <li>event</li> <li>event_i</li> <li>nstance</li> <li>readscore</li> <li>scoreline_i</li> <li>scoreline</li> <li>schedule</li> <li>schedulek</li> <li>schedwhen</li> <li>schedkwhen</li> <li>schedkwhennamed</li> </ul> <p>The mute opcode can be used to mute/unmute instruments during a performance.</p> <p>Instruments definitions can be removed using the remove opcode.</p> <p>These opcodes will compile one or more instruments at init time:</p> <ul> <li>compilecsd</li> <li>compileorc</li> <li>compilestr</li> </ul>"},{"location":"control/pgmctl/","title":"Program Flow Control","text":"<p>The opcodes to manipulate which orchestra statements are executed are:</p> <ul> <li>cggoto</li> <li>cigoto</li> <li>ckgoto</li> <li>cngoto</li> <li>elseif</li> <li>else</li> <li>endif</li> <li>goto</li> <li>if</li> <li>igoto</li> <li>kgoto</li> <li>tigoto</li> <li>timout</li> </ul> <p>Opcodes to create looping constructions are:</p> <ul> <li>loop_ge</li> <li>loop_gt</li> <li>loop_le</li> <li>loop_lt</li> <li>until</li> <li>while</li> </ul> <p> Warning</p> <p>Some of these opcodes work at i-rate even if they contain k- or a- rate comparisons. See the Reinitialization section.</p> <p>These opcodes are part of a counter system:</p> <ul> <li>count</li> <li>count_i</li> <li>cntCycles</li> <li>cntRead</li> <li>cntReset</li> <li>cntState</li> <li>cntCreate</li> <li>cntDelete</li> <li>cntDelete_i</li> </ul>"},{"location":"control/realtime/","title":"Real-time Performance Control","text":"<p>Opcodes that monitor and control real-time performance are:</p> <ul> <li>active</li> <li>cpuprc</li> <li>cpumeter</li> <li>exitnow</li> <li>maxalloc</li> <li>prealloc</li> </ul> <p>The running csound process can be terminated using exitnow.</p>"},{"location":"control/reinitn/","title":"Initialization and Reinitialization","text":"<p>Opcodes used for the initialization of variables:</p> <ul> <li>init</li> <li>tival</li> <li>=</li> <li>passign</li> <li>pset</li> </ul> <p>The opcodes that can generate another initialization pass are:</p> <ul> <li>reinit</li> <li>rigoto</li> <li>rireturn</li> </ul> <p>The opcode p can be used to find score p-fields at i- or k-rate.</p> <p>nstrnum returns the instrument number for a named instrument.</p> <p> Note</p> <p>Note that an instrument may modify the p3 (duration) parameter at initialisation time. For example statements like <pre><code>iattack = 0.02\nirelease = 0.04\nisustain = p3\np3 = iattack + isustain + irelease\n</code></pre> are valid.</p>"},{"location":"control/sensing/","title":"Sensing and Control","text":""},{"location":"control/sensing/#tcltk-widgets","title":"TCL/TK widgets","text":"<ul> <li>button</li> <li>checkbox</li> <li>control</li> <li>flashtxt</li> <li>setctrl</li> </ul>"},{"location":"control/sensing/#keyboard-and-mouse-sensing","title":"Keyboard and mouse sensing","text":"<ul> <li>joystick</li> <li>sensekey (also called sense)</li> <li>xyin</li> </ul>"},{"location":"control/sensing/#envelope-followers","title":"Envelope followers","text":"<ul> <li>follow</li> <li>follow2</li> <li>lufs</li> <li>peak</li> <li>rms</li> <li>vactrol</li> </ul>"},{"location":"control/sensing/#tempo-and-pitch-estimation","title":"Tempo and Pitch estimation","text":"<ul> <li>centroid</li> <li>pitch</li> <li>pitchamdf</li> <li>plltrack</li> <li>ptrack</li> <li>pvspitch</li> <li>tempest</li> </ul>"},{"location":"control/sensing/#tempo-and-sequencing","title":"Tempo and Sequencing","text":"<ul> <li>changed</li> <li>changed2</li> <li>metro</li> <li>metro2</li> <li>metrobpm</li> <li>miditempo</li> <li>seqtime</li> <li>seqtime2</li> <li>sequ</li> <li>splitrig</li> <li>tempo</li> <li>tempoval</li> <li>trigger</li> <li>trighold</li> <li>trigseq</li> <li>timedseq</li> </ul>"},{"location":"control/sensing/#system","title":"System","text":"<ul> <li>getcfg</li> </ul>"},{"location":"control/sensing/#score-control","title":"Score control","text":"<ul> <li>pcount</li> <li>pindex</li> <li>rewindscore</li> <li>setscorepos</li> </ul>"},{"location":"control/stacks/","title":"Stacks","text":"<p>These opcodes are deprecated.</p> <p>Csound implements a global stack that can be accessed with the following opcodes:</p> <ul> <li>stack</li> <li>pop</li> <li>push</li> <li>pop_f</li> <li>push_f</li> </ul>"},{"location":"control/subinstr/","title":"Sub-instrument Control","text":"<p>These opcodes let one define and use a sub-instrument:</p> <ul> <li>subinstr</li> <li>subinstrinit</li> </ul> <p>See also the UDO and Orchestra Macros section for similar functionality.</p>"},{"location":"control/timeread/","title":"Time Reading","text":"<p>Opcodes one can use to read time values are:</p> <ul> <li>elapsedcycles</li> <li>elapsedtime</li> <li>eventcycles</li> <li>eventtime</li> <li>readclock</li> <li>rtclock</li> <li>timeinstk</li> <li>timeinsts</li> <li>times</li> <li>timek</li> </ul> <p>You can obtain the system date using:</p> <ul> <li>date - Returns the number seconds since 1 January 1970.</li> <li>dates - Returns as a string the date and time specified.</li> </ul> <p>You can also set up counters using clockoff and clockon.</p>"},{"location":"math/amp/","title":"Amplitude Converters","text":"<p>Opcodes to convert between different amplitude measurements are:</p> <ul> <li>ampdb</li> <li>ampdbfs</li> <li>db</li> <li>dbamp</li> <li>dbfsamp</li> </ul> <p>Use rms to find the rms value of a signal. See also 0dbfs for another way to handle amplitudes in csound.</p>"},{"location":"math/array/","title":"Array Opcodes","text":""},{"location":"math/array/#array-opcodes","title":"Array Opcodes","text":"<p>List of Array Opcodes (6.12):</p> <ul> <li>init initiatlise array</li> <li>fillarray fill array with values</li> <li>genarray create array with artithmetic sequence</li> <li>= create or reset array as copy of another array</li> <li>slicearray take slice of an array</li> <li>maparray apply a function to an array</li> <li>scalearray scale values in an array</li> <li>sorta sort an array in ascending order</li> <li>sortd sort an array in descending order</li> <li>limit and limit1 limit array values</li> <li>reshapearray change dimensions of an array</li> <li>trim adjust size of a one-dimensional array</li> <li>copya2ftab copy array to a function table</li> <li>copyf2array copy function table to an array</li> <li>tab2array copy a slice from a table to an array</li> <li>dot calculate dot product from two arrays</li> <li>interleave interleave two arrays to a single one</li> <li>deinterleave deinterleave an array to two ones</li> <li>getrow get a row from a two-dimensional array</li> <li>getcol get a column from a two-dimensional array</li> <li>setrow set a row of a two-dimensional array</li> <li>setcol set a column of a two-dimensional array</li> <li>lenarray returns length of an array</li> <li>minarray returns minimum value in an array</li> <li>maxarray returns maximum value in an array</li> <li>sumarray returns sum of values in an array</li> <li>cmp compare two arrays</li> <li>printarray print an array</li> <li>product calculates the product of an array</li> <li>the unary functions ceil, floor round, int, frac, powoftwo, abs, log2, log10, log, exp, sqrt, cos, sin, tan, cosinv, sininv, taninv, sinh, cosh, tanh, cbrt, limit1, and the binary functions taninv2, pow, hypot, fmod, fmax, fmin accept arrays as input.</li> </ul> <p>Some instructions to work with arrays in Csound (see also the array chapter in the Csound FLOSS Manual:)</p>"},{"location":"math/array/#variable-name","title":"Variable Name","text":"<p>An array must be created (via init or fillarray) as kMyName plus_ ending brackets. The brackets determine the dimensions of the array. So,</p> <pre><code>kArr[] init 10\n</code></pre> <p>creates a one-dimensional array of length 10, whereas</p> <pre><code>kArr[][] init 10, 10\n</code></pre> <p>creates a two-dimensional array with 10 rows and 10 columns.</p> <p>After the initalization of the array, referring to the array as a whole is done without any brackets. Brackets are only used if an element is indexed:</p> <pre><code>kArr[]   init 10             ;with brackets because of initialization\nkLen     = lenarray(kArr)    ;without brackets\nkFirstEl = kArr[0]           ;indexing with brackets\n</code></pre> <p>The same syntax is used for a simple copy via the '=' operator:</p> <pre><code>kArr1[] fillarray 1, 2, 3, 4, 5\nkArr2[] = kArr1              ;creates kArr2 as copy of kArr1\n</code></pre>"},{"location":"math/array/#k-rate","title":"k-rate","text":"<p>Note that most array operations are currently k-rate only. So like any other k-rate opcode, an operation on arrays will be automatically repeated every k-cycle. For instance, this code will repeat re-writing the array with different random values every k-cycle, as long as the instrument runs:</p> <pre><code>kArr[] init 10\nkIndx  = 0\nuntil kIndx == lenarray(kArr) do\n  kArr[kIndx] rnd31 10, 0\n  kIndx += 1\nod\n</code></pre> <p>If you want to avoid this, you must organize it in one of the usual ways, for instance by using a trigger:</p> <pre><code>kArr[] init 10\nkTrig metro 1\nif kTrig == 1 then ;do the following once a second\n  kIndx  = 0\n  until kIndx == lenarray(kArr) do\n    kArr[kIndx] rnd31 10, 0\n    kIndx += 1\n  od\nendif\n</code></pre>"},{"location":"math/array/#creationinitialization","title":"Creation/Initialization","text":"<p>The usual way to create an array is with init:</p> <pre><code>kArr[]   init 10     ;creates one-dimensional array with length 10\nkArr[][] init 10, 10 ;creates two-dimensional array\n</code></pre> <p>A one-dimensional array can also be created and filled with distinct values by the opcode fillarray. This line creates a vector with length 4 and puts in the numbers [1, 2, 3, 4]:</p> <pre><code>kArr[] fillarray 1, 2, 3, 4\n</code></pre>"},{"location":"math/array/#length","title":"Length","text":"<p>The function lenarray(kArr) reports the length of an array. See example for function lenarray.</p> <p>Copy Arrays to/from Tables</p> <pre><code>copyf2array kArr, kfn\n</code></pre> <p>copies data from an ftable to a vector.</p> <pre><code>copya2ftab kArr, kfn\n</code></pre> <p>copies data from a vector to an function table.</p> <p>See examples for opcodes copyf2array and copya2ftab.</p>"},{"location":"math/array/#array-operations-math","title":"Array Operations: Math","text":""},{"location":"math/array/#-on-a-number","title":"+, -, *, / on a Number","text":"<p>If the four basic math operators are used between an array and a scalar (number), the operation is applied to each element. The safest way to do this is to store the result in a new array:</p> <pre><code>kArr1[] fillarray 1, 2, 3\nkArr2[] = kArr1 + 10    ;(kArr2 is now [11, 12, 13])\n</code></pre> <p>Here is an example of array/scalar operations. It uses the file array_scalar_math.csd.</p> Example of array operations<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n -m128\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\n  instr 1\n\n;create array and fill with numbers 1..10\nkArr1[] fillarray 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n;print content\n        printf  \"%s\", 1, \"\\nInitial content:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr1) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr1[kndx]\nkndx    +=      1\n  od\n\n;add 10\nkArr2[] =       kArr1 + 10\n\n;print content\n        printf  \"%s\", 1, \"\\nAfter adding 10:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr2) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr2[kndx]\nkndx    +=      1\n  od\n\n;subtract 5\nkArr3[] =       kArr2 - 5\n\n;print content\n        printf  \"%s\", 1, \"\\nAfter subtracting 5:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr3) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr3[kndx]\nkndx    +=      1\n  od\n\n;multiply by -1.5\nkArr4[] =       kArr3 * -1.5\n\n;print content\n        printf  \"%s\", 1, \"\\nAfter multiplying by -1.5:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr4) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr4[kndx]\nkndx    +=      1\n  od\n\n;divide by -3/2\nkArr5[] =       kArr4 / -(3/2)\n\n;print content\n        printf  \"%s\", 1, \"\\nAfter dividing by -3/2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr5) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr5[kndx]\nkndx    +=      1\n  od\n\n;turnoff\n        turnoff\n  endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"math/array/#-on-a-second-array","title":"+, -, *, / on a Second Array","text":"<p>If the four basic math operators are used between two arrays, the operation is applied element by element. The result can be straightforward stored in a new array:</p> <pre><code>kArr1[] fillarray 1, 2, 3\nkArr2[] fillarray 10, 20, 30\nkArr3[] = kArr1 + kArr2    ;(kArr3 is now [11, 22, 33])\n</code></pre> <p>Here is an example of array operations. It uses the file array_array_math.csd.</p> Example of array operations<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n -m128\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  instr 1\n\n;create array and fill with numbers 1..10 resp .1..1\nkArr1[] fillarray 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nkArr2[] fillarray 1, 2, 3, 5, 8, 13, 21, 34, 55, 89\n\n;print contents\n        printf  \"%s\", 1, \"\\nkArr1:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr1) do\n        printf  \"kArr1[%d] = %f\\n\", kndx+1, kndx, kArr1[kndx]\nkndx    +=      1\n  od\n        printf  \"%s\", 1, \"\\nkArr2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr2) do\n        printf  \"kArr2[%d] = %f\\n\", kndx+1, kndx, kArr2[kndx]\nkndx    +=      1\n  od\n\n;add arrays\nkArr3[] =       kArr1 + kArr2\n\n;print content\n        printf  \"%s\", 1, \"\\nkArr1 + kArr2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr3) do\n        printf  \"kArr3[%d] = %f\\n\", kndx+1, kndx, kArr3[kndx]\nkndx    +=      1\n  od\n\n;subtract arrays\nkArr4[] =       kArr1 - kArr2\n\n;print content\n        printf  \"%s\", 1, \"\\nkArr1 - kArr2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr4) do\n        printf  \"kArr4[%d] = %f\\n\", kndx+1, kndx, kArr4[kndx]\nkndx    +=      1\n  od\n\n;multiply arrays\nkArr5[] =       kArr1 * kArr2\n\n;print content\n        printf  \"%s\", 1, \"\\nkArr1 * kArr2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr5) do\n        printf  \"kArr5[%d] = %f\\n\", kndx+1, kndx, kArr5[kndx]\nkndx += 1\n  od\n\n;divide arrays\nkArr6[] =       kArr1 / kArr2\n\n;print content\n        printf  \"%s\", 1, \"\\nkArr1 / kArr2:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr6) do\n        printf  \"kArr5[%d] = %f\\n\", kndx+1, kndx, kArr6[kndx]\nkndx += 1\n  od\n\n;turnoff\n        turnoff\n\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"math/array/#map-a-function-to-an-array","title":"Map a Function to an Array","text":"<pre><code>kArrRes maparray kArrSrc, \"fun\"\n</code></pre> <p>maps the k-rate 1-arg function in the string to every element of the vector.</p> <p>Possible functions are for instance abs, ceil, exp, floor, frac, int, log, log10, round, sqrt. This is a simple example:</p> <pre><code>kArrSrc[] fillarray 1, 2, 3, 4, 5\nkArrRes[] init      5\nkArrRes   maparray  kArrSrc, \"sqrt\"\n</code></pre> <p>See example for opcode maparray.</p>"},{"location":"math/array/#array-operations-min-max-sum-scale-slice","title":"Array Operations: min, max, sum, scale, slice","text":""},{"location":"math/array/#minimum-and-maximum","title":"Minimum and Maximum","text":"<pre><code>kMin [,kMinIndx] minarray kArr\n</code></pre> <p>returns the smallest value in an array, and optionally its index.</p> <pre><code>kMax [,kMaxIndx] maxarray kArr\n</code></pre> <p>returns the largest value in an array, and optionally its index. See examples for opcodes minarray and maxarray.</p>"},{"location":"math/array/#sum","title":"Sum","text":"<pre><code>kSum sumarray kArr\n</code></pre> <p>returns the sum of all values in kArr. See example for opcode sumarray.</p>"},{"location":"math/array/#scale","title":"Scale","text":"<pre><code>scalearray kArr, kMin, kMax\n</code></pre> <p>scales all values in kArr between kMin and kMax.</p> <pre><code>  kArr[] fillarray  1, 3, 9, 5, 6\n         scalearray kArr, 1, 3\n</code></pre> <p>changes kArr to [1, 1.5, 3, 2, 2.25]. See example for opcode scalearray.</p>"},{"location":"math/array/#slice","title":"Slice","text":"<pre><code>slicearray kArr, iStart, iEnd\n</code></pre> <p>returns a slice of kArr from index iStart to index iEnd (included).</p> <p>The array for receiving the slice must have been created in advance:</p> <pre><code>  kArr[]  fillarray  1, 2, 3, 4, 5, 6, 7, 8, 9\n  kArr1[] init       5\n  kArr2[] init       4\n  kArr1   slicearray kArr, 0, 4        ;[1, 2, 3, 4, 5]\n  kArr2   slicearray kArr, 5, 8        ;[6, 7, 8, 9]\n</code></pre> <p>See example for opcode slicearray.</p>"},{"location":"math/array/#reshape","title":"Reshape","text":"<p>Use reshapearray to change the shape of an array without changing its capacity (change a 1D to a 2D array and viceversa). See example for opcode reshapearray.</p>"},{"location":"math/array/#arrays-in-udos","title":"Arrays in UDOs","text":"<p>The dimension of an input array must be declared in two places:</p> <ul> <li>as k[] or k[][] in the type input list</li> <li>as kName[], kName[][] etc in the xin list.</li> </ul> <p>For instance :</p> <pre><code>opcode FirstEl, k, k[]\n;returns the first element of vector kArr\nkArr[] xin\n       xout   kArr[0]\nendop\n</code></pre> <p>Here is an example of an array in an UDO. It uses the file array_udo.csd.</p> Example of an array in an UDO<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-nm128\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  opcode FirstEl, k, k[]\n  ;returns the first element of vector kArr\nkArr[] xin\nxout kArr[0]\n  endop\n\n  instr 1 \nkArr[] fillarray 6, 3, 9, 5, 1\nkFirst FirstEl kArr\nprintf \"kFirst = %d\\n\", 1, kFirst\nturnoff\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Note that if an opcode (for example inrg), alters arguments on its right hand argument list, an array index should not be used there. Unlike a normal variable, the array won't changed by the opcode.</p>"},{"location":"math/array/#credits","title":"Credits","text":"<p>This manual page has been written by Joachim Heintz. July 2013</p> <p>New in Csound 6.00</p>"},{"location":"math/artlogic/","title":"Arithmetic and Logic Operations","text":"<p>Opcodes that perform arithmetic and logic operations are:</p> <ul> <li>\\(-\\) </li> <li>\\(+\\) </li> <li>&amp;&amp; </li> <li>\\(!\\) </li> <li>\\(||\\) </li> <li>\\(*\\) </li> <li>\\(/\\) </li> <li>^ </li> <li>&lt;&lt; </li> <li>&gt;&gt;</li> <li>\\(\\#\\) </li> <li>&amp; </li> <li>\\(|\\) </li> <li>~ </li> <li>\\(\\%\\)</li> <li>cmp</li> </ul> <p>See the Conditional Values section and the if family of opcodes for usage of logical operators.</p>"},{"location":"math/linearalgebra/","title":"Linear Algebra Opcodes","text":""},{"location":"math/linearalgebra/#linear-algebra-opcodes","title":"Linear Algebra Opcodes","text":"<p>Scalar, vector, and matrix arithmetic on real and complex values.</p> <p>Plugin opcodes in linear_algebra. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>These opcodes implement many linear algebra operations, from scalar, vector, and matrix arithmetic up to and including QR based eigenvalue decompositions. The opcodes are designed for digital signal processing, and of course other mathematical operations, in the Csound orchestra language.</p> <p>The numerical implementation uses the gmm++ library from getfem.org/gmm/index.html.</p> <p> Warning</p> <p>For applications with f-sig variables, array arithmetic must be performed only when the f-sig is \"current,\" because f-rate is some fraction of k-rate; currency can be determined with the la_k_current_f opcode.</p> <p>For applications using assignments between real vectors and a-rate variables, array arithmetic must be performed only when the vectors are \"current\", because the size of the vector may be some integral multiple of ksmps; currency can be determined by means of the la_k_current_vr opcode.</p> Mathematical Type Code Corresponding Csound Type or Types real scalar r i-rate or k-rate variable complex scalar c pair of i-rate or k-rate variables, e.g. \"kr, ki\" real vector vr i-rate variable holding address of array real vector a a-rate variable real vector t function table number complex vector vc i-rate variable holding address of array complex vector f fsig variable real matrix mr i-rate variable holding address of array complex matrix mc i-rate variable holding address of array <p>All arrays are 0-based; the first index iterates rows to give columns, the second index iterates columns to give elements.</p> <p>All arrays are general and dense; banded, Hermitian, symmetric and sparse routines are not implemented.</p> <p>An array can be of type code vr, vc, mr, or mc and is stored in an i-rate object. In orchestra code, an array is passed as a MYFLT i-rate variable that contains the address of the array object, which is actually stored in the allocator opcode instance. Although array variables are i-rate, of course their values and even shapes may change at i-rate or k-rate.</p> <p>All operands must be pre-allocated; except for the creation opcodes, no opcode ever allocates any arrays. This is true even if the array appears on the left-hand side of an opcode! However, some operations may reshape arrays to hold results.</p> <p>Arrays are automatically deallocated when their instrument is deallocated.</p> <p>Not only for more efficient performance, but also to make it easier to remember opcode names, the performance rate, output value types, operation names, and input value types are deterministically encoded into the opcode name:</p> <ol> <li>\"la\" for \"linear algebra opcode family\".</li> <li>\"i\" or \"k\" for performance rate.</li> <li>Type code(s) (see above table) for output value(s), but only if the type is not implicit from the input values.</li> <li>Operation name: common mathematical name (preferred) or abbreviation.</li> <li>Type code(s) for input values, if not implicit.</li> </ol> <p>For additional details, see the gmm++ documentation at http://download.gna.org/getfem/doc/gmmuser.pdf.</p>"},{"location":"math/linearalgebra/#syntax","title":"Syntax","text":""},{"location":"math/linearalgebra/#array-creation","title":"Array Creation","text":"<pre><code>ivr                         la_i_vr_create        irows\n</code></pre> <p>Create a real vector with irows rows.</p> <pre><code>ivc                         la_i_vc_create        irows\n</code></pre> <p>Create a complex vector with irows rows.</p> <pre><code>imr                         la_i_mr_create        irows, icolumns  [, odiagonal]\n</code></pre> <p>Create a real matrix with irows rows and icolumns columns, with an optional value on the diagonal.</p> <pre><code>imc                         la_i_mc_create        irows, icolumns  [, odiagonal_r, odiagonal_i]\n</code></pre> <p>Create a complex matrix with irows rows and icolumns columns, with an optional complex value on the diagonal.</p>"},{"location":"math/linearalgebra/#array-introspection","title":"Array Introspection","text":"<pre><code>irows                       la_i_size_vr          ivr\n</code></pre> <p>Return the number of rows in real vector ivr.</p> <pre><code>irows                       la_i_size_vc          ivc\n</code></pre> <p>Return the number of rows in complex vector ivc.</p> <pre><code>irows, icolumns             la_i_size_mr          imr\n</code></pre> <p>Return the number of rows and columns in real matrix imr.</p> <pre><code>irows, icolumns             la_i_size_mc          imc\n</code></pre> <p>Return the number of rows and columns in complex matrix imc.</p> <pre><code>kfiscurrent                 la_k_current_f        fsig\n</code></pre> <p>Return 1 if fsig is current, that is, if the value of fsig will change on the next kperiod.</p> <pre><code>kvriscurrent                la_k_current_vr       ivr\n</code></pre> <p>Return 1 if the real vector ivr is current, that is, if Csound's current audio sample frame stands at index 0 of the vector.</p> <pre><code>la_i_print_vr         ivr\n</code></pre> <p>Print the value of real vector ivr.</p> <pre><code>la_i_print_vc         ivc\n</code></pre> <p>Print the value of complex vector ivc.</p> <pre><code>la_i_print_mr         imr\n</code></pre> <p>Print the value of real matrix imr.</p> <pre><code>la_i_print_mc         imc\n</code></pre> <p>Print the value of complex matrix imc.</p>"},{"location":"math/linearalgebra/#array-assignment-and-conversion","title":"Array Assignment and Conversion","text":"<pre><code>ivr                         la_i_assign_vr        ivr\n</code></pre> <p>Assign the value of the real vector on the right-hand side to the real vector on the left-hand side, at i-rate.</p> <pre><code>ivr                         la_k_assign_vr        ivr\n</code></pre> <p>Assign the value of the real vector on the right-hand side to the real vector on the left-hand side, at k-rate.</p> <pre><code>ivc                         la_i_assign_vc        ivc\nivc                         la_k_assign_vc        ivr\nimr                         la_i_assign_mr        imr\nimr                         la_k_assign_mr        imr\nimc                         la_i_assign_mc        imc\nimc                         la_k_assign_mc        imr\n</code></pre> <p> Warning</p> <p>Assignments to vectors from tables or fsigs may resize the vectors.</p> <p>Assignments to vectors from a-rate variables, or to a-rate variables from vectors, will be performed incrementally, one chunk of ksmps elements per kperiod. Therefore, array arithmetic on such vectors should only be performed when the vectors are current, as determined by the la_k_currrent_vr opcode.</p> <pre><code>ivr                         la_k_assign_a         asig\nivr                         la_i_assign_t         itablenumber\nivr                         la_k_assign_t         itablenumber\nivc                         la_k_assign_f         fsig\nasig                        la_k_a_assign         ivr\nitablenum                   la_i_t_assign         ivr\nitablenum                   la_k_t_assign         ivr\nfsig                        la_k_f_assign         ivc\n</code></pre>"},{"location":"math/linearalgebra/#fill-arrays-with-random-elements","title":"Fill Arrays with Random Elements","text":"<pre><code>ivr                         la_i_random_vr        [ifill_fraction]\nivr                         la_k_random_vr        [kfill_fraction]\nivc                         la_i_random_vc        [ifill_fraction]\nivc                         la_k_random_vc        [kfill_fraction]\nimr                         la_i_random_mr        [ifill_fraction]\nimr                         la_k_random_mr        [kfill_fraction]\nimc                         la_i_random_mc        [ifill_fraction]\nimc                         la_k_random_mc        [kfill_fraction]\n</code></pre>"},{"location":"math/linearalgebra/#array-element-access","title":"Array Element Access","text":"<pre><code>ivr                         la_i_vr_set           irow, ivalue\nkvr                         la_k_vr_set           krow, kvalue\nivc                         la_i_vc_set           irow, ivalue_r, ivalue_i\nkvc                         la_k_vc_set           krow, kvalue_r, kvalue_i\nimr                         la_i mr_set           irow, icolumn, ivalue\nkmr                         la_k mr_set           krow, kcolumn, ivalue\nimc                         la_i_mc_set           irow, icolumn, ivalue_r, ivalue_i\nkmc                         la_k_mc_set           krow, kcolumn, kvalue_r, kvalue_i\nivalue                      la_i_get_vr           ivr, irow\nkvalue                      la_k_get_vr           ivr, krow\nivalue_r, ivalue_i          la_i_get_vc           ivc, irow\nkvalue_r, kvalue_i          la_k_get_vc           ivc, krow\nivalue                      la_i_get_mr           imr, irow, icolumn\nkvalue                      la_k_get_mr           imr, krow, kcolumn\nivalue_r, ivalue_i          la_i_get_mc           imc, irow, icolumn\nkvalue_r, kvalue_i          la_k_get_mc           imc, krow, kcolumn\n</code></pre>"},{"location":"math/linearalgebra/#single-array-operations","title":"Single Array Operations","text":"<pre><code>imr                         la_i_transpose_mr     imr\nimr                         la_k_transpose_mr     imr\nimc                         la_i_transpose_mc     imc\nimc                         la_k_transpose_mc     imc\nivr                         la_i_conjugate_vr     ivr\nivr                         la_k_conjugate_vr     ivr\nivc                         la_i_conjugate_vc     ivc\nivc                         la_k_conjugate_vc     ivc\nimr                         la_i_conjugate_mr     imr\nimr                         la_k_conjugate_mr     imr\nimc                         la_i_conjugate_mc     imc\nimc                         la_k_conjugate_mc     imc\n</code></pre>"},{"location":"math/linearalgebra/#scalar-operations","title":"Scalar Operations","text":"<pre><code>ir                          la_i_norm1_vr         ivr\nkr                          la_k_norm1_vr         ivc\nir                          la_i_norm1_vc         ivc\nkr                          la_k_norm1_vc         ivc\nir                          la_i_norm1_mr         imr\nkr                          la_k_norm1_mr         imr\nir                          la_i_norm1_mc         imc\nkr                          la_k_norm1_mc         imc\nir                          la_i_norm_euclid_vr   ivr\nkr                          la_k_norm_euclid_vr   ivr\nir                          la_i_norm_euclid_vc   ivc\nkr                          la_k_norm_euclid_vc   ivc\nir                          la_i_norm_euclid_mr   mvr\nkr                          la_k_norm_euclid_mr   mvr\nir                          la_i_norm_euclid_mc   mvc\nkr                          la_k_norm_euclid_mc   mvc\nir                          la_i_distance_vr      ivr\nkr                          la_k_distance_vr      ivr\nir                          la_i_distance_vc      ivc\nkr                          la_k_distance_vc      ivc\nir                          la_i_norm_max         imr\nkr                          la_k_norm_max         imc\nir                          la_i_norm_max         imr\nkr                          la_k_norm_max         imc\nir                          la_i_norm_inf_vr      ivr\nkr                          la_k_norm_inf_vr      ivr\nir                          la_i_norm_inf_vc      ivc\nkr                          la_k_norm_inf_vc      ivc\nir                          la_i_norm_inf_mr      imr\nkr                          la_k_norm_inf_mr      imr\nir                          la_i_norm_inf_mc      imc\nkr                          la_k_norm_inf_mc      imc\nir                          la_i_trace_mr         imr\nkr                          la_k_trace_mr         imr\nir, ii                      la_i_trace_mc         imc\nkr, ki                      la_k_trace_mc         imc\nir                          la_i_lu_det           imr\nkr                          la_k_lu_det           imr\nir                          la_i_lu_det           imc\nkr                          la_k_lu_det           imc\n</code></pre>"},{"location":"math/linearalgebra/#elementwise-array-array-operations","title":"Elementwise Array-Array Operations","text":"<pre><code>ivr                         la_i_add_vr           ivr_a, ivr_b\nivc                         la_k_add_vc           ivc_a, ivc_b\nimr                         la_i_add_mr           imr_a, imr_b\nimc                         la_k_add_mc           imc_a, imc_b\nivr                         la_i_subtract_vr      ivr_a, ivr_b\nivc                         la_k_subtract_vc      ivc_a, ivc_b\nimr                         la_i_subtract_mr      imr_a, imr_b\nimc                         la_k_subtract_mc      imc_a, imc_b\nivr                         la_i_multiply_vr      ivr_a, ivr_b\nivc                         la_k_multiply_vc      ivc_a, ivc_b\nimr                         la_i_multiply_mr      imr_a, imr_b\nimc                         la_k_multiply_mc      imc_a, imc_b\nivr                         la_i_divide_vr        ivr_a, ivr_b\nivc                         la_k_divide_vc        ivc_a, ivc_b\nimr                         la_i_divide_mr        imr_a, imr_b\nimc                         la_k_divide_mc        imc_a, imc_b\n</code></pre>"},{"location":"math/linearalgebra/#inner-products","title":"Inner Products","text":"<pre><code>ir                          la_i_dot_vr           ivr_a, ivr_b\nkr                          la_k_dot_vr           ivr_a, ivr_b\nir, ii                      la_i_dot_vc           ivc_a, ivc_b\nkr, ki                      la_k_dot_vc           ivc_a, ivc_b\nimr                         la_i_dot_mr           imr_a, imr_b\nimr                         la_k_dot_mr           imr_a, imr_b\nimc                         la_i_dot_mc           imc_a, imc_b\nimc                         la_k_dot_mc           imc_a, imc_b\nivr                         la_i_dot_mr_vr        imr_a, ivr_b\nivr                         la_k_dot_mr_vr        imr_a, ivr_b\nivc                         la_i_dot_mc_vc        imc_a, ivc_b\nivc                         la_k_dot_mc_vc        imc_a, ivc_b\n</code></pre>"},{"location":"math/linearalgebra/#matrix-inversion","title":"Matrix Inversion","text":"<pre><code>imr, icondition             la_i_invert_mr        imr\nimr, kcondition             la_k_invert_mr        imr\nimc, icondition             la_i_invert_mc        imc\nimc, kcondition             la_k_invert_mc        imc\n</code></pre>"},{"location":"math/linearalgebra/#matrix-decompositions-and-solvers","title":"Matrix Decompositions and Solvers","text":"<pre><code>ivr                         la_i_upper_solve_mr   imr [, j_1_diagonal]\nivr                         la_k_upper_solve_mr   imr [, j_1_diagonal]\nivc                         la_i_upper_solve_mc   imc [, j_1_diagonal]\nivc                         la_k_upper_solve_mc   imc [, j_1_diagonal]\nivr                         la_i_lower_solve_mr   imr [, j_1_diagonal]\nivr                         la_k_lower_solve_mr   imr [, j_1_diagonal]\nivc                         la_i_lower_solve_mc   imc [, j_1_diagonal]\nivc                         la_k_lower_solve_mc   imc [, j_1_diagonal]\nimr, ivr_pivot, isize       la_i_lu_factor_mr     imr\nimr, ivr_pivot, ksize       la_k_lu_factor_mr     imr\nimc, ivr_pivot, isize       la_i_lu_factor_mc     imc\nimc, ivr_pivot, ksize       la_k_lu_factor_mc     imc\nivr_x                       la_i_lu_solve_mr      imr, ivr_b\nivr_x                       la_k_lu_solve_mr      imr, ivr_b\nivc_x                       la_i_lu_solve_mc      imc, ivc_b\nivc_x                       la_k_lu_solve_mc      imc, ivc_b\nimr_q, imr_r                la_i_qr_factor_mr     imr\nimr_q, imr_r                la_k_qr_factor_mr     imr\nimc_q, imc_r                la_i_qr_factor_mc     imc\nimc_q, imc_r                la_k_qr_factor_mc     imc\nivr_eig_vals                la_i_qr_eigen_mr      imr, i_tolerance\nivr_eig_vals                la_k_qr_eigen_mr      imr, k_tolerance\nivr_eig_vals                la_i_qr_eigen_mc      imc, i_tolerance\nivr_eig_vals                la_k_qr_eigen_mc      imc, k_tolerance\n</code></pre> <p> Warning</p> <p>Matrix must be Hermitian in order to compute eigenvectors.</p> <pre><code>ivr_eig_vals, imr_eig_vecs  la_i_qr_sym_eigen_mr  imr, i_tolerance\nivr_eig_vals, imr_eig_vecs  la_k_qr_sym_eigen_mr  imr, k_tolerance\nivc_eig_vals, imc_eig_vecs  la_i_qr_sym_eigen_mc  imc, i_tolerance\nivc_eig_vals, imc_eig_vecs  la_k_qr_sym_eigen_mc  imc, k_tolerance\n</code></pre>"},{"location":"math/linearalgebra/#see-also","title":"See also","text":"<p>For other information on the Linear Algebra Opcodes, see the Csound Journal.</p>"},{"location":"math/linearalgebra/#credits","title":"Credits","text":"<p>Michael Gogins</p> <p>New in Csound version 5.09</p>"},{"location":"math/mathfunc/","title":"Mathematical Functions","text":"<p>Opcodes that perform mathematical functions are:</p> <ul> <li>abs</li> <li>ceil</li> <li>exp</li> <li>floor</li> <li>frac</li> <li>int</li> <li>log</li> <li>log2</li> <li>log10</li> <li>logbtwo</li> <li>pow</li> <li>powershape</li> <li>powoftwo</li> <li>qinf</li> <li>qnan</li> <li>round</li> <li>sqrt</li> </ul>"},{"location":"math/opeqfunc/","title":"Opcode Equivalents of Functions","text":"<p>Opcodes that perform the equivalent of mathematical functions are:</p> <ul> <li>chebyshevpoly</li> <li>divz</li> <li>mac</li> <li>maca</li> <li>polynomial</li> <li>pow</li> <li>product</li> <li>sum</li> <li>taninv2</li> </ul>"},{"location":"math/rndfunc/","title":"Random Functions","text":"<p>Opcodes that perform random functions are:</p> <ul> <li>birnd</li> <li>rnd</li> </ul> <p>See the section Random (Noise) Generators for opcodes that generate random signals.</p>"},{"location":"math/trig/","title":"Trigonometric Functions","text":"<p>Opcodes that perform trigonometric functions are:</p> <ul> <li>cos, cosh and cosinv</li> <li>sin, sinh and sininv</li> <li>tan, tanh, taninv, and taninv2</li> <li>signum</li> </ul>"},{"location":"midi/convert/","title":"Converters","text":"<p>The following opcodes can convert MIDI information. Some are conceived to work with a MIDI-triggered instrument instance. All opcodes converting from MIDI note to frequency (and back) use the global variable A4 to set the reference frequency</p> <ul> <li>MIDI note number to frequency converters (MIDI-triggered events): cpsmidi, cpsmidib, cpstmid, octmidi, octmidib, pchmidi, pchmidib.</li> <li>MIDI note number to frequency converter (general case): mtof, cpsmidinn</li> <li>Pitch/frequency to MIDI note number converters: ftom, pchtom.</li> <li>MIDI velocity to amplitude converters: ampmidi, ampmidid and ampmidicurve</li> <li>Note name to midi / frequency and viceversa: ntom, mton, ntof.</li> </ul>"},{"location":"midi/extender/","title":"Event Extenders","text":"<p>Opcodes that let one extend the duration of an event are:</p> <ul> <li>lastcycle</li> <li>release</li> <li>xtratim</li> </ul>"},{"location":"midi/generic/","title":"Generic Input and Output","text":"<p>Opcodes for generic MIDI input and output are midiin, midiout and midiout_i</p>"},{"location":"midi/input/","title":"MIDI input and Initialization","text":"<p>The following opcodes can receive MIDI information:</p> <ul> <li>MIDI information for any instruments: aftouch, chanctrl and polyaft, pchbend.</li> <li>MIDI information for MIDI-triggered instruments: veloc, midictrl, midichn and notnum. See also Converters.</li> <li>MIDI Controller input for any instrument: ctrl7, ctrl14 and ctrl21.</li> <li>MIDI Controller input for MIDI-triggered instruments only: midic7, midic14 and midic21.</li> <li>MIDI controller  value initialization: initc7, initc14, initc21, ctrlinit, ctrlpreset, ctrlprint, ctrlprintpresets, ctrlsave and ctrlselect.</li> <li>MIDI file input information: midifilestatus.</li> <li>Generic MIDI input: midiin.</li> </ul> <p>massign can be used to specify the csound instrument to be triggered by a particular MIDI channel. pgmassign can be use to assign a csound instrument to a specific MIDI program.</p>"},{"location":"midi/interop/","title":"MIDI/Score Interoperability opcodes","text":"<p>The following opcodes can be used to design instruments that work interchangably for real-time MIDI and score events:</p> <ul> <li>midichannelaftertouch</li> <li>midichn</li> <li>midicontrolchange</li> <li>mididefault</li> <li>midinoteoff</li> <li>midinoteoncps</li> <li>midinoteonkey</li> <li>midinoteonoct</li> <li>midinoteonpch</li> <li>midipitchbend</li> <li>midipolyaftertouch</li> <li>midiprogramchange.</li> </ul> <p> Adapting a score-activated Csound instrument.</p> <p>To adapt an ordinary Csound instrument designed for score activation for score/MIDI interoperability:</p> <ul> <li>Change all linen, linseg, and expseg opcodes to linenr, linsegr, and expsegr, respectively, except for a de-clicking or damping envelope. This will not materially change score-driven performance.</li> <li>Add the following lines at the beginning of the instrument definition: <pre><code> ; Ensures that a MIDI-activated instrument\n ; will have a positive p3 field.\n mididefault 60, p3 \n ; Puts MIDI key translated to cycles per\n ; second into p4, and MIDI velocity into p5\n midinoteoncps p4, p5\n</code></pre> Obviously, midinoteoncps could be changed to midinoteonoct or any of the other options, and the choice of p-fields is arbitrary.</li> </ul> <p> MIDI Realtime Input/Ouput command line options</p> <p>New MIDI I/O flags in Csound 5.02, can replace most uses of these MIDI interop opcodes, and make usage easier.</p>"},{"location":"midi/onoff/","title":"Note-on/Note-off Output","text":"<p>Opcodes to output MIDI note on or off messages are:</p> <ul> <li>midiarp</li> <li>midion</li> <li>midion2</li> <li>moscil</li> <li>noteoff</li> <li>noteon</li> <li>noteondur</li> <li>noteondur2</li> </ul>"},{"location":"midi/output/","title":"MIDI Message Output","text":"<p>Opcodes that produce MIDI output are:</p> <ul> <li>mdelay</li> <li>midiout</li> <li>midiout_i</li> <li>nrpn</li> <li>outiat</li> <li>outic</li> <li>outic14</li> <li>outipat</li> <li>outipb</li> <li>outipc</li> <li>outkat</li> <li>outkc</li> <li>outkc14</li> <li>outkpat</li> <li>outkpb</li> <li>outkpc</li> </ul>"},{"location":"midi/realtime/","title":"System Realtime Messages","text":"<p>Opcodes for System Realtime MIDI messages are: mclock and mrtmsg.</p>"},{"location":"midi/sliderbk/","title":"Slider Banks","text":"<p>Opcodes for slider banks of MIDI controls are:</p> <ul> <li>slider8</li> <li>slider8f</li> <li>slider16</li> <li>slider16f</li> <li>slider32</li> <li>slider32f</li> <li>slider64</li> <li>slider64f</li> <li>s16b14</li> <li>s32b14</li> <li>sliderKawai</li> </ul> <p>Opcodes for storing slider banks of MIDI controls to tables are:</p> <ul> <li>slider8table</li> <li>slider8tablef</li> <li>slider16table</li> <li>slider16tablef</li> <li>slider32table</li> <li>slider32tablef</li> <li>slider64table</li> <li>slider64tablef</li> </ul>"},{"location":"midi/top/","title":"Real-time MIDI Support","text":"<p>Csound supports realtime MIDI input and output, as well as input    from MIDI files. Realtime MIDI input is activated using the -M (or    --midi-device=DEVICE) command line flag. For    single port input, you    must specify the device number or name after the -M. For multiport input (currently    implemented only in the PortMIDI module),  use 'a' or 'm'.    For example to use device number 2, you would use something like:</p> <pre><code>csound -M2 myrtmidi.csd\n</code></pre> <p>You can find out the available devices by running Csound with --midi-devices option:</p> <pre><code>csound --midi-devices\n</code></pre> <p>Starting from version 6.14, the PortMIDI module (see below for a listof all modules) allows multiple ports to be mapped to higher-orderchannels. By using the 'm' device name, Csound will take inputs fromany existing MIDI device in the system and map it according to(N+1)*channel, where N is the device number as listed by PortMIDI andchannel is the original device input channel. Alternatively, the 'a'device name listens to all inputs but does not map to higher-orderchannels.</p> <p>Realtime MIDI output is activated using -Q, using device number or names as shown above.</p> <p>You can also load a MIDI file using the -F or --midifile=FILE command line flag. The MIDI file is read in realtime, and behaves as if it was being performed or received in realtime. So the csound program is not aware if MIDI input comes from a MIDI file or directly from a MIDI interface.</p> <p>Once realtime MIDI input and/or output has been activated, opcodes like MIDI Input and MIDI Output will have effect.</p> <p>When MIDI input is enabled (with -M or -F), each incoming noteon message will generate a note event for an instrument which has the same number as the channel of the event  (This means that MIDI controlled instruments are polyphonic by default, since each note will generate a new instance of the instrument.)If you have 1 instrument only, Csound works in omni mode, ie. it responds to all channels into that single instrument.If you have more than one instrument and instrs 1 - 16 , then by default  instr 1 -&gt; chn 1, instr 2 -&gt; chn 2, unless you alter the mapping (see massign and pgmassign to change this behavior).For a single port input, if you have more than one instrument, but instr N in between 1 - 16 is missing, then chn N will be routed by default to the lowest order instrument.</p> <p>See the MIDI/Score Interoperability opcodes for information on designing instruments which can be used from the score or driven by MIDI.</p> <p>There are several realtime MIDI modules available, you must use the -+rtmidi flag (See -+rtmidi), to specify the module. The default module is portmidi which provides adequate MIDI I/O on all platforms, however for improved performance and reliability some platform specific modules are also provided. Currently the midi modules available are:</p> <ul> <li>portmidi - To use thePortMIDI system (all platforms). This is the default setting andit allows multiple-port inputs (with 'm' or 'a' device names).</li> <li>alsa - To use the ALSA midi system (Linux only)</li> <li>jack - To use the Jack midi system</li> <li>winmme - To use the windows MME system (Windows only)</li> <li>virtual - To use a virtual graphical keyboard (See below) as MIDI input (all platforms)</li> </ul> <p>:note:</p> <p>When csound runs, it will process the score and then quit. If there are no events in the score, Csound will run forever. If you want to use only MIDI events instead of score events and you know how long you wish to run, you can tell Csound to run that amount of time by using the dummy f-statement like \"f 0 360\".    </p>"},{"location":"midi/virtual/","title":"Virtual MIDI Keyboard","text":"Virtual MIDI keyboard <p>The Virtual Keyboard is a Plugin in widgets. This opcode is part of the plugin repository and has to be installed separately. This FLTK widget does not work on the Mac.The plugin repository can be found here:  https://github.com/csound/plugins.</p> <p>The virtual MIDI keyboard module (activated using -+rtmidi=virtual on thecommand line flags) provides a way of sending realtime MIDI information toCsound without the need of a MIDI device. It can send note information,control changes, bank and program changes on a specified channel. The MIDIinformation from the virtual keyboard is processed by Csound in exactly thesame way as MIDI information that comes from the other MIDI drivers, so ifyour Csound orchestra is designed to work with hardware MIDI devices, thiswill also work.</p> <p>For the device flag (-M), the virtual keyboard uses this to take in the nameof a keyboard mapping files. Like all MIDI drivers, a device must be givento activate the driver. If you would like to just use the default settingsof the keyboard, simply passing in 0 (i.e. -M0) and the virtual keyboardwill use its default settings. If instead of the 0 a name of a file isgiven, the keyboard will attempt to load the file as a keyboard mapping. Ifthe file could not be opened or read correctly, the default settings will beused.</p> <p>Keyboard Mapping files allow the user to customize the name and number of banksas well as the name and number of programs per bank.  The following examplekeyboard mapping (named keyboard.map) has inline comments on the file format.This file is also available with the Csound source distribution in theInOut/virtual_keyboard folder.</p> <p><pre><code># Custom Keyboard Map for Virtual Keyboard\n# Steven Yi\n#\n# USAGE\n#\n# When using the Virtual Keyboard, you can supply a filename for a mapping\n# of banks and programs via the -M flag, for example:\n#\n# csound -+rtmidi=virtual -Mkeyboard.map my_project.csd\n#\n# INFORMATION ON THE FORMAT\n#\n# -lines that start with '#' are comments\n# -lines that have [] start new bank definitions,\n#  the contents are bankNum=bankName, with bankNum=[1,16384]\n# -lines following bank statements are program definitions\n#  in the format programNum=programName, with programNum=[1,128]\n# -bankNumbers and programNumbers are defined in this file\n#  starting with 1, but are converted to midi values (starting\n#  with 0) when read\n#\n# NOTES\n#\n# -if an invalid bank definition is found, all program\n#  defintions that follow will be ignored until a new\n#  valid bank definition is found\n# -if a valid bank is defined by no valid programs found\n#  for that bank, it will default to General MIDI program\n#  definitions\n# -if an invalid program definition is found, it will be\n#  ignored\n\n[1=My Bank]\n1=My Test Patch 1\n2=My Test Patch 2\n30=My Test Patch 30\n\n[2=My Bank2]\n1=My Test Patch 1(bank2)\n2=My Test Patch 2(bank2)\n30=My Test Patch 30(bank3)\n</code></pre> The ten sliders up top are by default set to MIDI Controller number 1-10though they can be changed to whatever one wishes to use. The controllernumbers and values of each slider are set per channel, so one may usedifferent settings and values for each channel.</p> <p>By default there are 128 banks and for each bank 128 patches defaulting toGeneral Midi names. The MIDI bank standard uses 14-bit resolution to support16384 possible banks, but the bank numbers by default are 0-127. To usevalues higher than 127, one should use a custom keyboard map and set thedesired bank number value for the bank name. The virtual keyboard willcorrectly transmit the bank number as MSB and LSB with controller numbers 0and 32.</p> <p>Beyond the input available from interacting with the GUI via mouse, one mayalso trigger off MIDI notes by using the ASCII keyboard when the virtualkeyboard window is focused. The layout is done much like a tracker and offerstwo octaves and a major third to trigger, starting from Middle-C (MIDI note 60).The ASCII keyboard MIDI note values are given in the following table.</p>"},{"location":"midi/virtual/#ascii-keyboard-midi-note-values","title":"ASCII Keyboard MIDI Note Values","text":"Keyboard Key MIDI Value z 60 s 61 x 62 d 63 c 64 v 65 g 66 b 67 h 68 n 69 j 70 m 71 q 72 2 73 w 74 3 75 e 76 r 77 5 78 t 79 6 80 y 81 7 82 u 83 i 84 9 85 o 86 0 87 p 88 <p>Here's an example of usage of the virtual MIDI keyboard. It uses the file virtual.csd.</p> Example of the chuap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;; Select audio/midi flags here according to platform\n; Audio out   Audio in     Virtual MIDI    -M0 is needed anyway\n-odac           -iadc    -+rtmidi=virtual -M0\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n; By Mark Jamerson 2007\n\nsr=44100\nksmps=10\nnchnls=2\n\nmassign 1,1\nprealloc 1,10\n\ninstr 1  ;Midi FM synth \n\ninote cpsmidi\niveloc ampmidi 10000\nidur = 2\n    xtratim 1\n\nkgate oscil 1,10,2\nanoise noise 100*inote,.99\nacps  samphold anoise,kgate\naosc oscili 1000,acps,1\naout = aosc\n\n; Use controller 7 to control volume\nkvol ctrl7 1, 7, 0.2, 1\n\nouts kvol * aout, kvol * aout\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf0 3600\nf1 0 1024 10 1 \nf2 0 16 7 1 8 0 8\nf3 0 1024 10 1 .5 .6 .3 .2 .5\n\ne \n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/0dbfs/","title":"0dbfs","text":""},{"location":"opcodes/0dbfs/#0dbfs","title":"0dbfs","text":"<p>Sets the value of 0 decibels using full scale amplitude.</p>"},{"location":"opcodes/0dbfs/#syntax","title":"Syntax","text":"<pre><code>0dbfs = iarg\n0dbfs\n</code></pre>"},{"location":"opcodes/0dbfs/#initialization","title":"Initialization","text":"<p>iarg -- the value of 0 decibels using full scale amplitude.</p>"},{"location":"opcodes/0dbfs/#performance","title":"Performance","text":"<p>The default is 32767, so all existing orcs should work.</p> <p>Amplitude values in Csound are always relative to a 0dbfs value representing the peak available amplitude before clipping. In the original Csound, this value was always 32767, corresponding to the bipolar range of a 16bit soundfile or 16bit AD/DA codec. This remains the default peak amplitude for Csound, for backward compatibility. The 0dbfs value enables Csound to produce appropriately scaled values to whatever output format is being used, whether 16bit integer, 24bit integer, 32bit floats, or even 32bit integers.</p> <p>0dBFS can be defined in the header, to set the amplitude reference Csound will use, but it can also be used as a varible inside instruments like this:</p> <pre><code>ipeak 0dbfs\n</code></pre> <pre><code>asig 0dbfs, freq, 1\n0dbfs\n</code></pre> <p>The purpose of the 0dbfs opcode is for people to start to code 0dbfs-relatively (and use the ampdbfs() opcodes a lot more!), rather than use explicit sample values. Using 0dbfs=1 is in accordance to industry practice, as ranges from -1 to 1 are used in most commercial plugin formats and in most other synthesis systems like Pure Data.</p> <p>Floats written to a file, when 0dbfs = 1, will in effect go through no range translation at all. So the numbers in the file are exactly what the orc says they are.</p> <p>For more details on amplitude values in Csound, see the section Amplitude values in Csound</p> <p>Example</p> <p>Here is an example of the 0dbfs opcode. It uses the file 0dbfs.csd.</p> Example of the 0dbfs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o 0dbfs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 2\n\n; Set the 0dbfs to 1.\n0dbfs = 1\n\ninstr 1  ; from linear amplitude (0-1 range)\nprint p4\na1 oscil p4, 440, 1\nouts a1, a1\nendin\n\ninstr 2  ; from linear amplitude (0-32767 range)\niamp = p4 / 32767\nprint iamp\na1 oscil iamp, 440, 1\nouts a1, a1\nendin\n\ninstr 3  ; from dB FS\niamp = ampdbfs(p4)\nprint iamp\na1 oscil iamp, 440, 1\nouts a1, a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\ni 1 0 1   1\ni 1 + 1   0.5\ni 1 + 1   0.1\ns\ni 2 0 1   32767\ni 2 + 1   [32767/2]\ni 2 + 1   [3276.7]\ns\ni 3 0 1   0\ni 3 + 1   -6\ni 3 + 1   -20\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/0dbfs/#see-also","title":"See also","text":"<p>Sets the value of 0 decibels using full scale amplitude.</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/0dbfs/#credits","title":"Credits","text":"<p>Author: Richard Dobson May 2002</p> <p>New in version 4.10</p>"},{"location":"opcodes/A4/","title":"A4","text":""},{"location":"opcodes/A4/#a4","title":"A4","text":"<p>Sets the base frequency for pitch A4.</p> <p>These statements are global value assignments, made  at the beginning of an orchestra, before any instrument block is defined. Their function is to set certain reserved symbol variables that are required for performance. Once set, these reserved symbols can be used in expressions anywhere in the orchestra.</p>"},{"location":"opcodes/A4/#syntax","title":"Syntax","text":"<pre><code>A4 = iarg\n</code></pre>"},{"location":"opcodes/A4/#initialization","title":"Initialization","text":"<p>A4  = (optional) -- set reference frequency for pitch A4 to iarg Hertz. The default value is 440.</p> <p>In addition, any global variable can be initialized by an init-time assignment anywhere before the first instr statement.  All of the above assignments are run as instrument 0 (i-pass only) at the start of real performance.</p> <p>Beginning with Csound version 6.08, A4 may be used.  It affects the behaviour of the opcodes cpspch, cpsoct, cps2pch, cpsxpch and cpsmidinn.</p>"},{"location":"opcodes/A4/#examples","title":"Examples","text":"<p>Here is an example of the A4 opcode. It uses the file A4.csd.</p> Example of the A4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o A4.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi - 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n#define STANDARDPITCH #440# ; as set by ISO 1975:16 - STANDARD MUSICAL PITCH\n#define BAROQUEPITCH #415# ; common use (but not standard) in Baroque era (1600 - 1750) \n#define HIGHER #443# ; some orchestras, mainly in Europe use higher pitch (442-443 Hz)\n\n#define EXPRESSION #(440*1.3)+200# ; you can use an expression\n\nA4 = $STANDARDPITCH\n;A4 = $BAROQUEPITCH\n;A4 = $HIGHER\n\n;A4 = $EXPRESSION\n\ninstr 1 \n\nipch =  p4\nicps =  cpspch(ipch)\nasig    oscil 0.7, icps, 1\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 4096 10 1 0.3 0.2. 0.1\n\n; Theme from Bach BWV 578 -  Little fugue in G minor.\ni 1 0 1 7.07\ni 1 + 1 8.02\ni 1 + 1.5 7.10\ni 1 + .5 7.09\ni 1 + .5 7.07\ni 1 + .5 7.10\ni 1 + .5 7.09\ni 1 + .5 7.07\ni 1 + .5 7.06\ni 1 + .5 7.09\ni 1 + 1 7.02\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/A4/#see-also","title":"See also","text":"<p>Orchestra Header Statements</p>"},{"location":"opcodes/A4/#credits","title":"Credits","text":"<p>Authors: John ffitch September 2016</p> <p>New in Csound Version 6.08</p>"},{"location":"opcodes/abs/","title":"Abs","text":""},{"location":"opcodes/abs/#abs","title":"abs","text":"<p>Returns an absolute value.</p>"},{"location":"opcodes/abs/#syntax","title":"Syntax","text":"<pre><code>abs(x) (no rate restriction)\nabs(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/abs/#examples","title":"Examples","text":"<p>Here is an example of the abs opcode. It uses the file abs.csd.</p> Example of the abs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o abs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\nix = p4\niabs = abs(ix)\nprint iabs\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1 0\ni 1 + 1 -.15\ni 1 + 1 -13\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iabs = 0.000\ninstr 1:  iabs = 0.150\ninstr 1:  iabs = 13.000\n</code></pre>"},{"location":"opcodes/abs/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/active/","title":"Active","text":""},{"location":"opcodes/active/#active","title":"active","text":"<p>Returns the number of active instances of an instrument with options to ignore releasing instances.</p>"},{"location":"opcodes/active/#syntax","title":"Syntax","text":"<pre><code>ir active insnum [,iopt [,inorel]]\nir active Sinsname [,iopt [,inorel]]\nkres active kinsnum [,iopt [,inorel]]\n</code></pre>"},{"location":"opcodes/active/#initialization","title":"Initialization","text":"<p>insnum -- number or string name of the instrument to be reported</p> <p>Sinsname -- instrument name</p> <p>iopt -- select currently active (zero, default), or all every active (non zero)</p> <p>inorel -- if non-zero ignore instruments in release phase (zero, default), only valid if iopts is zero.</p>"},{"location":"opcodes/active/#performance","title":"Performance","text":"<p>kinsnum -- number or string name of the instrument to be reported</p> <p>active returns the number of active instances of instrument number insnum/kinsnum (or named instrument Sinsname). As of Csound 4.17 the output is updated at k-rate (if input arg is k-rate), to allow running count of instr instances.</p> <p>As of Csound 5.17 if the instrument number is given as zero then all instruments are counted.</p>"},{"location":"opcodes/active/#examples","title":"Examples","text":"<p>Here is a simple example of the active opcode. It uses the file active.csd.</p> Simple example of the active opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o active.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - a noisy waveform.\ninstr 1\n  ; Generate a really noisy waveform.\n  anoisy rand 44100\n  ; Turn down its amplitude.\n  aoutput gain anoisy, 2500\n  ; Send it to the output.\n  out aoutput\nendin\n\n; Instrument #2 - counts active instruments.\ninstr 2\n  ; Count the active instances of Instrument #1.\n  icount active 1\n  ; Print the number of active instances.\n  print icount\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Start the first instance of Instrument #1 at 0:00 seconds.\ni 1 0.0 3.0\n\n; Start the second instance of Instrument #1 at 0:015 seconds.\ni 1 1.5 1.5\n\n; Play Instrument #2 at 0:01 seconds, when we have only \n; one active instance of Instrument #1.\ni 2 1.0 0.1\n\n; Play Instrument #2 at 0:02 seconds, when we have \n; two active instances of Instrument #1.\ni 2 2.0 0.1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 2:  icount = 1.000\ninstr 2:  icount = 2.000\n</code></pre> <p>Here is a more advanced example of the active opcode. It displays the results of the active opcode at k-rate instead of i-rate. It uses the file active_k.csd.</p> Example of the active opcode at k-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o active_k.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - a noisy waveform.\ninstr 1\n  ; Generate a really noisy waveform.\n  anoisy rand 44100\n  ; Turn down its amplitude.\n  aoutput gain anoisy, 2500\n  ; Send it to the output.\n  out aoutput\nendin\n\n; Instrument #2 - counts active instruments at k-rate.\ninstr 2\n  ; Count the active instances of Instrument #1.\n  kcount active 1\n  ; Print the number of active instances.\n  printk2 kcount\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Start the first instance of Instrument #1 at 0:00 seconds.\ni 1 0.0 3.0\n\n; Start the second instance of Instrument #1 at 0:015 seconds.\ni 1 1.5 1.5\n\n; Play Instrument #2 at 0:01 seconds, when we have only \n; one active instance of Instrument #1.\ni 2 1.0 0.1\n\n; Play Instrument #2 at 0:02 seconds, when we have \n; two active instances of Instrument #1.\ni 2 2.0 0.1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i2     1.00000\ni2     2.00000\n</code></pre> <p>Here is another example of the active opcode, using the number of instances to calculate gain. It uses the file active_scale.csd.</p> Example of the active opcode at k-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac             -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o atone.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr= 44100\nksmps = 64\nnchnls = 1\n0dbfs = 1\n\n;by Victor Lazzarini 2008\n\ninstr 1\nkscal active  1\nkamp port   1/kscal, 0.01\nasig  oscili  kamp, p4, 1\nkenv linseg 0, 0.1,1,p3-0.2,1,0.1, 0\n\n        out asig*kenv\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\ni1 0 10 440\ni1 1 3  220\ni1 2 5  350\ni1 4 3  700\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/active/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/active/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK July, 1999</p> <p>Examples written by Kevin Conder.</p> <p>New in Csound version 3.57; named instruments added version 5.13</p> <p>Option for all ever active new in 5.13</p> <p>Count of all instruments new in 5.17</p> <p>No release option new in 5.19</p>"},{"location":"opcodes/adds/","title":"Adds","text":""},{"location":"opcodes/adds/#_1","title":"\\(+\\)","text":"<p>Addition operator</p> <p>Arithmetic operators perform operations of change-sign (negate), do-no-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/adds/#syntax","title":"Syntax","text":"<pre><code>+a  (no rate restriction)\na + b  (no rate restriction)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/adds/#arguments","title":"Arguments","text":"<p>The arguments of \\(+\\) can be scalar values or k-rate one dimensional arrays (vectors), or any combination.  If one of the arguments is an array, so is the value.</p>"},{"location":"opcodes/adds/#examples","title":"Examples","text":"<p>Here is an example of the + operator. It uses the file adds.csd.</p> Example of the + operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adds.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n; add unipolar square to oscil\nkamp = p4\nkcps = 1\nitype = 3\n\nklfo    lfo kamp, kcps, itype\nprintk2 klfo\nasig    oscil 0.7, 440+klfo, 1\n        outs asig, asig\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 32768 10 1\n\ni 1 0 2 1       ;adds 1 Hz to frequency\ni 1 + 2 10      ;adds 10 Hz to frequency\ni 1 + 2 220     ;adds 220 Hz to frequency\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/adds/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/adds/#credits","title":"Credits","text":"<p>Arithmetic on vectors is new in version 6.00</p>"},{"location":"opcodes/adsr/","title":"Adsr","text":""},{"location":"opcodes/adsr/#adsr","title":"adsr","text":"<p>Calculates the classical ADSR envelope using linear segments.</p>"},{"location":"opcodes/adsr/#syntax","title":"Syntax","text":"<pre><code>ares adsr iatt, idec, islev, irel [, idel]\nkres adsr iatt, idec, islev, irel [, idel]\n</code></pre>"},{"location":"opcodes/adsr/#initialization","title":"Initialization","text":"<p>iatt -- duration of attack phase</p> <p>idec -- duration of decay</p> <p>islev -- level for sustain phase</p> <p>irel -- duration of release phase</p> <p>idel -- period of zero before the envelope starts</p>"},{"location":"opcodes/adsr/#performance","title":"Performance","text":"<p>The envelope generated is the range 0 to 1 and may need to be scaled further, depending on the amplitude required. If using 0dbfs = 1, scaling down will probably be required since playing more than one note might result in clipping. If not using 0dbfs, scaling to a large amplitude (e.g. 32000) might be required.</p> <p>The envelope may be described as:</p> Picture of an ADSR envelope. <p>The length of the sustain is calculated from the length of the note. This means adsr is not suitable for use with MIDI events. The opcode madsr uses the linsegr mechanism, and so can be used in MIDI applications.</p> <p>adsr is new in Csound version 3.49.</p>"},{"location":"opcodes/adsr/#examples","title":"Examples","text":"<p>Here is an example of the adsr opcode. It uses the file adsr.csd.</p> Example of the adsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\niatt  = p5\nidec  = p6  \nislev = p7\nirel  = p8\n\nkenv    adsr iatt, idec, islev, irel\nkcps =  cpspch(p4)        ;frequency\n\nasig    vco2  kenv * 0.8, kcps\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1  0  2  7.00  .0001  1  .5  .001 ; short attack\ni 1  3  2  7.02  1  .5  .5  .001    ; long attack\ni 1  6  2  6.09  .0001  1 .5  .7     ; long release\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the adsr-group, comparing the different adsr opcodes. It uses the file adsr-group.csd.</p> Example of the adsr group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsr-group.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel - 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; both amplitude and filter use same ADSR curves \ninstr 1                  \nkenv    adsr    .01, .5, .5, p4         ; linear envelope \nasig    vco2    kenv, 110                       ; A+D+S+R = p3  \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig       \nendin\n\ninstr 2 ; midi behavior                  \nkenv    madsr   .01, .5, .5, p4         ; linear envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage                \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled  \n                outs    asig, asig                      \nendin\n\ninstr 3                  \nkenv    xadsr   .01, .5 , .5, p4    ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S+R = p3   \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig\nendin\n\ninstr 4 ; midi behavior          \nkenv    mxadsr  .01, .5 , .5, p4        ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage         \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig                      \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 1 2 .01      ; same notes for everyone!\ni1 5 . .5\ni1 9 . 1.5\ns\ni2 1 2 .01\ni2 5 . .5\ni2 9 . 1.5\ns\ni3 1 2 .01\ni3 5 . .5\ni3 9 . 1.5\ns\ni4 1 2 .01\ni4 5 . .5\ni4 9 . 1.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/adsr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/adsr/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.49</p>"},{"location":"opcodes/adsyn/","title":"Adsyn","text":""},{"location":"opcodes/adsyn/#adsyn","title":"adsyn","text":"<p>Output is an additive set of individually controlled sinusoids, using an oscillator bank.</p>"},{"location":"opcodes/adsyn/#syntax","title":"Syntax","text":"<pre><code>ares adsyn kamod, kfmod, ksmod, ifilcod\n</code></pre>"},{"location":"opcodes/adsyn/#initialization","title":"Initialization","text":"<p>ifilcod --  integer or character-string denoting a control-file derived from analysis of an audio signal. An integer denotes the suffix of a file adsyn.m or pvoc.m; a character-string (in double quotes) gives a filename, optionally a full pathname. If not fullpath, the file is sought first in the current directory, then in the one given by the environment variable SADIR (if defined). adsyn control contains breakpoint amplitude- and frequency-envelope values organized for oscillator resynthesis, while pvoc control contains similar data organized for fft resynthesis. Memory usage depends on the size of the files involved, which are read and held entirely in memory during computation but are shared by multiple calls (see also lpread).</p>"},{"location":"opcodes/adsyn/#performance","title":"Performance","text":"<p>kamod -- amplitude factor of the contributing partials.</p> <p>kfmod -- frequency factor of the contributing partials. It is a control-rate transposition factor: a value of 1 incurs no transposition, 1.5 transposes up a perfect fifth, and .5 down an octave.</p> <p>ksmod -- speed factor of the contributing partials.</p> <p>adsyn synthesizes complex time-varying timbres through the method of additive synthesis. Any number of sinusoids, each individually controlled in frequency and amplitude, can be summed by high-speed arithmetic to produce a high-fidelity result.</p> <p>Component sinusoids are described by a control file describing amplitude and frequency tracks in millisecond breakpoint fashion. Tracks are defined by sequences of 16-bit binary integers:</p> <p><pre><code>-1, time, amp, time, amp,...\n-2, time, freq, time, freq,...\n</code></pre> such as from hetrodyne filter analysis of an audio file. (For details see hetro.) The instantaneous amplitude and frequency values are used by an internal fixed-point oscillator that adds each active partial into an accumulated output signal. While there is a practical limit (limit removed in version 3.47) on the number of contributing partials, there is no restriction on their behavior over time. Any sound that can be described in terms of the behavior of sinusoids can be synthesized by adsyn alone.</p> <p>Sound described by an adsyn control file can also be modified during re-synthesis. The signals kamod, kfmod, ksmod will modify the amplitude, frequency, and speed of contributing partials. These are multiplying factors, with kfmod modifying the frequency and ksmod modifying the speed with which the millisecond breakpoint line-segments are traversed. Thus .7, 1.5, and 2 will give rise to a softer sound, a perfect fifth higher, but only half as long. The values 1,1,1 will leave the sound unmodified. Each of these inputs can be a control signal.</p>"},{"location":"opcodes/adsyn/#examples","title":"Examples","text":"<p>Here is an example of the adsyn opcode. It uses the file adsyn.csd.</p> Example of the adsyn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsyn.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs =  1\n\n; by Menno Knevel - 2021\n\n; start at 100 Hz, harmonics up to 10kHz\nires system_i 1,{{ hetro -f100 -h100 stereoJungle.wav Jungle.het }}\n\ninstr 1         ; play original sample\naL,aR   diskin  \"stereoJungle.wav\", 1\n        outs    aL, aR\nendin\n\ninstr 2\nkamod = 3       ; scale amplitude\nkfmod = p4\nksmod = p5\nasig    adsyn   kamod, kfmod, ksmod, \"Jungle.het\"\n        outs    asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 0 7                  ; original sample\ns\n;           frqmod speed\ni2 0  20      1    .2   ; 5 x slower\ni2 20 5       2     1   ; 2 x higher\ni2 25 15     .3    1.5  ; lower &amp; faster\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/adsyn/#see-also","title":"See also","text":"<p>Additive Synthesis/Resynthesis</p>"},{"location":"opcodes/adsynt/","title":"Adsynt","text":""},{"location":"opcodes/adsynt/#adsynt","title":"adsynt","text":"<p>Performs additive synthesis with an arbitrary number of partials, not necessarily harmonic.</p>"},{"location":"opcodes/adsynt/#syntax","title":"Syntax","text":"<pre><code>ares adsynt kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]\n</code></pre>"},{"location":"opcodes/adsynt/#initialization","title":"Initialization","text":"<p>iwfn -- table containing a waveform, usually a sine. Table values are not interpolated for performance reasons, so larger tables provide better quality.</p> <p>ifreqfn -- table containing frequency values for each partial. ifreqfn may contain beginning frequency values for each partial, but is usually used for generating parameters at runtime with tablew. Frequencies must be relative to kcps. Size must be at least icnt.</p> <p>iampfn -- table containing amplitude values for each partial. iampfn may contain beginning amplitude values for each partial, but is usually used for generating parameters at runtime with tablew. Amplitudes must be relative to kamp. Size must be at least icnt.</p> <p>icnt -- number of partials to be generated</p> <p>iphs -- initial phase of each oscillator, if iphs = -1, initialization is skipped. If iphs &gt; 1, all phases will be initialized with a random value.</p>"},{"location":"opcodes/adsynt/#performance","title":"Performance","text":"<p>kamp -- amplitude of note</p> <p>kcps -- base frequency of note. Partial frequencies will be relative to kcps.</p> <p>Frequency and amplitude of each partial is given in the two tables provided. The purpose of this opcode is to have an instrument generate synthesis parameters at k-rate and write them to global parameter tables with the tablew opcode.</p>"},{"location":"opcodes/adsynt/#examples","title":"Examples","text":"<p>Here is an example of the adsynt opcode. It uses the file adsynt.csd. These two instruments perform additive synthesis. The output of each sounds like a Tibetan bowl. The first one is static, as parameters are only generated at init-time. In the second one, parameters are continuously changed.</p> Example of the adsynt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsynt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; Generate a sinewave table.\ngiwave ftgen 1, 0, 1024, 10, 1\n; Generate two empty tables for adsynt.\ngifrqs ftgen 2, 0, 32, 7, 0, 32, 0\n; A table for freqency and amp parameters.\ngiamps ftgen 3, 0, 32, 7, 0, 32, 0\n\n; Generates parameters at init time\ninstr 1\n  ; Generate 10 voices.\n  icnt = 10 \n  ; Init loop index.\n  index = 0 \n\n; Loop only executed at init time.\nloop: \n  ; Define non-harmonic partials.\n  ifreq pow index + 1, 1.5 \n  ; Define amplitudes.\n  iamp = 1 / (index+1) \n  ; Write to tables.\n  tableiw ifreq, index, gifrqs \n  ; Used by adsynt.\n  tableiw iamp, index, giamps \n\n  index = index + 1\n  ; Do loop/\n  if (index &lt; icnt) igoto loop \n\n  asig adsynt 0.3, 150, giwave, gifrqs, giamps, icnt\n  outs asig, asig\nendin\n\n; Generates parameters every k-cycle.\ninstr 2 \n  ; Generate 10 voices.\n  icnt = 10 \n  ; Reset loop index.\n  kindex = 0\n\n; Loop executed every k-cycle.\nloop:\n  ; Generate lfo for frequencies.\n  kspeed  pow kindex + 1, 1.6\n  ; Individual phase for each voice.\n  kphas phasorbnk kspeed * 0.7, kindex, icnt\n  klfo table kphas, giwave, 1\n  ; Arbitrary parameter twiddling...\n  kdepth pow 1.4, kindex\n  kfreq pow kindex + 1, 1.5\n  kfreq = kfreq + klfo*0.006*kdepth\n\n  ; Write freqs to table for adsynt.\n  tablew kfreq, kindex, gifrqs \n\n  ; Generate lfo for amplitudes.\n  kspeed  pow kindex + 1, 0.8\n  ; Individual phase for each voice.\n  kphas phasorbnk kspeed*0.13, kindex, icnt, 2\n  klfo table kphas, giwave, 1\n  ; Arbitrary parameter twiddling...\n  kamp pow 1 / (kindex + 1), 0.4\n  kamp = kamp * (0.3+0.35*(klfo+1))\n\n  ; Write amps to table for adsynt.\n  tablew kamp, kindex, giamps\n\n  kindex = kindex + 1\n  ; Do loop.\n  if (kindex &lt; icnt) kgoto loop\n\n  asig adsynt 0.25, 150, giwave, gifrqs, giamps, icnt\n  outs asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 2.5 seconds.\ni 1 0 2.5\n; Play Instrument #2 for 2.5 seconds.\ni 2 3 2.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/adsynt/#see-also","title":"See also","text":"<p>Additive Synthesis/Resynthesis</p>"},{"location":"opcodes/adsynt/#credits","title":"Credits","text":"<p>Author: Peter Neub\u00e4cker Munich, Germany August, 1999</p> <p>New in Csound version 3.58</p>"},{"location":"opcodes/adsynt2/","title":"Adsynt2","text":""},{"location":"opcodes/adsynt2/#adsynt2","title":"adsynt2","text":"<p>Performs additive synthesis with an arbitrary number of partials, not necessarily harmonic. (see adsynt for detailed manual)</p>"},{"location":"opcodes/adsynt2/#syntax","title":"Syntax","text":"<pre><code>ar adsynt2 kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]\n</code></pre>"},{"location":"opcodes/adsynt2/#initialization","title":"Initialization","text":"<p>iwfn -- table containing a waveform, usually a sine. Table values are not interpolated for performance reasons, so larger tables provide better quality.</p> <p>ifreqfn -- table containing frequency values for each partial. ifreqfn may contain beginning frequency values for each partial, but is usually used for generating parameters at runtime with tablew. Frequencies must be relative to kcps. Size must be at least icnt.</p> <p>iampfn -- table containing amplitude values for each partial. iampfn may contain beginning amplitude values for each partial, but is usually used for generating parameters at runtime with tablew. Amplitudes must be relative to kamp. Size must be at least icnt.</p> <p>icnt -- number of partials to be generated</p> <p>iphs -- initial phase of each oscillator, if iphs = -1, initialization is skipped. If iphs &gt; 1, all phases will be initialized with a random value.</p>"},{"location":"opcodes/adsynt2/#performance","title":"Performance","text":"<p>kamp -- amplitude of note</p> <p>kcps -- base frequency of note. Partial frequencies will be relative to kcps.</p> <p>Frequency and amplitude of each partial is given in the two tables provided. The purpose of this opcode is to have an instrument generate synthesis parameters at k-rate and write them to global parameter tables with the tablew opcode.</p> <p>adsynt2 is identical to adsynt (by Peter Neub\u00e4cker), except it provides linear interpolation for amplitude envelopes of each partial. It is a bit slower than adsynt, but interpolation higly improves sound quality in fast amplitude envelope transients when kr &lt; sr (i.e. when ksmps &gt; 1). No interpolation is provided for pitch envelopes, since in this case sound quality degradation is not so evident even with high values of ksmps. It is not recommended when kr = sr, in this case adsynt is better (since it is faster).</p>"},{"location":"opcodes/adsynt2/#examples","title":"Examples","text":"<p>Here is an example of the adsynt2 opcode. It uses the file adsynt2.csd. These two instruments perform additive synthesis. The output of each sounds like a Tibetan bowl. The first one is static, as parameters are only generated at init-time. In the second one, parameters are continuously changed.</p> Example of the adsynt2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsynt2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; Generate a sinewave table.\ngiwave ftgen 1, 0, 1024, 10, 1\n; Generate two empty tables for adsynt2.\ngifrqs ftgen 2, 0, 32, 7, 0, 32, 0\n; A table for freqency and amp parameters.\ngiamps ftgen 3, 0, 32, 7, 0, 32, 0\n\n; Generates parameters at init time\ninstr 1\n  ; Generate 10 voices.\n  icnt = 10 \n  ; Init loop index.\n  index = 0 \n\n; Loop only executed at init time.\nloop: \n  ; Define non-harmonic partials.\n  ifreq pow index + 1, 1.5 \n  ; Define amplitudes.\n  iamp = 1 / (index+1) \n  ; Write to tables.\n  tableiw ifreq, index, gifrqs \n  ; Used by adsynt2.\n  tableiw iamp, index, giamps \n\n  index = index + 1\n  ; Do loop/\n  if (index &lt; icnt) igoto loop \n\n  asig adsynt2 0.4, 150, giwave, gifrqs, giamps, icnt\n  outs asig, asig\nendin\n\n; Generates parameters every k-cycle.\ninstr 2 \n  ; Generate 10 voices.\n  icnt = 10 \n  ; Reset loop index.\n  kindex = 0\n\n; Loop executed every k-cycle.\nloop:\n  ; Generate lfo for frequencies.\n  kspeed  pow kindex + 1, 1.6\n  ; Individual phase for each voice.\n  kphas phasorbnk kspeed * 0.7, kindex, icnt\n  klfo table kphas, giwave, 1\n  ; Arbitrary parameter twiddling...\n  kdepth pow 1.4, kindex\n  kfreq pow kindex + 1, 1.5\n  kfreq = kfreq + klfo*0.006*kdepth\n\n  ; Write freqs to table for adsynt2.\n  tablew kfreq, kindex, gifrqs \n\n  ; Generate lfo for amplitudes.\n  kspeed  pow kindex + 1, 0.8\n  ; Individual phase for each voice.\n  kphas phasorbnk kspeed*0.13, kindex, icnt, 2\n  klfo table kphas, giwave, 1\n  ; Arbitrary parameter twiddling...\n  kamp pow 1 / (kindex + 1), 0.4\n  kamp = kamp * (0.3+0.35*(klfo+1))\n\n  ; Write amps to table for adsynt2.\n  tablew kamp, kindex, giamps\n\n  kindex = kindex + 1\n  ; Do loop.\n  if (kindex &lt; icnt) kgoto loop\n\n  asig adsynt2 0.25, 150, giwave, gifrqs, giamps, icnt\n  outs asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 2.5 seconds.\ni 1 0 2.5\n; Play Instrument #2 for 2.5 seconds.\ni 2 3 2.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/adsynt2/#see-also","title":"See also","text":"<p>Additive Synthesis/Resynthesis</p>"},{"location":"opcodes/adsynt2/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/aftouch/","title":"Aftouch","text":""},{"location":"opcodes/aftouch/#aftouch","title":"aftouch","text":"<p>Get the current after-touch value for this channel.</p>"},{"location":"opcodes/aftouch/#syntax","title":"Syntax","text":"<pre><code>kaft aftouch [imin] [, imax]\n</code></pre>"},{"location":"opcodes/aftouch/#initialization","title":"Initialization","text":"<p>imin (optional, default=0) -- minimum limit on values obtained.</p> <p>imax (optional, default=127) -- maximum limit on values obtained.</p>"},{"location":"opcodes/aftouch/#examples","title":"Examples","text":"<p>Here is an example of the aftouch opcode. It uses the file aftouch.csd.</p> Example of the aftouch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   No messages  MIDI in\n-odac           -d         -M0  ;;;RT audio out with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkaft aftouch 0, 1\nprintk2 kaft\n\n;aftertouch from music keyboard used for volume control\nasig    oscil 0.7 * kaft, 220, 1\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 30\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/aftouch/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/aftouch/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/alpass/","title":"Alpass","text":""},{"location":"opcodes/alpass/#alpass","title":"alpass","text":"<p>Reverberates an input signal with a flat frequency response.</p>"},{"location":"opcodes/alpass/#syntax","title":"Syntax","text":"<pre><code>ares alpass asig, xrvt, ilpt [, iskip] [, insmps]\n</code></pre>"},{"location":"opcodes/alpass/#initialization","title":"Initialization","text":"<p>ilpt -- loop time in seconds, which determines the \u201cecho density\u201d of the reverberation. This in turn characterizes the \u201ccolor\u201d of the filter whose frequency response curve will contain ilpt * sr/2 peaks spaced evenly between 0 and sr/2 (the Nyquist frequency). Loop time can be as large as available memory will permit. The space required for an n second loop is 4_n_*sr bytes. The delay space is allocated and returned as in delay.</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p> <p>insmps (optional, default=0) -- delay amount, as a number of samples.</p>"},{"location":"opcodes/alpass/#performance","title":"Performance","text":"<p>xrvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>This filter reiterates the input with an echo density determined by loop time ilpt. The attenuation rate is independent and is determined by xrvt, the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude). Output will begin to appear immediately.</p>"},{"location":"opcodes/alpass/#examples","title":"Examples","text":"<p>Here is an example of the alpass opcode. It uses the file alpass.csd.</p> Example of the alpass opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o alpass.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 100\nnchnls = 2\n0dbfs = 1\n\ngamix init 0 \n\ninstr 1 \n\nacps    expon p4, p3, p5\nasig    vco  0.6, acps, 1\n        outs  asig, asig \n\ngamix = gamix + asig \n\nendin\n\ninstr 99 \n\narvt1 line 3.5*1.5, p3, 6\narvt2 line 3.5, p3, 4\nilpt =  0.1\naleft   alpass gamix, arvt1, ilpt\naright  alpass gamix, arvt2, ilpt*2\n        outs   aleft, aright\n\ngamix = 0       ; clear mixer\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1\ni 1 0 3 20 2000\n\ni 99 0 8\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/alpass/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/alpass/#credits","title":"Credits","text":"<p>Audio rate parameter introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/ampdb/","title":"Ampdb","text":""},{"location":"opcodes/ampdb/#ampdb","title":"ampdb","text":"<p>Returns the amplitude equivalent of the decibel value x. Thus:</p> <ul> <li>60 dB = 1000</li> <li>66 dB = 1995.262</li> <li>72 dB = 3891.07</li> <li>78 dB = 7943.279</li> <li>84 dB = 15848.926</li> <li>90 dB = 31622.764</li> </ul>"},{"location":"opcodes/ampdb/#syntax","title":"Syntax","text":"<pre><code>ampdb(x)  (no rate restriction)\n</code></pre>"},{"location":"opcodes/ampdb/#examples","title":"Examples","text":"<p>Here is an example of the ampdb opcode. It uses the file ampdb.csd.</p> Example of the ampdb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ampdb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nidb  =  p4\niamp =  ampdb(idb)\nasig    oscil iamp, 220\n        print iamp\n        outs  asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1 50\ni 1 + 1 90\ni 1 + 1 68\ni 1 + 1 80\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iamp = 316.228\ninstr 1:  iamp = 31622.763\ninstr 1:  iamp = 2511.886\ninstr 1:  iamp = 9999.996\n</code></pre>"},{"location":"opcodes/ampdb/#see-also","title":"See also","text":"<p>Amplitude Converters</p>"},{"location":"opcodes/ampdbfs/","title":"Ampdbfs","text":""},{"location":"opcodes/ampdbfs/#ampdbfs","title":"ampdbfs","text":"<p>Returns the amplitude equivalent (in 16-bit signed integer scale) of the full scale decibel (dB FS) value x.</p> <p>The logarithmic full scale decibel values will be converted to linear 16-bit signed integer values from \u221232,768 to +32,767.</p>"},{"location":"opcodes/ampdbfs/#syntax","title":"Syntax","text":"<pre><code>ampdbfs(x)  (no rate restriction)\n</code></pre>"},{"location":"opcodes/ampdbfs/#examples","title":"Examples","text":"<p>Here is an example of the ampdbfs opcode. It uses the file ampdbfs.csd.</p> Example of the ampdbfs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ampdbfs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\n\ninstr 1\n\nidb  =  p4\niamp =  ampdbfs(idb)\nasig    oscil iamp, 220, 1\n        print iamp\n        outs  asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 1 -1\ni 1 + 1 -5\ni 1 + 1 -6\ni 1 + 1 -20\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iamp = 29204.511\ninstr 1:  iamp = 18426.801\ninstr 1:  iamp = 16422.904\ninstr 1:  iamp = 3276.800\n</code></pre>"},{"location":"opcodes/ampdbfs/#see-also","title":"See also","text":"<p>Amplitude Converters</p> <p>New in Csound version 4.10</p>"},{"location":"opcodes/ampmidi/","title":"Ampmidi","text":""},{"location":"opcodes/ampmidi/#ampmidi","title":"ampmidi","text":"<p>Get the velocity of the current MIDI event.</p>"},{"location":"opcodes/ampmidi/#syntax","title":"Syntax","text":"<pre><code>iamp ampmidi iscal [, ifn]\n</code></pre>"},{"location":"opcodes/ampmidi/#initialization","title":"Initialization","text":"<p>iscal -- i-time scaling factor</p> <p>ifn (optional, default=0) -- function table number of a normalized translation table, by which the incoming value is first interpreted. The default value is 0, denoting no translation.</p>"},{"location":"opcodes/ampmidi/#performance","title":"Performance","text":"<p>Get the velocity of the current MIDI event, optionally pass it through a normalized translation table, and return an amplitude value in the range 0 - iscal.</p>"},{"location":"opcodes/ampmidi/#examples","title":"Examples","text":"<p>Here is an example of the ampmidi opcode. It uses the file ampmidi.csd.</p> Example of the ampmidi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o ampmidi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1  ;expects MIDI note inputs on channel 1\n\niamp    ampmidi 1       ; scale amplitude between 0 and 1\nasig    oscil iamp, 220, 1\n        print iamp\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;Dummy f-table for 1 minute\nf 0 60\n;sine wave.\nf 1 0 16384 10 1\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ampmidi/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/ampmidi/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/ampmidicurve/","title":"Ampmidicurve","text":""},{"location":"opcodes/ampmidicurve/#ampmidicurve","title":"ampmidicurve","text":"<p>Maps an input MIDI velocity number to an output gain factor with a maximum value of 1, modifying the output gain by a dynamic range and a shaping exponent.</p> <p>Plugin opcode in ampmidid.</p> <p>The minimum output gain is 1 minus the dynamic range. A shaping exponent of 1 gives a linear response; increasing the exponent produces an increasingly depressed knee in the gain response curve.</p>"},{"location":"opcodes/ampmidicurve/#syntax","title":"Syntax","text":"<pre><code>igain ampmidicurve ivelocity, idynamicrange, iexponent\nkgain ampmidicurve kvelocity, kdynamicrange, kexponent\n</code></pre>"},{"location":"opcodes/ampmidicurve/#initialization","title":"Initialization","text":"<p>_imidivelocity _ -- MIDI velocity number, ranging from 0 through 127.</p> <p>idynamicrange -- Intended dynamic range of gain, from 0 through 1.</p> <p>iexponent -- Exponent applied to shape the gain response curve, 1 or greater.</p>"},{"location":"opcodes/ampmidicurve/#performance","title":"Performance","text":"<p>_kmidivelocity _ -- MIDI velocity number, ranging from 0 through 127.</p> <p>kdynamicrange -- Intended dynamic range of gain, from 0 through 1.</p> <p>kexponent -- Exponent applied to shape the gain response curve, 1 or greater.</p> <p>Maps an input MIDI velocity number to an output gain factor with a maximum value of 1, modifying the output gain by a dynamic range and a shaping exponent. The minimum output gain is 1 minus the dynamic range. A shaping exponent of 1 gives a linear response; increasing the exponent produces an increasingly depressed knee in the gain response curve, according to the equation: \\(y = d \\; (x/127)^h + 1 - d\\), where \\(y\\) = the gain, \\(x\\) = the input MIDI velocity (from 0 through 127), \\(d\\) = the dynamic range (from p through 1), and \\(h\\) = the shaping exponent (1 or greater). This opcode was suggested by Mauro Giubileo.</p>"},{"location":"opcodes/ampmidicurve/#examples","title":"Examples","text":"<p>Here is an example of the ampmidicurve opcode. It uses the file ampmidicurve.csd.</p> Example of the ampmidicurve opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;;;RT audio out, note=p4 and velocity=p5\n-odac --midi-key=4 --midi-velocity-amp=5\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ampmidid.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\nmassign 0, 1    ;assign all midi to instr. 1\n\ninstr 1\n\nisine ftgenonce 0, 0, 4096, 10, 1 ;sine wave\n\n  ihz = cpsmidinn(p4)\n  ivelocity = p5\n  ; MIDI velocity to signal amplitude.\n  iamplitude = ampdb(ivelocity)\n  ; Gain with compressed dynamic range, soft knee.\n  igain ampmidicurve ivelocity, .92, 3\n  print ivelocity, iamplitude, igain\n  a1   oscili 1, ihz, isine\n  aenv madsr 0.05, 0.1, 0.5, 0.2\n  asig = a1 * aenv * igain\n  outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;       note velocity\ni 1 0 2  61  100\ni 1 + 2  65  10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ampmidicurve/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/ampmidicurve/#credits","title":"Credits","text":"<p>Author: Michael Gogins 2019</p>"},{"location":"opcodes/ampmidid/","title":"Ampmidid","text":""},{"location":"opcodes/ampmidid/#ampmidid","title":"ampmidid","text":"<p>Musically map MIDI velocity to peak amplitude within a specified dynamic range in decibels.</p> <p>Plugin opcode in ampmidid.</p>"},{"location":"opcodes/ampmidid/#syntax","title":"Syntax","text":"<pre><code>iamplitude ampmidid ivelocity, idecibels\nkamplitude ampmidid kvelocity, idecibels\n</code></pre>"},{"location":"opcodes/ampmidid/#initialization","title":"Initialization","text":"<p>iamplitude -- Amplitude.</p> <p>ivelocity -- MIDI velocity number, ranging from 0 through 127.</p> <p>idecibels -- Desired dynamic range in decibels.</p>"},{"location":"opcodes/ampmidid/#performance","title":"Performance","text":"<p>kamplitude -- Amplitude.</p> <p>kvelocity -- MIDI velocity number, ranging from 0 through 127.</p> <p>Musically map MIDI velocity to peak amplitude within a specified dynamic range in decibels: \\(a = (mv + b) ^ 2\\), where \\(a\\) = amplitude, \\(v\\) = MIDI velocity, \\(r = 10 ^ {R / 20}\\), \\(b = 127 / (126 \\sqrt{r}) - 1 / 126\\), \\(m = (1 - b) / 127\\), and \\(R\\) = specified dynamic range in decibels. See Roger Dannenberg, \"The Interpretation of MIDI Velocity\", in Georg Essl and Ichiro Fujinaga (Eds.), Proceedings of the 2006 International Computer Music Conference, November 6-11, 2006 (San Francisco: The International Computer Music Association), pp. 193-196.</p>"},{"location":"opcodes/ampmidid/#examples","title":"Examples","text":"<p>Here is an example of the ampmidid opcode. It uses the file ampmidid.csd.</p> Example of the ampmidid opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;;;RT audio out, note=p4 and velocity=p5\n-odac --midi-key=4 --midi-velocity-amp=5\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ampmidid.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\nmassign 0, 1    ;assign all midi to instr. 1\n\ninstr 1\n\nisine ftgenonce 0, 0, 4096, 10, 1 ;sine wave\n\n  ihz = cpsmidinn(p4)\n  ivelocity = p5\n  idb ampmidid ivelocity, 20    ;map to dynamic range of 20 dB.\n  idb = idb + 60                ;limit range to 60 to 80 decibels\n  iamplitude = ampdb(idb)       ;loudness in dB to signal amplitude\n\na1   oscili iamplitude, ihz, isine\naenv madsr 0.05, 0.1, 0.5, 0.2\nasig = a1 * aenv\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;       note velocity\ni 1 0 2  61  100\ni 1 + 2  65  10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ampmidid/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/ampmidid/#credits","title":"Credits","text":"<p>Author: Michael Gogins 2006</p>"},{"location":"opcodes/areson/","title":"Areson","text":""},{"location":"opcodes/areson/#areson","title":"areson","text":"<p>A notch filter whose transfer functions are the complements of the reson opcode.</p>"},{"location":"opcodes/areson/#syntax","title":"Syntax","text":"<pre><code>ares areson asig, kcf, kbw [, iscl] [, iskip]\nares areson asig, acf, kbw [, iscl] [, iskip]\nares areson asig, kcf, abw [, iscl] [, iskip]\nares areson asig, acf, abw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/areson/#initialization","title":"Initialization","text":"<p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf/acf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/areson/#performance","title":"Performance","text":"<p>ares -- the output signal at audio rate.</p> <p>asig -- the input signal at audio rate.</p> <p>kcf/acf  -- the center frequency of the filter, or frequency position of the peak response.</p> <p>kbw/abw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points).</p> <p>areson is a filter whose transfer functions is the complement of reson. Thus areson is a notch filter whose transfer functions represents the \u201cfiltered out\u201d aspects of their complements. However, power scaling is not normalized in areson but remains the true complement of the corresponding unit. Thus an audio signal, filtered by parallel matching reson and areson units, would under addition simply reconstruct the original spectrum.</p> <p>This property is particularly useful for controlled mixing of different sources (see lpreson). Complex response curves such as those with multiple peaks can be obtained by using a bank of suitable filters in series. (The resultant response is the product of the component responses.) In such cases, the combined attenuation may result in a serious loss of signal power, but this can be regained by the use of balance.</p> <p> Warning</p> <p>When used with iscl this opcode is not a notch filter but similar to reson.</p>"},{"location":"opcodes/areson/#examples","title":"Examples","text":"<p>Here is an example of the areson opcode. It uses the file areson.csd.</p> Example of the areson opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o areson.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; unfiltered noise\n\nasig rand 0.5           ; white noise signal.\n     outs asig, asig\nendin\n\ninstr 2 ; filtered noise\n\nkcf  init 1000\nkbw  init 100\nasig rand 0.5\nafil areson asig, kcf, kbw\nafil balance afil,asig  ; afil = very loud\n     outs afil, afil\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/areson/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/areson/#credits","title":"Credits","text":"<p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/aresonk/","title":"Aresonk","text":""},{"location":"opcodes/aresonk/#aresonk","title":"aresonk","text":"<p>A notch filter whose transfer functions are the complements of the reson opcode.</p>"},{"location":"opcodes/aresonk/#syntax","title":"Syntax","text":"<pre><code>kres aresonk ksig, kcf, kbw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/aresonk/#initialization","title":"Initialization","text":"<p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/aresonk/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>kcf -- the center frequency of the filter, or frequency position of the peak response.</p> <p>kbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points).</p> <p>aresonk is a filter whose transfer functions is the complement of resonk. Thus aresonk is a notch filter whose transfer functions represents the \u201cfiltered out\u201d aspects of their complements. However, power scaling is not normalized in aresonk but remains the true complement of the corresponding unit.</p>"},{"location":"opcodes/aresonk/#examples","title":"Examples","text":"<p>Here is an example of the aresonk opcode. It uses the file aresonk.csd.</p> Example of the aresonk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o aresonk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nksig    randomh 400, 1800, 150\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\ninstr 2\n\nksig    randomh 400, 1800, 150\nkbw     line    1, p3, 600      ; vary bandwith\nksig    aresonk ksig, 800, kbw\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5.5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/aresonk/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/assign/","title":"Assign","text":""},{"location":"opcodes/assign/#_1","title":"=","text":"<p>Performs a simple assignment.</p>"},{"location":"opcodes/assign/#syntax","title":"Syntax","text":"<pre><code>ares = xarg\nires = iarg\nkres = karg\nires, ... = iarg, ...\nkres, ... = karg, ...\ntable [ kval] = karg\n</code></pre>"},{"location":"opcodes/assign/#initialization","title":"Initialization","text":"<p>= (simple assignment) - Put the value of the expression iarg (karg, xarg) into the named result. This provides a means of saving an evaluated result for later use.</p> <p>From version 5.13 onwards the i- and k-rate versions of assignment can take a number of outputs, and an equal or less number of inputs.  If there are less the last value is repeated as necessary.</p> <p>From version 5.14 values can be assigned to elements of a vector with the square bracket form.</p>"},{"location":"opcodes/assign/#examples","title":"Examples","text":"<p>Here is an example of the assign opcode. It uses the file assign.csd.</p> Example of the assign opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o assign.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n  ; Assign a value to the variable i1.\n  i1 = 1234\n\n  ; Print the value of the i1 variable.\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 1234.000\n</code></pre>"},{"location":"opcodes/assign/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p> <p>Array opcodes</p>"},{"location":"opcodes/assign/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p> <p>The extension to multiple values is by</p> <p>Author: John ffitch University of Bath, and Codemist Ltd. Bath, UK February 2010</p> <p>New in version 5.13</p>"},{"location":"opcodes/atone/","title":"Atone","text":""},{"location":"opcodes/atone/#atone","title":"atone","text":"<p>A hi-pass filter whose transfer functions are the complements of the tone opcode.</p>"},{"location":"opcodes/atone/#syntax","title":"Syntax","text":"<pre><code>ares atone asig, khp [, iskip]\n</code></pre>"},{"location":"opcodes/atone/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/atone/#performance","title":"Performance","text":"<p>ares -- the output signal at audio rate.</p> <p>asig -- the input signal at audio rate.</p> <p>khp --  the response curve's half-power point, in Hertz. Half power is defined as peak power / root 2.</p> <p>atone is a filter whose transfer functions is the complement of tone. atone is thus a form of high-pass filter whose transfer functions represent the \u201cfiltered out\u201d aspects of their complements. However, power scaling is not normalized in atone but remains the true complement of the corresponding unit. Thus an audio signal, filtered by parallel matching tone and atone units, would under addition simply reconstruct the original spectrum.</p> <p>This property is particularly useful for controlled mixing of different sources (see lpreson). Complex response curves such as those with multiple peaks can be obtained by using a bank of suitable filters in series. (The resultant response is the product of the component responses.) In such cases, the combined attenuation may result in a serious loss of signal power, but this can be regained by the use of balance.</p>"},{"location":"opcodes/atone/#examples","title":"Examples","text":"<p>Here is an example of the atone opcode. It uses the file atone.csd.</p> Example of the atone opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o atone.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ;white noise\n\nasig    rand 1\n        outs asig, asig\n\nendin\n\n\ninstr 2 ;filtered noise\n\nasig    rand 1\nkhp     init 4000\nasig    atone asig, khp\n        outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/atone/#see-also","title":"See also","text":"<p>Standard filters: Hi-pass filters</p>"},{"location":"opcodes/atonek/","title":"Atonek","text":""},{"location":"opcodes/atonek/#atonek","title":"atonek","text":"<p>A hi-pass filter whose transfer functions are the complements of the tonek opcode.</p>"},{"location":"opcodes/atonek/#syntax","title":"Syntax","text":"<pre><code>kres atonek ksig, khp [, iskip]\n</code></pre>"},{"location":"opcodes/atonek/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/atonek/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>khp --  the response curve's half-power point, in Hertz. Half power is defined as peak power / root 2.</p> <p>atonek is a filter whose transfer functions is the complement of tonek. atonek is thus a form of high-pass filter whose transfer functions represent the \u201cfiltered out\u201d aspects of their complements. However, power scaling is not normalized in atonek but remains the true complement of the corresponding unit.</p>"},{"location":"opcodes/atonek/#examples","title":"Examples","text":"<p>Here is an example of the atonek opcode. It uses the file atonek.csd.</p> Example of the atonek opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o atonek.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nksig    randomh 400, 1800, 150\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\ninstr 2\n\nksig    randomh 400, 1800, 150\nkhp     line    1, p3, 400      ;vary high-pass\nksig    atonek  ksig, khp\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5.5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/atonek/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/atonek/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/atonex/","title":"Atonex","text":""},{"location":"opcodes/atonex/#atonex","title":"atonex","text":"<p>Emulates a stack of filters using the atone opcode.</p> <p>atonex is equivalent to a filter consisting of more layers of atone with the same arguments, serially connected. Using a stack of a larger number of filters allows a sharper cutoff. They are faster than using a larger number instances in a Csound orchestra of the old opcodes, because only one initialization and k- cycle are needed at time and the audio loop falls entirely inside the cache memory of processor.</p>"},{"location":"opcodes/atonex/#syntax","title":"Syntax","text":"<pre><code>ares atonex asig, khp [, inumlayer] [, iskip]\nares atonex asig, ahp [, inumlayer] [, iskip]\n</code></pre>"},{"location":"opcodes/atonex/#initialization","title":"Initialization","text":"<p>inumlayer (optional) -- number of elements in the filter stack. Default value is 4.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/atonex/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>khp/ahp -- the response curve's half-power point. Half power is defined as peak power / root 2.</p>"},{"location":"opcodes/atonex/#examples","title":"Examples","text":"<p>Here is an example of the atonex opcode. It uses the file atonex.csd.</p> Example of the atonex opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o atonex.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; unfiltered noise\n\nasig    rand    0.7     ; white noise\n        outs    asig, asig\n\nendin\n\ninstr 2 ; filtered noise\n\nasig    rand    0.7\nkhp     line    100, p3, 3000\nafilt   atonex  asig, khp, 32\n\n; Clip the filtered signal's amplitude to 85 dB.\na1      clip afilt, 2, ampdb(85)\n        outs a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/atonex/#see-also","title":"See also","text":"<p>Standard filters: Hi-pass filters</p>"},{"location":"opcodes/atonex/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado (adapted by John ffitch) Italy</p> <p>New in Csound version 3.49</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/babo/","title":"Babo","text":""},{"location":"opcodes/babo/#babo","title":"babo","text":"<p>A physical model reverberator.</p> <p>babo  stands  for  ball-within-the-box.   It is a physical model reverberator based on the paper by Davide  Rocchesso \"The  Ball  within  the Box: a sound-processing metaphor\", Computer Music Journal,  Vol  19,  N.4,  pp.45-47,  Winter 1995.</p> <p>The resonator geometry can be defined, along with some response characteristics, the position of the listener within the resonator, and the position of the sound source.</p> <p>babo2 was introduced to fix the issue of the direct sound parameter (see expert parameters), which is a non-op in the original opcode.</p>"},{"location":"opcodes/babo/#syntax","title":"Syntax","text":"<pre><code>a1, a2 babo asig, ksrcx, ksrcy, ksrcz, irx, iry, irz [, idiff] [, ifno]\na1, a2 babo2 asig, ksrcx, ksrcy, ksrcz, irx, iry, irz [, idiff] [, ifno]\n</code></pre>"},{"location":"opcodes/babo/#initialization","title":"Initialization","text":"<p>irx, iry, irz -- the  coordinates of the geometry of the resonator (length of the edges in meters)</p> <p>idiff -- is  the  coefficient  of  diffusion  at  the walls,  which regulates the amount of diffusion (0-1, where 0 = no diffusion, 1 = maximum diffusion - default: 1)</p> <p>ifno -- expert  values  function:  a function number that holds all the additional parameters  of the resonator. This is typically a GEN2--type function used in non-rescaling mode. They are as follows:</p> <ul> <li>decay -- main decay of the resonator (default: 0.99)</li> <li>hydecay -- high frequency decay of the resonator (default: 0.1)</li> <li>rcvx, rcvy, rcvz -- the coordinates of the position of the receiver (the listener) (in  meters;  0,0,0 is the resonator center)</li> <li>rdistance -- the  distance in meters between the two pickups (your ears,  for  example  - default: 0.3)</li> <li>direct -- the attenuation of the direct signal (0-1, default: 0.5). This is a non-op in babo, but has been introduced in babo2.</li> <li>early_diff -- the attenuation coefficient of the  early reflections (0-1, default: 0.8)</li> </ul>"},{"location":"opcodes/babo/#performance","title":"Performance","text":"<p>asig -- the input signal</p> <p>ksrcx, ksrcy, ksrcz -- the virtual coordinates of the source of sound (the input signal). These are allowed to move at k-rate and provide all the necessary variations in terms of response of the resonator.</p>"},{"location":"opcodes/babo/#examples","title":"Examples","text":"<p>Here is a simple example of the babo opcode. It uses the file babo.csd, and drumsMlp.wav.</p> A simple example of the babo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o babo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Nicola Bernardini */\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\n; minimal babo instrument\n;\ninstr 1\n       ix     = p4  ; x position of source\n       iy     = p5  ; y position of source\n       iz     = p6  ; z position of source\n       ixsize = p7  ; width  of the resonator\n       iysize = p8  ; depth  of the resonator\n       izsize = p9  ; height of the resonator\n\nainput soundin \"drumsMlp.wav\"\n\nal,ar  babo    ainput*0.7, ix, iy, iz, ixsize, iysize, izsize\n\n       outs    al,ar\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Nicola Bernardini */\n; simple babo usage:\n;\n;p4     : x position of source\n;p5     : y position of source\n;p6     : z position of source\n;p7     : width  of the resonator\n;p8     : depth  of the resonator\n;p9     : height of the resonator\n;\ni  1  0  20 6  4  3    14.39 11.86 10\n;           ^^^^^^^    ^^^^^^^^^^^^^^\n;           |||||||    ++++++++++++++: optimal room dims according to\n;           |||||||                    Milner and Bernard JASA 85(2), 1989\n;           +++++++++: source position\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an advanced example of the babo opcode. It uses the file babo_expert.csd, and drumsMlp.wav.</p> An advanced example of the babo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o babo_expert.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Nicola Bernardini */\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\n; full blown babo instrument with movement\n;\ninstr 2\n  ixstart = p4   ; start x position of source (left-right)\n  ixend   = p7   ; end   x position of source\n  iystart = p5   ; start y position of source (front-back)\n  iyend   = p8   ; end   y position of source\n  izstart = p6   ; start z position of source (up-down)\n  izend   = p9  ; end   z position of source\n  ixsize  = p10  ; width  of the resonator\n  iysize  = p11  ; depth  of the resonator\n  izsize  = p12  ; height of the resonator\n  idiff   = p13  ; diffusion coefficient\n  iexpert = p14  ; power user values stored in this function\n\nainput    soundin \"drumsMlp.wav\"\nksource_x line    ixstart, p3, ixend\nksource_y line    iystart, p3, iyend\nksource_z line    izstart, p3, izend\n\nal,ar     babo    ainput*0.7, ksource_x, ksource_y, ksource_z, ixsize, iysize, izsize, idiff, iexpert\n\n          outs    al,ar\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Nicola Bernardini */\n; full blown instrument\n;p4         : start x position of source (left-right)\n;p5         : end   x position of source\n;p6         : start y position of source (front-back)\n;p7         : end   y position of source\n;p8         : start z position of source (up-down)\n;p9         : end   z position of source\n;p10        : width  of the resonator\n;p11        : depth  of the resonator\n;p12        : height of the resonator\n;p13        : diffusion coefficient\n;p14        : power user values stored in this function\n\n;         decay  hidecay rx ry rz rdistance direct early_diff\nf1  0 8 -2  0.95   0.95   0  0  0    0.3     0.5      0.8  ; brighter\nf2  0 8 -2  0.95   0.5    0  0  0    0.3     0.5      0.8  ; default (to be set as)\nf3  0 8 -2  0.95   0.01   0  0  0    0.3     0.5      0.8  ; darker\nf4  0 8 -2  0.95   0.7    0  0  0    0.3     0.1      0.4  ; to hear the effect of diffusion\nf5  0 8 -2  0.9    0.5    0  0  0    0.3     2.0      0.98 ; to hear the movement\nf6  0 8 -2  0.99   0.1    0  0  0    0.3     0.5      0.8  ; default vals\n;        ^\n;         ----- gen. number: negative to avoid rescaling\n\n\ni2 0 10  6  4  3   6   4  3  14.39  11.86  10    1  6 ; defaults\ni2 +  4  6  4  3   6   4  3  14.39  11.86  10    1  1 ; hear brightness 1\ni2 +  4  6  4  3  -6  -4  3  14.39  11.86  10    1  2 ; hear brightness 2\ni2 +  4  6  4  3  -6  -4  3  14.39  11.86  10    1  3 ; hear brightness 3\ni2 +  3 .6 .4 .3 -.6 -.4 .3  1.439  1.186  1.0 0.0  4 ; hear diffusion 1\ni2 +  3 .6 .4 .3 -.6 -.4 .3  1.439  1.186  1.0 1.0  4 ; hear diffusion 2\ni2 +  4 12  4  3 -12  -4 -3  24.39  21.86  20    1  5 ; hear movement\n;\ni2 +  4  6  4  3   6   4  3  14.39  11.86   10   1  1 ; hear brightness 1\ni2 +  4  6  4  3  -6  -4  3  14.39  11.86   10   1  2 ; hear brightness 2\ni2 +  4  6  4  3  -6  -4  3  14.39  11.86   10   1  3 ; hear brightness 3\ni2 +  3 .6 .4 .3 -.6 -.4 .3  1.439  1.186  1.0 0.0  4 ; hear diffusion 1\ni2 +  3 .6 .4 .3 -.6 -.4 .3  1.439  1.186  1.0 1.0  4 ; hear diffusion 2\ni2 +  4 12  4  3 -12  -4 -3  24.39  21.86   20   1  5 ; hear movement\n;       ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^   ^  ^\n;       |||||||||||||||||||  |||||||||||||||||   |   --: expert values function\n;       |||||||||||||||||||  |||||||||||||||||   +--: diffusion\n;       |||||||||||||||||||  ----------------: optimal room dims according to Milner and Bernard JASA 85(2), 1989\n;       |||||||||||||||||||\n;       --------------------: source position start and end\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/babo/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/babo/#credits","title":"Credits","text":"<p>Author: Paolo Filippi Padova, Italy 1999</p> <p>Nicola Bernardini Rome, Italy 2000</p> <p>New in Csound version 4.09</p>"},{"location":"opcodes/balance/","title":"Balance","text":""},{"location":"opcodes/balance/#balance","title":"balance","text":"<p>Adjust one audio signal according to the values of another.</p> <p>The rms power of asig can be interrogated, set, or adjusted to match that of a comparator signal.</p>"},{"location":"opcodes/balance/#syntax","title":"Syntax","text":"<pre><code>ares balance asig, acomp [, ihp] [, iskip]\n</code></pre>"},{"location":"opcodes/balance/#initialization","title":"Initialization","text":"<p>ihp (optional) -- half-power point (in Hz) of a special internal low-pass filter. The default value is 10.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space (see reson). The default value is 0.</p>"},{"location":"opcodes/balance/#performance","title":"Performance","text":"<p>asig -- input audio signal</p> <p>acomp -- the comparator signal</p> <p>balance outputs a version of asig, amplitude-modified so that its rms power is equal to that of a comparator signal acomp. Thus a signal that has suffered loss of power (eg., in passing through a filter bank) can be restored by matching it with, for instance, its own source. It should be noted that gain and balance provide amplitude modification only - output signals are not altered in any other respect.</p>"},{"location":"opcodes/balance/#examples","title":"Examples","text":"<p>Here is an example of the balance opcode. It uses the file balance.csd.</p> Example of the balance opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o balance.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n; Generate a band-limited pulse train.\nasrc buzz 0.9, 440, sr/440, 1\n\n; Send the source signal through 2 filters.\na1 reson asrc, 1000, 100       \na2 reson a1, 3000, 500\n\n; Balance the filtered signal with the source.\nafin balance a2, asrc\n     outs afin, afin\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/balance/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/balance2/","title":"Balance2","text":""},{"location":"opcodes/balance2/#balance2","title":"balance2","text":"<p>Adjust one audio signal according to the values of another.</p> <p>The rms power of asig can be interrogated, set, or adjusted to match that of a comparator signal.</p>"},{"location":"opcodes/balance2/#syntax","title":"Syntax","text":"<pre><code>ares balance2 asig, acomp [, ihp] [, iskip]\n</code></pre>"},{"location":"opcodes/balance2/#initialization","title":"Initialization","text":"<p>ihp (optional) -- half-power point (in Hz) of a special internal low-pass filter. The default value is 10.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space (see reson). The default value is 0.</p>"},{"location":"opcodes/balance2/#performance","title":"Performance","text":"<p>asig -- input audio signal</p> <p>acomp -- the comparator signal</p> <p>balance2 outputs a version of asig, amplitude-modified so that its rms power is equal to that of a comparator signal acomp. Thus a signal that has suffered loss of power (eg., in passing through a filter bank) can be restored by matching it with, for instance, its own source. It should be noted that gain and balance2 provide amplitude modification only - output signals are not altered in any other respect.</p> <p>Note that balance2 is just like balance except the gain is recalculated for every sample rather than interpolating k-rate values.</p>"},{"location":"opcodes/balance2/#examples","title":"Examples","text":"<p>Here is an example of the balance2 opcode. It uses the file balance2.csd.</p> Example of the balance2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o balance.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n; Generate a band-limited pulse train.\nasrc buzz 0.9, 440, sr/440, 1\n\n; Send the source signal through 2 filters.\na1 reson asrc, 1000, 100       \na2 reson a1, 3000, 500\n\n; Balance the filtered signal with the source.\nafin balance2 a2, asrc\n     outs afin, afin\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/balance2/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/balance2/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini; March 2018</p> <p>New in Csound version 6.11</p>"},{"location":"opcodes/bamboo/","title":"Bamboo","text":""},{"location":"opcodes/bamboo/#bamboo","title":"bamboo","text":"<p>Semi-physical model of a bamboo sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/bamboo/#syntax","title":"Syntax","text":"<pre><code>ares bamboo kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n            [, ifreq1] [, ifreq2]\n</code></pre>"},{"location":"opcodes/bamboo/#initialization","title":"Initialization","text":"<p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 1.25.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.9999 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.9999 which means that the default value of idamp is 0. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 0.05.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional, default=0) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p> <p>ifreq (optional) -- the main resonant frequency. The default value is 2800.</p> <p>ifreq1 (optional) -- the first resonant frequency. The default value is 2240.</p> <p>ifreq2 (optional) -- the second resonant frequency. The default value is 3360.</p>"},{"location":"opcodes/bamboo/#performance","title":"Performance","text":"<p>kamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only an approximation.</p>"},{"location":"opcodes/bamboo/#examples","title":"Examples","text":"<p>Here is an example of the bamboo opcode. It uses the file bamboo.csd.</p> Example of the bamboo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o bamboo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\nasig  bamboo p4, 0.01,0, 0, 0, 8000\n      outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 20000\ni1 2 1 20000\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bamboo/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/bamboo/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/barmodel/","title":"Barmodel","text":""},{"location":"opcodes/barmodel/#barmodel","title":"barmodel","text":"<p>Creates a tone similar to a struck metal bar.</p> <p>It uses a physical model developed from solving the partial differential equation. There are controls over the boundary conditions as well as the bar characteristics.</p>"},{"location":"opcodes/barmodel/#syntax","title":"Syntax","text":"<pre><code>ares barmodel kbcL, kbcR, iK, ib, kscan, iT30, ipos, ivel, iwid\n</code></pre>"},{"location":"opcodes/barmodel/#initialization","title":"Initialization","text":"<p>iK -- dimensionless stiffness parameter. If this parameter is negative then the initialisation is skipped and the previous state of the bar is continued.</p> <p>ib -- high-frequency loss parameter (keep this small).</p> <p>iT30 -- 30 db decay time in seconds.</p> <p>ipos -- position along the bar that the strike occurs.</p> <p>ivel -- normalized strike velocity.</p> <p>iwid -- spatial width of strike.</p>"},{"location":"opcodes/barmodel/#performance","title":"Performance","text":"<p>A note is played on a metalic bar, with the arguments as below.</p> <p>kbcL -- Boundary condition at left end of bar (1 is clamped, 2 pivoting and 3 free).</p> <p>kbcR -- Boundary condition at right end of bar (1 is clamped, 2 pivoting and 3 free).</p> <p>kscan -- Speed of scanning the output location.</p> <p>Note that changing the boundary conditions during playing may lead to glitches and is made available as an experiment.  The use of a non-zero kscan can give apparent re-introduction of sound due to modulation.</p>"},{"location":"opcodes/barmodel/#examples","title":"Examples","text":"<p>Here is an example of the barmodel opcode. It uses the file barmodel.csd.</p> Example of the barmodel opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o barmodel.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\n  sr        =           44100\n  kr        =           4410\n  ksmps     =           10\n  nchnls    =           1\n\n; Instrument #1.\ninstr 1\n  aq        barmodel    1, 1, p4, 0.001, 0.23, 5, p5, p6, p7\n            out         aq\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\ni1 0.0 0.5  3 0.2 500  0.05\ni1 0.5 0.5 -3 0.3 1000 0.05\ni1 1.0 0.5 -3 0.4 1000 0.1\ni1 1.5 4.0 -3 0.5 800  0.05\ne\n/* barmodel */\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/barmodel/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/barmodel/#credits","title":"Credits","text":"<p>Author: Stefan Bilbao  University of Edinburgh, UK Author: John ffitch  University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/bbcutm/","title":"Bbcutm","text":""},{"location":"opcodes/bbcutm/#bbcutm","title":"bbcutm","text":"<p>Generates breakbeat-style cut-ups of a mono audio stream.</p> <p>The BreakBeat Cutter automatically generates cut-ups of a source audio stream in the style of drum and bass/jungle breakbeat manipulations.  There are two versions, for mono (bbcutm) or stereo (bbcuts) sources.  Whilst originally based on breakbeat cutting, the opcode can be applied to any type of source audio.</p> <p>The prototypical cut sequence favoured over one bar with eighth note subdivisions would be</p> <pre><code>3+ 3R + 2\n</code></pre> <p>where we take a 3 unit block from the source's start, repeat it, then 2 units from the 7th and 8th eighth notes of the source.</p> <p>We talk of rendering phrases (a sequence of cuts before reaching a new phrase at the beginning of a bar) and units (as subdivision the notes).</p> <p>The opcode comes most alive when multiple synchronised versions are used simultaneously.</p>"},{"location":"opcodes/bbcutm/#syntax","title":"Syntax","text":"<pre><code>a1 bbcutm asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats \\\n          [, istutterspeed] [, istutterchance] [, ienvchoice ]\n</code></pre>"},{"location":"opcodes/bbcutm/#initialization","title":"Initialization","text":"<p>ibps -- Tempo to cut at, in beats per second.</p> <p>isubdiv -- Subdivisions unit, for a bar. So 8 is eighth notes (of a 4/4 bar).</p> <p>ibarlength -- How many beats per bar. Set to 4 for default 4/4 bar behaviour.</p> <p>iphrasebars -- The output cuts are generated in phrases, each phrase is up to iphrasebars long</p> <p>inumrepeats --  In normal use the algorithm would allow up to one additional repeat of a given cut at a time. This parameter allows that to be changed. Value 1 is normal- up to one extra repeat. 0 would avoid repeating, and you would always get back the original source except for enveloping and stuttering.</p> <p>istutterspeed -- (optional, default=1) The stutter can be an integer multiple of the subdivision speed. For instance, if subdiv is 8 (quavers) and stutterspeed is 2, then the stutter is in semiquavers (sixteenth notes= subdiv 16). The default is 1.</p> <p>istutterchance -- (optional, default=0) The tail of a phrase has this chance of becoming a single repeating one unit cell stutter (0.0 to 1.0). The default is 0.</p> <p>ienvchoice -- (optional, default=1) choose 1 for on (exponential envelope for cut grains) or 0 for off. Off will cause clicking, but may give good noisy results, especially for percussive sources. The default is 1, on.</p>"},{"location":"opcodes/bbcutm/#performance","title":"Performance","text":"<p>asource -- The audio signal to be cut up. This version runs in real-time without knowledge of future audio.</p>"},{"location":"opcodes/bbcutm/#examples","title":"Examples","text":"<p>Here is a simple example of the bbcutm opcode. It uses the file bbcutm.csd, and drumsMlp.wav.</p> A simple example of the bbcutm opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o bbcutm.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; Play an audio file normally.\n\nasource soundin \"drumsMlp.wav\"\nouts asource, asource\n\nendin\n\ninstr 2     ; Cut-up an audio file\n\nibps = 4\nisubdiv = 8\nibarlength = 4\niphrasebars = 1\ninumrepeats = p4\nasource diskin2 \"drumsMlp.wav\", 1, 0 ,1\na1 bbcutm asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\n;       repeats\ni 2 3 8     2\ni 2 12 8    6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here are some more advanced examples...</p> First steps- mono and stereo versions<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsInstruments&gt;\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         2\n\ninstr 1\nasource diskin \"drumsMlp.wav\",1,0,1 ; a source breakbeat sample, wraparound lest it stop!\n\n; cuts in eighth notes per 4/4 bar, up to 4 bar phrases, up to 1\n; repeat in total (standard use) rare stuttering at 16 note speed,\n; no enveloping\nasig bbcutm asource, 2.6937, 8, 4, 4, 1, 2, 0.1, 0\n\nouts        asig,asig\nendin\n\ninstr 2 ;stereo version\nasource1,asource2 diskin \"drumsSlp.wav\", 1, 0, 1    ; a source breakbeat sample, wraparound lest it stop!\n\n; cuts in eighth notes per 4/4 bar, up to 4 bar phrases, up to 1\n; repeat in total (standard use) rare stuttering at 16 note speed,\n; no enveloping\nasig1,asig2 bbcuts asource1, asource2, 2.6937, 8, 4, 4, 1, 2, 0.1, 0\n\nouts  asig1,asig2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ni2 11 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> Multiple simultaneous synchronised breaks<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsInstruments&gt;\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         2\n\ninstr 1\nibps    = 2.6937\niplaybackspeed = ibps/p5\nasource diskin p4, iplaybackspeed, 0, 1\n\nasig bbcutm asource, 2.6937, p6, 4, 4, p7, 2, 0.1, 1\n\nouts   asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;   source      bps cut repeats\ni1 0 10 \"drumsMlp.wav\" 2.3 8   2  //2.3 is the source original tempo\ni1 0 10 \"beats.wav\" 2.4 8   3\ni1 0 10 \"fox.wav\" 2.5 16  4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> Cutting up any old audio- much more interesting noises than this should be possible!<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsInstruments&gt;\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         2\n\ninstr 1\nasource oscil 20000, 70, 1\n; ain, bps, subdiv, barlength, phrasebars, numrepeats,\n;stutterspeed, stutterchance, envelopingon\nasig bbcutm asource, 2, 32, 1, 1, 2, 4, 0.6, 1\nouts  asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 256 10 1\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> Constant stuttering- faked, not possible since can only stutter in last half bar could make extra stuttering option parameter<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsInstruments&gt;\nsr        =         44100\nkr        =         4410\nksmps     =         10\nnchnls    =         2\n\ninstr 1\nasource diskin \"drumsMlp.wav\", 1, 0, 1\n\n;16th note cuts- but cut size 2 over half a beat.\n;each half beat will either survive intact or be turned into\n;the first sixteenth played twice in succession\n\nasig bbcutm asource, 2, 2, 0.5, 1, 2, 2, 1.0, 0\nouts  asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bbcutm/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/bbcutm/#credits","title":"Credits","text":"<p>Author: Nick Collins London August 2001</p> <p>New in version 4.13</p>"},{"location":"opcodes/bbcuts/","title":"Bbcuts","text":""},{"location":"opcodes/bbcuts/#bbcuts","title":"bbcuts","text":"<p>Generates breakbeat-style cut-ups of a stereo audio stream.</p> <p>The BreakBeat Cutter automatically generates cut-ups of a source audio stream in the style of drum and bass/jungle breakbeat manipulations.  There are two versions, for mono (bbcutm) or stereo (bbcuts) sources.  Whilst originally based on breakbeat cutting, the opcode can be applied to any type of source audio.</p> <p>The prototypical cut sequence favoured over one bar with eighth note subdivisions would be</p> <pre><code>3+ 3R + 2\n</code></pre> <p>where we take a 3 unit block from the source's start, repeat it, then 2 units from the 7th and 8th eighth notes of the source.</p> <p>We talk of rendering phrases (a sequence of cuts before reaching a new phrase at the beginning of a bar) and units (as subdivision th notes).</p> <p>The opcode comes most alive when multiple synchronised versions are used simultaneously.</p>"},{"location":"opcodes/bbcuts/#syntax","title":"Syntax","text":"<pre><code>a1,a2 bbcuts asource1, asource2, ibps, isubdiv, ibarlength, iphrasebars, \\\n             inumrepeats [, istutterspeed] [, istutterchance] [, ienvchoice]\n</code></pre>"},{"location":"opcodes/bbcuts/#initialization","title":"Initialization","text":"<p>ibps -- Tempo to cut at, in beats per second.</p> <p>isubdiv -- Subdivisions unit, for a bar. So 8 is eighth notes (of a 4/4 bar).</p> <p>ibarlength -- How many beats per bar. Set to 4 for default 4/4 bar behaviour.</p> <p>iphrasebars -- The output cuts are generated in phrases, each phrase is up to iphrasebars long</p> <p>inumrepeats --  In normal use the algorithm would allow up to one additional repeat of a given cut at a time. This parameter allows that to be changed. Value 1 is normal- up to one extra repeat. 0 would avoid repeating, and you would always get back the original source except for enveloping and stuttering.</p> <p>istutterspeed -- (optional, default=1) The stutter can be an integer multiple of the subdivision speed. For instance, if subdiv is 8 (quavers) and stutterspeed is 2, then the stutter is in semiquavers (sixteenth notes= subdiv 16). The default is 1.</p> <p>istutterchance -- (optional, default=0) The tail of a phrase has this chance of becoming a single repeating one unit cell stutter (0.0 to 1.0). The default is 0.</p> <p>ienvchoice -- (optional, default=1) choose 1 for on (exponential envelope for cut grains) or 0 for off. Off will cause clicking, but may give good noisy results, especially for percussive sources. The default is 1, on.</p>"},{"location":"opcodes/bbcuts/#performance","title":"Performance","text":"<p>asource -- The audio signal to be cut up. This version runs in real-time without knowledge of future audio.</p>"},{"location":"opcodes/bbcuts/#examples","title":"Examples","text":"<p>Here is an example of the bbcuts opcode. It uses the file bbcuts.csd.</p> Example of the bbcuts opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o bbcuts.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2022\n\ninstr 1 ;Play an audio file\n\naleft, aright diskin2 \"drumsSlp.wav\", 1, 0\n              outs aleft, aright\nendin\n\ninstr 2 ;Cut-up stereo audio file.\n\nibps = 16\nisubdiv = p4\nibarlength = 2\niphrasebars = 1\ninumrepeats = 8\n\naleft, aright diskin2 \"drumsSlp.wav\", 1, 0\naleft, aright bbcuts aleft, aright, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats\n              outs aleft, aright\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0  4         ; original sample\ni2 5  4 1       ; subdivisions = 1\ni2 10 4 .5      ; subdivisions = .5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bbcuts/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/bbcuts/#credits","title":"Credits","text":"<p>Author: Nick Collins London August 2001</p> <p>New in version 4.13</p>"},{"location":"opcodes/betarand/","title":"Betarand","text":""},{"location":"opcodes/betarand/#betarand","title":"betarand","text":"<p>Beta distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/betarand/#syntax","title":"Syntax","text":"<pre><code>ares betarand krange, kalpha, kbeta\nires betarand krange, kalpha, kbeta\nkres betarand krange, kalpha, kbeta\n</code></pre>"},{"location":"opcodes/betarand/#performance","title":"Performance","text":"<p>krange -- range of the random numbers (0 - krange).</p> <p>kalpha -- alpha value. If kalpha is smaller than one, smaller values favor values near 0.</p> <p>kbeta -- beta value. If kbeta is smaller than one, smaller values favor values near krange.</p> <p>If both kalpha and kbeta equal one we have uniform distribution. If both kalpha and kbeta are greater than one we have a sort of Gaussian distribution. Outputs only positive numbers.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/betarand/#examples","title":"Examples","text":"<p>Here is an example of the betarand opcode. It uses the file betarand.csd.</p> Example of the betarand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o betarand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1         ; every run time same values\n\nkbeta   betarand 100, 1, 1\n        printk .2, kbeta                ; look \naout    oscili 0.8, 440+kbeta, 1        ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nkbeta   betarand 100, 1, 1\n        printk .2, kbeta                ; look \naout    oscili 0.8, 440+kbeta, 1        ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like:</p> <pre><code>i   1 time     0.00267:    85.74227\ni   1 time     0.20267:    12.07606\ni   1 time     0.40267:    25.03239\ni   1 time     0.60267:     0.42037\ni   1 time     0.80267:    76.69589\ni   1 time     1.00000:    29.73339\ni   1 time     1.20267:    48.29811\ni   1 time     1.40267:    75.46507\ni   1 time     1.60267:    74.80686\ni   1 time     1.80000:    81.37473\ni   1 time     2.00000:    55.48827\nSeeding from current time 3472120656\ni   2 time     3.00267:    57.21408\ni   2 time     3.20267:    30.95705\ni   2 time     3.40267:    19.71687\ni   2 time     3.60000:    64.48965\ni   2 time     3.80267:    72.35818\ni   2 time     4.00000:    49.65395\ni   2 time     4.20000:    55.25888\ni   2 time     4.40267:     3.98308\ni   2 time     4.60267:    52.98075\ni   2 time     4.80267:    58.07925\ni   2 time     5.00000:    56.38914\n</code></pre>"},{"location":"opcodes/betarand/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/betarand/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p>"},{"location":"opcodes/bexprnd/","title":"Bexprnd","text":""},{"location":"opcodes/bexprnd/#bexprnd","title":"bexprnd","text":"<p>Exponential distribution random number generator.</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/bexprnd/#syntax","title":"Syntax","text":"<pre><code>ares bexprnd krange\nires bexprnd krange\nkres bexprnd krange\n</code></pre>"},{"location":"opcodes/bexprnd/#performance","title":"Performance","text":"<p>krange -- the range of the random numbers (-krange to +krange)</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/bexprnd/#examples","title":"Examples","text":"<p>Here is an example of the bexprnd opcode. It uses the file bexprnd.csd.</p> Example of the bexprnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o bexprnd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1         ; every run time same values\n\nkexp    bexprnd 100\n        printk .2, kexp                 ; look \naout    oscili 0.8, 440+kexp, 1         ; &amp; listen\n        outs    aout, aout\n\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nkexp    bexprnd 100\n        printk .2, kexp                 ; look \naout    oscili 0.8, 440+kexp, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like:</p> <pre><code>i   1 time     0.00267:    99.27598\ni   1 time     0.20267:    74.97176\ni   1 time     0.40267:   -35.67213\ni   1 time     0.60267:     1.10579\ni   1 time     0.80267:   -18.08816\ni   1 time     1.00000:    28.93329\ni   1 time     1.20267:   320.63733\ni   1 time     1.40267:  -332.05614\ni   1 time     1.60267:  -212.66361\ni   1 time     1.80000:   -92.57433\ni   1 time     2.00000:   140.70939\nSeeding from current time 4055201702\ni   2 time     3.00267:   190.30495\ni   2 time     3.20267:   -58.30677\ni   2 time     3.40267:   192.39784\ni   2 time     3.60000:    12.72448\ni   2 time     3.80267:    79.91503\ni   2 time     4.00000:    34.44258\ni   2 time     4.20000:   167.92680\ni   2 time     4.40267:  -117.10278\ni   2 time     4.60267:   -70.99155\ni   2 time     4.80267:   -23.24037\ni   2 time     5.00000:  -226.35500\n</code></pre>"},{"location":"opcodes/bexprnd/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/bexprnd/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/bformdec1/","title":"Bformdec1","text":""},{"location":"opcodes/bformdec1/#bformdec1","title":"bformdec1","text":"<p>Decodes an ambisonic B format signal into loudspeaker specific signals.</p>"},{"location":"opcodes/bformdec1/#syntax","title":"Syntax","text":"<pre><code>ao1, ao2 bformdec1 isetup, aw, ax, ay, az [, ar, as, at, au, av \\\n    [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4 bformdec1 isetup, aw, ax, ay, az [, ar, as, at, au, av \\\n    [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5 bformdec1 isetup, aw, ax, ay, az [, ar, as, at, au, av \\\n    [, abk, al, am, an, ao, ap, aq]]\nao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8 bformdec1 isetup, aw, ax, ay, az \\\n    [, ar, as, at, au, av [, abk, al, am, an, ao, ap, aq]]\naout[] bformdec1 isetup, abform[]\n</code></pre>"},{"location":"opcodes/bformdec1/#initialization","title":"Initialization","text":"<p>Note that horizontal angles are measured anticlockwise in this description.</p> <p>isetup \u2013- loudspeaker setup. There are five supported setups:</p> <ul> <li>1:  Stereo - L(90), R(-90); this is an M+S style stereo decode.</li> <li>2:    Quad - FL(45), BL(135), BR(-135), FR(-45). This is a first-order `in-phase' decode.</li> <li>3:    5.0 - L(30),R(-30),C(0),BL(110),BR(-110). Note that many people do not actually use the angles above for their speaker arrays and a good decode for DVD etc can be achieved using the Quad configuration to feed L, R, BL and BR (leaving C silent).</li> <li>4:    Octagon - FFL(22.5), FLL(67.5), BLL(112.5), BBL(157.5), BBR(-157.5), BRR(-112.5), FRR(-67.5), FFR(-22.5). This is a first-, second- or third-order `in-phase' decode, depending on the number of input channels.</li> <li>5:    Cube - FLD(45,-35.26), FLU(45,35.26), BLD(135,-35.26), BLU(135,35.26), BRD(-135,-35.26), BRU(-135,35.26), FRD(-45,-35.26), FRU(-45,35.26). This is a first-order `in-phase' decode.</li> </ul>"},{"location":"opcodes/bformdec1/#performance","title":"Performance","text":"<p>aw, ax, ay, ... -- input signal in the B format.</p> <p>ao1 .. ao8 -- loudspeaker specific output signals.</p>"},{"location":"opcodes/bformdec1/#example","title":"Example","text":"<p>Here is an example of the bformdec1 opcode. It uses the file bformenc1.csd.</p> Example of the bformdec1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n;-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n -o bformenc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 8\n0dbfs = 1\n\ninstr 1 ;without arrays\n; generate pink noise\nanoise pinkish 1\n\n; two full turns\nkalpha line 0, p3, 720\nkbeta = 0\n\n; generate B format\naw, ax, ay, az, ar, as, at, au, av bformenc1 anoise, kalpha, kbeta\n\n; decode B format for 8 channel circle loudspeaker setup\na1, a2, a3, a4, a5, a6, a7, a8 bformdec1 4, aw, ax, ay, az, ar, as, at, au, av        \n\n; write audio out\nouto a1, a2, a3, a4, a5, a6, a7, a8\nendin\n\ninstr 2 ;with arrays (csound6)\n;set file names for:\nS_bform = \"bform_out.wav\" ;b-format (2nd order) output\nS_sound = \"sound_out.wav\" ;sound output\n\n; generate pink noise\nanoise pinkish 1\n\n; two full turns\nkalpha line 0, p3, 720\nkbeta = 0\n\n;create array for B-format 2nd order (9 chnls)\naBform[] init 9\n\n; generate B-format\naBform bformenc1 anoise, kalpha, kbeta\n\n;write out b-format\nfout \"fout.wav\", 18, aBform\n\n;create array for audio output (8 channels)\naAudio[] init 8\n\n;decode B format for 8 channel circle loudspeaker setup\naAudio bformdec1 4, aBform\n\n; write audio out\nfout S_sound, 18, aAudio\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 8\ni 2 8 8\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bformdec1/#see-also","title":"See also","text":"<p>Panning and Spatialization: Ambisonics</p>"},{"location":"opcodes/bformdec1/#credits","title":"Credits","text":"<p>Author: Richard Furse, Bruce Wiggins and Fons Adriaensen, following code by Samuel Groner 2008</p> <p>New in version 5.09</p>"},{"location":"opcodes/bformdec2/","title":"Bformdec2","text":""},{"location":"opcodes/bformdec2/#bformdec2","title":"bformdec2","text":"<p>Decodes an Ambisonics B format signal into loudspeaker specific signals, with dual--band decoding and near--field compensation.</p>"},{"location":"opcodes/bformdec2/#syntax","title":"Syntax","text":"<pre><code>aout[] bformdec2 isetup, abform[], [idecoder, idistance, ifreq, imix, \\\n                 ifilel, ifiler]\n</code></pre>"},{"location":"opcodes/bformdec2/#initialization","title":"Initialization","text":"<p>isetup -- loudspeaker setup. There are currently 8 supported setups, the first five are backwards compatible with bformdec1:</p> <p>(Note that horizontal angles are measured anticlockwise in this description.)</p> <ul> <li>1: Stereo -- L(90), R(-90); this is an M+S style stereo decode.</li> <li>2: Quad -- FL(45), BL(135), BR(-135), FR(-45). This is a first-order decode.</li> <li>3: 5.0 -- L(30), R(-30), C(0), BL(110), BR(-110). This is the configuration suggested by the International Telecommunication Union for 5.1 surround systems for music listening. This is a first- or second- order decode.</li> <li>4: Octagon -- FFL(22.5), FLL(67.5), BLL(112.5), BBL(157.5), BBR(-157.5), BRR(-112.5), FRR(-67.5), FFR(-22.5). This is a first-, second- or third-order decode, depending on the number of input channels.</li> <li>5: Cube -- FLD(45,-35.26), FLU(45,35.26), BLD(135,-35.26), BLU(135,35.26), BRD(-135,-35.26), BRU(-135,35.26), FRD(-45,-35.26), FRU(-45,35.26). This is a first-order decode.</li> <li>6: Hexagon -- FL(30), L(90) BL(150), BR(-150), R(-90), FR(-30). This is a first- or second- order decode.</li> <li>21: 2D binaural configuration. This first decodes to a octagon configuration and then applies HRTF filters.</li> <li>31: 3D binaural configuration. This first decodes to a dodecahedron configuration and then applies HRTF filters.</li> </ul> <p>idecoder -- optional (default 0), select the type of decoder</p> <ul> <li>0: Dual decoder (velocity and energy decoders using dual-band splitting).</li> <li>1: Velocity decoder.</li> <li>2: Energy decoder.</li> </ul> <p>idistance -- optional (default 1 meter), select the distance (in meters) to the loudspeaker (radius if regular configuration)</p> <p>ifreq -- optional (default 400 Hz), frequency cut (Hz) of the band splitting filter (only has an effect if idecoder=0)* </p> <p>imix -- optional (default 0), type of mix of the velocity and energy decoders' outputs</p> <ul> <li>0: Energy</li> <li>1: RMS</li> <li>2: Amplitude</li> </ul> <p>ifilel -- left HRTF spectral data file</p> <p>ifiler -- right HRTF spectral data file</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) should be in the current directory or the SADIR (see the hrtfstat documentation).</p>"},{"location":"opcodes/bformdec2/#performance","title":"Performance","text":"<p>abform -- input signal array in the B format</p> <p>aout[] -- loudspeaker specific output signals</p> <p>The opcode receives as input an audio type array with an Ambisonics signal, and outputs another array with a multichannel audio signal decoded according to the given setup.</p>"},{"location":"opcodes/bformdec2/#see-also","title":"See also","text":"<p>Panning and Spatialization: Ambisonics</p>"},{"location":"opcodes/bformdec2/#credits","title":"Credits","text":"<p>By: Pablo Zinemanas, Mart\u00edn Rocamora and Luis Jure, 2019. Adapted by John ffitch</p> <p>Based on code from the Ambisonics Decoder Toolbox by Aaron J. Heller.</p> <p>For more information about the opcode and technical details see: Pablo Zinemanas, Mart\u00edn Rocamora and Luis Jure. Improving Csound's Ambisonics decoders. Fifth International Csound Conference -- ICSC2019. Italy, 2019 -- PDF.</p> <p>New in version 6.17</p>"},{"location":"opcodes/bformenc1/","title":"Bformenc1","text":""},{"location":"opcodes/bformenc1/#bformenc1","title":"bformenc1","text":"<p>Codes a signal into the ambisonic B format.</p>"},{"location":"opcodes/bformenc1/#syntax","title":"Syntax","text":"<pre><code>aw, ax, ay, az bformenc1 asig, kalpha, kbeta\naw, ax, ay, az, ar, as, at, au, av bformenc1 asig, kalpha, kbeta\naw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq bformenc1 \\\n    asig, kalpha, kbeta\naarray[] bformenc1 asig, kalpha, kbeta\n</code></pre>"},{"location":"opcodes/bformenc1/#performance","title":"Performance","text":"<p>aw, ax, ay, ... -- output cells of the B format.</p> <p>aarray -- output array to hold cells of the B format.</p> <p>asig -- input signal.</p> <p>kalpha -- azimuth angle in degrees (anticlockwise).</p> <p>kbeta -- altitude angle in degrees.</p>"},{"location":"opcodes/bformenc1/#example","title":"Example","text":"<p>Here is an example of the bformenc1 opcode. It uses the file bformenc1.csd.</p> Example of the bformenc1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n;-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n -o bformenc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 8\n0dbfs = 1\n\ninstr 1 ;without arrays\n; generate pink noise\nanoise pinkish 1\n\n; two full turns\nkalpha line 0, p3, 720\nkbeta = 0\n\n; generate B format\naw, ax, ay, az, ar, as, at, au, av bformenc1 anoise, kalpha, kbeta\n\n; decode B format for 8 channel circle loudspeaker setup\na1, a2, a3, a4, a5, a6, a7, a8 bformdec1 4, aw, ax, ay, az, ar, as, at, au, av        \n\n; write audio out\nouto a1, a2, a3, a4, a5, a6, a7, a8\nendin\n\ninstr 2 ;with arrays (csound6)\n;set file names for:\nS_bform = \"bform_out.wav\" ;b-format (2nd order) output\nS_sound = \"sound_out.wav\" ;sound output\n\n; generate pink noise\nanoise pinkish 1\n\n; two full turns\nkalpha line 0, p3, 720\nkbeta = 0\n\n;create array for B-format 2nd order (9 chnls)\naBform[] init 9\n\n; generate B-format\naBform bformenc1 anoise, kalpha, kbeta\n\n;write out b-format\nfout \"fout.wav\", 18, aBform\n\n;create array for audio output (8 channels)\naAudio[] init 8\n\n;decode B format for 8 channel circle loudspeaker setup\naAudio bformdec1 4, aBform\n\n; write audio out\nfout S_sound, 18, aAudio\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 8\ni 2 8 8\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bformenc1/#see-also","title":"See also","text":"<p>Panning and Spatialization: Ambisonics</p>"},{"location":"opcodes/bformenc1/#credits","title":"Credits","text":"<p>Author: Richard Furse, Bruce Wiggins and Fons Adriaensen, following code by Samuel Groner 2008</p> <p>New in version 5.09</p> <p>Array output new in version 6.01</p>"},{"location":"opcodes/biquad/","title":"Biquad","text":""},{"location":"opcodes/biquad/#biquad","title":"biquad","text":"<p>A sweepable general purpose biquadratic digital filter.</p>"},{"location":"opcodes/biquad/#syntax","title":"Syntax","text":"<pre><code>ares biquad asig, kb0, kb1, kb2, ka0, ka1, ka2 [, iskip]\n</code></pre>"},{"location":"opcodes/biquad/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non-zero, intialization will be skipped. Default value 0. (New in Csound version 3.50)</p>"},{"location":"opcodes/biquad/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>biquad is a general purpose biquadratic digital filter of the form:</p> \\[ a_0 y(n) + a_1 y(n-1) + a_2 y(n-2) = b_0 x(n) + b_1 x(n-1) + b_2 x(n-2) \\] <p>This filter has the following frequency response:</p> \\[ H(z) = \\frac{B(z)}{A(z)} = \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{a_0 + a_1 z^{-1} + a_2 z^{-2}} \\] <p>This type of filter is often encountered in digital signal processing literature. It allows six user-defined k-rate coefficients.</p>"},{"location":"opcodes/biquad/#examples","title":"Examples","text":"<p>Here is an example of the biquad opcode. It uses the file biquad.csd.</p> Example of the biquad opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o biquad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Instrument #1.\ninstr 1\n  ; Get the values from the score.\n  idur = p3\n  iamp = p4\n  icps = cpspch(p5)\n  kfco = p6\n  krez = p7\n\n  ; Calculate the biquadratic filter's coefficients \n  kfcon = 2*3.14159265*kfco/sr\n  kalpha = 1-2*krez*cos(kfcon)*cos(kfcon)+krez*krez*cos(2*kfcon)\n  kbeta = krez*krez*sin(2*kfcon)-2*krez*cos(kfcon)*sin(kfcon)\n  kgama = 1+cos(kfcon)\n  km1 = kalpha*kgama+kbeta*sin(kfcon)\n  km2 = kalpha*kgama-kbeta*sin(kfcon)\n  kden = sqrt(km1*km1+km2*km2)\n  kb0 = 1.5*(kalpha*kalpha+kbeta*kbeta)/kden\n  kb1 = kb0\n  kb2 = 0\n  ka0 = 1\n  ka1 = -2*krez*cos(kfcon)\n  ka2 = krez*krez\n\n  ; Generate an input signal.\n  axn vco 1, icps, 1\n\n  ; Filter the input signal.\n  ayn biquad axn, kb0, kb1, kb2, ka0, ka1, ka2\n  outs ayn*iamp/2, ayn*iamp/2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n;    Sta  Dur  Amp    Pitch Fco   Rez\ni 1  0.0  1.0  20000  6.00  1000  .8\ni 1  1.0  1.0  20000  6.03  2000  .95\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the biquad opcode used for modal synthesis. It uses the file biquad-2.csd. See the Modal Frequency Ratios appendix for other frequency ratios.</p> Example of the biquad opcode for modal synthesis.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o biquad-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n/*  modal synthesis using biquad filters as oscillators\n    Example by Scott Lindroth 2007 */\n\n\ninstr 1\n\n    ipi = 3.1415926\n    idenom = sr*0.5\n\n    ipulseSpd = p4\n    icps     = p5\n    ipan = p6\n    iamp    = p7\n    iModes = p8\n\n    apulse    mpulse iamp, 0\n\n    icps    = cpspch( icps )\n\n    ; filter gain\n\n    iamp1 = 600\n    iamp2 = 1000\n    iamp3 = 1000\n    iamp4 = 1000\n    iamp5 = 1000\n    iamp6 = 1000\n\n    ; resonance\n\n    irpole1 = 0.99999\n    irpole2 = irpole1\n    irpole3 = irpole1\n    irpole4 = irpole1\n    irpole5 = irpole1\n    irpole6 = irpole1\n\n    ; modal frequencies\n\n    if (iModes == 1) goto modes1\n    if (iModes == 2) goto modes2\n\n    modes1:\n    if1    = icps * 1            ;pot lid\n    if2    = icps * 6.27\n    if3    = icps * 3.2\n    if4    = icps * 9.92\n    if5    = icps * 14.15\n    if6    = icps * 6.23\n    goto nextPart\n\n    modes2:\n    if1     = icps * 1            ;uniform wood bar\n    if2     = icps * 2.572\n    if3     = icps * 4.644\n    if4     = icps * 6.984\n    if5     = icps * 9.723\n    if6     = icps * 12.0\n    goto nextPart\n\n    nextPart:\n\n    ; convert frequency to radian frequency\n\n    itheta1 = (if1/idenom) * ipi\n    itheta2 = (if2/idenom) * ipi\n    itheta3 = (if3/idenom) * ipi\n    itheta4 = (if4/idenom) * ipi\n    itheta5 = (if5/idenom) * ipi\n    itheta6 = (if6/idenom) * ipi\n\n    ; calculate coefficients\n\n    ib11 = -2 * irpole1 * cos(itheta1)\n    ib21 = irpole1 * irpole1\n    ib12 = -2 * irpole2 * cos(itheta2)\n    ib22 = irpole2 * irpole2\n    ib13 = -2 * irpole3 * cos(itheta3)\n    ib23 = irpole3 * irpole3\n    ib14 = -2 * irpole4 * cos(itheta4)\n    ib24 = irpole4 * irpole4\n    ib15 = -2 * irpole5 * cos(itheta5)\n    ib25 = irpole5 * irpole5\n    ib16 = -2 * irpole6 * cos(itheta6)\n    ib26 = irpole6 * irpole6\n\n    ;printk 1, ib 11\n    ;printk 1, ib 21\n\n    ;  also try setting the -1 coeff. to 0, but be sure to scale down the amplitude!\n\n    asin1     biquad  apulse * iamp1, 1, 0, -1, 1, ib11, ib21\n         asin2       biquad  apulse * iamp2, 1, 0, -1, 1, ib12, ib22\n         asin3       biquad  apulse * iamp3, 1, 0, -1, 1, ib13, ib23\n         asin4       biquad  apulse * iamp4, 1, 0, -1, 1, ib14, ib24\n         asin5       biquad  apulse * iamp5, 1, 0, -1, 1, ib15, ib25\n         asin6       biquad  apulse * iamp6, 1, 0, -1, 1, ib16, ib26\n\n\n    afin    =    (asin1 + asin2 + asin3 + asin4 + asin5 + asin6)\n\n    outs        afin * sqrt(p6), afin*sqrt(1-p6)\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;ins     st    dur  pulseSpd   pch    pan    amp     Modes\ni1        0    12    0       7.089    0      0.7    2\ni1        .    .    .        7.09     1      .      .\ni1        .    .    .        7.091    0.5    .      .\n\ni1        0    12    0       8.039    0      0.7    2\ni1        0    12    0       8.04     1      0.7    2\ni1        0    12    0       8.041    0.5    0.7    2\n\ni1        9    .    .        7.089    0      .      2\ni1        .    .    .        7.09     1      .      .\ni1        .    .    .        7.091    0.5    .      .\n\ni1        9    12    0       8.019    0      0.7    2\ni1        9    12    0       8.02     1      0.7    2\ni1        9    12    0       8.021    0.5    0.7    2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/biquad/#see-also","title":"See also","text":"<p>Standard filters: Biquad filters</p>"},{"location":"opcodes/biquad/#credits","title":"Credits","text":"<p>Author: Hans Mikelson October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/biquada/","title":"Biquada","text":""},{"location":"opcodes/biquada/#biquada","title":"biquada","text":"<p>A sweepable general purpose biquadratic digital filter with a-rate parameters.</p>"},{"location":"opcodes/biquada/#syntax","title":"Syntax","text":"<pre><code>ares biquada asig, ab0, ab1, ab2, aa0, aa1, aa2 [, iskip]\n</code></pre>"},{"location":"opcodes/biquada/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non-zero, intialization will be skipped. Default value 0. (New in Csound version 3.50)</p>"},{"location":"opcodes/biquada/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>biquada is a general purpose biquadratic digital filter of the form:</p> \\[ a_0 y(n) + a_1 y(n-1) + a_2 y(n-2) = b_0 x(n) + b_1 x(n-1) + b_2 x(n-2) \\] <p>This filter has the following frequency response:</p> \\[ H(z) = \\frac{B(z)}{A(z)} = \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{a_0 + a_1 z^{-1} + a_2 z^{-2}} \\] <p>This type of filter is often encountered in digital signal processing literature. It allows six user-defined a-rate coefficients.</p>"},{"location":"opcodes/biquada/#examples","title":"Examples","text":"<p>Here is an example of the biquada opcode. It uses the file biquada.csd.</p> Example of the biquada opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o biquad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Instrument #1.\ninstr 1\n  ; Get the values from the score.\n  idur = p3\n  iamp = p4\n  icps = cpspch(p5)\n  afco   expon  100, p3, 2000\n  arez   line  0.8, p3, 0.99\n\n  ; Calculate the biquadratic filter's coefficients \n  afcon = 2*3.14159265*afco/sr\n  aalpha = 1-2*arez*cos(afcon)*cos(afcon)+arez*arez*cos(2*afcon)\n  abeta = arez*arez*sin(2*afcon)-2*arez*cos(afcon)*sin(afcon)\n  agama = 1+cos(afcon)\n  am1 = aalpha*agama+abeta*sin(afcon)\n  am2 = aalpha*agama-abeta*sin(afcon)\n  aden = sqrt(am1*am1+am2*am2)\n  ab0 = 1.5*(aalpha*aalpha+abeta*abeta)/aden\n  ab1 = ab0\n  ab2 = 0\n  aa0 = 1\n  aa1 = -2*arez*cos(afcon)\n  aa2 = arez*arez\n\n  ; Generate an input signal.\n  axn vco 1, icps, 1\n\n  ; Filter the input signal.\n  ayn biquada axn, ab0, ab1, ab2, aa0, aa1, aa2\n  outs ayn*iamp/2, ayn*iamp/2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n;    Sta  Dur  Amp    Pitch\ni 1  0.0  5.0  20000  6.00 \ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/biquada/#see-also","title":"See also","text":"<p>Standard filters: Biquad filters</p>"},{"location":"opcodes/biquada/#credits","title":"Credits","text":"<p>Author: John ffitch after Hans Mikelson August 2001</p> <p>New in Csound version 4.13</p>"},{"location":"opcodes/birnd/","title":"Birnd","text":""},{"location":"opcodes/birnd/#birnd","title":"birnd","text":"<p>Returns a random number in a bi-polar range.</p>"},{"location":"opcodes/birnd/#syntax","title":"Syntax","text":"<pre><code>birnd(x) (init- or control-rate only)\n</code></pre> <p>Where the argument within the parentheses may be an expression. These value converters sample a global random sequence, but do not reference seed. The result can be a term in a further expression.</p>"},{"location":"opcodes/birnd/#performance","title":"Performance","text":"<p>Returns a random number in the bipolar range -x to x. rnd and birnd obtain values from a global pseudo-random number generator, then scale them into the requested range. The single global generator will thus distribute its sequence to these units throughout the performance, in whatever order the requests arrive.</p>"},{"location":"opcodes/birnd/#examples","title":"Examples","text":"<p>Here is an example of the birnd opcode. It uses the file birnd.csd.</p> Example of the birnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o birnd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; Generate a random number from -1 to 1.\n\nkbin =  birnd(1)\n        printk .2, kbin\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  i1 = 0.94700\ninstr 1:  i1 = -0.72119\ninstr 1:  i1 = 0.53898\ninstr 1:  i1 = 0.05001\ninstr 1:  i1 = 0.24533\ninstr 1:  i1 = 0.93902\ninstr 1:  i1 = 0.43364\n</code></pre>"},{"location":"opcodes/birnd/#see-also","title":"See also","text":"<p>Random Functions</p>"},{"location":"opcodes/birnd/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe MIT Cambridge, Massachussetts 1997</p> <p>Extended in 3.47 to x-rate by John ffitch.</p>"},{"location":"opcodes/bob/","title":"Bob","text":""},{"location":"opcodes/bob/#bob","title":"bob","text":"<p>Runge-Kutte numerical simulation of the Moog analog resonant filter.</p> <p>Bob is based on bob~ by Miller Puckette in Pure Data. The design is based on the papers by Tim Stilson, Timothy E. Stinchcombe, and Antti Huovilainen.</p>"},{"location":"opcodes/bob/#syntax","title":"Syntax","text":"<pre><code>asig bob ain, xcf, xres, xsat [, iosamps, istor]\n</code></pre>"},{"location":"opcodes/bob/#initialization","title":"Initialization","text":"<p>iosamps -- number of times of oversampling used in the filtering process. This will determine the maximum sharpness of the filter resonance (Q). More oversampling allows higher Qs, less oversampling will limit the resonance. The default is 2 times (iosamps=0).</p> <p>istor -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/bob/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xcf -- filter cutoff frequency</p> <p>xres -- filter resonance. Nominally, a value of 4 should be the limit of stability -- above that, the filter oscillates.</p> <p>xsat --  saturation. This parameter determines at what signal level the \"transistors\" in the model saturate. The maximum output amplitude is about 2/3 of that value.</p> <p>According to bob~ manual page, \"By default bob~ does one step of 4th-order Runge-Kutte integration per audio sample. This works OK for resonant/cutoff frequencies up to about 1/2 Nyquist. To improve accuracy and/or to extend the range of the filter to higher cutoff frequencies you can oversample by any factor - but note that computation time rises accordingly. At high cutoff frequencies/resonance values the RK approximation can go unstable. You can combat this by raising the oversampling factor. The saturation parameter determines at what signal level the \"transistors\" in the model saturate. The maximum output amplitude is about 2/3 of that value\".</p>"},{"location":"opcodes/bob/#examples","title":"Examples","text":"<p>Here is an example of the bob opcode. It uses the file bob.csd.</p> Example of the bob opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o bob.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nga1 init 0\nga2 init 0\n\n    seed 777\n\ninstr 7\na0  vco2     1, cpsmidinn(p4) ; a saw wave to be filtered\nk1  jspline  0.7, 0.7, 1/0.7; add some jitter to filter resonance\nkA  linseg   0,        p3/17, 1,     (17-2)*p3/17, 1,   p3/17, 0; overal amplitude envelope\nk7  linseg   70,       p3/3,  700,   p3/3,     700,     p3/3,  70; filter cutoff envelope\nk77 expseg   sqrt(7),  p3/2,  7.7,   p3/2,     sqrt(7); filter resonance modulation\na1  bob      a0 * kA, k7 - k1 * 70, k77 + k1, 3; PD bob~ ported\na1           /= 7; some normalization to avoid overload\naL           = p5 * a1; and then panning\naR           = a1 * (1 - p5)\n    outs     aL, aR\n\nga1          +=  aL/7; AUX send\nga2          +=  aR/7\nendin\n\ninstr 77 ; What a sound without some good reverb??\na1,a2  reverbsc ga1,ga2, 0.97+.1/7, 7777\n    outs     a1, a2\nga1          = 0\nga2          = 0\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 7  0 30 70 0.7; Perfect 7th\ni 7  0 30 77 0.7\ni 77 0 40\n; In text editor try Find and Replace to substitute all 7 numbers for 3...8 )\n; all 8s is a bit too high, all 3s is a bit too low, 4 sounds great!\n; Do such replacement in initial 7 file, otherwise avoid accidental changes in the header...\n\n; Tired of numerology? Try this:\n; i 7  0 30 60 0.6\n; i 7  0 32 45 0.4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bob/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/bob/#credits","title":"Credits","text":"<p>By: Gleb Rogozinsky 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/bpf/","title":"Bpf","text":""},{"location":"opcodes/bpf/#bpf","title":"bpf","text":"<p>Break point function with linear interpolation</p> <p>Plugin opcode in emugens.</p>"},{"location":"opcodes/bpf/#syntax","title":"Syntax","text":"<pre><code>ky bpf kx, kx1, ky1, kx2, ..., kxn, kyn\niy bpf ix, ix1, iy1, ix2, ..., ixn, iyn\nkys[] bpf kxs[], kx1, ky1, kx2, ..., kxn, kyn\niys[] bpf ixs[], ix1, iy1, ix2, ..., ixn, iyn\nky bpf kx, kxs[], kys[]\niy bpf ix, ixs[], iys[]\nay bpf ax, kx1, ky1, kx2, ..., kxn, kyn\nay bpf ax, kxs[], kys[]\nky, kw bpf kx, kxs[], kys[], kws[]\n</code></pre>"},{"location":"opcodes/bpf/#performance","title":"Performance","text":"<p>kx -- Input value</p> <p>kxn, kyn -- Defines a breakpoint. Can be changed at krate, but all _kx_s must be sorted.</p> <p>The points (kx1, ky1), (kx2, ky2), etc, define a linearly interpolated function. This function is evaluated at point kx. This function extends to both -inf and +inf, so if kx &lt; kx1 then ky = ky1 and the same holds true the other end.</p> <p>These are equivalent:</p> <pre><code>ky bpf kx, 0, 0,  0.5, 10,  1.02, 200\n\nitab ftgenonce 0, 0, -27, 0, 0, 50, 10, 102, 200\nky = tablei(limit(kx, 0, 1.02)*100, itab)\n</code></pre> <p> Note</p> <p>x values need to be sorted. Both x and y values can change but x values must stay sorted.</p>"},{"location":"opcodes/bpf/#examples","title":"Examples","text":"<p>Here is an example of the bpf opcode. It uses the file bpf.csd.</p> Example of the bpf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example for opcode bpf\n\n/*\n\n  bpf stands for Break Point Function\n\n  Given an x value and a series of pairs (x, y), it returns\n  the corresponding y value in the linear curve defined by the\n  pairs\n\n  It works both at i- and k- time\n\n  ky    bpf kx,    kx0, ky0, kx1, ky1, kx2, ky2, ...\n  kys[] bpf kxs[], kx0, ky0, kx1, ky1, kx2, ky2, ...\n\n  NB: x values must be ordered (kx0 &lt; kx1 &lt; kx2 etc)\n\n  See also: bpfcos, linlin, lincos\n\n*/\n\nsr = 44100\nksmps = 64\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n  kx line -1, p3, 2.5\n  ky bpf kx,        \\\n         0,    0,   \\\n         1.01, 10,  \\\n         2,    0.5, \\\n         2.5,  -1\n  if metro(10) == 1 then\n    printsk \"kx: %f   ky: %f \\n\", kx, ky\n  endif\nendin\n\ninstr 2\n  ; test i-time\n  ix = 1.2\n  iy bpf ix, 0,0, 0.5,5, 1,10, 1.5,15, 2,20, 2.5,25, 3,30\n  prints \"iy: %f\", iy\n  turnoff\nendin\n\ninstr 3\n  ; bpf also works with arrays\n  kx[] fillarray 0, 0.15, 0.25, 0.35, 0.45, 0.55, 0.6\n  ky[] bpf kx, 0,0, 0.1,10, 0.2,20, 0.3,30, 0.4,40, 0.5,50\n  printarray ky, 1, \"\", \"ky=\"\n  turnoff\nendin\n\ninstr 4\n  ; bpf as an envelope generator, like linsegb but driven by external phase\n  ; bpf + rms can also be used as compressor\n\n  atime linseg 0, p3*0.62, p3, p3*0.38, 0\n  aenv = bpf(atime, 0,0, 0.1,1, 0.5, 0.2) ^ 2\n  kbw  = bpf(timeinsts(), 0, 0, p3*0.62, 1) ^ 3\n  asig = (beosc(1000, kbw, -1, rnd(6.28)) + beosc(1012, kbw, -1, rnd(6.28))) * 0.3\n  kratio bpf dbamp(rms:k(asig)), -12, 1, -6, 0.4, -3, 1/100\n  asig *= aenv * interp(lagud(kratio, 0.01, 0.1))\n  outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; i 1 0 3 \n; i 2 0 -1\n; i 3 0 -1\ni 4 0 3\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bpf/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/bpf/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/bpfcos/","title":"Bpfcos","text":""},{"location":"opcodes/bpfcos/#bpfcos","title":"bpfcos","text":"<p>Break point function with cosine (easy-in/easy-out) interpolation</p> <p>Plugin opcode in emugens.</p> <p>Given an x value and a series of pairs (x, y), it returns the corresponding y value in the half cosine curve defined by the pairs. It works both at i- and k- time</p>"},{"location":"opcodes/bpfcos/#syntax","title":"Syntax","text":"<pre><code>ky bpfcos kx, kx1, ky1, kx2, ..., kxn, kyn\nkys[] bpfcos kxs[], kx1, ky1, kx2, ..., kxn, kyn\nky bpfcos kx, kxs[], kys[]\nky bpfcos kx, ixs[], iys[]\nky, kz bpfcos kx, kxs[], kys[], kzs[]\nky, kz bpfcos kx, ixs[], iys[], izs[]\n</code></pre>"},{"location":"opcodes/bpfcos/#performance","title":"Performance","text":"<p>kx -- Input value. Can also be an array</p> <p>kxn, kyn -- Defines a breakpoint. Can be changed at krate, but all _kx_s must be sorted</p> <p>The points (kx1, ky1), (kx2, ky2), etc, define a cosine interpolated function. This function is evaluated at point kx. This function extends to both -inf and +inf, so if kx &lt; kx1 then ky = ky1 and the same holds true the other end.</p> <p>Array Variants:</p> <pre><code>kys[] bpfcos kxs[], kx1, ky1, kx2, ..., kxn, kyn\n</code></pre> <p>For each x in kxs, calculate the y value defined by the points (kx1, ky1), ... (kxn, kyn)</p> <pre><code>ky bpfcos kx, ixs[], iys[]\n</code></pre> <p>In this variants the points are defined through arrays. ixs contains all the x values, iys contains all the y values</p> <pre><code>ky, kz bpfcos kx, kxs[], kys[], kzs[] \n</code></pre> <p>The same as the variant above, but for multidimensional points. Given two curves sharing the same x points, calculate the value at x for both dimensions simultaneously. (see example)</p> <p> Note</p> <p>x values need to be sorted. Both x and y values can change but x values must stay sorted.</p>"},{"location":"opcodes/bpfcos/#examples","title":"Examples","text":"<p>Here is an example of the bpfcos opcode. It uses the file bpfcos.csd.</p> Example of the bpfcos opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example for opcode bpfcos\n\n/*\n\n  bpf stands for Break Point Function\n\n  Given an x value and a series of pairs (x, y), it returns\n  the corresponding y value in the half cosine curve defined by the\n  pairs\n\n  It works both at i- and k- time\n\n  ky     bpfcos kx,    kx0, ky0, kx1, ky1, kx2, ky2, ...\n  kys[]  bpfcos kxs[], kx0, ky0, kx1, ky1, kx2, ky2, ...\n  ky     bpfcos kx, kxs[], kys[]\n  ky, kz bpfcos kx, kxs[], kys[], kzs[]\n\n  NB: x values must be ordered (kx0 &lt; kx1 &lt; kx2 etc)\n\n  See also: bpf, linlin, lincos\n\n*/\nsr = 44100\nksmps = 64\nnchnls = 1\n0dbfs = 1\n\ninstr 1\n  kx line -1, p3, 2.5\n  ky bpfcos kx,        \\\n            0,    0,   \\\n            1.01, 10,  \\\n            2,    0.5, \\\n            2.5,  -1\n  printks \"kx: %f   ky: %f \\n\", 0.1, kx, ky\nendin\n\ninstr 2\n  ; test i-time\n  ix = 1.2\n  iy bpfcos ix, 0,0, 0.5,5, 1,10, 1.5,15, 2,20, 2.5,25, 3,30\n  print iy\n  turnoff\nendin\n\ninstr 3\n  ; bpfcos also works with arrays. For each kx value in kxs, \n  ; calculate the corresponding ky \n  kxs[] fillarray 0, 0.15, 0.25, 0.35, 0.45, 0.55, 0.6\n  kys[] bpfcos kxs, 0,0, 0.1,10, 0.2,20, 0.3,30, 0.4,40, 0.5,50\n  printarray kys, 1, \"\", \"kys=\"\n  turnoff\nendin\n\ninstr 4\n  ; bpfcos is useful to implement envelopes with ease-in/out shape\n  kpitch bpfcos timeinsts(), 0, 60, 2, 61, 3, 65, 3.5, 60\n  a0 oscili 0.5, mtof(kpitch)\n  kenv0 linseg 0, 0.5, 1, p3-1, 1, 0.5, 0\n  kenv bpfcos kenv0, 0, 0, 0.5, 0.25, 1, 0.7\n  a0 *= interp(kenv)\n  outch 1, a0\nendin\n\ninstr 5\n  ; arrays can also be used to define the points of a break-point-function\n  ; multiple arrays can be used simultaneously\n  ; In this case, we define a line and for each point in the line a \n  ; corresponding pitch (midinote) and amplitude\n  ; NB: kTimes uses absolute times\n  kTimes[] fillarray    0,  1, 1.5,  2,   3,  5\n  kPitches[] fillarray 60, 65,  64, 69,  60, 61\n  kAmps[] fillarray     0,  1, 0.1,  1, 0.1,  1\n  ; play the envelopes at half speed\n  kpitch, kamp bpfcos timeinsts()*0.5, kTimes, kPitches, kAmps\n  aout oscili a(kamp), a(mtof:k(kpitch))\n  ; declick\n  aout *= linsegr(0, 0.1, 1, 0.1, 0)\n  outch 1, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; i 1 1 3 \n; i 2 0 -1\n; i 3 0 -1\n; i 4 0 5\ni 5 0 10\ne 12\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bpfcos/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/bpfcos/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p> <p>Array versions in version 6.14</p>"},{"location":"opcodes/bqrez/","title":"Bqrez","text":""},{"location":"opcodes/bqrez/#bqrez","title":"bqrez","text":"<p>A second-order multi-mode filter.</p>"},{"location":"opcodes/bqrez/#syntax","title":"Syntax","text":"<pre><code>ares bqrez asig, xfco, xres [, imode] [, iskip]\n</code></pre>"},{"location":"opcodes/bqrez/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- The mode of the filter. Choose from one of the following:</p> <ul> <li>0 = low-pass (default)</li> <li>1 = high-pass</li> <li>2 = band-pass</li> <li>3 = band-reject</li> <li>4 = all-pass</li> </ul> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/bqrez/#performance","title":"Performance","text":"<p>ares -- output audio signal.</p> <p>asig -- input audio signal.</p> <p>xfco -- filter cut-off frequency in Hz. May be i-time, k-rate, a-rate.</p> <p>xres -- amount of resonance. Values of 1 to 100 are typical. Resonance should be one or greater. A value of 100 gives a 20dB gain at the cutoff frequency. May be i-time, k-rate, a-rate.</p> <p>All filter modes can be frequency modulated as well as the resonance can also be frequency modulated.</p> <p>bqrez is a resonant low-pass filter created using the Laplace s-domain equations for low-pass, high-pass, and band-pass filters normalized to a frequency. The bi-linear transform was used which contains a frequency transform constant from s-domain to z-domain to exactly match the frequencies together. Alot of trigonometric identities where used to simplify the calculation. It is very stable across the working frequency range up to the Nyquist frequency.</p>"},{"location":"opcodes/bqrez/#examples","title":"Examples","text":"<p>Here is an example of the bqrez opcode. It uses the file bqrez.csd.</p> Example of the bqrez opcode borrowed from the \u201crezzy\u201d opcode in Kevin Conder's manual.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o bqrez.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1                 ;sawtooth waveform.\n\nkfco  line 200, p3, 2000;filter-cutoff frequency from .2 to 5 KHz.\nkres  = p4              ;resonance\nimode = p5              ;mode\nasig    vco 0.2, 220, 1\nafilt   bqrez asig, kfco, kres, imode\nasig    balance afilt, asig\n        outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave\nf 1 0 16384 10 1\n\ni 1 0 3 1 0             ; low pass\ni 1 + 3 30 0            ; low pass\ni 1 + 3 1 1             ; high pass\ni 1 + 3 30 1            ; high pass\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/bqrez/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/bqrez/#credits","title":"Credits","text":"<p>Author: Matt Gerassimoff New in version 4.32 Written in November 2002.</p>"},{"location":"opcodes/butbp/","title":"Butbp","text":""},{"location":"opcodes/butbp/#butbp","title":"butbp","text":"<p>Same as the butterbp opcode.</p>"},{"location":"opcodes/butbp/#syntax","title":"Syntax","text":"<pre><code>ares butbp asig, kfreq, kband [, iskip]\n</code></pre>"},{"location":"opcodes/butbr/","title":"Butbr","text":""},{"location":"opcodes/butbr/#butbr","title":"butbr","text":"<p>Same as the butterbr opcode.</p>"},{"location":"opcodes/butbr/#syntax","title":"Syntax","text":"<pre><code>ares butbr asig, kfreq, kband [, iskip]\n</code></pre>"},{"location":"opcodes/buthp/","title":"Buthp","text":""},{"location":"opcodes/buthp/#buthp","title":"buthp","text":"<p>Same as the butterhp opcode.</p>"},{"location":"opcodes/buthp/#syntax","title":"Syntax","text":"<pre><code>ares buthp asig, kfreq [, iskip]\nares buthp asig, afreq [, iskip]\n</code></pre>"},{"location":"opcodes/butlp/","title":"Butlp","text":""},{"location":"opcodes/butlp/#butlp","title":"butlp","text":"<p>Same as the butterlp opcode.</p>"},{"location":"opcodes/butlp/#syntax","title":"Syntax","text":"<pre><code>ares butlp asig, kfreq [, iskip]\nares butlp asig, afreq [, iskip]\n</code></pre>"},{"location":"opcodes/butterbp/","title":"Butterbp","text":""},{"location":"opcodes/butterbp/#butterbp","title":"butterbp","text":"<p>A band-pass Butterworth filter.</p> <p>Implementation of a second-order band-pass Butterworth filter. This opcode can also be written as butbp.</p>"},{"location":"opcodes/butterbp/#syntax","title":"Syntax","text":"<pre><code>ares butterbp asig, xfreq, xband [, iskip]\n</code></pre>"},{"location":"opcodes/butterbp/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/butterbp/#performance","title":"Performance","text":"<p>These filters are Butterworth second-order IIR filters. They are slightly slower than the original filters in Csound, but they offer an almost flat passband and very good precision and stopband attenuation.</p> <p>asig -- Input signal to be filtered.</p> <p>xfreq -- Cutoff or center frequency for each of the filters.</p> <p>xband -- Bandwidth of the bandpass and bandreject filters.</p>"},{"location":"opcodes/butterbp/#examples","title":"Examples","text":"<p>Here is an example of the butterbp opcode. It uses the file butterbp.csd.</p> Example of the butterbp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o butterbp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; White noise signal\n\nasig rand 0.6\n     outs asig, asig\n\nendin\n\ninstr 2 ;filtered noise\n\nasig rand 1\nabp  butterbp asig, 2000, 100   ;passing only 1950 to 2050 Hz\n     outs abp, abp\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/butterbp/#see-also","title":"See also","text":"<p>Standard filters: Butterworth filters</p>"},{"location":"opcodes/butterbp/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/butterbr/","title":"Butterbr","text":""},{"location":"opcodes/butterbr/#butterbr","title":"butterbr","text":"<p>A band-reject Butterworth filter.</p> <p>Implementation of a second-order band-reject Butterworth filter. This opcode can also be written as butbr.</p>"},{"location":"opcodes/butterbr/#syntax","title":"Syntax","text":"<pre><code>ares butterbr asig, xfreq, xband [, iskip]\n</code></pre>"},{"location":"opcodes/butterbr/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/butterbr/#performance","title":"Performance","text":"<p>These filters are Butterworth second-order IIR filters. They are slightly slower than the original filters in Csound, but they offer an almost flat passband and very good precision and stopband attenuation.</p> <p>asig -- Input signal to be filtered.</p> <p>xfreq -- Cutoff or center frequency for each of the filters.</p> <p>xband -- Bandwidth of the bandpass and bandreject filters.</p>"},{"location":"opcodes/butterbr/#examples","title":"Examples","text":"<p>Here is an example of the butterbr opcode. It uses the file butterbr.csd.</p> Example of the butterbr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o butterbr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; White noise\n\nasig rand 0.5\n     outs asig, asig\n\nendin\n\ninstr 2 ; filtered noise\n\nasig rand 0.7\nabr  butterbr asig, 3000, 2000  ;center frequency = 3000, bandwidth =  +/- (2000)/2, so 2000-4000 \n     outs abr, abr\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/butterbr/#see-also","title":"See also","text":"<p>Standard filters: Butterworth filters</p>"},{"location":"opcodes/butterbr/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/butterhp/","title":"Butterhp","text":""},{"location":"opcodes/butterhp/#butterhp","title":"butterhp","text":"<p>A high-pass Butterworth filter.</p> <p>Implementation of second-order high-pass Butterworth filter. This opcode can also be written as buthp.</p>"},{"location":"opcodes/butterhp/#syntax","title":"Syntax","text":"<pre><code>ares butterhp asig, kfreq [, iskip]\nares butterhp asig, afreq [, iskip]\n</code></pre>"},{"location":"opcodes/butterhp/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/butterhp/#performance","title":"Performance","text":"<p>These filters are Butterworth second-order IIR filters. They are slightly slower than the original filters in Csound, but they offer an almost flat passband and very good precision and stopband attenuation.</p> <p>asig -- Input signal to be filtered.</p> <p>kfreq/afreq -- Cutoff or center frequency for each of the filters.</p>"},{"location":"opcodes/butterhp/#examples","title":"Examples","text":"<p>Here is an example of the butterhp opcode. It uses the file butterhp.csd.</p> Example of the butterhp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o butterhp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1   ; White noise \n\nasig rand 0.5\nouts asig, asig\n\nendin\n\ninstr 2 ; filtered noise\n\nasig rand 0.6\nahp  butterhp asig, 500  ;pass frequencies above 500 Hz\n     outs ahp, ahp\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/butterhp/#see-also","title":"See also","text":"<p>Standard filters: Butterworth filters</p>"},{"location":"opcodes/butterhp/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/butterlp/","title":"Butterlp","text":""},{"location":"opcodes/butterlp/#butterlp","title":"butterlp","text":"<p>A low-pass Butterworth filter.</p> <p>Implementation of a second-order low-pass Butterworth filter. This opcode can also be written as butlp.</p>"},{"location":"opcodes/butterlp/#syntax","title":"Syntax","text":"<pre><code>ares butterlp asig, kfreq [, iskip]\nares butterlp asig, afreq [, iskip]\n</code></pre>"},{"location":"opcodes/butterlp/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/butterlp/#performance","title":"Performance","text":"<p>These filters are Butterworth second-order IIR filters. They are slightly slower than the original filters in Csound, but they offer an almost flat passband and very good precision and stopband attenuation.</p> <p>asig -- Input signal to be filtered.</p> <p>kfreq/afreq -- Cutoff or center frequency for each of the filters.</p>"},{"location":"opcodes/butterlp/#examples","title":"Examples","text":"<p>Here is an example of the butterlp opcode. It uses the file butterlp.csd.</p> Example of the butterlp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o butterlp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; White noise signal\n\nasig rand 0.5\n     outs asig, asig\n\nendin\n\n\n\ninstr 2 ; filtered noise\n\nasig rand 0.7\nalp  butterlp asig, 1000          ;cutting frequencies above 1 KHz\n     outs alp, alp\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/butterlp/#see-also","title":"See also","text":"<p>Standard filters: Butterworth filters</p>"},{"location":"opcodes/butterlp/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/button/","title":"Button","text":""},{"location":"opcodes/button/#button","title":"button","text":"<p>Sense on-screen controls. Requires Winsound or TCL/TK.</p>"},{"location":"opcodes/button/#syntax","title":"Syntax","text":"<pre><code>kres button knum\n</code></pre>"},{"location":"opcodes/button/#performance","title":"Performance","text":"<p>Note that this opcode is not available on Windows due to the implimentation of pipes on that system.</p> <p>kres -- value of the button control. If the button has been pushed since the last k-period, then return 1, otherwise return 0.</p> <p>knum -- the number of the button. If it does not exist, it is made on-screen at initialization.</p>"},{"location":"opcodes/button/#examples","title":"Examples","text":"<p>Here is a simple example of the checkbox opcode. It uses the file checkbox.csd.</p> Simple example of the checkbox opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc       ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o checkbox.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n  kq init 0\n  ; Get the value from the checkbox.\n  k1 checkbox 1\n\n  ; If the checkbox is selected then k2=440, otherwise k2=880.\n  k2 = (k1 == 0 ? 440 : 880)\n\n  a1 oscil 10000, k2, 1\n  outs a1, a1\n  kq button 1\n  schedkwhen kq, 0, 1, 2, 0, 0\nendin\n\ninstr 2\n  exitnow\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; sine wave.\nf 1 0 32768 10 1\n\ni 1 0 1000 \ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/button/#see-also","title":"See also","text":"<p>Sensing and Control: TCL/TK widgets</p>"},{"location":"opcodes/button/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK September 2000</p> <p>New in Csound version 4.08</p>"},{"location":"opcodes/buzz/","title":"Buzz","text":""},{"location":"opcodes/buzz/#buzz","title":"buzz","text":"<p>Output is a set of harmonically related sine partials.</p>"},{"location":"opcodes/buzz/#syntax","title":"Syntax","text":"<pre><code>ares buzz xamp, xcps, knh, ifn [, iphs]\n</code></pre>"},{"location":"opcodes/buzz/#initialization","title":"Initialization","text":"<p>ifn -- table number of a stored function containing a sine wave. A large table of at least 8192 points is recommended.</p> <p>iphs (optional, default=0) -- initial phase of the fundamental frequency, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is zero</p>"},{"location":"opcodes/buzz/#performance","title":"Performance","text":"<p>xamp -- amplitude</p> <p>xcps -- frequency in cycles per second</p> <p>The buzz units generate an additive set of harmonically related cosine partials of fundamental frequency xcps, and whose amplitudes are scaled so their summation peak equals xamp. The selection and strength of partials is determined by the following control parameters:</p> <p>knh -- total number of harmonics requested. New in Csound version 3.57, knh defaults to one. If knh is negative, the absolute value is used.</p> <p>buzz and gbuzz are useful as complex sound sources in subtractive synthesis. buzz is a special case of the more general gbuzz in which klh = kmul = 1; it thus produces a set of knh equal-strength harmonic partials, beginning with the fundamental. (This is a band-limited pulse train; if the partials extend to the Nyquist, i.e. knh = int (sr / 2 / fundamental freq.), the result is a real pulse train of amplitude xamp.)</p> <p>Although knh may be varied during performance, its internal value is necessarily integer and may cause \u201cpops\u201d due to discontinuities in the output. buzz can be amplitude- and/or frequency-modulated by either control or audio signals.</p> <p>N.B. This unit has its analog in GEN11, in which the same set of cosines can be stored in a function table for sampling by an oscillator. Although computationally more efficient, the stored pulse train has a fixed spectral content, not a time-varying one as above.</p>"},{"location":"opcodes/buzz/#examples","title":"Examples","text":"<p>Here is an example of the buzz opcode. It uses the file buzz.csd.</p> Example of the buzz opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o buzz.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkcps = 110\nifn  = 1\n\nknh  line p4, p3, p5\nasig buzz 1, kcps, knh, ifn\n     outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 3 20 20\ni 1 + 3 3 3\ni 1 + 3 10 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the buzz opcode: BuzzFof_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/buzz/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/buzz/#credits","title":"Credits","text":"<p>September 2003. Thanks to Kanata Motohashi for correcting the mentions of the kmul parameter.</p>"},{"location":"opcodes/cabasa/","title":"Cabasa","text":""},{"location":"opcodes/cabasa/#cabasa","title":"cabasa","text":"<p>Semi-physical model of a cabasa sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/cabasa/#syntax","title":"Syntax","text":"<pre><code>ares cabasa iamp, idettack [, inum] [, idamp] [, imaxshake]\n</code></pre>"},{"location":"opcodes/cabasa/#initialization","title":"Initialization","text":"<p>iamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only a approximation.</p> <p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 512.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.998 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.997 which means that the default value of idamp is -0.5. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 1.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p>"},{"location":"opcodes/cabasa/#examples","title":"Examples","text":"<p>Here is an example of the cabasa opcode. It uses the file cabasa.csd.</p> Example of the cabasa opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cabasa.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 \n\ninum    = p4\nidamp   = p5               \nasig    cabasa 0.9, 0.01, inum, idamp\n        outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 1 1 48 .95\ni1 + 1 1000 .5\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cabasa/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/cabasa/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/cauchy/","title":"Cauchy","text":""},{"location":"opcodes/cauchy/#cauchy","title":"cauchy","text":"<p>Cauchy distribution random number generator.</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/cauchy/#syntax","title":"Syntax","text":"<pre><code>ares cauchy kalpha\nires cauchy kalpha\nkres cauchy kalpha\n</code></pre>"},{"location":"opcodes/cauchy/#performance","title":"Performance","text":"<p>kalpha -- controls the spread from zero (big kalpha = big spread). Outputs both positive and negative numbers.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/cauchy/#examples","title":"Examples","text":"<p>Here is an example of the cauchy opcode. It uses the file cauchy.csd.</p> Example of the cauchy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cauchy.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1         ; every run time same values\n\nkalpha  cauchy  100\n        printk  .2, kalpha              ; look\naout    oscili  0.8, 440+kalpha, 1      ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nkalpha  cauchy  100\n        printk  .2, kalpha              ; look \naout    oscili  0.8, 440+kalpha, 1      ; &amp; listen\n        outs    aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i   1 time     0.00267:    -0.20676\ni   1 time     0.20267:    -0.28814\ni   1 time     0.40267:     0.61651\ni   1 time     0.60267:   -18.18552\ni   1 time     0.80267:     1.18140\ni   1 time     1.00000:    -0.75432\ni   1 time     1.20267:    -0.02002\ni   1 time     1.40267:     0.01785\ni   1 time     1.60267:    -0.48834\ni   1 time     1.80000:     9.69401\ni   1 time     2.00000:    -0.41257\nSeeding from current time 3112109827\ni   2 time     3.00267:    -0.46887\ni   2 time     3.20267:     0.06189\ni   2 time     3.40267:    -0.40303\ni   2 time     3.60000:     0.89312\ni   2 time     3.80267:    -0.40374\ni   2 time     4.00000:     0.86557\ni   2 time     4.20000:     0.09192\ni   2 time     4.40267:    -0.16748\ni   2 time     4.60267:     0.30133\ni   2 time     4.80267:     0.31657\ni   2 time     5.00000:     0.44681\n</code></pre>"},{"location":"opcodes/cauchy/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/cauchy/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Existed in 3.30</p>"},{"location":"opcodes/cauchyi/","title":"Cauchyi","text":""},{"location":"opcodes/cauchyi/#cauchyi","title":"cauchyi","text":"<p>Cauchy distribution random number generator with interpolation between values.</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/cauchyi/#syntax","title":"Syntax","text":"<pre><code>ares cauchyi klambda, xamp, xcps\nires cauchyi klambda, xamp, xcps\nkres cauchyi klambda, xamp, xcps\n</code></pre>"},{"location":"opcodes/cauchyi/#performance","title":"Performance","text":"<p>kalpha -- controls the spread from zero (big kalpha = big spread). Outputs both positive and negative numbers.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol> <p>xamp -- range over which random numbers are distributed.</p> <p>xcps -- the frequency which new random numbers are generated.</p>"},{"location":"opcodes/cauchyi/#examples","title":"Examples","text":"<p>Here is an example of the cauchyi opcode. It uses the file cauchyi.csd.</p> Example of the cauchyi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o exprand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nklambda cauchyi 100, 1, 3\n        printk2 klambda         ; look\naout    oscili  0.8, 440+klambda, 1     ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 4\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cauchyi/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/cauchyi/#credits","title":"Credits","text":"<p>Author: John ffitch Bath May 2011 New in version 5.14</p>"},{"location":"opcodes/cbrt/","title":"Cbrt","text":""},{"location":"opcodes/cbrt/#cbrt","title":"cbrt","text":"<p>Cubic root function.</p>"},{"location":"opcodes/cbrt/#syntax","title":"Syntax","text":"<pre><code>ires[] cbrt iarg\nkres[] cbrt karg\n</code></pre>"},{"location":"opcodes/cbrt/#initialization","title":"Initialization","text":"<p>iarg[] -- the argument.</p>"},{"location":"opcodes/cbrt/#performance","title":"Performance","text":"<p>karg[] -- the argument.</p>"},{"location":"opcodes/cbrt/#examples","title":"Examples","text":"<p>Here is an example of the cbrt opcode. It uses the file cbrt.csd.</p> Example of the cbrt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg[] fillarray 1,2,3\niRes[] cbrt iArg\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cbrt/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/cbrt/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017</p>"},{"location":"opcodes/ceil/","title":"Ceil","text":""},{"location":"opcodes/ceil/#ceil","title":"ceil","text":"<p>Returns the smallest integer not less than x</p>"},{"location":"opcodes/ceil/#syntax","title":"Syntax","text":"<pre><code>ceil(x) (init-, control-, or audio-rate arg allowed)\nceil(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/ceil/#examples","title":"Examples","text":"<p>Here is an example of the ceil opcode. It uses the file ceil.csd.</p> Example of the ceil opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1 \n\ninum = p4 \niceil = ceil(inum) \nprint iceil \n\nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 0 1 \ni . . . 0.999999 \ni . . . 0.000001 \ni . . . 0 \ni . . . -0.0000001 \ni . . . -0.9999999 \ni . . . -1 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iceil = -1.000\ninstr 1:  iceil = 1.000\ninstr 1:  iceil = 1.000\ninstr 1:  iceil = 1.000\ninstr 1:  iceil = 0.000\ninstr 1:  iceil = 0.000\ninstr 1:  iceil = 0.000\n</code></pre> <p>Here is another example of the ceil opcode. It uses the file ceil-2.csd.</p> A second example of the ceil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ceil-2.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi - 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps = 100\nkcar = 1\nkmod = p4\n\nkndx oscil 30, .25/p3, 1\nkndx ceil kndx\n\nasig foscili .5, kcps, kcar, kmod, kndx, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 16384 10 1\n\ni 1 0 10 1.5    \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the rounding-group, comparing the different rounding opcodes. It uses the file rounding-group.csd.</p> Example of the rounding group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac       ;   \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n\n; by tgrey 2020\ninstr 1\n\niLoopStart = p4\niLoopEnd   = p5\niOffset    = p6\n\niCount init iLoopStart\n\n\nif(iLoopStart&lt;iLoopEnd) then            ; loop going up\n        while iCount &lt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount + 1             \n        od\n\nelseif(iLoopEnd&lt;iLoopStart) then        ; loop going down\n        while iCount &gt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount - 1             \n        od\nendif\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 .1 0 10 .5\ni1 .2 .1 0 -10 .5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ceil/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/ceil/#credits","title":"Credits","text":"<p>Author: Istvan Varga New in Csound 5 2005</p>"},{"location":"opcodes/cell/","title":"Cell","text":""},{"location":"opcodes/cell/#cell","title":"cell","text":"<p>Cellular Automaton</p> <p>Plugin opcode in cellular</p> <p>One-Dimensional Cellular Automaton. This opcode is the modified version of vcella by Gabriel Maldonado.</p>"},{"location":"opcodes/cell/#syntax","title":"Syntax","text":"<pre><code>cell ktrig, kreinit, ioutFunc, initStateFunc, iRuleFunc, ielements\n</code></pre>"},{"location":"opcodes/cell/#initialization","title":"Initialization","text":"<p>ioutFunc -- number of the table where the state of each cell is stored.</p> <p>initStateFunc -- number of the table containing the inital states of cells.</p> <p>iRuleFunc -- number of a lookup table containing the 8-bit rule.</p> <p>ielements -- total number of cells in a row.</p>"},{"location":"opcodes/cell/#performance","title":"Performance","text":"<p>ktri -- trigger signal. Each time it is non-zero, a new generation of cells is evaluated.</p> <p>kreinit -- reset signal. Each time it is non-zero, state of all cells is forced to be that of initStateFunc.</p> <p>cell models a classical 1D cellular automaton and stores the state of each cell in the table identified by ioutFunc.</p> <p>initStateFunc is an input vector containing the inital value of the row of cells, while iRuleFunc is an input vector containing the chosen rule in the binary form (least significant bit first).</p> <p>A new generation of cells is evaluated each time ktrig contains a non-zero value.  Also the status of all cells can be forced to assume the status corresponding to the contents of initStateFunc each time kreinit contains a non-zero value.</p> <p>Note that each cell is supposed to be in one of two possible states (1 = \"alive\", 0 = \"dead\"), although fractional values should work too, because truncation is used.</p>"},{"location":"opcodes/cell/#examples","title":"Examples","text":"<p>Here is a simple example of the cell opcode. It uses the file cell.csd.</p> A simple example of the cell opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;-odac           -iadc     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cell.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; cell.csd by Gleb Rogozinsky\n\nsr        = 44100\nkr        = 4410\nksmps     = 10\nnchnls    = 1\n0dbfs     = 1\n\n; Cellular automaton-driven synthesis in spectral domain\ninstr 1\n\n  iatt      = p4                                ; envelope attack time\n  isus      = p5                                ; envelope sustain time\n  irel      = p6                                ; envelope release time\n  ivol      = p7                                ; overall volume\n\n  ; create some white noise\n  asig      rand      0.8                      \n\n  ; spectral analysis of asig\n  fsig      pvsanal   asig, 2048, 1024, 2048, 0  ; get a vector of magnitudes\n\n  ; calculate cellular automaton state\n  kfreq     line      50, 5, 1                  ; variable CA triggering frequency\n  ktrig     metro     kfreq                     ; trigger the CA to update cells\n            cell      ktrig, 0, 3, 1, 2, 2048   ; cells are written into ftable 3 \n\n\n  ; use current row of cells in spectral domain\n  fmas      pvstencil fsig, 0, 1, 3             ; apply spectral mask \n  aout      pvsynth   fmas                      ; reconstruct time signal \n\n  ; apply envelope and out signal\n  kenv      expseg    .001, iatt, 1, isus, 1, irel, .001\n            out       aout*kenv*ivol\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; This example uses one-dimensional cellular automaton\n; to produce structures in spectral domain\n\n; We have to prepare initial row of cells.\n; One alive cell is enough to produce a simple fractal,\n; so two alivee cells will make structure more sophisticated\nf1 0 2048 7 0 150 0 0 1 1 1 0 0 45 0 0 1 1 1 0 0\n\n; The CA rule is used as follows:\n; the states (values) of each cell are summed with their neighboring cells.\n; Each sum is used as an index to read a next state of cell\n; from the rule table.\n; Let us try rule # 129 (LSB binary 1 0 0 0 0 0 0 1).\n; This rule will produce a fractal structure for single active cell\n; For more rules see http://mathworld.wolfram.com/ElementaryCellularAutomaton.html\nf2 0 8 -2 1 0 0 0 0 0 0 1\n; Try some different rules i.E. 254 (0 1 1 1 1 1 1 1) or 169 (1 0 0 1 0 1 0 1)\n\n; Prepare the output table of ielements size\nf3 0 2048 10 0\n\n; Time to make it sound!\ni1 0  13  0.3  7  3  1 \ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cell/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/cell/#credits","title":"Credits","text":"<p>Author: Gleb Rogozinsky October 2011</p> <p>New in Csound version 5.16.6</p>"},{"location":"opcodes/cent/","title":"Cent","text":""},{"location":"opcodes/cent/#cent","title":"cent","text":"<p>Calculates a factor to raise/lower a frequency by a given amount of cents.</p>"},{"location":"opcodes/cent/#syntax","title":"Syntax","text":"<pre><code>cent(x)\n</code></pre> <p>This function works at a-rate, i-rate, and k-rate.</p>"},{"location":"opcodes/cent/#initialization","title":"Initialization","text":"<p>x -- a value expressed in cents.</p>"},{"location":"opcodes/cent/#performance","title":"Performance","text":"<p>The value returned by the cent function is a factor. You can multiply a frequency by this factor to raise/lower it by the given amount of cents.</p>"},{"location":"opcodes/cent/#examples","title":"Examples","text":"<p>Here is an example of the cent opcode. It uses the file cent.csd.</p> Example of the cent opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cent.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; original pitch\n\niroot = 440     ; root note = A (440 Hz)\n\nprint iroot     ;print out\n\nasig oscili 0.6, iroot, 1 \n     outs asig, asig\n\nendin\n\ninstr 2\n\niroot   = 440   ; root note = A (440 Hz)\nicents  = p4    ; change root note by 300 and 1200 cents\n\nifactor = cent(icents) ; calculate new note\ninew    = iroot * ifactor\n\nprint iroot     ; Print all\nprint ifactor\nprint inew\n\nasig oscili 0.6, inew, 1 \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf1 0 32768 10 1\n\ni 1 0  2        ;no change\ni 2 2.5 2 300   ;note = C above A\ni 2 5  2 1200   ;1 octave higher \n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iroot = 440.000\n\ninstr 2:  iroot = 440.000\ninstr 2:  ifactor = 1.189\ninstr 2:  inew = 523.251\n\ninstr 2:  iroot = 440.000\ninstr 2:  ifactor = 2.000\ninstr 2:  inew = 880.000\n</code></pre>"},{"location":"opcodes/cent/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>New in version 4.16</p>"},{"location":"opcodes/centroid/","title":"Centroid","text":""},{"location":"opcodes/centroid/#centroid","title":"centroid","text":"<p>Calculate the spectral centroid of an audio signal on a given trigger.</p>"},{"location":"opcodes/centroid/#syntax","title":"Syntax","text":"<pre><code>kcent centroid asig, ktrig, ifftsize\n</code></pre>"},{"location":"opcodes/centroid/#initialization","title":"Initialization","text":"<p>ifftsize  -- fftsize. Non pow-of-two values are converted to the next pow-of-two not smaller than ifftsize.</p>"},{"location":"opcodes/centroid/#performance","title":"Performance","text":"<p>kcent -- the spectral centroid in Hz</p> <p>asig -- an input audio signal</p> <p>ktrig -- 1 to calculate a new centroid, 0 to skip the process (and output previous value).</p>"},{"location":"opcodes/centroid/#examples","title":"Examples","text":"<p>Here is an example of the centroid opcode. It uses the file centroid.csd.</p> Example of the centroid opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o centroid.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 16384, 10, 1\n\ninstr 1\n\nktrig init 1                            ;calculate centroid\na1   oscil3 0.5, p4, giSine             ;of the sine wave\nk1   centroid a1, ktrig, 16384\nasig oscil3 0.5, k1, giSine\n     printk2 k1                         ;print &amp; compare:\n     outs a1, asig                      ;left = original, right = centroid signal\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2 20\ni1 + 2 200\ni1 + 2 2000\ne     \n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/centroid/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/centroid/#credits","title":"Credits","text":"<p>Author: V Lazzarini; August 2012</p>"},{"location":"opcodes/cggoto/","title":"Cggoto","text":""},{"location":"opcodes/cggoto/#cggoto","title":"cggoto","text":"<p>Conditionally transfer control to label on every pass. (Combination of cigoto and ckgoto)</p>"},{"location":"opcodes/cggoto/#syntax","title":"Syntax","text":"<pre><code>cggoto condition, label\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where condition uses one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p>"},{"location":"opcodes/cggoto/#examples","title":"Examples","text":"<p>Here is an example of the cggoto opcode. It uses the file cggoto.csd.</p> Example of the cggoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; -o cggoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = p4\n\n  ; If i1 is equal to one, play a high note.\n  ; Otherwise play a low note.\n  cggoto (i1 == 1), highnote\n\nlownote:\n  a1 oscil 10000, 220, 1\n  goto playit\n\nhighnote:\n  a1 oscil 10000, 440, 1\n  goto playit\n\nplayit:\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play lownote for one second.\ni 1 0 1 1\n; Play highnote for one second.\ni 1 1 1 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cggoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/cggoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/chanctrl/","title":"Chanctrl","text":""},{"location":"opcodes/chanctrl/#chanctrl","title":"chanctrl","text":"<p>Get the current value of a MIDI channel controller and optionally map it onto specified range.</p>"},{"location":"opcodes/chanctrl/#syntax","title":"Syntax","text":"<pre><code>ival chanctrl ichnl, ictlno [, ilow] [, ihigh]\nkval chanctrl ichnl, ictlno [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/chanctrl/#initialization","title":"Initialization","text":"<p>ichnl -- the MIDI channel (1-16).</p> <p>ictlno -- the MIDI controller number (0-127).</p> <p>ilow, ihigh -- low and high ranges for mapping</p>"},{"location":"opcodes/chanctrl/#examples","title":"Examples","text":"<p>Here is an example of the chanctrl opcode. It uses the file chanctrl.csd.</p> Example of the chanctrl opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   No messages  MIDI in\n-odac            -d         -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chanctrl.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; press your midi keyboard and move your midi controller to see result\n\nichnl  = 1              ;MIDI note inputs on channel 1\nictlno = 7              ;use midi volume controller \nkch  chanctrl ichnl, 7  ;to control amplitude of oscil\n     printk2  kch\n\nasig oscil kch*(1/127), 220, 1\n     outs  asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;Dummy f-table to give time for real-time MIDI events\nf 0 30\n;sine wave.\nf 1 0 16384 10 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chanctrl/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/chanctrl/#credits","title":"Credits","text":"<p>Author: Mike Berry Mills College May, 1997</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/changed/","title":"Changed","text":""},{"location":"opcodes/changed/#changed","title":"changed","text":"<p>k-rate signal change detector.</p> <p>This opcode outputs a trigger signal that informs when any one of its k-rate arguments has changed. Useful with valuator widgets or MIDI controllers.</p>"},{"location":"opcodes/changed/#syntax","title":"Syntax","text":"<pre><code>ktrig changed kvar1 [, kvar2,..., kvarN]\n</code></pre>"},{"location":"opcodes/changed/#performance","title":"Performance","text":"<p>ktrig - Outputs a value of 1 when any of the k-rate signals has changed, otherwise outputs 0.</p> <p>kvar1 [, kvar2,..., kvarN] - k-rate variables to watch for changes.</p> <p> Note</p> <p>If any of the kvars is non-zero at the first k-cycle changed is called it will report a change.  For more consistent behaviour use changed2.</p>"},{"location":"opcodes/changed/#examples","title":"Examples","text":"<p>Here is an example of the changed opcode. It uses the file changed.csd.</p> Example of the changed opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o changed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nksig  oscil 2, 0.5, 1\nkint  = int(ksig)\nktrig changed kint\n      printk 0.2, kint\n      printk2 ktrig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 10 1\ni 1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i   1 time     0.00267:     0.00000\ni1     0.00000\ni1     1.00000\ni1     0.00000\ni   1 time     0.20267:     1.00000\ni   1 time     0.40267:     1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     0.60267:     1.00000\ni   1 time     0.80267:     1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.00000:     0.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.20267:    -1.00000\ni   1 time     1.40267:    -1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.60267:    -1.00000\ni   1 time     1.80000:    -1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     2.00000:    -0.00000\ni1     1.00000\ni1     0.00000\n.........\n</code></pre>"},{"location":"opcodes/changed/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/changed/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>Example written by Andr\u00e9s Cabrera.</p> <p>New in Csound 5.7.</p>"},{"location":"opcodes/changed2/","title":"Changed2","text":""},{"location":"opcodes/changed2/#changed2","title":"changed2","text":"<p>k-rate signal change detector.</p> <p>This opcode outputs a trigger signal that informs when any one of its k-rate arguments has changed, or a value in an array. Useful with valuator widgets or MIDI controllers.</p>"},{"location":"opcodes/changed2/#syntax","title":"Syntax","text":"<pre><code>ktrig changed2 kvar1 [, kvar2,..., kvarN]\nktrig changed2 karr[]\nktrig changed2 aarr[]\n</code></pre>"},{"location":"opcodes/changed2/#performance","title":"Performance","text":"<p>ktrig - Outputs a value of 1 when any of the k-rate signals has changed, or any value in the array, otherwise outputs 0.</p> <p>kvar1 [, kvar2,..., kvarN] - k-rate variables to watch for changes.</p> <p>xarray - any array type.</p> <p>Unlike the opcode changed this opcode will never report the first cycle as a change.</p>"},{"location":"opcodes/changed2/#examples","title":"Examples","text":"<p>Here are two examples of the changed2 opcode. They use the files changed2.csd and changed2a.csd.</p> Example of the changed2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o changed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nksig  oscil 2, 0.5, 1\nkint  = int(ksig)\nktrig changed2 kint\n      printk 0.2, kint\n      printk2 ktrig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 10 1\ni 1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i   1 time     0.00267:     0.00000\ni1     0.00000\ni1     1.00000\ni1     0.00000\ni   1 time     0.20267:     1.00000\ni   1 time     0.40267:     1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     0.60267:     1.00000\ni   1 time     0.80267:     1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.00000:     0.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.20267:    -1.00000\ni   1 time     1.40267:    -1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     1.60267:    -1.00000\ni   1 time     1.80000:    -1.00000\ni1     1.00000\ni1     0.00000\ni   1 time     2.00000:    -0.00000\ni1     1.00000\ni1     0.00000\n.........\n</code></pre> Example of the changed2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ngkArray[][] init   2,3\ngkArray     fillarray  1,2,3,7,6,5\n\ninstr 1\nk1 changed2 gkArray\nif k1==1 then\n    printks \"An element in the array changed\", 0\nendif\nendin\n\ninstr 2; change value of channel 'step1'\n    gkArray[1][0] = 3\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 100\ni2 4 .1\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/changed2/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/changed2/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>Example written by Andr\u00e9s Cabrera.</p> <p>New in Csound 6.7</p>"},{"location":"opcodes/chani/","title":"Chani","text":""},{"location":"opcodes/chani/#chani","title":"chani","text":"<p>Reads data from a channel of the inward software bus.</p>"},{"location":"opcodes/chani/#syntax","title":"Syntax","text":"<pre><code>kval chani kchan\naval chani kchan\n</code></pre>"},{"location":"opcodes/chani/#performance","title":"Performance","text":"<p>kchan -- a positive integer that indicates which channel of the software bus to read</p> <p>Note that the inward and outward software busses are independent, and are not mixer buses.  Also the k-rate and a-rate busses are independent.  The last value remains until a new value is written.  There is no imposed limit to the number of busses but they use memory so small numbers are to be preferred.</p>"},{"location":"opcodes/chani/#example","title":"Example","text":"<p>The example shows the software bus being used as an asynchronous control signal to select a filter cutoff.  It assumes that an external program that has access to the API is feeding the values</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\ninstr   1\n    kc   chani     1\n    a1   oscil     p4, p5, 100\n    a2   lowpass2  a1, kc, 200\n         out       a2\nendin\n</code></pre>"},{"location":"opcodes/chani/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chani/#credits","title":"Credits","text":"<p>Author: John ffitch 2005</p> <p>New in Csound 5.00</p>"},{"location":"opcodes/chano/","title":"Chano","text":""},{"location":"opcodes/chano/#chano","title":"chano","text":"<p>Send data to a channel of the outward software bus.</p>"},{"location":"opcodes/chano/#syntax","title":"Syntax","text":"<pre><code>chano kval, kchan\nchano aval, kchan\n</code></pre>"},{"location":"opcodes/chano/#performance","title":"Performance","text":"<p>xval --- value to transmit</p> <p>kchan -- a positive integer that indicates which channel of the software bus to write</p> <p>Note that the inward and outward software busses are independent, and are not mixer buses.  Also the k-rate and a-rate busses are independent.  The last value remains until a new value is written.  There is no imposed limit to the number of busses but they use memory so small numbers are to be preferred.</p> <p>Example</p> <p>The example shows the software bus being used as an output audio channel. It assumes that an external program that has access to the API is receiving the values.</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\ninstr   1\n    a1   oscil     p4, p5, 100\n         chano     1, a1\nendin\n</code></pre>"},{"location":"opcodes/chano/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chano/#credits","title":"Credits","text":"<p>Author: John ffitch 2005</p> <p>New in Csound 5.00</p>"},{"location":"opcodes/chebyshevpoly/","title":"Chebyshevpoly","text":""},{"location":"opcodes/chebyshevpoly/#chebyshevpoly","title":"chebyshevpoly","text":"<p>Efficiently evaluates the sum of Chebyshev polynomials of arbitrary order.</p> <p>The chebyshevpoly opcode calculates the value of a polynomial expression with a single a-rate input variable that is made up of a linear combination of the first N Chebyshev polynomials of the first kind.  Each Chebyshev polynomial, Tn(x), is weighted by a k-rate coefficient, kn, so that the opcode is calculating a sum of any number of terms in the form kn*Tn(x).  Thus, the chebyshevpoly opcode allows for the waveshaping of an audio signal with a dynamic transfer function that gives precise control over the harmonic content of the output.</p>"},{"location":"opcodes/chebyshevpoly/#syntax","title":"Syntax","text":"<pre><code>aout chebyshevpoly ain, k0 [, k1 [, k2 [...]]]\n</code></pre>"},{"location":"opcodes/chebyshevpoly/#performance","title":"Performance","text":"<p>ain --  the input signal used as the independent variable of the Chebyshev polynomials (\"x\").</p> <p>aout --  the output signal (\"y\").</p> <p>k0, k1, k2, ... --  k-rate multipliers for each Chebyshev polynomial.</p> <p>This opcode is very useful for dynamic waveshaping of an audio signal.  Traditional waveshaping techniques utilize a lookup table for the transfer function -- usually a sum of Chebyshev polynomials.  When a sine wave at full-scale amplitude is used as an index to read the table, the precise harmonic spectrum as defined by the weights of the Chebyshev polynomials is produced.   A dynamic spectrum is acheived by varying the amplitude of the input sine wave, but this produces a non-linear change in the spectrum.</p> <p>By directly calculating the Chebyshev polynomials, the chebyshevpoly opcode allows more control over the spectrum and the number of harmonic partials added to the input can be varied with time.  The value of each kn coefficient directly controls the amplitude of the nth harmonic partial if the input ain is a sine wave with amplitude = 1.0.  This makes chebyshevpoly an efficient additive synthesis engine for N partials that requires only one oscillator instead of N oscillators.  The amplitude or waveform of the input signal can also be changed for different waveshaping effects.</p> <p>If we consider the input parameter ain to be \"x\" and the output aout to be \"y\", then the chebyshevpoly opcode calculates the following equation:</p> <pre><code>y = k0*T0(x) + k1*T1(x) + k2*T2(x) + k3*T3(x) + ...\n</code></pre> <p>where the Tn(x) are defined by the recurrence relation</p> <pre><code>T0(x) = 1,\nT1(x) = x,\nTn(x) = 2x*T[n-1](x) - T[n-2](x)\n</code></pre> <p>More information about Chebyshev polynomials can be found on Wikipedia at http://en.wikipedia.org/wiki/Chebyshev_polynomial</p>"},{"location":"opcodes/chebyshevpoly/#examples","title":"Examples","text":"<p>Here is an example of the chebyshevpoly opcode. It uses the file chebyshevpoly.csd.</p> Example of the chebyshevpoly opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chebyshevpoly.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\n; time-varying mixture of first six harmonics\ninstr 1\n        ; According to the GEN13 manual entry,\n        ; the pattern + - - + + - - for the signs of \n        ; the chebyshev coefficients has nice properties.\n\n        ; these six lines control the relative powers of the harmonics\n        k1         line           1.0, p3, 0.0\n        k2         line           -0.5, p3, 0.0\n        k3         line           -0.333, p3, -1.0\n        k4         line           0.0, p3, 0.5\n        k5         line           0.0, p3, 0.7\n        k6         line           0.0, p3, -1.0\n\n        ; play the sine wave at a frequency of 256 Hz with amplitude = 1.0\n        ax         oscili         1, 256, 1\n\n        ; waveshape it\n        ay         chebyshevpoly  ax, 0, k1, k2, k3, k4, k5, k6\n\n        ; avoid clicks, scale final amplitude, and output\n        adeclick   linseg         0.0, 0.05, 1.0, p3 - 0.1, 1.0, 0.05, 0.0\n                   outs           ay * adeclick * 10000, ay * adeclick * 10000\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32768 10 1 ; a sine wave\n\ni1 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chebyshevpoly/#see-also","title":"See also","text":"<p>Waveshaping</p> <p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/chebyshevpoly/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/checkbox/","title":"Checkbox","text":""},{"location":"opcodes/checkbox/#checkbox","title":"checkbox","text":"<p>Sense on-screen controls. Requires Winsound or TCL/TK.</p> <p>Plugin opcode in control.</p>"},{"location":"opcodes/checkbox/#syntax","title":"Syntax","text":"<pre><code>kres checkbox knum\n</code></pre>"},{"location":"opcodes/checkbox/#performance","title":"Performance","text":"<p>Note that this opcode is not available on Windows due to the implimentation of pipes on that system.</p> <p>kres -- value of the checkbox control. If the checkbox is set (pushed) then return 1, if not, return 0.</p> <p>knum -- the number of the checkbox. If it does not exist, it is made on-screen at initialization.</p>"},{"location":"opcodes/checkbox/#examples","title":"Examples","text":"<p>Here is a simple example of the checkbox opcode. It uses the file checkbox.csd.</p> Simple example of the checkbox opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc       ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o checkbox.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n  kq init 0\n  ; Get the value from the checkbox.\n  k1 checkbox 1\n\n  ; If the checkbox is selected then k2=440, otherwise k2=880.\n  k2 = (k1 == 0 ? 440 : 880)\n\n  a1 oscil 10000, k2, 1\n  outs a1, a1\n  kq button 1\n  schedkwhen kq, 0, 1, 2, 0, 0\nendin\n\ninstr 2\n  exitnow\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; sine wave.\nf 1 0 32768 10 1\n\ni 1 0 1000 \ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/checkbox/#see-also","title":"See also","text":"<p>Sensing and Control: TCL/TK widgets</p>"},{"location":"opcodes/checkbox/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK September, 2000</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 4.08</p>"},{"location":"opcodes/chn/","title":"Chn","text":""},{"location":"opcodes/chn/#chn","title":"chn","text":"<p>Declare a channel of the named software bus.</p> <p>Optional parameters can be set in the case of a control channel. If the channel does not exist yet, it is created, with an inital value of zero or empty string. Otherwise, the type (control, audio, or string) of the existing channel must match the declaration, or an init error occurs. The input/output mode of an existing channel is updated so that it becomes the bitwise OR of the previous and the newly specified value.</p>"},{"location":"opcodes/chn/#syntax","title":"Syntax","text":"<pre><code>chn_k Sname, imode[, itype, idflt, imin, ima, ix, iy, iwidth, iheight, Sattributes]\nchn_a Sname, imode\nchn_S Sname, imode\nchn_S Sname, Smode\nchn_array Sname, imode, Stype, iSizes[]\n</code></pre>"},{"location":"opcodes/chn/#initialization","title":"Initialization","text":"<p>imode -- sum of at least one of 1 for input and 2 for output.</p> <p>Smode -- The mode can also be set with a string: \"r\" for input, \"w\" for output or \"rw\" for input/output</p> <p>Stypes -- the array channel type (\"k\", \"a\", \"S\").</p> <p>iSizes[] -- the sizes for each dimension of the array channel.</p> <p>itype (optional, defaults to 0) -- channel subtype for control channels only. Possible values are:</p> <ul> <li>0: default/unspecified (idflt, imin, and imax are ignored)</li> <li>1: integer values only</li> <li>2: linear scale</li> <li>3: exponential scale</li> </ul> <p>idflt (optional, defaults to 0) -- default value, for control channels with non-zero itype only. Must be greater than or equal to imin, and less than or equal to imax.</p> <p>imin (optional, defaults to 0) -- minimum value, for control channels with non-zero itype only. Must be non-zero for exponential scale (itype = 3).</p> <p>imax (optional, defaults to 0) -- maximum value, for control channels with non-zero itype only. Must be greater than imin. In the case of exponential scale, it should also match the sign of imin.</p> <p>ix -- suggested x position for controller.</p> <p>iy -- suggested y position for controller.</p> <p>iwidth -- suggested width position for controller.</p> <p>iheight -- suggested height position for controller.</p> <p>Sattributes -- attributes for controller.</p>"},{"location":"opcodes/chn/#notes","title":"Notes","text":"<p>The channel parameters (imode, itype, idflt, imin, and imax) are only hints for the host application or external software accessing the bus through the API, and do not actually restrict reading from or writing to the channel in any way. Also, the initial value of a newly created control channel is zero, regardless of the setting of idflt.</p> <p>For communication with external software, using chnexport may be preferred, as it allows direct access to orchestra variables exported as channels of the bus, eliminating the need for using chnset and chnget to send or receive data.</p>"},{"location":"opcodes/chn/#performance","title":"Performance","text":"<p>chn_k, chn_a, and chn_S declare a control, audio, or string channel, respectively.</p>"},{"location":"opcodes/chn/#example","title":"Example","text":"<p>The example shows the software bus being used as an asynchronous control signal to select a filter cutoff.  It assumes that an external program that has access to the API is feeding the values.</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\nchn_k \"cutoff\", 1, 3, 1000, 500, 2000\n\ninstr   1\n    kc   chnget    \"cutoff\"\n    a1   oscil     p4, p5, 100\n    a2   lowpass2  a1, kc, 200\n         out       a2\nendin\n</code></pre>"},{"location":"opcodes/chn/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chn/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/chnclear/","title":"Chnclear","text":""},{"location":"opcodes/chnclear/#chnclear","title":"chnclear","text":"<p>Clears a number of audio output channel of the named software bus.</p> <p>Implies declaring the channel with imode=2 (see also chn_a).</p>"},{"location":"opcodes/chnclear/#syntax","title":"Syntax","text":"<pre><code>chnclear Sname1[, Sname2,...]\n</code></pre>"},{"location":"opcodes/chnclear/#initialization","title":"Initialization","text":"<p>Sname* -- a string that indicates which named channel of the software bus to clear.</p>"},{"location":"opcodes/chnclear/#examples","title":"Examples","text":"<p>Here is an example of the chnclear opcode. It uses the file chnclear.csd.</p> Example of the chnclear opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chnclear.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;Example by Joachim Heintz\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n  instr 1; send i-values\n          chnset    1, \"sio\"\n          chnset    -1, \"non\"\n  endin\n\n  instr 2; send k-values\nkfreq     randomi   100, 300, 1\n          chnset    kfreq, \"cntrfreq\"\nkbw       =         kfreq/10\n          chnset    kbw, \"bandw\"\n  endin\n\n  instr 3; send a-values\nanois     rand      .1\n          chnset    anois, \"noise\"\n loop:\nidur      random    .3, 1.5\n          timout    0, idur, do_\n          reinit    loop\n do_:\nifreq     random    400, 1200\niamp      random    .1, .3\nasig      oscils    iamp, ifreq, 0\naenv      transeg   1, idur, -10, 0\nasine     =         asig * aenv\n          chnset    asine, \"sine\"\n  endin\n\n  instr 11; receive some chn values and send again\nival1     chnget    \"sio\"\nival2     chnget    \"non\"\n          print     ival1, ival2\nkcntfreq  chnget    \"cntrfreq\"\nkbandw    chnget    \"bandw\"\nanoise    chnget    \"noise\"\nafilt     reson     anoise, kcntfreq, kbandw\nafilt     balance   afilt, anoise\n          chnset    afilt, \"filtered\"\n  endin\n\n  instr 12; mix the two audio signals\namix1     chnget     \"sine\"\namix2     chnget     \"filtered\"\n          chnmix     amix1, \"mix\"\n          chnmix     amix2, \"mix\"\n  endin\n\n  instr 20; receive and reverb\namix      chnget     \"mix\"\naL, aR    freeverb   amix, amix, .8, .5\n          outs       aL, aR\n  endin\n\n  instr 100; clear\n          chnclear   \"mix\"\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\ni 2 0 20\ni 3 0 20\ni 11 0 20\ni 12 0 20\ni 20 0 20\ni 100 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chnclear/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnclear/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2006</p>"},{"location":"opcodes/chnexport/","title":"Chnexport","text":""},{"location":"opcodes/chnexport/#chnexport","title":"chnexport","text":"<p>Export a global variable as a channel of the bus.</p> <p>The channel should not already exist, otherwise an init error occurs. This opcode is normally called from the orchestra header, and allows the host application to read or write orchestra variables directly, without having to use chnget or chnset to copy data.</p>"},{"location":"opcodes/chnexport/#syntax","title":"Syntax","text":"<pre><code>gival chnexport Sname, imode[, itype, idflt, imin, imax]\ngkval chnexport Sname, imode[, itype, idflt, imin, imax]\ngaval chnexport Sname, imode\ngSval chnexport Sname, imode\n</code></pre>"},{"location":"opcodes/chnexport/#initialization","title":"Initialization","text":"<p>imode -- sum of at least one of 1 for input and 2 for output.</p> <p>itype (optional, defaults to 0) -- channel subtype for control channels only. Possible values are:</p> <ul> <li>0: default/unspecified (idflt, imin, and imax are ignored)</li> <li>1: integer values only</li> <li>2: linear scale</li> <li>3: exponential scale</li> </ul> <p>idflt (optional, defaults to 0) -- default value, for control channels with non-zero itype only. Must be greater than or equal to imin, and less than or equal to imax.</p> <p>imin (optional, defaults to 0) -- minimum value, for control channels with non-zero itype only. Must be non-zero for exponential scale (itype = 3).</p> <p>imax (optional, defaults to 0) -- maximum value, for control channels with non-zero itype only. Must be greater than imin. In the case of exponential scale, it should also match the sign of imin.</p>"},{"location":"opcodes/chnexport/#notes","title":"Notes","text":"<p>The channel parameters (imode, itype, idflt, imin, and imax) are only hints for the host application or external software accessing the bus through the API, and do not actually restrict reading from or writing to the channel in any way.</p> <p>While the global variable is used as output argument, chnexport does not actually change it, and always runs at i-time only. If the variable is not previously declared, it is created by Csound with an initial value of zero or empty string.</p>"},{"location":"opcodes/chnexport/#example","title":"Example","text":"<p>The example shows the software bus being used as an asynchronous control signal to select a filter cutoff.  It assumes that an external program that has access to the API is feeding the values.</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\ngkc init 1000   ; set default value\ngkc chnexport \"cutoff\", 1, 3, i(gkc), 500, 2000\n\ninstr   1\n    a1   oscil     p4, p5, 100\n    a2   lowpass2  a1, gkc, 200\n         out       a2\nendin\n</code></pre>"},{"location":"opcodes/chnexport/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnexport/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/chnget/","title":"Chnget","text":""},{"location":"opcodes/chnget/#chnget","title":"chnget","text":"<p>Reads data from a channel of the inward named software bus.</p> <p>Implies declaring the channel with imode=1 (see also chn_k, chn_a, and chn_S).</p>"},{"location":"opcodes/chnget/#syntax","title":"Syntax","text":"<pre><code>ival chnget Sname\nkval chnget Sname\naval chnget Sname\nSval chnget Sname\nSval chngetks Sname\nival[] chngeti Sname[]\nkval[] chngetk Sname[]\naval[] chngeta Sname[]\nSval[] chngets Sname[]\n</code></pre>"},{"location":"opcodes/chnget/#initialization","title":"Initialization","text":"<p>Sname -- a string that identifies a channel of the named software bus to read.</p> <p>Sname[] -- an array of named software channels to query.</p> <p>ival -- the control value read at i-time.</p> <p>Sval -- the string value read at i-time.</p> <p>ival[] -- an array of control values read at i-time.</p> <p>Sval{} -- an array of strings read at i-time.</p>"},{"location":"opcodes/chnget/#performance","title":"Performance","text":"<p>kval -- the control value read at performance time.</p> <p>kval[] -- an array of control values read at performance time.</p> <p>aval -- the audio signal read at performance time.</p> <p>aval[] -- the array of audio vectors read at performance time.</p> <p>Sval -- the string value read at k-rate. The chnget opcode works both at i-time and perf-time, whereas chngetks works only at perf-time. String variables are only updated if the channel has changed.</p> <p> Note</p> <p>Although it is possible to loop through channel names from an array with chnget and chnset, using the array based variants is more efficient.</p>"},{"location":"opcodes/chnget/#example","title":"Example","text":"<p>The example shows the software bus being used as an asynchronous control signal to select a filter cutoff.  It assumes that an external program that has access to the API is feeding the values.</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\ninstr   1\n    kc   chnget    \"cutoff\"\n    a1   oscil     p4, p5, 100\n    a2   lowpass2  a1, kc, 200\n         out       a2\nendin\n</code></pre> <p>Here is another example of the chnget opcode. It uses the file chnget.csd.</p> Example of the chnget opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chnget.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;Example by Joachim Heintz\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n  instr 1; send i-values\n          chnset    1, \"sio\"\n          chnset    -1, \"non\"\n  endin\n\n  instr 2; send k-values\nkfreq     randomi   100, 300, 1\n          chnset    kfreq, \"cntrfreq\"\nkbw       =         kfreq/10\n          chnset    kbw, \"bandw\"\n  endin\n\n  instr 3; send a-values\nanois     rand      .1\n          chnset    anois, \"noise\"\n loop:\nidur      random    .3, 1.5\n          timout    0, idur, do_\n          reinit    loop\n do_:\nifreq     random    400, 1200\niamp      random    .1, .3\nasig      oscils    iamp, ifreq, 0\naenv      transeg   1, idur, -10, 0\nasine     =         asig * aenv\n          chnset    asine, \"sine\"\n  endin\n\n  instr 11; receive some chn values and send again\nival1     chnget    \"sio\"\nival2     chnget    \"non\"\n          print     ival1, ival2\nkcntfreq  chnget    \"cntrfreq\"\nkbandw    chnget    \"bandw\"\nanoise    chnget    \"noise\"\nafilt     reson     anoise, kcntfreq, kbandw\nafilt     balance   afilt, anoise\n          chnset    afilt, \"filtered\"\n  endin\n\n  instr 12; mix the two audio signals\namix1     chnget     \"sine\"\namix2     chnget     \"filtered\"\n          chnmix     amix1, \"mix\"\n          chnmix     amix2, \"mix\"\n  endin\n\n  instr 20; receive and reverb\namix      chnget     \"mix\"\naL, aR    freeverb   amix, amix, .8, .5\n          outs       aL, aR\n  endin\n\n  instr 100; clear\n          chnclear   \"mix\"\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\ni 2 0 20\ni 3 0 20\ni 11 0 20\ni 12 0 20\ni 20 0 20\ni 100 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chnget/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnget/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005 Array based channel opcodes added in version 6.14 - Rory Walsh</p>"},{"location":"opcodes/chnmix/","title":"Chnmix","text":""},{"location":"opcodes/chnmix/#chnmix","title":"chnmix","text":"<p>Writes audio data to the named software bus, mixing to the previous output.</p> <p>Implies declaring the channel with imode=2 (see also chn_a).</p>"},{"location":"opcodes/chnmix/#syntax","title":"Syntax","text":"<pre><code>chnmix aval, Sname\n</code></pre>"},{"location":"opcodes/chnmix/#initialization","title":"Initialization","text":"<p>Sname -- a string that indicates which named channel of the software bus to write.</p>"},{"location":"opcodes/chnmix/#performance","title":"Performance","text":"<p>aval -- the audio signal to write at performance time.</p>"},{"location":"opcodes/chnmix/#examples","title":"Examples","text":"<p>Here is an example of the chnmix opcode. It uses the file chnmix.csd.</p> Example of the chnmix opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chnmix.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;Example by Joachim Heintz\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n  instr 1; send i-values\n          chnset    1, \"sio\"\n          chnset    -1, \"non\"\n  endin\n\n  instr 2; send k-values\nkfreq     randomi   100, 300, 1\n          chnset    kfreq, \"cntrfreq\"\nkbw       =         kfreq/10\n          chnset    kbw, \"bandw\"\n  endin\n\n  instr 3; send a-values\nanois     rand      .1\n          chnset    anois, \"noise\"\n loop:\nidur      random    .3, 1.5\n          timout    0, idur, do_\n          reinit    loop\n do_:\nifreq     random    400, 1200\niamp      random    .1, .3\nasig      oscils    iamp, ifreq, 0\naenv      transeg   1, idur, -10, 0\nasine     =         asig * aenv\n          chnset    asine, \"sine\"\n  endin\n\n  instr 11; receive some chn values and send again\nival1     chnget    \"sio\"\nival2     chnget    \"non\"\n          print     ival1, ival2\nkcntfreq  chnget    \"cntrfreq\"\nkbandw    chnget    \"bandw\"\nanoise    chnget    \"noise\"\nafilt     reson     anoise, kcntfreq, kbandw\nafilt     balance   afilt, anoise\n          chnset    afilt, \"filtered\"\n  endin\n\n  instr 12; mix the two audio signals\namix1     chnget     \"sine\"\namix2     chnget     \"filtered\"\n          chnmix     amix1, \"mix\"\n          chnmix     amix2, \"mix\"\n  endin\n\n  instr 20; receive and reverb\namix      chnget     \"mix\"\naL, aR    freeverb   amix, amix, .8, .5\n          outs       aL, aR\n  endin\n\n  instr 100; clear\n          chnclear   \"mix\"\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\ni 2 0 20\ni 3 0 20\ni 11 0 20\ni 12 0 20\ni 20 0 20\ni 100 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chnmix/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnmix/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2006</p>"},{"location":"opcodes/chnparams/","title":"Chnparams","text":""},{"location":"opcodes/chnparams/#chnparams","title":"chnparams","text":"<p>Query parameters of a channel (if it does not exist, all returned values are zero).</p>"},{"location":"opcodes/chnparams/#syntax","title":"Syntax","text":"<pre><code>itype, imode, ictltype, idflt, imin, imax chnparams Sname\n</code></pre>"},{"location":"opcodes/chnparams/#initialization","title":"Initialization","text":"<p>itype -- channel data type (1: control, 2: audio, 3: string)</p> <p>imode -- sum of 1 for input and 2 for output</p> <p>ictltype -- special parameter for control channel only; if not available, set to zero.</p> <p>idflt -- special parameter for control channel only; if not available, set to zero.</p> <p>imin -- special parameter for control channel only; if not available, set to zero.</p> <p>imax -- special parameter for control channel only; if not available, set to zero.</p> <p>Sname -- string identifying the channel.</p>"},{"location":"opcodes/chnparams/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnparams/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/chnset/","title":"Chnset","text":""},{"location":"opcodes/chnset/#chnset","title":"chnset","text":"<p>Writes data to a channel of the named software bus.</p> <p>Implies declaring the channel with imod=2 (see also chn_k, chn_a, and chn_S).</p>"},{"location":"opcodes/chnset/#syntax","title":"Syntax","text":"<pre><code>chnset ival, Sname\nchnset kval, Sname\nchnset aval, Sname\nchnset Sval, Sname\nchnsetks Sval, Sname\nchnseti ival[], []Sname\nchnsetk kval[], []Sname\nchnseta aval[], []Sname\nchnsets Sval[], []Sname\n</code></pre>"},{"location":"opcodes/chnset/#initialization","title":"Initialization","text":"<p>Sname -- a string that indicates which named channel of the software bus to write.</p> <p>Sname[] -- an array of string that indicates which named channels of the software bus to write to.</p> <p>ival -- the control value to write at i-time.</p> <p>ival[] -- an array of control values to write at i-time.</p> <p>Sval -- the string value to write at i-time.</p> <p>Sval[] -- an array of string values to write at i-time.</p>"},{"location":"opcodes/chnset/#performance","title":"Performance","text":"<p>kval -- the control value to write at performance time.</p> <p>aval -- the audio signal to write at performance time.</p> <p>Sval -- the string value to write at perf-time. The opcode chnset with strings works at both i- and perf-time, whereas chnsetks works only a perf-time. Channel contents are only updated if the string variable is modified.</p> <p>kval[] -- an array of control values to write at performance time.</p> <p>aval[] -- an array of audio vectors to write at performance time.</p> <p> Note</p> <p>Although it is possible to loop through channel names from an array with chnget and chnset, using the array based channel opcodes is more efficient.</p>"},{"location":"opcodes/chnset/#example","title":"Example","text":"<p>The example shows the software bus being used to write pitch information to a controlling program.</p> <pre><code>sr = 44100\nkr = 100\nksmps = 1\n\ninstr   1\n    a1    in\n    kp,ka pitchamdf a1\n          chnset    kp, \"pitch\"\nendin\n</code></pre> <p>Here is another example of the chnset opcode. It uses the file chnset.csd.</p> Example of the chnset opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chnset.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;Example by Joachim Heintz\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n  instr 1; send i-values\n          chnset    1, \"sio\"\n          chnset    -1, \"non\"\n  endin\n\n  instr 2; send k-values\nkfreq     randomi   100, 300, 1\n          chnset    kfreq, \"cntrfreq\"\nkbw       =         kfreq/10\n          chnset    kbw, \"bandw\"\n  endin\n\n  instr 3; send a-values\nanois     rand      .1\n          chnset    anois, \"noise\"\n loop:\nidur      random    .3, 1.5\n          timout    0, idur, do_\n          reinit    loop\n do_:\nifreq     random    400, 1200\niamp      random    .1, .3\nasig      oscils    iamp, ifreq, 0\naenv      transeg   1, idur, -10, 0\nasine     =         asig * aenv\n          chnset    asine, \"sine\"\n  endin\n\n  instr 11; receive some chn values and send again\nival1     chnget    \"sio\"\nival2     chnget    \"non\"\n          print     ival1, ival2\nkcntfreq  chnget    \"cntrfreq\"\nkbandw    chnget    \"bandw\"\nanoise    chnget    \"noise\"\nafilt     reson     anoise, kcntfreq, kbandw\nafilt     balance   afilt, anoise\n          chnset    afilt, \"filtered\"\n  endin\n\n  instr 12; mix the two audio signals\namix1     chnget     \"sine\"\namix2     chnget     \"filtered\"\n          chnmix     amix1, \"mix\"\n          chnmix     amix2, \"mix\"\n  endin\n\n  instr 20; receive and reverb\namix      chnget     \"mix\"\naL, aR    freeverb   amix, amix, .8, .5\n          outs       aL, aR\n  endin\n\n  instr 100; clear\n          chnclear   \"mix\"\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\ni 2 0 20\ni 3 0 20\ni 11 0 20\ni 12 0 20\ni 20 0 20\ni 100 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chnset/#see-also","title":"See also","text":"<p>Software Bus</p>"},{"location":"opcodes/chnset/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005 Array based channel opcodes added in version 6.14 - Rory Walsh</p>"},{"location":"opcodes/chuap/","title":"Chuap","text":""},{"location":"opcodes/chuap/#chuap","title":"chuap","text":"<p>Simulates Chua's oscillator, an LRC oscillator with an active resistor, proved capable of bifurcation and chaotic attractors, with k-rate control of circuit elements.</p> <p>Plugin opcode in chua. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>Simulates Chua's oscillator, an LRC oscillator with an active resistor, proved capable of bifurcation and chaotic attractors, with k-rate control of circuit elements.</p>"},{"location":"opcodes/chuap/#syntax","title":"Syntax","text":"<pre><code>aI3, aV2, aV1 chuap kL, kR0, kC2, kG, kGa, kGb, kE, kC1, iI3, iV2, iV1, ktime_step\n</code></pre>"},{"location":"opcodes/chuap/#initialization","title":"Initialization","text":"<p>iI3 -- Initial current at G</p> <p>iV2 -- Initial voltage at C2</p> <p>iV1 -- Initial voltage at C1</p>"},{"location":"opcodes/chuap/#performance","title":"Performance","text":"<p>kL -- Inductor L (L1 in the diagram)</p> <p>kR0 -- Resistor R0 (R0 in the diagram)</p> <p>kC1 -- Capacitor C1</p> <p>kC2 -- Capacitor C2</p> <p>kG -- Resistor G (part of the active resistor, R1 in the diagram). The G parameter is the time step, which is needed to get the same slope of the piecewise discontinuity from Ga and Gb for all sampling rates.</p> <p>kGa -- Resistor V (nonlinearity term of the active resistor, one of the R2's in the diagram)</p> <p>kGb -- Resistor V (nonlinearity term of the active resistor, one of the R2's in the diagram)</p> <p>kE -- Size of the piecewise discontinuity simulating the active resistor</p> <p>ktime_step -- Delta time in the difference equation, can be used to more or less control pitch.</p> <p>Chua's oscillator is a simple LRC oscillator with an active resistor. The oscillator can be driven into period bifurcation, and thus to chaos, because of the nonlinear response of the active resistor.</p> Diagram of Chua's Oscillator Circuit <p>The circuit is described by a set of three ordinary differential equations called Chua's equations:</p> <pre><code>dI3      R0      1\n--- =  - -- I3 - - V2\ndt       L       L\n\ndV2    1       G\n--- = -- I3 - -- (V2 - V1)\ndt    C2      C2\n\ndV1    G              1\n--- = -- (V2 - V1) - -- f(V1)\ndt    C1             C1\n</code></pre> <p>where f() is a piecewise discontinuity simulating the active resistor:</p> <pre><code>f(V1) = Gb V1 + - (Ga - Gb)(|V1 + E| - |V1 - E|)\n</code></pre> <p>A solution of these equations (I3,V2,V1)(t) starting from an initial state (I3,V2,V1)(0) is called a trajectory of Chua's oscillator. The Csound implementation is a difference equation simulation of Chua's oscillator with Runge-Kutta integration.</p> <p> Note</p> <p>This algorithm uses internal non linear feedback loops which causes audio result to depend on the orchestra sampling rate. For example, if you develop a project with sr=48000Hz and if you want to produce an audio CD from it, you should record a file with sr=48000Hz and then downsample the file to 44100Hz using the src_conv utility.</p> <p> Warning</p> <p>Be careful! Some sets of parameters will produce amplitude spikes or positive feedback that could damage your speakers.</p>"},{"location":"opcodes/chuap/#examples","title":"Examples","text":"<p>Here is an example of the chuap opcode. It uses the file chuap.csd.</p> Example of the chuap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o chuap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ngibuzztable ftgen 1, 0, 16384, 10, 1\n\ninstr 1 \n\n    istep_size    =       p4\n    iL            =       p5\n    iR0           =       p6\n    iC2           =       p7\n    iG            =       p8\n    iGa           =       p9\n    iGb           =       p10\n    iE            =       p11\n    iC1           =       p12\n    iI3           =       p13\n    iV2           =       p14\n    iV1           =       p15\n\n    iattack       =       0.02\n    isustain      =       p3\n    irelease      =       0.02\n    p3            =       iattack + isustain + irelease\n    iscale        =       1.0\n    adamping      linseg  0.0, iattack, iscale, isustain, iscale, irelease, 0.0\n    aguide        buzz    0.5, 440, sr/440, gibuzztable\n    aI3, aV2, aV1 chuap   iL, iR0, iC2, iG, iGa, iGb, iE, iC1, iI3, iV2, iV1, istep_size \n    asignal       balance aV2, aguide\n\n    outs asignal*adamping, asignal*adamping\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt; \n;        Adapted from ABC++ MATLAB example data.\n//             time_step      kL           kR0         kC2              kG            kGa           kGb          kE          kC1           iI3                     iV2                     iV1\n; torus attractor ( gallery of attractors ) \ni 1 0 20       .1            -0.00707925   0.00001647  100              1             -.99955324    -1.00028375  1          -.00222159     -2.36201596260071       3.08917625807226e-03    3.87075614929199   \n; heteroclinic orbit\ni 1 + 20       .425           1.3506168    0           -4.50746268737  -1             2.4924        .93          1           1             -22.28662665            .009506608              -22.2861576            \n; periodic attractor (torus breakdown route)\ni 1 + 20       .05            0.00667      0.000651    10              -1             .856          1.1          1           .06           -20.200590133667        .172539323568344        -4.07686233520508      \n; torus attractor (torus breakdown route)'\ni 1 + 20       0.05           0.00667      0.000651    10              -1             0.856         1.1          1           0.1            21.12496758             0.03001749              0.515828669            \n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/chuap/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/chuap/#credits","title":"Credits","text":"<p>Inventor of Chua's oscillator: Leon O. Chua Author of MATLAB simulation: James Patrick McEvoy MATLAB Adventures in Bifurcations and Chaos (ABC++) Author of Csound port: Michael Gogins</p> <p>New in Csound version 5.09</p> <p>Note added by Fran\u00e7ois Pinot, August 2009</p>"},{"location":"opcodes/cigoto/","title":"Cigoto","text":""},{"location":"opcodes/cigoto/#cigoto","title":"cigoto","text":"<p>During the i-time pass only, conditionally transfer control to the statement labeled by label.</p>"},{"location":"opcodes/cigoto/#syntax","title":"Syntax","text":"<pre><code>cigoto condition, label\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where condition uses one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p>"},{"location":"opcodes/cigoto/#examples","title":"Examples","text":"<p>Here is an example of the cigoto opcode. It uses the file cigoto.csd.</p> Example of the cigoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cigoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the value of the 4th p-field from the score.\n  iparam = p4\n\n  ; If iparam is 1 then play the high note.\n  ; If not then play the low note.\n  cigoto (iparam ==1), highnote\n    igoto lownote\n\nhighnote:\n  ifreq = 880\n  goto playit\n\nlownote:\n  ifreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of iparam and ifreq.\n  print iparam\n  print ifreq\n\n  a1 oscil 10000, ifreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; p4: 1 = high note, anything else = low note\n; Play Instrument #1 for one second, a low note.\ni 1 0 1 0\n; Play a Instrument #1 for one second, a high note.\ni 1 1 1 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iparam = 0.000\ninstr 1:  ifreq = 440.000\ninstr 1:  iparam = 1.000\ninstr 1:  ifreq = 880.000\n</code></pre>"},{"location":"opcodes/cigoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/cigoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/ckgoto/","title":"Ckgoto","text":""},{"location":"opcodes/ckgoto/#ckgoto","title":"ckgoto","text":"<p>During the p-time passes only, conditionally transfer control to the statement labeled by label.</p>"},{"location":"opcodes/ckgoto/#syntax","title":"Syntax","text":"<pre><code>ckgoto condition, label\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where condition uses one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p>"},{"location":"opcodes/ckgoto/#examples","title":"Examples","text":"<p>Here is an example of the ckgoto opcode. It uses the file ckgoto.csd.</p> Example of the ckgoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ckgoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change kval linearly from 0 to 2 over\n  ; the period set by the third p-field.\n  kval line 0, p3, 2\n\n  ; If kval is greater than or equal to 1 then play the high note.\n  ; If not then play the low note.\n  ckgoto (kval &gt;= 1), highnote\n    kgoto lownote\n\nhighnote:\n  kfreq = 880\n  goto playit\n\nlownote:\n  kfreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of kval and kfreq.\n  printks \"kval = %f, kfreq = %f\\\\n\", 1, kval, kfreq\n\n  a1 oscil 10000, kfreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>kval = 0.000000, kfreq = 440.000000\nkval = 0.999732, kfreq = 440.000000\nkval = 1.999639, kfreq = 880.000000\n</code></pre>"},{"location":"opcodes/ckgoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/ckgoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/clear/","title":"Clear","text":""},{"location":"opcodes/clear/#clear","title":"clear","text":"<p>Zeroes a list of audio signals.</p>"},{"location":"opcodes/clear/#syntax","title":"Syntax","text":"<pre><code>clear avar1 [, avar2] [, avar3] [...]\nclear avar[]\n</code></pre>"},{"location":"opcodes/clear/#performance","title":"Performance","text":"<p>avar1, avar2, avar3, ... -- signals to be zeroed</p> <p>avar[] -- array of signals to be cleared.</p> <p>kvar[] ... -- array of k-values to be cleared.</p> <p> Note</p> <p>Before version 6.13 this opcode was not compatible with multicore operations if used with a global variable.</p> <p>clear sets every sample of each of the given audio signals to zero when it is performed.  This is equivalent to writing avarN = 0 in the orchestra for each of the specified variables.  Typically, clear is used with global variables that combine multiple signals from different sources and change with each k-pass (performance loop) through all of the active instrument instances.  After the final usage of such a variable and before the next k-pass, it is necessary to clear the variable so that it does not add the next cycle's signals to the previous result.  clear is especially useful in combination with vincr (variable increment) and they are intended to be used together with file output opcodes such as fout.</p>"},{"location":"opcodes/clear/#examples","title":"Examples","text":"<p>Here is an example of the clear opcode. It uses the file clear.csd.</p> Example of the clear opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o clear.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngaReverb init 0\n\ninstr 1\n\nidur    =       p3\nkpitch  =       p4\na1      diskin2 \"fox.wav\", kpitch\na1      =       a1*.5                   ;reduce volume\n        vincr   gaReverb, a1\nendin\n\ninstr 99 ; global reverb                \nal, ar  reverbsc gaReverb, gaReverb, .8, 10000\n        outs    gaReverb+al, gaReverb+ar\n        clear   gaReverb\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1  0 3 1\ni99 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>See the fout opcode for another example.</p>"},{"location":"opcodes/clear/#see-also","title":"See also","text":"<p>File Input and Output</p> <p>Comparators and Accumulators</p>"},{"location":"opcodes/clear/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999 Author: Victor Lazzarini</p> <p>New in Csound version 3.56</p> <p>Revised in Csound version 6.17 for arrays</p>"},{"location":"opcodes/clfilt/","title":"Clfilt","text":""},{"location":"opcodes/clfilt/#clfilt","title":"clfilt","text":"<p>Implements the classical standard analog filter types: low-pass and high-pass.</p> <p>They are implemented with the four classical kinds of filters: Butterworth, Chebyshev Type I, Chebyshev Type II, and Elliptical.  The number of poles may be any even number from 2 to 80.</p>"},{"location":"opcodes/clfilt/#syntax","title":"Syntax","text":"<pre><code>ares clfilt asig, kfreq, itype, inpol [, ikind] [, ipbr] [, isba] [, iskip]\n</code></pre>"},{"location":"opcodes/clfilt/#initialization","title":"Initialization","text":"<p>itype -- 0 for low-pass, 1 for high-pass.</p> <p>inpol -- The number of poles in the filter. It must be an even number from 2 to 80.</p> <p>ikind (optional) -- 0 for Butterworth, 1 for Chebyshev Type I, 2 for Chebyshev Type II, 3 for Elliptical. Defaults to 0 (Butterworth)</p> <p>ipbr (optional) -- The pass-band ripple in dB. Must be greater than 0. It is ignored by Butterworth and Chebyshev Type II. The default is 1 dB.</p> <p>isba (optional) -- The stop-band attenuation in dB. Must be less than 0. It is ignored by Butterworth and Chebyshev Type I. The default is -60 dB.</p> <p>iskip (optional) --  0 initializes all filter internal states to 0. 1 skips initialization. The default is 0.</p>"},{"location":"opcodes/clfilt/#performance","title":"Performance","text":"<p>asig -- The input audio signal.</p> <p>kfreq -- The corner frequency for low-pass or high-pass.</p>"},{"location":"opcodes/clfilt/#examples","title":"Examples","text":"<p>Here is an example of the clfilt opcode as a low-pass filter. It uses the file clfilt_lowpass.csd.</p> Example of the clfilt opcode as a low-pass filter.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o clfilt_lowpass.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; white noise\n\nasig rand 0.5\nouts asig, asig\n\nendin\n\ninstr 2 ; filtered noise \n\nasig rand 0.9\n; Lowpass filter signal asig with a \n; 10-pole Butterworth at 500 Hz.\na1 clfilt asig, 500, 0, 10\n   outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the clfilt opcode as a high-pass filter. It uses the file clfilt_highpass.csd.</p> Example of the clfilt opcode as a high-pass filter.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o clfilt_highpass.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; white noise\n\nasig rand 0.6\n     outs asig, asig\n\nendin\n\ninstr 2 ;filtered noise\n\nasig rand 0.7\n; Highpass filter signal asig with a 6-pole Chebyshev\n; Type I at 20 Hz with 3 dB of passband ripple.\na1 clfilt asig, 20, 1, 6, 1, 3\n   outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/clfilt/#see-also","title":"See also","text":"<p>Standard filters: General filters</p>"},{"location":"opcodes/clfilt/#credits","title":"Credits","text":"<p>Author: Erik Spjut</p> <p>New in version 4.20</p>"},{"location":"opcodes/clip/","title":"Clip","text":""},{"location":"opcodes/clip/#clip","title":"clip","text":"<p>Clips an a-rate signal to a predefined limit, in a \u201csoft\u201d manner, using one of three methods.</p>"},{"location":"opcodes/clip/#syntax","title":"Syntax","text":"<pre><code>ares clip asig, imeth, ilimit [, iarg]\n</code></pre>"},{"location":"opcodes/clip/#initialization","title":"Initialization","text":"<p>imeth -- selects the clipping method. The default is 0. The methods are:</p> <ul> <li>0 = Bram de Jong method (default)</li> <li>1 = sine clipping</li> <li>2 = tanh clipping</li> </ul> <p>ilimit -- limiting value</p> <p>iarg (optional, default=0.5) -- when imeth = 0, indicates the point at which clipping starts, in the range 0 - 1. Not used when imeth = 1 or imeth = 2. Default is 0.5.</p>"},{"location":"opcodes/clip/#performance","title":"Performance","text":"<p>asig -- a-rate input signal</p> <p>The Bram de Jong method (imeth = 0) applies the algorithm (denoting ilimit as limit and iarg as a):</p> \\[ |x| \\ge 0 \\: \\mathrm{and} \\: |x| \\le (limit \\times a):  f(x) = f(x) \\] \\[ |x| \\gt (limit \\times a) \\: \\mathrm{and} \\: |x| \\le limit:  f(x) = sign(x) \\times (limit \\times a+ \\frac{x - limit \\times a}{1 + ((x-limit \\times a)/(limit \\times (1-a)))^2}) \\] \\[ |x| \\gt limit:  f(x) = sign(x) \\times \\frac{(limit\\times(1+a))}{2} \\] <p>The second method (imeth = 1) is the sine clip:</p> \\[ |x| \\lt limit:  f(x) = limit \\times sin(\\pi x/(2 \\times limit)), \\;  |x| \\ge limit:  f(x) = limit \\times sign(x) \\] <p>The third method (imeth = 2) is the tanh clip:</p> \\[ |x| \\lt limit:  f(x) = limit \\times tanh(x/limit)/tanh(1), \\;  |x| \\ge limit:  f(x) = limit \\times sign(x) \\] <p> Note</p> <p>Method 1 appears to be non-functional at release of Csound version 4.07.</p>"},{"location":"opcodes/clip/#examples","title":"Examples","text":"<p>Here is an example of the clip opcode. It uses the file clip.csd.</p> Example of the clip opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o clip.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; white noise\n\narnd rand 1     ; full amlitude\n; Clip the noisy waveform's amplitude to 0.5\na1 clip arnd, p4, 0.5\n   outs a1, a1\n\nendin\n\ninstr 2 ; white noise\n\narnd rand 1     ; full amlitude\n; Clip the noisy waveform's amplitude to 0.1\na1 clip arnd, p4, 0.1\n   outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1 2\n; Play Instrument #2 for one second.\ni 2 1 1 2\ns 3\n; Play Instrument #1 for one second.\ni 1 0 1 0\n; Play Instrument #2 for one second.\ni 2 1 1 0\ns 3\n; Play Instrument #1 for one second.\ni 1 0 1 1\n; Play Instrument #2 for one second.\ni 2 1 1 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/clip/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p> <p>Waveshaping</p>"},{"location":"opcodes/clip/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK August, 2000</p> <p>New in Csound version 4.07</p> <p>September 2009: Thanks to a note from Paolo Dell'Osso, corrected the formula.</p>"},{"location":"opcodes/clockoff/","title":"Clockoff","text":""},{"location":"opcodes/clockoff/#clockoff","title":"clockoff","text":"<p>Stops one of a number of internal clocks.</p>"},{"location":"opcodes/clockoff/#syntax","title":"Syntax","text":"<pre><code>clockoff inum\n</code></pre>"},{"location":"opcodes/clockoff/#initialization","title":"Initialization","text":"<p>inum -- the number of a clock.  There are 32 clocks numbered 0 through 31. All other values are mapped to clock number 32.</p>"},{"location":"opcodes/clockoff/#performance","title":"Performance","text":"<p>Between a clockon and a clockoff opcode, the CPU time used is accumulated in the clock.  The precision is machine dependent but is the millisecond range on UNIX and Windows systems. The readclock opcode reads the current value of a clock at initialization time.</p>"},{"location":"opcodes/clockoff/#examples","title":"Examples","text":"<p>Here is an example of the clockoff opcode. It uses the file clockoff.csd.</p> Example of the clockoff opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o clockoff.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Start clock #1.\n  clockon 1\n  ; Do something that keeps Csound busy.\n  a1 oscili 10000, 440, 1\n  out a1\n  ; Stop clock #1.\n  clockoff 1\n  ; Print the time accumulated in clock #1.\n  i1 readclock 1\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Initialize the function tables.\n; Table 1: an ordinary sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for one second starting at 0:00.\ni 1 0 1\n; Play Instrument #1 for one second starting at 0:01.\ni 1 1 1\n; Play Instrument #1 for one second starting at 0:02.\ni 1 2 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/clockoff/#see-also","title":"See also","text":"<p>Clock Control</p>"},{"location":"opcodes/clockoff/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK July, 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/clockon/","title":"Clockon","text":""},{"location":"opcodes/clockon/#clockon","title":"clockon","text":"<p>Starts one of a number of internal clocks.</p>"},{"location":"opcodes/clockon/#syntax","title":"Syntax","text":"<pre><code>clockon inum\n</code></pre>"},{"location":"opcodes/clockon/#initialization","title":"Initialization","text":"<p>inum -- the number of a clock.  There are 32 clocks numbered 0 through 31. All other values are mapped to clock number 32.</p>"},{"location":"opcodes/clockon/#performance","title":"Performance","text":"<p>Between a clockon and a clockoff opcode, the CPU time used is accumulated in the clock. The precision is machine dependent but is the millisecond range on UNIX and Windows systems. The readclock opcode reads the current value of a clock at initialization time.</p>"},{"location":"opcodes/clockon/#examples","title":"Examples","text":"<p>Here is an example of the clockon opcode. It uses the file clockon.csd.</p> Example of the clockon opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o clockon.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Start clock #1.\n  clockon 1\n  ; Do something that keeps Csound busy.\n  a1 oscili 10000, 440, 1\n  out a1\n  ; Stop clock #1.\n  clockoff 1\n  ; Print the time accumulated in clock #1.\n  i1 readclock 1\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Initialize the function tables.\n; Table 1: an ordinary sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for one second starting at 0:00.\ni 1 0 1\n; Play Instrument #1 for one second starting at 0:01.\ni 1 1 1\n; Play Instrument #1 for one second starting at 0:02.\ni 1 2 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/clockon/#see-also","title":"See also","text":"<p>Clock Control</p>"},{"location":"opcodes/clockon/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK July, 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/cmp/","title":"Cmp","text":""},{"location":"opcodes/cmp/#cmp","title":"cmp","text":"<p>Compares audio signals or arrays</p> <p>Plugin opcode in emugens.</p> <p>Compares audio signals or arrays, sample by sample or value by value. All comparison operations are possible: &lt;, &lt;=, &gt;, &gt;=, ==, !=</p> <p>An audio signal can be compared against another audio signal, or against a scalar (i- or k-value).</p> <pre><code>aOut cmp aL, \"&gt;\", aR\naOut cmp aIn, \"&gt;=\", 0.5\naOut cmp aIn, \"&lt;=\", kthreshold\n</code></pre> <p>An array can be compared against another array, against a scalar, or checked to be within the range of two scalars. All operations are available for i- and k- arrays</p> <pre><code>kOut[] cmp kIn[], \"&gt;=\", kx\nkOut[] cmp kA[], \"==\", kB[]\nkOut[] cmp 0.5, \"&lt;\", kIn[], \"&lt;=\", 1\n</code></pre>"},{"location":"opcodes/cmp/#syntax","title":"Syntax","text":"<pre><code>aout cmp a1, S_operator, a2\naout cmp a1, S_operator, kb\nkOut[] cmp kA[], S_operator, kb\nkOut[] cmp kA[], S_operator, kB[]\nkOut[] cmp k1, S_operator1, kIn[], S_operator2, k2\n</code></pre>"},{"location":"opcodes/cmp/#initialization","title":"Initialization","text":"<p>S_operator -- Math operator, one of \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\", \"==\"</p>"},{"location":"opcodes/cmp/#performance","title":"Performance","text":"<p>a1 / a2 -- Input signals</p> <p>kb / ib -- Scalar term</p> <p>kA[] / kB[] -- array inputs</p> <p>Some example usages:</p> <pre><code>aout cmp aL, \"&gt;\", aR      ; aout = aL &gt; aR for every sample\naout cmp aL, \"&gt;=\", aR\naout cmp aL, \"&lt;\", aR\naout cmp aL, \"&lt;\", aR\naout cmp aL, \"==\", aR\nkOut[] cmp kA, \"&gt;=\", kb   ; kA is an array\n</code></pre>"},{"location":"opcodes/cmp/#examples","title":"Examples","text":"<p>Here is an example of the cmp opcode. It uses the file cmp.csd.</p> Example of the cmp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 5\n0dbfs = 1.0\n\n; this is the example file for 'cmp'\n\n/*\n\ncmp\n\ncompare audio or arrays, value by value\n\nAudio:\n  * compare audio signals, sample by sample, against another signal or scalar\n  * compara audio singal, sample by sample, within a range:\n    aout cmp klo, \"&lt;\", ain, \"&lt;=\", khi\n\nArrays:\n  * compare arrays value by value or against a scalar\n  * compare array value by value within a range:\n    kout[] = klo &lt; kin[] &lt;= khi   -&gt;   kout[] cmp klo, \"&lt;\", kin[], \"&lt;=\", khi\n\naout cmp a1, Sop, a2                 : aout cmp ain, \"&lt;\", acmp\naout cmp a1, Sop, kval               : aout cmp ain, \"&gt;=\", 0.1\nkout[] cmp k1[], Sop, k2[]           : kout[] cmp kxs, \"&lt;\", kys\niout[] cmp i1[], Sop, i2[]           : iout[] cmp ixs, \"&lt;\", iys\nkout[] cmp k1[], Sop, k              : kout[] cmp kxs, \"&lt;\", 0.5\niout[] cmp i1[], Sop, i              : iout[] cmp ixs, \"&lt;\", 0.5\nkout[] cmp klo, Sop, kx[], Sop, khi  : kout[] cmp 0, \"&lt;\", kxs, \"&lt;=\", 1\niout[] cmp ilo, Sop, ix[], Sop, ihi  : iout[] cmp 0, \"&lt;\", ixs, \"&lt;=\", 1\n\nTODO: implement array operations for multidim. arrays\n      (at the time, array operations work only for 1D-arrays)\n\n*/\n\n; for audio operations, render this to a soundfile and open in an editor\n; to check the results\n\ninstr 1\n  a0 linseg 0, p3, 1\n  a1 linseg 1, p3, 0\n  aout1 cmp a0, \"&lt;\", a1\n  aout2 cmp a0, \"&lt;=\", 0.5\n  aout3 cmp a0, \"&gt;\", 0.5\n  outch 1, a0\n  outch 2, a1\n  outch 3, aout1\n  outch 4, aout2\n  outch 5, aout3\nendin\n\ninstr 4\n  ; cmp with arrays\n  ixs[] fillarray 0, 1, 2, 3, 4, 5\n  iys[] cmp ixs, \"&gt;=\", 3\n  printarray iys, \"\", \"instr 4, iys\"\n\n  kxs[] fillarray 0, 1, 2, 3, 4, 5\n  kys[] cmp kxs, \"&gt;=\", 3\n  printarray kys, 1, \"\", \"instr 4, kys\"\n  turnoff\nendin\n\ninstr 5\n  ; range\n  ixs[] fillarray 0, 1, 2, 3, 4, 5\n  iys[] cmp 1, \"&lt;\", ixs, \"&lt;=\", 4\n  printarray iys, \"\", \"instr 5, iys\"\n\n  kxs[] fillarray 0, 1, 2, 3, 4, 5\n  kys[] cmp 1, \"&lt;\", kxs, \"&lt;=\", 4\n  printarray kys, 1, \"\", \"instr 5, kys\"\n  turnoff\nendin\n\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 2\ni 4 0 1\ni 5 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cmp/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p> <p>Comparators and Accumulators</p> <p>Array opcodes</p>"},{"location":"opcodes/cmp/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/cngoto/","title":"Cngoto","text":""},{"location":"opcodes/cngoto/#cngoto","title":"cngoto","text":"<p>Transfers control on every pass when the condition is not true.</p>"},{"location":"opcodes/cngoto/#syntax","title":"Syntax","text":"<pre><code>cngoto condition, label\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where condition uses one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p>"},{"location":"opcodes/cngoto/#examples","title":"Examples","text":"<p>Here is an example of the cngoto opcode. It uses the file cngoto.csd.</p> Example of the cngoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; -o cngoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change kval linearly from 0 to 2 over\n  ; the period set by the third p-field.\n  kval line 0, p3, 2\n\n  ; If kval *is not* greater than or equal to 1 then play\n  ; the high note. Otherwise, play the low note.\n  cngoto (kval &gt;= 1), highnote\n    kgoto lownote\n\nhighnote:\n  kfreq = 880\n  goto playit\n\nlownote:\n  kfreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of kval and kfreq.\n  printks \"kval = %f, kfreq = %f\\\\n\", 1, kval, kfreq\n\n  a1 oscil 10000, kfreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>kval = 0.000000, kfreq = 880.000000\nkval = 0.999732, kfreq = 880.000000\nkval = 1.999639, kfreq = 440.000000\n</code></pre>"},{"location":"opcodes/cngoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/cngoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p> <p>New in version 4.21</p>"},{"location":"opcodes/cntDelete/","title":"cntDelete","text":""},{"location":"opcodes/cntDelete/#cntdelete","title":"cntDelete","text":"<p>Delete a counter and render any memory used.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntDelete/#syntax","title":"Syntax","text":"<pre><code>kval cntDelete icnt\n</code></pre>"},{"location":"opcodes/cntDelete/#initialization","title":"Initialization","text":"<p>icnt -- the handle of a counter object from a call to cntCreate.</p>"},{"location":"opcodes/cntDelete/#performance","title":"Performance","text":"<p>kval -- the handle deleted or a negative number if there was no such counter.</p>"},{"location":"opcodes/cntDelete/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntDelete/#credits","title":"Credits","text":"<p>By: John ffitch August 2020</p> <p>New in version 6.16</p>"},{"location":"opcodes/cntDelete_i/","title":"cntDelete i","text":""},{"location":"opcodes/cntDelete_i/#cntdelete_i","title":"cntDelete_i","text":"<p>Delete a counter.</p> <p>Plugin opcode in counter and render any memory used.</p>"},{"location":"opcodes/cntDelete_i/#syntax","title":"Syntax","text":"<pre><code>ival cntDelete_i icnt\n</code></pre>"},{"location":"opcodes/cntDelete_i/#initialization","title":"Initialization","text":"<p>icnt -- the handle of a counter object from a call to cntCreate.</p>"},{"location":"opcodes/cntDelete_i/#performance","title":"Performance","text":"<p>ival -- the handle deleted or a negative number if there was no such counter.</p>"},{"location":"opcodes/cntDelete_i/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntDelete_i/#credits","title":"Credits","text":"<p>By: John ffitch August 2020</p> <p>New in version 6.16</p>"},{"location":"opcodes/cntcreate/","title":"Cntcreate","text":""},{"location":"opcodes/cntcreate/#cntcreate","title":"cntCreate","text":"<p>Create a counter object.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntcreate/#syntax","title":"Syntax","text":"<pre><code>icnt cntCreate [imax, imin, inc]\n</code></pre>"},{"location":"opcodes/cntcreate/#initialization","title":"Initialization","text":"<p>imax -- optional maximum value for the counter, defaulting to 1.</p> <p>imin -- optional minimun value for the counter, defaulting to 0.</p> <p>inc -- optional increment for the counter, defaulting to 1.</p> <p>icnt -- a handle for the counter.</p>"},{"location":"opcodes/cntcreate/#performance","title":"Performance","text":"<p>Creates a counter object which loops between imin and imax in steps of inc.  Used without an argument, using the defaults creates a flip-flop.</p>"},{"location":"opcodes/cntcreate/#examples","title":"Examples","text":"<p>Here is an example of the cndCreate opcode. It uses the file counter.csd.</p> Example of the cntCreate opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -Mhw:1,0,0\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n gicnt cntCreate 1     ; a toggle\n gicntNote cntCreate 1 ; ignore note-off message to turn MIDI notes into toggles\n\n\ninstr 1\n\nkkey sensekey\n\ninote notnum\n\nif (kkey == 97) then\n k1 count gicnt\n if k1==0 then\n  event \"i\", 2, 0, -1\n else\n  event \"d\", 2, 0, -1\n endif\nendif\n\nprint  inote\nif (inote == 60) then\n i2 count_i gicntNote\n print i2\n if i2==0 then\n  event_i \"i\", 3, 0, -1\n else\n  event_i \"d\", 3, 0, -1\n endif\nendif\nendin\n\ninstr 2\nasig oscil 10000, 440\nout asig\nendin\n\ninstr 3\nasig oscil 5000, 880\nout asig\nendin\n\n&lt;/CsInstruments&gt;\n\n\n&lt;CsScore&gt;\ni1 0 z\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the cntCreate opcode: NervousHappyBirthday_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/cntcreate/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntcreate/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/cntcycles/","title":"Cntcycles","text":""},{"location":"opcodes/cntcycles/#cntcycles","title":"cntCycles","text":"<p>Get the number of times a counter has cycled.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntcycles/#syntax","title":"Syntax","text":"<pre><code>kval cntCycles icnt\n</code></pre>"},{"location":"opcodes/cntcycles/#initialization","title":"Initialization","text":"<p>icnt -- the handle of a counter object from a call to cntCreate.</p>"},{"location":"opcodes/cntcycles/#performance","title":"Performance","text":"<p>Counts the number of times a counter has been restarted.</p> <p>kval -- returned value.</p>"},{"location":"opcodes/cntcycles/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntcycles/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/cntread/","title":"Cntread","text":""},{"location":"opcodes/cntread/#cntread","title":"cntRead","text":"<p>Read current value of a counter object without changing it.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntread/#syntax","title":"Syntax","text":"<pre><code>kval cntRead icnt\n</code></pre>"},{"location":"opcodes/cntread/#initialization","title":"Initialization","text":"<p>icnt -- a handle for the counter.</p>"},{"location":"opcodes/cntread/#performance","title":"Performance","text":"<p>Reads a counter object.</p>"},{"location":"opcodes/cntread/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntread/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/cntreset/","title":"Cntreset","text":""},{"location":"opcodes/cntreset/#cntreset","title":"cntReset","text":"<p>Resets a counter object to its initial state.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntreset/#syntax","title":"Syntax","text":"<pre><code>cntReset icnt\n</code></pre>"},{"location":"opcodes/cntreset/#initialization","title":"Initialization","text":"<p>icnt -- a handle for the counter.</p>"},{"location":"opcodes/cntreset/#performance","title":"Performance","text":"<p>Resets a counter object.</p>"},{"location":"opcodes/cntreset/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntreset/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/cntstate/","title":"Cntstate","text":""},{"location":"opcodes/cntstate/#cntstate","title":"cntState","text":"<p>Gives the range and increment of a counter.</p> <p>Plugin opcode in counter.</p>"},{"location":"opcodes/cntstate/#syntax","title":"Syntax","text":"<pre><code>kmax, kmin, kinc cntState icnt\n</code></pre>"},{"location":"opcodes/cntstate/#initialization","title":"Initialization","text":"<p>icnt -- a handle for the counter.</p>"},{"location":"opcodes/cntstate/#performance","title":"Performance","text":"<p>kmax, kmin, kinc -- arguments to the original creation</p>"},{"location":"opcodes/cntstate/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/cntstate/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/comb/","title":"Comb","text":""},{"location":"opcodes/comb/#comb","title":"comb","text":"<p>Reverberates an input signal with a \u201ccolored\u201d frequency response.</p>"},{"location":"opcodes/comb/#syntax","title":"Syntax","text":"<pre><code>ares comb asig, krvt, ilpt [, iskip] [, insmps]\n</code></pre>"},{"location":"opcodes/comb/#initialization","title":"Initialization","text":"<p>ilpt -- loop time in seconds, which determines the \u201cecho density\u201d of the reverberation. This in turn characterizes the \u201ccolor\u201d of the comb filter whose frequency response curve will contain ilpt * sr/2 peaks spaced evenly between 0 and sr/2 (the Nyquist frequency). Loop time can be as large as available memory will permit. The space required for an n second loop is n*sr floating or double numbers (usually 4 or 8 bytes). Delay space is allocated and returned as in delay.</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p> <p>insmps (optional, default=0) -- delay amount, as a number of samples.</p>"},{"location":"opcodes/comb/#performance","title":"Performance","text":"<p>krvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>This filter reiterates input with an echo density determined by loop time ilpt. The attenuation rate is independent and is determined by krvt, the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude). Output from a comb filter will appear only after ilpt seconds.</p>"},{"location":"opcodes/comb/#examples","title":"Examples","text":"<p>Here is an example of the comb opcode. It uses the file comb.csd.</p> Example of the comb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o comb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngamix init 0 \n\ninstr 1 \n\nkcps    expon p5, p3, p4\nasig    vco2  0.3, kcps\n        outs  asig, asig \n\ngamix = gamix + asig \n\nendin\n\ninstr 99 \n\nkrvt =  3.5\nilpt =  0.1\naleft   comb gamix, krvt, ilpt\naright  comb gamix, krvt, ilpt*.2\n        outs   aleft, aright\n\nclear gamix     ; clear mixer\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 20 2000\ni 1 5 .01 440 440\n\ni 99 0 8\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/comb/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/comb/#credits","title":"Credits","text":"<p>Barry L. Vercoe</p>"},{"location":"opcodes/combinv/","title":"Combinv","text":""},{"location":"opcodes/combinv/#combinv","title":"combinv","text":"<p>Reverberates an input signal with a \u201ccolored\u201d frequency response. with a FIR filter.</p>"},{"location":"opcodes/combinv/#syntax","title":"Syntax","text":"<pre><code>ares combinv asig, krvt, ilpt [, iskip] [, insmps]\n</code></pre>"},{"location":"opcodes/combinv/#initialization","title":"Initialization","text":"<p>ilpt -- loop time in seconds, which determines the \u201cecho density\u201d of the reverberation. This in turn characterizes the \u201ccolor\u201d of the combinv filter whose frequency response curve will contain ilpt * sr/2 peaks spaced evenly between 0 and sr/2 (the Nyquist frequency). Loop time can be as large as available memory will permit. The space required for an n second loop is n*sr floating or double numbers (usually 4 or 8 bytes). Delay space is allocated and returned as in delay.</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p> <p>insmps (optional, default=0) -- delay amount, as a number of samples.</p>"},{"location":"opcodes/combinv/#performance","title":"Performance","text":"<p>krvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>This filter reiterates input with an echo density determined by loop time ilpt. The attenuation rate is independent and is determined by krvt, the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).  Affect from a combinv filter will appear only after ilpt seconds.</p>"},{"location":"opcodes/combinv/#examples","title":"Examples","text":"<p>Here is an example of the combinv opcode. It uses the file combinv.csd.</p> Example of the combinv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o comb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 \n\nkcps    expon p5, p3, p4\nasig    oscil3 0.3, kcps\nkrvt =  3.5\nilpt =  0.1\naleft   combinv asig, krvt, ilpt\n        outs   aleft, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3 20 2000\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/combinv/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/combinv/#credits","title":"Credits","text":"<p>Author: John ffitch October 2012</p>"},{"location":"opcodes/compilecsd/","title":"Compilecsd","text":""},{"location":"opcodes/compilecsd/#compilecsd","title":"compilecsd","text":"<p>Compiles a new orchestra from an ASCII file.</p> <p>Compilecsd will read a CSD file and compile one or more instruments at init time, which will be added to the running engine. In case of existing instrument numbers or names, these will be replaced, but any instance still running of the old instrument definition will still perform until it terminates. In addition, it will read the score (if it exists) contained in the CSD file and add it to the list of events to be performed by Csound. The opcode ignores any section in the CSD file that is not the orchestra or the score.</p>"},{"location":"opcodes/compilecsd/#syntax","title":"Syntax","text":"<pre><code>ires compilecsd Sfilename\n</code></pre>"},{"location":"opcodes/compilecsd/#initialization","title":"Initialization","text":"<p>\u201cSfilename\u201d --  a string containing the name of the file containing the orchestra.</p> <p>ires --  returns 0 if compilation was successful, or -1 if not.</p>"},{"location":"opcodes/compilecsd/#examples","title":"Examples","text":"<p>Here is an example of the compilecsd opcode. It uses the file compilecsd.csd.</p> Example of the compilecsd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nnchnls = 1\nksmps = 32\n0dbfs = 1\n\ninstr 1\nires compilecsd \"does_not_exist.csd\"\nprint ires ; -1 as could not compile\nires compilecsd \"my.csd\"\nprint ires ; 0 as compiled successfully\nevent_i \"i\", 2, 0, 3, .2, 465 ;send event \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/compilecsd/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/compilecsd/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2013</p>"},{"location":"opcodes/compileorc/","title":"Compileorc","text":""},{"location":"opcodes/compileorc/#compileorc","title":"compileorc","text":"<p>Compiles a new orchestra from an ASCII file.</p> <p>Compileorc will compile one or more instruments at init time, which will be added to the running engine. In case of existing instrument numbers or names, these will be replaced, but any instance still running of the old instrument definition will still perform until it terminates.</p>"},{"location":"opcodes/compileorc/#syntax","title":"Syntax","text":"<pre><code>ires compileorc Sfilename\n</code></pre>"},{"location":"opcodes/compileorc/#initialization","title":"Initialization","text":"<p>\u201cSfilename\u201d --  a string containing the name of the file containing the orchestra.</p> <p>ires --  returns 0 if compilation was successful, or -1 if not.</p>"},{"location":"opcodes/compileorc/#examples","title":"Examples","text":"<p>Here is an example of the compileorc opcode. It uses the file compileorc.csd.</p> Example of the compileorc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nnchnls = 1\nksmps = 32\n0dbfs = 1\n\ninstr 1\nires compileorc \"does_not_exist.orc\"\nprint ires ; -1 as could not compile\nires compileorc \"my.orc\"\nprint ires ; 0 as compiled successfully\nevent_i \"i\", 2, 0, 3, .2, 465 ;send event \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/compileorc/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/compileorc/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2013</p>"},{"location":"opcodes/compilestr/","title":"Compilestr","text":""},{"location":"opcodes/compilestr/#compilestr","title":"compilestr","text":"<p>Compiles a new orchestra passed in as an ASCII string.</p> <p>Compilestr will compile one or more instruments at init time, which will be added to the running engine. In case of existing instrument numbers or names, these will be replaced, but any instance still running of the old instrument definition will still perform until it terminates. Only new instances will use the new definition. Multi-line strings are accepted, using {{  }} to enclose the string.</p>"},{"location":"opcodes/compilestr/#syntax","title":"Syntax","text":"<pre><code>ires compilestr Sorch\n</code></pre>"},{"location":"opcodes/compilestr/#initialization","title":"Initialization","text":"<p>\u201cSorch\u201d --  a string (in double-quotes or enclosed by {{ }}) containing one or more instruments.</p> <p>ires --  returns 0 if compilation was successful, or -1 if not.</p>"},{"location":"opcodes/compilestr/#examples","title":"Examples","text":"<p>Here is an example of the compilestr opcode. It uses the file compilestr.csd.</p> Example of the compilestr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nnchnls = 1\nksmps = 32\n0dbfs = 1\n\ninstr 1\n\n ;will fail because of wrong code\nires compilestr {{\ninstr 2 \na1 oscilb p4, p5, 0\nout a1 \nendin \n}}\nprint ires ; returns -1 because not successfull\n\n ;will compile ...\nires compilestr {{\ninstr 2 \na1 oscils p4, p5, 0\nout a1 \nendin \n}}\nprint ires ; ... and returns 0\n\n ;call the new instrument\n ;(note that the overall performance is extended)\nscoreline_i \"i 2 0 3 .2 415\"\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/compilestr/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/compilestr/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2013</p>"},{"location":"opcodes/compress/","title":"Compress","text":""},{"location":"opcodes/compress/#compress","title":"compress","text":"<p>Compress, limit, expand, duck or gate an audio signal.</p> <p>This unit functions as an audio compressor, limiter, expander, or noise gate, using either soft-knee or hard-knee mapping, and with dynamically variable performance characteristics.  It takes two audio input signals, aasig and acsig, the first of which is modified by a running analysis of the second. Both signals can be the same, or the first can be modified by a different controlling signal.</p> <p>compress first examines the controlling acsig by performing envelope detection.  This is directed by two control values katt and krel, defining the attack and release time constants (in seconds) of the detector.  The detector rides the peaks (not the RMS) of the control signal. Typical values are .01 and .1, the latter usually being similar to ilook.</p> <p>The running envelope is next converted to decibels, then passed through a mapping function to determine what compresser action (if any) should be taken.  The mapping function is defined by four decibel control values.  These are given as positive values, where 0 db corresponds to an amplitude of 0dbfs/32768, and 90 db corresponds to an amplitude of 0dbfs.</p>"},{"location":"opcodes/compress/#syntax","title":"Syntax","text":"<pre><code>ar compress aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook\n</code></pre>"},{"location":"opcodes/compress/#initialization","title":"Initialization","text":"<p>ilook -- lookahead time in seconds, by which an internal envelope release can sense what is coming.  This induces a delay between input and output, but a small amount of lookahead improves the performance of the envelope detector.  Typical value is .05 seconds, sufficient to sense the peaks of the lowest frequency in acsig.</p>"},{"location":"opcodes/compress/#performance","title":"Performance","text":"<p>kthresh -- sets the lowest decibel level that will be allowed through. This is a threshold of a separate noise gate, normally 0 or less, but if higher the threshold will begin removing low-level signal energy such as background noise.</p> <p>kloknee, khiknee -- decibel break-points denoting where compression or expansion will begin. These set the boundaries of a soft-knee curve joining the low-amplitude 1:1 line and the higher-amplitude compression ratio line.  Typical values are 48 and 60 db.   If the two breakpoints are equal, a hard-knee (angled) map will result.</p> <p>kratio -- ratio of compression when the signal level is above the knee. The value 2 will advance the output just one decibel for every input gain of two;  3 will advance just one in three; 20 just one in twenty, etc. Inverse ratios will cause signal expansion:  .5 gives two for one, .25 four for one, etc.  The value 1 will result in no change.</p> <p>The actions of compress will depend on the parameter settings given.  A hard-knee compressor-limiter, for instance, is obtained from a near-zero attack time, equal-value break-points, and a very high ratio (say 100).  A noise-gate plus expander is obtained from some positive threshold, and a fractional ratio above the knee.  A voice-activated music compressor (ducker) will result from feeding the music into aasig and the speech into acsig.  A voice de-esser will result from feeding the voice into both, with the acsig version being preceded by a band-pass filter that emphasizes the sibilants. Each application will require some experimentation to find the best parameter settings;  these have been made k-variable to make this practical.</p>"},{"location":"opcodes/compress/#examples","title":"Examples","text":"<p>Here is an example of the compress opcode. It uses the file compress.csd.</p> Example of the compress opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -iadc    ;;;RT audio out and in\n; For Non-realtime ouput leave only the line below:\n; -o compress.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\nnchnls_i = 1    ; assume only one mono signal for audio input!\n0dbfs  = 1\n\n\ninstr 1 ; uncompressed signal\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\n     outs asig, asig\nendin\n\n\ninstr 2 ; compressed signal, use the \"drumsMlp.wav\" audio file and a soundfile\n\navoice  diskin2 \"Mathews.wav\", 1, 0, 1\nasig   diskin2 \"drumsMlp.wav\", 1, 0, 1\nprints \"***compressing according to Mathews.wav***\\n\\n\"\n  kthresh = 0\n  kloknee = 40\n  khiknee = 60\n  kratio  = 5\n  katt    = 0.01\n  krel    = .1\n  ilook   = .02\nasig  compress asig, avoice, kthresh, kloknee, khiknee, kratio, katt, krel, ilook       ; voice-activated compressor\n      outs asig, asig\nendin\n\ninstr 3 ; compressed signal, use the \"drumsMlp.wav\" audio file and a mic\n\navoice in                                     ; duck the audio signal \"drumsMlp.wav\" with your voice.\nasig   diskin2 \"drumsMlp.wav\", 1, 0, 1\nprints \"***compressing according to your mic -- if present***\\n\\n\"\n  kthresh = 0\n  kloknee = 40\n  khiknee = 60\n  kratio  = 3\n  katt    = 0.1\n  krel    = .5\n  ilook   = .02\nasig  compress asig, avoice, kthresh, kloknee, khiknee, kratio, katt, krel, ilook       ; voice-activated compressor\n      outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 0 4\ns\ni2 0 16\ns\ni3 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/compress/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/compress/#credits","title":"Credits","text":"<p>Written by Barry L. Vercoe for Extended Csound and released in csound5.02.</p>"},{"location":"opcodes/compress2/","title":"Compress2","text":""},{"location":"opcodes/compress2/#compress2","title":"compress2","text":"<p>Compress, limit, expand, duck or gate an audio signal.</p> <p>This unit functions as an audio compressor, limiter, expander, or noise gate, using either soft-knee or hard-knee mapping, and with dynamically variable performance characteristics.  It takes two audio input signals, aasig and acsig, the first of which is modified by a running analysis of the second. Both signals can be the same, or the first can be modified by a different controlling signal.</p> <p>compress2 first examines the controlling acsig by performing envelope detection.  This is directed by two control values katt and krel, defining the attack and release time constants (in seconds) of the detector.  The detector rides the peaks (not the RMS) of the control signal. Typical values are .01 and .1, the latter usually being similar to ilook.</p> <p>The running envelope is next converted to decibels, then passed through a mapping function to determine what compresser action (if any) should be taken.  The mapping function is defined by four decibel control values.  These are given as negative values, where 0 db corresponds to an amplitude of 0dbfs.</p>"},{"location":"opcodes/compress2/#syntax","title":"Syntax","text":"<pre><code>ar compress2 aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook\n</code></pre>"},{"location":"opcodes/compress2/#initialization","title":"Initialization","text":"<p>ilook -- lookahead time in seconds, by which an internal envelope release can sense what is coming.  This induces a delay between input and output, but a small amount of lookahead improves the performance of the envelope detector.  Typical value is .05 seconds, sufficient to sense the peaks of the lowest frequency in acsig.</p>"},{"location":"opcodes/compress2/#performance","title":"Performance","text":"<p>kthresh -- sets the lowest decibel level that will be allowed through. This is a threshold of a separate noise gate, normally set at -90 dB or less, but if higher the threshold will begin removing low-level signal energy such as background noise.</p> <p>kloknee, khiknee -- decibel break-points denoting where compression or expansion will begin. These set the boundaries of a soft-knee curve joining the low-amplitude 1:1 line and the higher-amplitude compression ratio line.  Typical values are -52 and -30 dB. If the two breakpoints are equal, a hard-knee (angled) map will result.</p> <p>kratio -- ratio of compression when the signal level is above the knee. The value 2 will advance the output just one decibel for every input gain of two;  3 will advance just one in three; 20 just one in twenty, etc. Inverse ratios will cause signal expansion:  .5 gives two for one, .25 four for one, etc.  The value 1 will result in no change.</p> <p>The actions of compress2 will depend on the parameter settings given.  A hard-knee compressor-limiter, for instance, is obtained from a near-zero attack time, equal-value break-points, and a very high ratio (say 100).  A noise-gate plus expander is obtained from some positive threshold, and a fractional ratio above the knee.  A voice-activated music compressor (ducker) will result from feeding the music into aasig and the speech into acsig.  A voice de-esser will result from feeding the voice into both, with the acsig version being preceded by a band-pass filter that emphasizes the sibilants. Each application will require some experimentation to find the best parameter settings;  these have been made k-variable to make this practical.</p>"},{"location":"opcodes/compress2/#examples","title":"Examples","text":"<p>Here is an example of the compress2 opcode. It uses the file compress2.csd.</p> Example of the compress2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -iadc    ;;;RT audio out and in\n; For Non-realtime ouput leave only the line below:\n; -o compress2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\nnchnls_i = 1    ; assume only one mono signal for audio input!\n0dbfs  = 1\n\ninstr 1 ; uncompressed signal\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\n     outs asig, asig\nendin\n\n\ninstr 2 ; compressed signal, use the \"drumsMlp.wav\" audio file and a soundfile\n\navoice  diskin2 \"Mathews.wav\", 1, 0, 1\nasig   diskin2 \"drumsMlp.wav\", 1, 0, 1\nprints \"***compressing according to Mathews.wav***\\n\\n\"\n  kthresh = -90\n  kloknee = -50\n  khiknee = -30\n  kratio  = 6\n  katt    = 0.01\n  krel    = .1\n  ilook   = .02\nasig  compress2 asig, avoice, kthresh, kloknee, khiknee, kratio, katt, krel, ilook      ; voice-activated compressor\n      outs asig, asig\nendin\n\ninstr 3 ; compressed signal, use the \"drumsMlp.wav\" audio file and a mic\n\navoice in                                     ; duck the audio signal \"drumsMlp.wav\" with your voice.\nasig   diskin2 \"drumsMlp.wav\", 1, 0, 1\nprints \"***compressing according to your mic -- if present***\\n\\n\"\n  kthresh = -90\n  kloknee = -50\n  khiknee = -30\n  kratio  = 5\n  katt    = 0.1\n  krel    = .5\n  ilook   = .02\nasig  compress2 asig, avoice, kthresh, kloknee, khiknee, kratio, katt, krel, ilook      ; voice-activated compressor\n      outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 0 4\ns\ni2 0 16\ns\ni3 0 30\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/compress2/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/compress2/#credits","title":"Credits","text":"<p>Written by John ffitch after Barry L. Vercoe from Extended but with more common dB values, new in version 6.07.</p>"},{"location":"opcodes/control/","title":"Control","text":""},{"location":"opcodes/control/#control","title":"control","text":"<p>Configurable slider controls for realtime user input. Requires Winsound or TCL/TK. It reads a slider's value.</p> <p>Plugin opcode in control.</p>"},{"location":"opcodes/control/#syntax","title":"Syntax","text":"<pre><code>kres control knum\n</code></pre>"},{"location":"opcodes/control/#performance","title":"Performance","text":"<p>Note that this opcode is not available on Windows due to the implimentation of pipes on that system.</p> <p>knum -- number of the slider to be read.</p> <p>Calling control will create a new slider on the screen. There is no theoretical limit to the number of sliders. Windows and TCL/TK use only integers for slider values, so the values may need rescaling. GUIs usually pass values at a fairly slow rate, so it may be advisable to pass the output of control through port.</p>"},{"location":"opcodes/control/#examples","title":"Examples","text":"<p>See the setctrl opcode for an example.</p>"},{"location":"opcodes/control/#see-also","title":"See also","text":"<p>Sensing and Control: TCL/TK widgets</p>"},{"location":"opcodes/control/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK May, 2000</p> <p>New in Csound version 4.06</p>"},{"location":"opcodes/convle/","title":"Convle","text":""},{"location":"opcodes/convle/#convle","title":"convle","text":"<p>Same as the convolve opcode.</p>"},{"location":"opcodes/convolve/","title":"Convolve","text":""},{"location":"opcodes/convolve/#convolve","title":"convolve","text":"<p>Convolves a signal and an impulse response.</p> <p>Output is the convolution of signal ain and the impulse response contained in ifilcod. If more than one output signal is supplied, each will be convolved with the same impulse response. Note that it is considerably more efficient to use one instance of the operator when processing a mono input to create stereo, or quad, outputs.</p> <p>Note: this opcode can also be written as convle.</p>"},{"location":"opcodes/convolve/#syntax","title":"Syntax","text":"<pre><code>ar1 [, ar2] [, ar3] [, ar4] convolve ain, ifilcod [, ichannel]\n</code></pre>"},{"location":"opcodes/convolve/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting an impulse response data file. An integer denotes the suffix of a file convolve.m; a character string (in double quotes) gives a filename, optionally a full pathname. If not a fullpath, the file is sought first in the current directory, then in the one given by the environment variable SADIR (if defined). The data file contains the Fourier transform of an impulse response. Memory usage depends on the size of the data file, which is read and held entirely in memory during computation, but which is shared by multiple calls.</p> <p>ichannel (optional) -- which channel to use from the impulse response data file.</p>"},{"location":"opcodes/convolve/#performance","title":"Performance","text":"<p>ain -- input audio signal.</p> <p>convolve implements Fast Convolution. The output of this operator is delayed with respect to the input. The following formulas should be used to calculate the delay:</p> <pre><code>For (1/kr) &lt;= IRdur:\n        Delay = ceil(IRdur * kr) / kr\nFor (1/kr) &gt; IRdur: \n        Delay = IRdur * ceil(1/(kr*IRdur))\nWhere:\n        kr  = Csound control rate\n        IRdur = duration, in seconds, of impulse response\n        ceil(n) = smallest integer not smaller than n\n</code></pre> <p>One should be careful to also take into account the initial delay, if any, of the impulse response. For example, if an impulse response is created from a recording, the soundfile may not have the initial delay included. Thus, one should either ensure that the soundfile has the correct amount of zero padding at the start, or, preferably, compensate for this delay in the orchestra (the latter method is more efficient). To compensate for the delay in the orchestra, subtract the initial delay from the result calculated using the above formula(s), when calculating the required delay to introduce into the 'dry' audio path.</p> <p>For typical applications, such as reverb, the delay will be in the order of 0.5 to 1.5 seconds, or even longer. This renders the current implementation unsuitable for real time applications. It could conceivably be used for real time filtering however, if the number of taps is small enough.</p> <p>The author intends to create a higher-level operator at some stage, that would mix the wet &amp; dry signals, using the correct amount of delay automatically.</p>"},{"location":"opcodes/convolve/#examples","title":"Examples","text":"<p>Create frequency domain impulse response file using the cvanal utility:</p> <pre><code>csound -Ucvanal l1_44.wav l1_44.cv\n</code></pre> <p>Determine duration of impulse response. For high accuracy, determine the number of sample frames in the impulse response soundfile, and then compute the duration with:</p> <pre><code>duration = (sample frames)/(sample rate of soundfile)\n</code></pre> <p>This is due to the fact that the sndinfo utility only reports the duration to the nearest 10ms. If you have a utility that reports the duration to the required accuracy, then you can simply use the reported value directly.</p> <pre><code>sndinfo l1_44.wav\n</code></pre> <pre><code>length = 60822 samples, sample rate = 44100\n\nDuration = 60822/44100 = 1.379s.\n</code></pre> <p>Determine initial delay, if any, of impulse response. If the impulse response has not had the initial delay removed, then you can skip this step. If it has been removed, then the only way you will know the initial delay is if the information has been provided separately. For this example, let us assume that the initial delay is 60ms (0.06s)</p> <p>Determine the required delay to apply to the dry signal, to align it with the convolved signal:</p> <pre><code>If kr = 441:\n      1/kr = 0.0023, which is &lt;= IRdur (1.379s), so:\n      Delay1  = ceil(IRdur * kr) / kr\n              = ceil(608.14) / 441\n              = 609/441\n              = 1.38s\n\n\nAccounting for the initial delay:\n      Delay2  = 0.06s\n Total delay  = delay1 - delay2\n              = 1.38 - 0.06\n              = 1.32s\n</code></pre> <p>Here is similar example of the convolve opcode. It uses the file convolve.csd.</p> Example of the convolve opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o convolve.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; NB: 'Small' reverbs often require a much higher percentage of wet signal to sound interesting. 'Large'\n; reverbs seem require less. Experiment! The wet/dry mix is very important - a small change can make a large difference.\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n; by Menno Knevel - 2021\n\nires1 system_i 1,{{ cvanal rv_mono.wav rv_mono.con }}  ; analyze mono spring reverb\nires2 system_i 1,{{ cvanal rv_stereo.wav rv_stereo.con }} ; analyze stereo spring reverb\n\ninstr 1 \n\nimix = 0.25     ;wet/dry mix. Vary as desired.\nivol = .8       ;Overall volume level of reverb. Adjust to avoid clipping.\n\nidel   filelen p4                       ;calculate length and number of channels of soundfile\nichnls filenchnls  p4\nprints  \"\\n**this reverb file = %f seconds and has %d channel(s)**\\n\", idel, ichnls\n\nif (ichnls == 1) then                                   ; if mono\n        adry    soundin \"fox.wav\"               ; input (dry) audio\n        awet    convolve adry,\"rv_mono.con\"     ; mono convolved (wet) audio\n        awet1   diff    awet                    ; brighten sound\n        awet2   =       awet1                                           ; as it is a mono file played stereo\n        adrydel delay   (1-imix)*adry, idel     ; Delay dry signal to align it with convolved signal\nelse                                                                    ; if stereo\n        adry    soundin \"fox.wav\"               ; input (dry) audio\n        awet1, awet2 convolve adry,\"rv_stereo.con\" ; stereo convolved (wet) audio\n        awet1   diff    awet1                   ; brighten left sound\n        awet2   diff    awet2                   ; and brighten right sound\n        adrydel delay   (1-imix)*adry, idel     ; Delay dry signal to align it with convolved signal\nendif\nouts    ivol*(adrydel+imix*awet1),ivol*(adrydel+imix*awet2) ; Mix wet &amp; dry signals\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 \"rv_mono.wav\"\ni 1 5 4 \"rv_stereo.wav\"\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/convolve/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/convolve/#credits","title":"Credits","text":"<p>Author: Greg Sullivan</p> <p>1996</p> <p>New in version 3.28</p>"},{"location":"opcodes/copya2ftab/","title":"Copya2ftab","text":""},{"location":"opcodes/copya2ftab/#copya2ftab","title":"copya2ftab","text":"<p>The copya2ftab opcode takes a k-array and copies the contents to an f-table.</p>"},{"location":"opcodes/copya2ftab/#syntax","title":"Syntax","text":"<pre><code>copya2ftab kArray[], ktab [, koffset]\ncopya2ftab iArray[], itab [, ioffset]\n</code></pre>"},{"location":"opcodes/copya2ftab/#performance","title":"Performance","text":"<p>kArray[] --  one-dimensional array for source.</p> <p>ktab --  f-table for destination.</p> <p>koffset --  offset into the f-table (defaults to 0).</p>"},{"location":"opcodes/copya2ftab/#example","title":"Example","text":"<p>Here is an example of the copya2ftab opcode. It uses the file copya2ftab.csd.</p> Example of the copya2ftab opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n;an 'empty' function table with 10 points\ngiTable ftgen   0, 0, -10, 2, 0\n\n\n  instr 1\n\n;print inital values of giTable\n        puts    \"\\nInitial table content:\", 1\nindx    =       0\n  until indx == ftlen(giTable) do\niVal    table   indx, giTable\n        printf_i \"Table index %d = %f\\n\", 1, indx, iVal\nindx += 1\n  od\n\n;create array\nkArr[]  init    10\n\n;fill in values\nkArr    genarray 1, 10\n\n;print array values\n        printf  \"%s\", 1, \"\\nArray content:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr[kndx]\nkndx    +=      1\n  od\n\n;copy array values to table\n        copya2ftab kArr, giTable\n\n;print modified values of giTable\n        printf  \"%s\", 1, \"\\nModified table content after copya2ftab:\\n\"\nkndx    =       0\n  until kndx == ftlen(giTable) do\nkVal    table   kndx, giTable\n        printf  \"Table index %d = %f\\n\", kndx+1, kndx, kVal\nkndx += 1\n  od\n\n;turn instrument off\n        turnoff\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/copya2ftab/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/copya2ftab/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.15</p> <p>Renamed in Csound version 6.00</p> <p>Offset added in version 6.14</p>"},{"location":"opcodes/copyf2array/","title":"Copyf2array","text":""},{"location":"opcodes/copyf2array/#copyf2array","title":"copyf2array","text":"<p>The copyf2array opcode takes an f-table and copies the contents to a t-var.</p>"},{"location":"opcodes/copyf2array/#syntax","title":"Syntax","text":"<pre><code>copyf2array tab, kftbl\n</code></pre>"},{"location":"opcodes/copyf2array/#performance","title":"Performance","text":"<p>tab --  tables for destination.</p> <p>kftbl --  f-tables for source.</p>"},{"location":"opcodes/copyf2array/#example","title":"Example","text":"<p>Here is an example of the copyf2array opcode. It uses the file copyf2array.csd.</p> Example of the copyf2array opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n;8 points sine wave function table\ngiSine  ftgen   0, 0, 8, 10, 1\n\n\n  instr 1\n;create array\nkArr[]  init    8\n\n;copy table values in it\n        copyf2array kArr, giSine\n\n;print values\nkndx    =       0\n  until kndx == lenarray(kArr) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr[kndx]\nkndx    +=      1\n  od\n\n;turn instrument off\n        turnoff\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/copyf2array/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/copyf2array/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.15</p> <p>Renamed in Csound version 6.00</p>"},{"location":"opcodes/cos/","title":"Cos","text":""},{"location":"opcodes/cos/#cos","title":"cos","text":"<p>Returns the cosine of x (x in radians).</p>"},{"location":"opcodes/cos/#syntax","title":"Syntax","text":"<pre><code>cos(x)     (no rate restriction)\ncos(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/cos/#examples","title":"Examples","text":"<p>Here is an example of the cos opcode. It uses the file cos.csd.</p> Example of the cos opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cos.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nicos1     =          cos(0) ;cosine of 0 is 1\nicos2     =          cos($M_PI_2) ;cosine of pi/2 (1.5707...) is 0\nicos3     =          cos($M_PI) ;cosine of pi (3.1415...) is -1\nicos4     =          cos($M_PI_2 * 3) ;cosine of 3/2pi (4.7123...) is 0\nicos5     =          cos($M_PI * 2) ;cosine of 2pi (6.2831...) is 1\nicos6     =          cos($M_PI * 4) ;cosine of 4pi is also 1 as it is periodically to 2pi\n          print      icos1, icos2, icos3, icos4, icos5, icos6\nendin\n\ninstr 2 ;cos used in panning, after an example from Hans Mikelson\naout      vco2       0.8, 220 ; sawtooth\nkpan      linseg     p4, p3, p5 ;0 = left, 1 = right\nkpan      =          kpan*$M_PI_2 ;range 0-1 becomes 0-pi/2\nkpanl     =          cos(kpan)\nkpanr     =          sin(kpan)\n          outs       aout*kpanl, aout*kpanr\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0\ni 2 0 5 0 1 ;move left to right\ni 2 6 5 1 0 ;move right to left\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cos/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/cosh/","title":"Cosh","text":""},{"location":"opcodes/cosh/#cosh","title":"cosh","text":"<p>Returns the hyperbolic cosine of x (x in radians).</p>"},{"location":"opcodes/cosh/#syntax","title":"Syntax","text":"<pre><code>cosh(x)     (no rate restriction)\ncosh(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/cosh/#examples","title":"Examples","text":"<p>Here is an example of the cosh opcode. It uses the file cosh.csd.</p> Example of the cosh opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n  ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o cosh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nirad = 1\ni1 = cosh(irad)\nprint i1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = 1.543\n</code></pre>"},{"location":"opcodes/cosh/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/cosh/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.47</p>"},{"location":"opcodes/cosinv/","title":"Cosinv","text":""},{"location":"opcodes/cosinv/#cosinv","title":"cosinv","text":"<p>Returns the arccosine of x (x in radians).</p>"},{"location":"opcodes/cosinv/#syntax","title":"Syntax","text":"<pre><code>cosinv(x)     (no rate restriction)\ncosinv(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/cosinv/#examples","title":"Examples","text":"<p>Here is an example of the cosinv opcode. It uses the file cosinv.csd.</p> Example of the cosinv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n  ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o cosinv.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nirad = 0.5\ni1 = cosinv(irad)\nprint i1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = 1.047\n</code></pre>"},{"location":"opcodes/cosinv/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/cosinv/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.48</p>"},{"location":"opcodes/cosseg/","title":"Cosseg","text":""},{"location":"opcodes/cosseg/#cosseg","title":"cosseg","text":"<p>Trace a series of line segments between specified points with cosine interpolation.</p>"},{"location":"opcodes/cosseg/#syntax","title":"Syntax","text":"<pre><code>ares cosseg ia, idur1, ib [, idur2] [, ic] [...]\nkres cosseg ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/cosseg/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p>"},{"location":"opcodes/cosseg/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note.</p>"},{"location":"opcodes/cosseg/#examples","title":"Examples","text":"<p>Here is an example of the cosseg opcode. It uses the file cosseg.csd.</p> Example of the cosseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o linseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkcps = cpspch(p4)\nkenv cosseg 0, 0.25, 1, 0.75, 0 ; together = 1 sec\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 2 ; scaling to duration\n\nkcps = cpspch(p4)\nkenv cosseg 0, p3*0.25, 1, p3*0.75, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 3 ; with negative value\n\nkcps = cpspch(p4)\naenv cosseg 0, 0.1, 1, 0.5, -0.9, 0.4, 0\nasig poscil aenv, kcps, giSine\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1   7.00  ; = 1 sec, p3 fits exactly\ni 1 2 2   7.00  ; = 2 sec, p3 truncated at 1 sec\n\ni 2 4 1   7.00  ; scales to duration\ni 2 6 2   7.00  ; of p3\n\ni 3 9 2   7.00\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cosseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/cosseg/#credits","title":"Credits","text":"<p>Author: John ffitch Aug 2012 </p> <p>New in version 5.18</p>"},{"location":"opcodes/cossegb/","title":"Cossegb","text":""},{"location":"opcodes/cossegb/#cossegb","title":"cossegb","text":"<p>Trace a series of line segments between specified absolute points with cosine interpolation.</p>"},{"location":"opcodes/cossegb/#syntax","title":"Syntax","text":"<pre><code>ares cossegb ia, itim1, ib [, itim2] [, ic] [...]\nkres cossegb ia, itim1, ib [, itim2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/cossegb/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value at tim1 seconds, etc.</p> <p>itim1 -- time in seconds of end of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>itim2, itim3, etc. -- time in seconds at the end of subsequent segments.</p>"},{"location":"opcodes/cossegb/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The last tim value may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note.</p>"},{"location":"opcodes/cossegb/#examples","title":"Examples","text":"<p>Here is an example of the cossegb opcode. It uses the file cossegb.csd.</p> Example of the cossegb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o linseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkcps = cpspch(p4)\nkenv cossegb 0, 0.25, 1, 1, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 2 ; scaling to duration\n\nkcps = cpspch(p4)\nkenv cossegb 0, p3*0.25, 1, p3, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1   7.00  ; = 1 sec, p3 fits exactly\ni 1 2 2   7.00  ; = 2 sec, p3 truncated at 1 sec\n\ni 2 4 1   7.00  ; scales to duration\ni 2 6 2   7.00  ; of p3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cossegb/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/cossegb/#credits","title":"Credits","text":"<p>Author: John ffitch Aug 2012 </p> <p>New in version 5.18</p>"},{"location":"opcodes/cossegr/","title":"Cossegr","text":""},{"location":"opcodes/cossegr/#cossegr","title":"cossegr","text":"<p>Trace a series of line segments between specified points with cosine interpolation, including a release segment.</p>"},{"location":"opcodes/cossegr/#syntax","title":"Syntax","text":"<pre><code>ares cossegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres cossegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\n</code></pre>"},{"location":"opcodes/cossegr/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p> <p>irel, iz -- duration in seconds and final value of a note releasing segment.</p>"},{"location":"opcodes/cossegr/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.</p> <p>cossegr is amongst the Csound \u201cr\u201d units that contain a note-off sensor and release time extender. When each senses an event termination or MIDI noteoff, it immediately extends the performance time of the current instrument by irel _seconds, and sets out to reach the value _iz by the end of that period (no matter which segment the unit is in). \u201cr\u201d units can also be modified by MIDI noteoff velocities. For two or more extenders in an instrument, extension is by the greatest period.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linenr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using cossegr, since the time is extended automatically.</p>"},{"location":"opcodes/cossegr/#examples","title":"Examples","text":"<p>Here is an example of the cossegr opcode. It uses the file cossegr.csd.</p> Example of the cossegr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0   ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o linsegr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n\nicps    cpsmidi      \niamp    ampmidi .3   \n\nkenv    cossegr 1, .05, 0.5, 1, 0\nasig    pluck   kenv, icps, 200, 1, 1    \n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ;sine wave\n\nf0 30   ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cossegr/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/cossegr/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>August 2012.</p> <p>New in Csound 5.18</p>"},{"location":"opcodes/count/","title":"Count","text":""},{"location":"opcodes/count/#count","title":"count","text":"<p>Get the next value from a counter.</p> <p>Plugin opcode in counter.</p> <p>Get the next value from a counter by adding the increment and keeping the counter in the declared range.</p>"},{"location":"opcodes/count/#syntax","title":"Syntax","text":"<pre><code>kval count icnt\n</code></pre>"},{"location":"opcodes/count/#initialization","title":"Initialization","text":"<p>icnt -- the handle of a counter object from a call to cntCreate.</p>"},{"location":"opcodes/count/#performance","title":"Performance","text":"<p>Calculate the next value from the counter object and return that  value.</p> <p>kval -- returned value.</p>"},{"location":"opcodes/count/#examples","title":"Examples","text":"<p>Here is an example of the count opcode. It uses the file counter.csd.</p> Example of the count opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -Mhw:1,0,0\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n gicnt cntCreate 1     ; a toggle\n gicntNote cntCreate 1 ; ignore note-off message to turn MIDI notes into toggles\n\n\ninstr 1\n\nkkey sensekey\n\ninote notnum\n\nif (kkey == 97) then\n k1 count gicnt\n if k1==0 then\n  event \"i\", 2, 0, -1\n else\n  event \"d\", 2, 0, -1\n endif\nendif\n\nprint  inote\nif (inote == 60) then\n i2 count_i gicntNote\n print i2\n if i2==0 then\n  event_i \"i\", 3, 0, -1\n else\n  event_i \"d\", 3, 0, -1\n endif\nendif\nendin\n\ninstr 2\nasig oscil 10000, 440\nout asig\nendin\n\ninstr 3\nasig oscil 5000, 880\nout asig\nendin\n\n&lt;/CsInstruments&gt;\n\n\n&lt;CsScore&gt;\ni1 0 z\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/count/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/count/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/count_i/","title":"Count i","text":""},{"location":"opcodes/count_i/#count_i","title":"count_i","text":"<p>Get the next value from a counter.</p> <p>Plugin opcode in counter.</p> <p>Get the next value from a counter a init time by adding the increment and keeping the counter in the declared range.</p>"},{"location":"opcodes/count_i/#syntax","title":"Syntax","text":"<pre><code>ival count_i icnt\n</code></pre>"},{"location":"opcodes/count_i/#initialization","title":"Initialization","text":"<p>icnt -- the handle of a counter object from a call to cntCreate.</p>"},{"location":"opcodes/count_i/#performance","title":"Performance","text":"<p>Calculate the next value from the counter object and return that value.</p> <p>ival -- returned value.</p>"},{"location":"opcodes/count_i/#examples","title":"Examples","text":"<p>Here is an example of the count_i opcode. It uses the file counter.csd.</p> Example of the count_i opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -Mhw:1,0,0\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n gicnt cntCreate 1     ; a toggle\n gicntNote cntCreate 1 ; ignore note-off message to turn MIDI notes into toggles\n\n\ninstr 1\n\nkkey sensekey\n\ninote notnum\n\nif (kkey == 97) then\n k1 count gicnt\n if k1==0 then\n  event \"i\", 2, 0, -1\n else\n  event \"d\", 2, 0, -1\n endif\nendif\n\nprint  inote\nif (inote == 60) then\n i2 count_i gicntNote\n print i2\n if i2==0 then\n  event_i \"i\", 3, 0, -1\n else\n  event_i \"d\", 3, 0, -1\n endif\nendif\nendin\n\ninstr 2\nasig oscil 10000, 440\nout asig\nendin\n\ninstr 3\nasig oscil 5000, 880\nout asig\nendin\n\n&lt;/CsInstruments&gt;\n\n\n&lt;CsScore&gt;\ni1 0 z\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/count_i/#see-also","title":"See also","text":"<p>Program Flow Control: Counter</p>"},{"location":"opcodes/count_i/#credits","title":"Credits","text":"<p>By: John ffitch June 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/cps2pch/","title":"Cps2pch","text":""},{"location":"opcodes/cps2pch/#cps2pch","title":"cps2pch","text":"<p>Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of the octave.</p>"},{"location":"opcodes/cps2pch/#syntax","title":"Syntax","text":"<pre><code>icps cps2pch ipch, iequal\n</code></pre>"},{"location":"opcodes/cps2pch/#initialization","title":"Initialization","text":"<p>ipch -- Input number of the form 8ve.pc, indicating an 'octave' and which note in the octave.</p> <p>iequal -- If positive, the number of equal intervals into which the 'octave' is divided. Must be less than or equal to 100. If negative, is the number of a table of frequency multipliers.</p> <p> Note</p> <ol> <li> <p>The following are essentially the same <pre><code>ia  =  cpspch(8.02)\nib     cps2pch  8.02, 12\nic     cpsxpch  8.02, 12, 2, 1.02197503906\n</code></pre></p> </li> <li> <p>These are opcodes not functions</p> </li> <li>Negative values of ipch are allowed.</li> </ol>"},{"location":"opcodes/cps2pch/#examples","title":"Examples","text":"<p>Here is an example of the cps2pch opcode. It uses the file cps2pch.csd.</p> Example of the cps2pch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cps2pch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use a normal twelve-tone scale.\n  ipch = 8.02\n  iequal = 12\n\n  icps cps2pch ipch, iequal\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 293.666\n</code></pre> <p>Here is an example of the cps2pch opcode using a table of frequency multipliers. It uses the file cps2pch_ftable.csd.</p> Example of the cps2pch opcode using a table of frequency multipliers.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cps2pch_ftable.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ipch = 8.02\n\n  ; Use Table #1, a table of frequency multipliers.\n  icps cps2pch ipch, -1\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a table of frequency multipliers.\n; Creates a 10-note scale of unequal divisions.\nf 1 0 16 -2 1 1.1 1.2 1.3 1.4 1.6 1.7 1.8 1.9\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 313.951\n</code></pre> <p>Here is an example of the cps2pch opcode using a 19ET scale. It uses the file cps2pch_19et.csd.</p> Example of the cps2pch opcode using a 19ET scale.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cps2pch_19et.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use 19ET scale.\n  ipch = 8.02\n  iequal = 19\n\n  icps cps2pch ipch, iequal\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 281.429\n</code></pre>"},{"location":"opcodes/cps2pch/#see-also","title":"See also","text":"<p>Pitch Converters: Tuning Opcodes</p>"},{"location":"opcodes/cps2pch/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK 1997</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/cpsmidi/","title":"Cpsmidi","text":""},{"location":"opcodes/cpsmidi/#cpsmidi","title":"cpsmidi","text":"<p>Get the note number of the current MIDI event, expressed in cycles-per-second.</p>"},{"location":"opcodes/cpsmidi/#syntax","title":"Syntax","text":"<pre><code>icps cpsmidi\n</code></pre>"},{"location":"opcodes/cpsmidi/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, expressed in cycles-per-second units, for local processing.</p> <p> cpsmidi vs. cpsmidinn</p> <p>The cpsmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With cpsmidi, the Midi note number value is taken from the Midi event that is internally associated with the instrument instance.  On the other hand, the cpsmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for cpsmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.</p>"},{"location":"opcodes/cpsmidi/#examples","title":"Examples","text":"<p>Here is an example of the cpsmidi opcode. It uses the file cpsmidi.csd.</p> Example of the cpsmidi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpsmidi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nicps cpsmidi\nasig    oscil 0.6, icps, 1\n        print icps\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 20\n;sine wave.\nf 1 0 16384 10 1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpsmidi/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/cpsmidi/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/cpsmidib/","title":"Cpsmidib","text":""},{"location":"opcodes/cpsmidib/#cpsmidib","title":"cpsmidib","text":"<p>Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in cycles-per-second.</p>"},{"location":"opcodes/cpsmidib/#syntax","title":"Syntax","text":"<pre><code>icps cpsmidib [irange]\nkcps cpsmidib [irange]\n</code></pre>"},{"location":"opcodes/cpsmidib/#initialization","title":"Initialization","text":"<p>irange (optional) -- the pitch bend range in semitones.</p>"},{"location":"opcodes/cpsmidib/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, modify it by the current pitch-bend value, and express the result in cycles-per-second units. Available as an i-time value or as a continuous k-rate value.</p>"},{"location":"opcodes/cpsmidib/#examples","title":"Examples","text":"<p>Here is an example of the cpsmidib opcode. It uses the file cpsmidib.csd.</p> Example of the cpsmidib opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpsmidi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; move pitch bend wheel while you play\n\nkcps cpsmidib\nasig    oscil 0.6, kcps, 1\n        printk2 kcps\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 20\n;sine wave.\nf 1 0 16384 10 1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpsmidib/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/cpsmidib/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/cpsmidinn/","title":"Cpsmidinn","text":""},{"location":"opcodes/cpsmidinn/#cpsmidinn","title":"cpsmidinn","text":"<p>Converts a Midi note number value to cycles-per-second.</p>"},{"location":"opcodes/cpsmidinn/#syntax","title":"Syntax","text":"<pre><code>cpsmidinn (MidiNoteNumber)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/cpsmidinn/#performance","title":"Performance","text":"<p>cpsmidinn is a function that takes an i-rate or k-rate value representing a Midi note number and returns the equivalent frequency value in cycles-per-second (Hertz). This conversion assumes that Middle C is Midi note number 60 and that Middle A is tuned to 440 Hz. Midi note number values are typically integers in the range from 0 to 127 but fractional values or values outside of this range will be interpreted consistently.</p> <p> cpsmidinn vs. cpsmidi</p> <p>The cpsmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for cpsmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.  You must specify an i-rate or k-rate expression for the Midi note number that is to be converted.  On the other hand, the cpsmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With cpsmidi, the Midi note number value is taken from the Midi event associated with the instrument instance, and no location or expression for this value may be specified.</p> <p>cpsmidinn and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/cpsmidinn/#examples","title":"Examples","text":"<p>Here is an example of the cpsmidinn opcode. It uses the file cpsmidinn.csd.</p> Example of the cpsmidinn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n; Prints a table showing the equivalents of all Midi\n; note numbers from 0-127 in cycles-per-second, \n; octave.decimal, and octave.pitchclass units.\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform.\n; This example produces no audio, so we render in\n; non-realtime and turn off sound to disk:\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n  ; i-time loop to print conversion table\n  imidiNN =   0\n  loop1:\n    icps  = cpsmidinn(imidiNN)\n    ioct  = octmidinn(imidiNN)\n    ipch  = pchmidinn(imidiNN)\n\n    print   imidiNN, icps, ioct, ipch\n\n    imidiNN = imidiNN + 1\n  if (imidiNN &lt; 128) igoto loop1\nendin\n\ninstr 2\n  ; test k-rate converters\n  kMiddleC  =   60\n  kcps  = cpsmidinn(kMiddleC)\n  koct  = octmidinn(kMiddleC)\n  kpch  = pchmidinn(kMiddleC)\n\n  printks \"%d %f %f %f\\n\", 1.0, kMiddleC, kcps, koct, kpch\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\ni2 0 0.1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the cpsmidinn opcode. It uses the file cpsmidinn2.csd.</p> Second example of the cpsmidinn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;;;RT audio out, midi in, note=p4 and velocity=p5\n-odac -+rtmidi=virtual -M0d --midi-key=4 --midi-velocity-amp=5\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpsmidinn.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\nmassign 0, 1    ;assign all midi to instr. 1\n\ninstr 1 ;play virtual keyboard\n\ninote = p4\nicps  = cpsmidinn(inote)\nasig    oscil 0.6, icps, 1\n        print icps\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 20\n;sine wave.\nf 1 0 16384 10 1\n;play note from score too\ni1 0 1 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpsmidinn/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/cpsmidinn/#credits","title":"Credits","text":"<p>Derived from original value converters by Barry Vercoe.</p> <p>New in version 5.07</p>"},{"location":"opcodes/cpsoct/","title":"Cpsoct","text":""},{"location":"opcodes/cpsoct/#cpsoct","title":"cpsoct","text":"<p>Converts an octave-point-decimal value to cycles-per-second.</p>"},{"location":"opcodes/cpsoct/#syntax","title":"Syntax","text":"<pre><code>cpsoct (oct)  (no rate restriction)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/cpsoct/#performance","title":"Performance","text":"<p>cpsoct and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/cpsoct/#examples","title":"Examples","text":"<p>Here is an example of the cpsoct opcode. It uses the file cpsoct.csd.</p> Example of the cpsoct opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpsoct.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; Convert octave-point-decimal value into Hz\n\nioct =  p4\nicps =  cpsoct(ioct)\n        print icps\nasig    oscil 0.7, icps, 1\n        outs  asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 1 8.75\ni 1 + 1 8.77\ni 1 + 1 8.79\ni 1 + .5 6.30\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 440.000\ninstr 1:  icps = 446.110\ninstr 1:  icps = 452.344\ninstr 1:  icps = 80.521\n</code></pre>"},{"location":"opcodes/cpsoct/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/cpspch/","title":"Cpspch","text":""},{"location":"opcodes/cpspch/#cpspch","title":"cpspch","text":"<p>Converts a pitch-class value to cycles-per-second.</p>"},{"location":"opcodes/cpspch/#syntax","title":"Syntax","text":"<pre><code>cpspch (pch)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/cpspch/#performance","title":"Performance","text":"<p>cpspch and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p> <p>If you need more precision in the calculation, use cps2pch or  cpsxpch instead.</p>"},{"location":"opcodes/cpspch/#examples","title":"Examples","text":"<p>Here is an example of the cpspch opcode. It uses the file cpspch.csd.</p> Example of the cpspch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpspch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; Convert pitch-class value into Hz \n\nipch =  p4\nicps =  cpspch(ipch)\n        print icps\nasig    oscil 0.7, icps, 1\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 1 8.01\ni 1 + 1 8.02\ni 1 + 1 8.03\ni 1 + .5 5.09\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 277.167\ninstr 1:  icps = 293.656\ninstr 1:  icps = 311.101\ninstr 1:  icps = 54.995\n</code></pre>"},{"location":"opcodes/cpspch/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/cpstmid/","title":"Cpstmid","text":""},{"location":"opcodes/cpstmid/#cpstmid","title":"cpstmid","text":"<p>Get a MIDI note number (allows customized micro-tuning scales).</p> <p>This unit is similar to cpsmidi, but allows fully customized micro-tuning scales.</p>"},{"location":"opcodes/cpstmid/#syntax","title":"Syntax","text":"<pre><code>icps cpstmid ifn\n</code></pre>"},{"location":"opcodes/cpstmid/#initialization","title":"Initialization","text":"<p>ifn -- function table containing the parameters (numgrades, interval, basefreq, basekeymidi) and the tuning ratios.</p>"},{"location":"opcodes/cpstmid/#performance","title":"Performance","text":"<p>Init-rate only</p> <p>cpsmid requires five parameters, the first, ifn, is the function table number of the tuning ratios, and the other parameters must be stored in the function table itself. The function table ifn should be generated by GEN02, with normalization inhibited. The first four values stored in this function are:</p> <ol> <li>numgrades -- the number of grades of the micro-tuning scale</li> <li>interval -- the frequency range covered before repeating the grade ratios, for example 2 for one octave, 1.5 for a fifth etc.</li> <li>basefreq -- the base frequency of the scale in Hz</li> <li>basekeymidi -- the MIDI note number to which basefreq is assigned unmodified</li> </ol> <p>After these four values, the user can begin to insert the tuning ratios. For example, for a standard 12 note scale with the base frequency of 261 Hz assigned to the key number 60, the corresponding f-statement in the score to generate the table should be:</p> <pre><code>;          numgrades interval  basefreq basekeymidi tuning ratios (equal temp)\nf1 0 64 -2   12       2        261        60         1  1.059463094359  1.122462048309  1.189207115003 ..etc...\n</code></pre> <p>Another example with a 24 note scale with a base frequency of 440 assigned to the key number 48, and a repetition interval of 1.5:</p> <pre><code>;           numgrades interval  basefreq basekeymidi tuning-ratios (equal temp)\nf1 0 64 -2   24        1.5      440        48         1   1.01  1.02  1.03   ..etc...\n</code></pre>"},{"location":"opcodes/cpstmid/#examples","title":"Examples","text":"<p>Here is an example of the cpstmid opcode. It uses the file cpstmid.csd.</p> Example of the cpstmid opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpstmid.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; after an example from Kevin Conder\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n; Table #1, a normal 12-tone equal temperament scale.\n; numgrades = 12 (twelve tones)\n; interval = 2 (one octave)\n; basefreq = 261.659 (Middle C)\n; basekeymidi = 60 (Middle C)\ngitemp ftgen 1, 0, 64, -2, 12, 2, 261.659, 60, 1.00, \\\n             1.059, 1.122, 1.189, 1.260, 1.335, 1.414, \\\n             1.498, 1.588, 1.682, 1.782, 1.888, 2.000\n\ninstr 1\n\nifn = 1\nicps    cpstmid ifn\n        print icps\nasig    oscil 0.6, icps, 2\n        outs  asig, asig\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 20\n;sine wave.\nf 2 0 16384 10 1\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpstmid/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/cpstmid/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/cpstun/","title":"Cpstun","text":""},{"location":"opcodes/cpstun/#cpstun","title":"cpstun","text":"<p>Returns micro-tuning values at k-rate.</p>"},{"location":"opcodes/cpstun/#syntax","title":"Syntax","text":"<pre><code>kcps cpstun ktrig, kindex, kfn\n</code></pre>"},{"location":"opcodes/cpstun/#performance","title":"Performance","text":"<p>kcps -- Return value in cycles per second.</p> <p>ktrig -- A trigger signal used to trigger the evaluation.</p> <p>kindex -- An integer number denoting an index of scale.</p> <p>kfn --  Function table containing the parameters (numgrades, interval, basefreq, basekeymidi) and the tuning ratios.</p> <p>These opcodes are similar to cpstmid, but work without necessity of MIDI.</p> <p>cpstun works at k-rate. It allows fully customized micro-tuning scales. It requires a function table number containing the tuning ratios, and some other parameters stored in the function table itself.</p> <p>kindex arguments should be filled with integer numbers expressing the grade of given scale to be converted in cps. In cpstun, a new value is evaluated only when ktrig contains a non-zero value.  The function table kfn should be generated by GEN02 and the first four values stored in this function are parameters that express:</p> <ul> <li>numgrades -- The number of grades of the micro-tuning scale.</li> <li>interval -- The frequency range covered before repeating the grade ratios, for example 2 for one octave, 1.5 for a fifth etcetera.</li> <li>basefreq -- The base frequency of the scale in cycles per second.</li> <li>basekey -- The integer index of the scale to which to assign basefreq unmodified.</li> </ul> <p>After these four values, the user can begin to insert the tuning ratios.  For example, for a standard 12-grade scale with the base-frequency of 261 cps assigned to the key-number 60, the corresponding f-statement in the score to generate the table should be:</p> <pre><code>;           numgrades    basefreq     tuning-ratios (eq.temp) .......\n;                  interval    basekey\nf1 0 64 -2  12     2     261   60     1   1.059463 1.12246 1.18920 ..etc...\n</code></pre> <p>Another example with a 24-grade scale with a base frequency of 440 assigned to the key-number 48, and a repetition interval of 1.5:</p> <pre><code>;                  numgrades       basefreq      tuning-ratios .......\n;                          interval       basekey\nf1 0 64 -2         24      1.5     440    48     1   1.01  1.02  1.03   ..etc...\n</code></pre>"},{"location":"opcodes/cpstun/#examples","title":"Examples","text":"<p>Here is an example of the cpstun opcode. It uses the file cpstun.csd.</p> Example of the cpstun opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cpstun.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Table #1, a normal 12-tone equal temperament scale.\n; numgrades = 12 (twelve tones)\n; interval = 2 (one octave)\n; basefreq = 261.659 (Middle C)\n; basekeymidi = 60 (Middle C)\ngitemp ftgen 1, 0, 64, -2, 12, 2, 261.659, 60, 1.00, \\\n             1.059, 1.122, 1.189, 1.260, 1.335, 1.414, \\\n             1.498, 1.588, 1.682, 1.782, 1.888, 2.000\n\n; Instrument #1.\ninstr 1\n  ; Set the trigger.\n  ktrig init 1\n\n  ; Use Table #1.\n  kfn init 1\n\n  ; If the base key (note #60) is C, then 9 notes \n  ; above it (note #60 + 9 = note #69) should be A.\n  kindex init 69\n\n  k1 cpstun ktrig, kindex, kfn\n\n  printk2 k1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>i1   440.11044\n</code></pre>"},{"location":"opcodes/cpstun/#see-also","title":"See also","text":"<p>Pitch Converters: Tuning Opcodes</p>"},{"location":"opcodes/cpstun/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/cpstuni/","title":"Cpstuni","text":""},{"location":"opcodes/cpstuni/#cpstuni","title":"cpstuni","text":"<p>Returns micro-tuning values at init-rate.</p>"},{"location":"opcodes/cpstuni/#syntax","title":"Syntax","text":"<pre><code>icps cpstuni index, ifn\n</code></pre>"},{"location":"opcodes/cpstuni/#initialization","title":"Initialization","text":"<p>icps -- Return value in cycles per second.</p> <p>index -- An integer number denoting an index of scale.</p> <p>ifn -- Function table containing the parameters (numgrades, interval, basefreq, basekeymidi) and the tuning ratios.</p>"},{"location":"opcodes/cpstuni/#performance","title":"Performance","text":"<p>These opcodes are similar to cpstmid, but work without necessity of MIDI.</p> <p>cpstuni works at init-rate. It allows fully customized micro-tuning scales. It requires a function table number containing the tuning ratios, and some other parameters stored in the function table itself.</p> <p>The index argument should be filled with integer numbers expressing the grade of given scale to be converted in cps. The function table ifn should be generated by GEN02 and the first four values stored in this function are parameters that express:</p> <ul> <li>numgrades -- The number of grades of the micro-tuning scale.</li> <li>interval -- The frequency range covered before repeating the grade ratios, for example 2 for one octave, 1.5 for a fifth etcetera.</li> <li>basefreq -- The base frequency of the scale in cycles per second.</li> <li>basekey -- The integer index of the scale to which to assign basefreq unmodified.</li> </ul> <p>After these four values, the user can begin to insert the tuning ratios.  For example, for a standard 12-grade scale with the base-frequency of 261 cps assigned to the key-number 60, the corresponding f-statement in the score to generate the table should be:</p> <pre><code>;           numgrades    basefreq     tuning-ratios (eq.temp) .......\n;                  interval    basekey\nf1 0 64 -2  12     2     261   60     1   1.059463 1.12246 1.18920 ..etc...\n</code></pre> <p>Another example with a 24-grade scale with a base frequency of 440 assigned to the key-number 48, and a repetition interval of 1.5:</p> <pre><code>;                  numgrades       basefreq      tuning-ratios .......\n;                          interval       basekey\nf1 0 64 -2         24      1.5     440    48     1   1.01  1.02  1.03   ..etc...\n</code></pre>"},{"location":"opcodes/cpstuni/#examples","title":"Examples","text":"<p>Here is an example of the cpstuni opcode. It uses the file cpstuni.csd.</p> Example of the cpstuni opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cpstuni.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Table #1, a normal 12-tone equal temperament scale.\n; numgrades = 12 (twelve tones)\n; interval = 2 (one octave)\n; basefreq = 261.659 (Middle C)\n; basekeymidi = 60 (Middle C)\ngitemp ftgen 1, 0, 64, -2, 12, 2, 261.659, 60, 1.00, \\\n             1.059, 1.122, 1.189, 1.260, 1.335, 1.414, \\\n             1.498, 1.588, 1.682, 1.782, 1.888, 2.000\n\n; Instrument #1.\ninstr 1\n  ; Use Table #1.\n  ifn = 1\n\n  ; If the base key (note #60) is C, then 9 notes \n  ; above it (note #60 + 9 = note #69) should be A.\n  index = 69\n\n  i1 cpstuni index, ifn\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = 440.110\n</code></pre>"},{"location":"opcodes/cpstuni/#see-also","title":"See also","text":"<p>Pitch Converters: Tuning Opcodes</p>"},{"location":"opcodes/cpstuni/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/cpsxpch/","title":"Cpsxpch","text":""},{"location":"opcodes/cpsxpch/#cpsxpch","title":"cpsxpch","text":"<p>Converts a pitch-class value into cycles-per-second (Hz) for equal divisions of any interval.</p> <p>There is a restriction of no more than 100 equal divisions.</p>"},{"location":"opcodes/cpsxpch/#syntax","title":"Syntax","text":"<pre><code>icps cpsxpch ipch, iequal, irepeat, ibase\n</code></pre>"},{"location":"opcodes/cpsxpch/#initialization","title":"Initialization","text":"<p>ipch -- Input number of the form 8ve.pc, indicating an 'octave' and which note in the octave.</p> <p>iequal -- if positive, the number of equal intervals into which the 'octave' is divided. Must be less than or equal to 100. If negative, is the number of a table of frequency multipliers.</p> <p>irepeat -- Number indicating the interval which is the 'octave.' The integer 2 corresponds to octave divisions, 3 to a twelfth, 4 is two octaves, and so on. This need not be an integer, but must be positive.</p> <p>ibase -- The frequency which corresponds to pitch 0.0</p> <p> Note</p> <ol> <li>The following are essentially the same <pre><code>ia  =  cpspch(8.02)\nib     cps2pch  8.02, 12\nic     cpsxpch  8.02, 12, 2, 1.02197503906\n</code></pre></li> <li>These are opcodes not functions</li> <li>Negative values of ipch are allowed, but not negative irepeat, iequal or ibase.</li> </ol>"},{"location":"opcodes/cpsxpch/#examples","title":"Examples","text":"<p>Here is an example of the cpsxpch opcode. It uses the file cpsxpch.csd.</p> Example of the cpsxpch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cpsxpch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use a normal twelve-tone scale.\n  ipch = 8.02\n  iequal = 12\n  irepeat = 2\n  ibase = 1.02197503906\n\n  icps cpsxpch ipch, iequal, irepeat, ibase\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 293.666\n</code></pre> <p>Here is an example of the cpsxpch opcode using a 10.5 ET scale. It uses the file cpsxpch_105et.csd.</p> Example of the cpsxpch opcode using a 10.5 ET scale.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cpsxpch_105et.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use a 10.5ET scale.\n  ipch = 4.02\n  iequal = 21\n  irepeat = 4\n  ibase = 16.35160062496\n\n  icps cpsxpch ipch, iequal, irepeat, ibase\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 4776.824\n</code></pre> <p>Here is an example of the cpsxpch opcode using a Pierce scale centered on middle A. It uses the file cpsxpch_pierce.csd.</p> Example of the cpsxpch opcode using a Pierce scale centered on middle A.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o cpsxpch_pierce.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use a Pierce scale centered on middle A.\n  ipch = 2.02\n  iequal = 12\n  irepeat = 3\n  ibase = 261.62561\n\n  icps cpsxpch ipch, iequal, irepeat, ibase\n\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  icps = 2827.762\n</code></pre>"},{"location":"opcodes/cpsxpch/#see-also","title":"See also","text":"<p>Pitch Converters: Tuning Opcodes</p>"},{"location":"opcodes/cpsxpch/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK 1997</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/cpumeter/","title":"Cpumeter","text":""},{"location":"opcodes/cpumeter/#cpumeter","title":"cpumeter","text":"<p>Reports the usage of cpu either total or per core to monitor how close to max-out the processing is.</p> <p>Please note that this opcode is currently only supported on GNU/Linux .</p>"},{"location":"opcodes/cpumeter/#syntax","title":"Syntax","text":"<pre><code>ktot[,kcpu1, kcpu2,...]cpumeter ifreq\n</code></pre>"},{"location":"opcodes/cpumeter/#initialization","title":"Initialization","text":"<p>ifreq is the time in seconds that the meter is refreshed. If this is too low then mainly figures of zero or one hundred occur. A value of 0.1 seems acceptable.</p>"},{"location":"opcodes/cpumeter/#performance","title":"Performance","text":"<p>cpumeter reads the total idle time in the last ifreq seconds and reports it as a percentage usage.  If more than just ktot results are requested these report the same value for individual cores.</p>"},{"location":"opcodes/cpumeter/#examples","title":"Examples","text":"<p>Here is an example of the cpumeter opcode. It uses the file cpumeter.csd.</p> Example of the cpumeter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpumeter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 1\n0dbfs  = 1\n\n\ninstr 1 ;cpu metering; stop when too large\nk0   cpumeter   0.1\n     printk2 k0\n     if k0&gt;70 then\n       event \"i\", 3, 0.1, 1\n     endif\nendin\n\ninstr 2\n     event_i    \"i\", 2, 1, 1000\n     asig oscil 0.2, 440, 1\n     out asig\nendin\n\ninstr 3\n     exitnow\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 32768 10 1        ; sine wave\n\ni 1 0 1000\ni 2 0 1000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpumeter/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/cpumeter/#credits","title":"Credits","text":"<p>Author: John ffitch May 2011</p> <p>New in Csound version 5.14, for Linux/Unix and OSX only</p>"},{"location":"opcodes/cpuprc/","title":"Cpuprc","text":""},{"location":"opcodes/cpuprc/#cpuprc","title":"cpuprc","text":"<p>Control allocation of cpu resources on a per-instrument basis, to optimize realtime output.</p>"},{"location":"opcodes/cpuprc/#syntax","title":"Syntax","text":"<pre><code>cpuprc insnum, ipercent\ncpuprc Sinsname, ipercent\n</code></pre>"},{"location":"opcodes/cpuprc/#initialization","title":"Initialization","text":"<p>insnum -- instrument number or string</p> <p>Sinsname -- instrument number or string</p> <p>ipercent -- percent of cpu processing-time to assign. Can also be expressed as a fractional value.</p>"},{"location":"opcodes/cpuprc/#performance","title":"Performance","text":"<p>cpuprc sets the cpu processing-time percent usage of an instrument, in order to avoid buffer underrun in realtime performances, enabling a sort of polyphony theshold. The user must set ipercent value for each instrument to be activated in realtime. Assuming that the total theoretical processing time of the cpu of the computer is 100%, this percent value can only be defined empirically, because there are too many factors that contribute to limiting realtime polyphony in different computers.</p> <p>For example, if ipercent is set to 5% for instrument 1, the maximum number of voices that can be allocated in realtime, is 20 (5% * 20 = 100%). If the user attempts to play a further note while the 20 previous notes are still playing, Csound inhibits the allocation of that note and will display the following warning message:</p> <pre><code>cannot allocate last note because it exceeds 100% of cpu time\n</code></pre> <p>In order to avoid audio buffer underruns, it is suggested to set the maximum number of voices slightly lower than the real processing power of the computer. Sometimes an instrument can require more processing time than normal. If, for example, the instrument contains an oscillator which reads a table that does not fit in cache memory, it will be slower than normal. In addition, any program running concurrently in multitasking, can subtract processing power to varying degrees.</p> <p>At the start, all instruments are set to a default value of ipercent = 0.0% (i.e. zero processing time or rather infinite cpu processing-speed). This setting is OK for deferred-time sessions.</p> <p>All instances of cpuprc must be defined in the header section, not in the instrument body.</p>"},{"location":"opcodes/cpuprc/#examples","title":"Examples","text":"<p>Here is an example of the cpuprc opcode. It uses the file cpuprc.csd.</p> Example of the cpuprc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cpuprc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ncpuprc 1, 2\ncpuprc 2, 30\n\ninstr 1 ;cpu processing-time percent usage is set to 2% for each note\n\nasig oscil 0.2, 440, 1\n     outs asig, asig\n\nendin\n\ninstr 2 ;cpu processing-time percent usage is set to 30% for each note\n        ;so the 4 notes of the score exceeds 100% by far\nasig oscil 0.2, 440, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 32768 10 1        ; sine wave\n\ni 1 0 1\ni 1 0 1\ni 1 0 1\ni 1 0 1\n\n;too many notes to process,\n;check Csound output!\ni 2 3 1\ni 2 3 1\ni 2 3 1\ni 2 3 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cpuprc/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/cpuprc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy July, 1999</p> <p>New in Csound version 3.57; named instruments added version 5.13</p>"},{"location":"opcodes/cross2/","title":"Cross2","text":""},{"location":"opcodes/cross2/#cross2","title":"cross2","text":"<p>Cross synthesis using FFT's.</p> <p>This is an implementation of cross synthesis using FFT's.</p>"},{"location":"opcodes/cross2/#syntax","title":"Syntax","text":"<pre><code>ares cross2 ain1, ain2, isize, ioverlap, iwin, kbias\n</code></pre>"},{"location":"opcodes/cross2/#initialization","title":"Initialization","text":"<p>isize --  This is the size of the FFT to be performed. The larger the size the better the frequency response but a sloppy time response.</p> <p>ioverlap --  This is the overlap factor of the FFT's, must be a power of two. The best settings are 2 and 4.  A  big overlap takes a long time to compile.</p> <p>iwin --  This is the function table that contains the window to be used in the analysis. One can use the GEN20 routine to create this window.</p>"},{"location":"opcodes/cross2/#performance","title":"Performance","text":"<p>ain1 --  The stimulus sound.  Must have high frequencies for best results.</p> <p>ain2 --  The modulating sound.  Must have a moving frequency response (like speech) for best results.</p> <p>kbias --  The amount of cross synthesis.  1 is the normal, 0 is no cross synthesis.</p>"},{"location":"opcodes/cross2/#examples","title":"Examples","text":"<p>Here is an example of the cross2 opcode. It uses the file cross2.csd and fox.wav.</p> Example of the cross2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cross2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; after example from Kevin Conder\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ;play audio file\n\naout soundin \"fox.wav\"\n     outs aout, aout\nendin\n\ninstr 2 ;cross-synthesize\n\nicps = p4\nifn  = p5               ; Use the \"ahhc.aiff\" sound and \"eeec.aiff\"\nain1 oscil 0.6, p4, ifn\nain2 soundin \"fox.wav\"  ; Use the \"fox.wav\" as modulator\n\n  isize = 4096\n  ioverlap = 2\n  iwin = 3\n  kbias init 1\n\naout cross2 ain1, ain2, isize, ioverlap, iwin, kbias\n     outs aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;audio files\nf 1 0 128 1 \"ahhc.aiff\" 0 4 0\nf 2 0 128 1 \"eeec.aiff\" 0 4 0\n\nf 3 0 2048 20 2 ;windowing function\n\ni 1 0 3\n\ni 2 3 3  50     1 ;\"eeec.aiff\"\ni 2 + 3  50     2 ;\"ahhc.aiff\"\ni 2 + 3  100    1 ;\"eeec.aiff\"\ni 2 + 3  100    2 ;\"ahhc.aiff\"\ni 2 + 3  250    1 ;\"eeec.aiff\"\ni 2 + 3  250    2 ;\"ahhc.aiff\"\ni 2 + 3  20     1 ;\"eeec.aiff\"\ni 2 + 3  20     2 ;\"ahhc.aiff\"\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/cross2/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/cross2/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1997</p>"},{"location":"opcodes/crossfm/","title":"Crossfm","text":""},{"location":"opcodes/crossfm/#crossfm","title":"crossfm","text":"<p>Two oscillators, mutually frequency and/or phase modulated by each other.</p>"},{"location":"opcodes/crossfm/#syntax","title":"Syntax","text":"<pre><code>a1, a2 crossfm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 crossfmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 crosspm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 crosspmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 crossfmpm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\na1, a2 crossfmpmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]\n</code></pre>"},{"location":"opcodes/crossfm/#initialization","title":"Initialization","text":"<p>ifn1 -- function table number for oscillator #1. Requires a wrap-around guard point.</p> <p>ifn2 -- function table number for oscillator #2. Requires a wrap-around guard point.</p> <p>iphs1 (optional, default=0) -- initial phase of waveform in table ifn1, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped.</p> <p>iphs2 (optional, default=0) -- initial phase of waveform in table ifn2, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped.</p>"},{"location":"opcodes/crossfm/#performance","title":"Performance","text":"<p>xfrq1 -- a factor that, when multipled by the kcps parameter, gives the frequency of oscillator #1.</p> <p>xfrq2 -- a factor that, when multipled by the kcps parameter, gives the frequency of oscillator #2.</p> <p>xndx1 -- the index of the modulation of oscillator #2 by oscillator #1.</p> <p>xndx2 -- the index of the modulation of oscillator #1 by oscillator #2.</p> <p>kcps -- a common denominator, in cycles per second, for both oscillators frequencies.</p> <p>crossfm implements a crossed frequency modulation algorithm. The audio-rate output of oscillator #1 is used to modulate the frequency input of oscillator #2 while the audio-rate output of oscillator #2 is used to modulate the frequency input of oscillator #1. This double feedback structure produces a rich set of sounds with some chaotic behaviour. crossfmi behaves like crossfm except that linear interpolation is used for table lookup.</p> <p>crosspm and crosspmi implement cross phase modulation between two oscillators.</p> <p>crossfmpm and crossfmpmi implement cross frequency/phase modulation between two oscillators. Oscillator #1 is frequency-modulated by oscillator #2 while oscillator #2 is phase-modulated by oscillator #1.</p> <p> Warning</p> <p>Those opcodes may produce very rich spectra, especially with high modulation indexes, and in some cases foldover aliases may occur if the sampling rate is not high enough. Moreover the audio output may vary in function of the sampling rate, due to the non-linearity of the algorithm. In Csound, two other opcodes have this characteristic: planet and chuap.</p>"},{"location":"opcodes/crossfm/#examples","title":"Examples","text":"<p>Here is an example of the crossfm opcode. It uses the file crossfm.csd.</p> Example of the crossfm opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n  -d -o dac\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr     = 48000\nksmps  = 10\nnchnls = 2\n0dbfs  = 1\n\n          instr 1\nidur       =          p3 \niamp       =          p4 \nifrq1      =          p5 \nifrq2      =          p6 \nindx1      =          p7 \nindx2      =          p8 \nkenv       linen      iamp, 0.05, idur, 0.2 \na1, a2     crossfm    ifrq1, ifrq2, indx1, indx2, 1, 1, 1 \n           outs       a1*kenv, a2*kenv \n          endin\n\n          instr 2\nkx         init       0.0 \nkdx        init       0.1 \nkdur       init       p4 \nkamp       init       p5 \nkndx       init       0 \nkmax       init       p6 \nkfq1       init       440.0 \nkfq2       init       557.0 \nknx1       init       3.5 \nknx2       init       4.8 \n           event      \"i\", 1, kx, kdur, kamp, kfq1, kfq2, knx1, knx2 \nkx         =          kx + kdx \nknx1       =          knx1 - 0.025 \nknx2       =          knx2 - 0.075 \nkndx       =          kndx + 1 \nif (kndx &lt;= kmax) kgoto nextone\n           turnoff \nnextone: \n          endin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf 1 0 16384 10 1 0\n\ni 2 0 2 0.67 0.16 150\ni 1 15.1 1.5 0.1 440 557 -0.25 -6.45 0.05 1.2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/crossfm/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p> <p>More information on these opcodes: http://www.csoundjournal.com/issue12/crossfm.html.</p>"},{"location":"opcodes/crossfm/#credits","title":"Credits","text":"<p>Author: Fran\u00e7ois Pinot 2005-2009</p> <p>New in version 5.12</p>"},{"location":"opcodes/crunch/","title":"Crunch","text":""},{"location":"opcodes/crunch/#crunch","title":"crunch","text":"<p>Semi-physical model of a crunch sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/crunch/#syntax","title":"Syntax","text":"<pre><code>ares crunch iamp, idettack [, inum] [, idamp] [, imaxshake]\n</code></pre>"},{"location":"opcodes/crunch/#initialization","title":"Initialization","text":"<p>iamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only a approximation.</p> <p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 7.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.998 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.99806 which means that the default value of idamp is 0.03. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 1.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p>"},{"location":"opcodes/crunch/#examples","title":"Examples","text":"<p>Here is an example of the crunch opcode. It uses the file crunch.csd.</p> Example of the crunch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o crunch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nasig   crunch 0.8, 0.1, 7, p4\n       outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 .9\ni1 1 1 .1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/crunch/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/crunch/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhOLIES (Physically-Oriented Library of Imitated Environmental Sounds) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/ctrl14/","title":"Ctrl14","text":""},{"location":"opcodes/ctrl14/#ctrl14","title":"ctrl14","text":"<p>Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/ctrl14/#syntax","title":"Syntax","text":"<pre><code>idest ctrl14 ichan, ictlno1, ictlno2, imin, imax [, ifn]\nkdest ctrl14 ichan, ictlno1, ictlno2, kmin, kmax [, ifn]\n</code></pre>"},{"location":"opcodes/ctrl14/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ichan -- MIDI channel number (1-16)</p> <p>ictln1o -- most-significant byte controller number (0-127)</p> <p>ictlno2 -- least-significant byte controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to imax and imin val.</p>"},{"location":"opcodes/ctrl14/#performance","title":"Performance","text":"<p>kdest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>ctrl14 (i- and k-rate 14 bit MIDI control) allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range. The minimum and maximum values can be varied at k-rate. It can use optional interpolated table indexing. It requires two MIDI controllers as input.</p> <p>ctrl14 differs from midic14 because it can be included in score-oriented instruments without Csound crashes. It needs the additional parameter ichan containing the MIDI channel of the controller. MIDI channel is the same for all the controllers used in a single ctrl14 opcode.</p>"},{"location":"opcodes/ctrl14/#examples","title":"Examples","text":"<p>Here is an example of the ctrl14 opcode. It uses the file ctrl14.csd.</p> Example of the ctrl14 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; expects MIDI controller input on channel 1\n; run and move your midi controller to see result\n\nimax = 1\nimin = 0\nichan = 1 \nictlno = 7\n\n        initc14 1, ictlno, ictlno+1, 1                  ; start at max. volume\nkamp    ctrl14  ichan, ictlno, ictlno+1, imin, imax     ; controller 7\n        printk2 kamp\nasig    oscil   kamp, 220, 1\n        outs    asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrl14/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrl14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/ctrl21/","title":"Ctrl21","text":""},{"location":"opcodes/ctrl21/#ctrl21","title":"ctrl21","text":"<p>Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/ctrl21/#syntax","title":"Syntax","text":"<pre><code>idest ctrl21 ichan, ictlno1, ictlno2, ictlno3, imin, imax [, ifn]\nkdest ctrl21 ichan, ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]\n</code></pre>"},{"location":"opcodes/ctrl21/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ichan -- MIDI channel number (1-16)</p> <p>ictlno1 -- most-significant byte controller number (0-127)</p> <p>ictlno2 -- mid-significant byte controller number (0-127)</p> <p>ictlno3 -- least-significant byte controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to imax and imin val.</p>"},{"location":"opcodes/ctrl21/#performance","title":"Performance","text":"<p>kdest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>ctrl21 (i- and k-rate 21 bit MIDI control) allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range. Minimum and maximum values can be varied at k-rate. It can use optional interpolated table indexing. It requires three MIDI controllers as input.</p> <p>ctrl21 differs from midic21 because it can be included in score oriented instruments without Csound crashes. It needs the additional parameter ichan containing the MIDI channel of the controller. MIDI channel is the same for all the controllers used in a single ctrl21 opcode.</p>"},{"location":"opcodes/ctrl21/#examples","title":"Examples","text":"<p>Here is an example of the ctrl21 opcode. It uses the file ctrl21.csd.</p> Example of the ctrl21 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; expects MIDI controller input on channel 1\n; run and move your midi controller to see result\n\nimax = 1\nimin = 0\nichan = 1 \nictlno = 7\n\n        initc21 1, ictlno, ictlno+1, ictlno+2. 1                        ; start at max. volume\nkamp    ctrl21  ichan, ictlno, ictlno+1, ictlno+2, imin, imax   ; controller 7\n        printk2 kamp\nasig    oscil   kamp, 220, 1\n        outs    asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrl21/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrl21/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/ctrl7/","title":"Ctrl7","text":""},{"location":"opcodes/ctrl7/#ctrl7","title":"ctrl7","text":"<p>Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/ctrl7/#syntax","title":"Syntax","text":"<pre><code>idest ctrl7 ichan, ictlno, imin, imax [, ifn]\nkdest ctrl7 ichan, ictlno, kmin, kmax [, ifn]\nadest ctrl7 ichan, ictlno, kmin, kmax [, ifn] [, icutoff]\n</code></pre>"},{"location":"opcodes/ctrl7/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlno -- MIDI controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to imax and imin val.</p> <p>icutoff (optional) -- low pass filter cut-off frequency for smoothing a-rate output.</p>"},{"location":"opcodes/ctrl7/#performance","title":"Performance","text":"<p>kdest, adest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>ctrl7 (i- and k-rate 7 bit MIDI control) allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range. It also allows optional non-interpolated table indexing. Minimum and maximum values can be varied at k-rate.</p> <p>ctrl7 differs from midic7 because it can be included in score-oriented instruments without Csound crashes. It also needs the additional parameter ichan containing the MIDI channel of the controller.</p> <p>The a-rate version of ctrl7 outputs an a-rate variable, which is low-pass filtered (smoothed). It contains an optional icutoff parameter, to set the cutoff frecuency for the low-pass filter. The default is 5.</p>"},{"location":"opcodes/ctrl7/#examples","title":"Examples","text":"<p>Here is an example of the ctrl7 opcode. It uses the file ctrl7.csd.</p> Example of the ctrl7 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -M0  ;;;RT audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; expects MIDI controller input on channel 1\n; run and move your midi controller to see result\n\nimax = 1\nimin = 0\nichan = 1 \nictlno = 7\n\n        initc7  1, 7, 1                 ; start at max. volume\nkamp    ctrl7   ichan, ictlno, imin, imax       ; controller 7\n        printk2 kamp\nasig    oscil   kamp, 220, 1\n        outs    asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p> Note</p> <p>ctrl7 only outputs k values once the controller is first moved. To set an initial k-value, a call to initc7 is required. Ctrlinit does not work for this purpose.</p>"},{"location":"opcodes/ctrl7/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrl7/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p> <p>The a-rate version of ctrl7 was added in version 5.06</p>"},{"location":"opcodes/ctrlinit/","title":"Ctrlinit","text":""},{"location":"opcodes/ctrlinit/#ctrlinit","title":"ctrlinit","text":"<p>Sets the initial values for a set of MIDI controllers.</p>"},{"location":"opcodes/ctrlinit/#syntax","title":"Syntax","text":"<pre><code>ctrlinit ichnl, ictlno1, ival1 [, ictlno2] [, ival2] [, ictlno3] \\\n         [, ival3] [,...ival32]\n</code></pre>"},{"location":"opcodes/ctrlinit/#initialization","title":"Initialization","text":"<p>ichnl -- MIDI channel number (1-16)</p> <p>ictlno1, ictlno1, etc. -- MIDI controller numbers (0-127)</p> <p>ival1, ival2, etc. -- initial value for corresponding MIDI controller number, in the range 0 to 127.</p> <p> Note</p> <p>If this opcode is to be used with a scaling opcode such as ctrl7 the ival1..  should be 127*(initial-min)/(max-min)</p>"},{"location":"opcodes/ctrlinit/#performance","title":"Performance","text":"<p>Sets the initial values for a set of MIDI controllers.</p>"},{"location":"opcodes/ctrlinit/#examples","title":"Examples","text":"<p>Here is an example of the ctrlinit opcode. It uses the file ctrlinit.csd.</p> Example of the ctrlinit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nnchnls = 1\n0dbfs = 1\n\nctrlinit 1,1,64 ; init control to 64.\n\ninstr 1\n kval ctrl7 1,1,0,1  ; read in the range 0-1\n printk2 kval   ; prints 0.50394\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlinit/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/ctrlinit/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT, Cambridge, Mass.</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/ctrlpreset/","title":"Ctrlpreset","text":""},{"location":"opcodes/ctrlpreset/#ctrlpreset","title":"ctrlpreset","text":"<p>Defines a preset for MIDI controllers.</p>"},{"location":"opcodes/ctrlpreset/#syntax","title":"Syntax","text":"<pre><code>kpreset ctrlpreset ktag, kchnl, kctlno1, [kctlno2] [, kctlno3] ...\n</code></pre>"},{"location":"opcodes/ctrlpreset/#initialization","title":"Initialization","text":"<p>At initialisation time an internal data structure is created to save the preset, ensuring it is sufficiently large.</p>"},{"location":"opcodes/ctrlpreset/#performance","title":"Performance","text":"<p>kpreset -- the numeric tag for where the preset it stored.  If ktag is not zero kpreset will be the same as ktag.</p> <p>ktag -- the tag for this preset; either a strictly positive integer or zero if the system is to allocate an unused preset.</p> <p>kchanl -- the MIDI channel to which the preset refers.</p> <p>kctlno1, kctlno1, etc. -- MIDI controller numbers and values (0-127).  up to 16 initialisation values are permitted.</p>"},{"location":"opcodes/ctrlpreset/#examples","title":"Examples","text":"<p>Here is an example of the ctrlpreset opcode. It uses the file ctrls.csd.</p> Example of the ctrlpreset opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n// -o dac -M hw:1,0,0  ; Terminal\n// -Mhw:1,0,0 -+rtmidi=NULL --daemon -dm0 ;  Bela\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; by John ffitch and Richard Boulanger\nctrlinit  1, 21,101, 22,11, 23,12, 24,16, 25,0, 26,82      ; Starting Preset\ninstr 42   ; A Bank of Controller Presets - selected by ASCII Key Numbers 1-&gt;9 and a,b,c,d in instr 1 below\n\nkpre1  ctrlpreset  0, 1, 21, 101, 22, 94, 23, 01, 24, 06, 25, 14, 26, 02 ; Preset 1 = ASCII 1\nkpre2  ctrlpreset  0, 1, 21, 102, 22, 57, 23, 76, 24, 55, 25, 77, 26, 12 ; Preset 2 = ASCII 2\nkpre3  ctrlpreset  0, 1, 21, 103, 22, 12, 23, 13, 24, 16, 25, 84, 26, 22 ; Preset 3 = ASCII 3\nkpre4  ctrlpreset  0, 1, 21, 104, 22, 83, 23, 18, 24, 13, 25, 24, 26, 32 ; Preset 4 = ASCII 4\nkpre5  ctrlpreset  0, 1, 21, 105, 22, 20, 23, 48, 24, 33, 25, 94, 26, 42 ; Preset 5 = ASCII 5\nkpre6  ctrlpreset  0, 1, 21, 106, 22, 52, 23, 10, 24, 03, 25, 68, 26, 52 ; Preset 6 = ASCII 6\nkpre7  ctrlpreset  0, 1, 21, 107, 22, 09, 23, 02, 24, 07, 25, 01, 26, 02 ; Preset 7 = ASCII 7\nkpre8  ctrlpreset  0, 1, 21, 108, 22, 34, 23, 10, 24, 96, 25, 44, 26, 42 ; Preset 8 = ASCII 8\nkpre9  ctrlpreset  0, 1, 21, 109, 22, 04, 23, 91, 24, 66, 25, 04, 26, 92 ; Preset 9 = ASCII 9\nkpre10 ctrlpreset  0, 1, 21, 110, 22, 04, 23, 10, 24, 66, 25, 44, 26, 22 ; Preset 10 = ASCII 'a'\nkpre11 ctrlpreset  0, 1, 21, 111, 22, 07, 23, 46, 24, 45, 25, 17, 26, 32 ; Preset 11 = ASCII 'b'\nkpre12 ctrlpreset  0, 1, 21, 112, 22, 22, 23, 03, 24, 06, 25, 04, 26, 42 ; Preset 12 = ASCII 'c'\nkpre13 ctrlpreset  0, 1, 21, 113, 22, 43, 23, 98, 24, 93, 25, 94, 26, 52 ; Preset 13 = ASCII 'd'\nctrlprintpresets ; print the CC Presets in the console in response to the 'i42 0 0.1' note in score\nctrlprintpresets \"./my_ctrlpresets.txt\"   ; print the CC Presets to a file\nturnoff\nendin\ninstr  1\nkc[] init 6\nicps cpsmidi\niamp ampmidi 0.6\nkvol midic7  21, 0,1\nkcar midic7  22, 1,10\nkmod midic7  23, .1,10\nkndx midic7  24, 1,30\nkndx port    kndx,.1\niatk midic7  25, .01,1\nirel midic7  26, .01,2\nkpre midic7  28, 1,13   ; use CC 28 to select from the preset 1 - 13 above\nktrig changed2 kpre\nif ktrig == 1 then\nkpre = int(kpre)\n  ctrlselect kpre\n  printk2 kpre\nendif\nasig  foscil iamp, icps, kcar, kmod, kndx, 1\nkmgate linsegr 0, iatk, 1, irel, 0\nouts  (asig*kmgate)*kvol, (asig*kmgate)*kvol\nkc   ctrlsave 1, 21,22,23,24,25,26    ; MIDI Channel and CC values to read &amp; save (Chan1 &amp; CC21-&gt;CC26)\nkchar  sensekey                       ; CC values printed to console after playing next note\nif kchar != 65 goto end0              ; ASCII character \"65\" is the letter 'A' (shift-a)\n ctrlprint kc                         ; prints Controller Settings (CC Presets) to the console\n ctrlprint kc, \"./my_ctrlinits.txt\"   ; appends Controller Settings (CC Presets) to a file\nend0:\nif kchar&lt;49 || kchar&gt;57 goto end1     ; ASCII numbers 1 -&gt; 9\n kval = kchar - 48\n ctrlselect kval\nend1:\nif kchar &lt;97 || kchar&gt;122 goto end2   ; ASCII numbers 10 -&gt; 36 (lower-case letters a -&gt; z)\n  kval = (kchar - 97) + 10\n  ctrlselect kval\n end2:\nif kchar != 86  goto end3                     ; ASCII character \"86\" is the letter 'V' (shift-v)\n kk ctrlpreset 0,kc                           ; adding and numbering the current state as a preset to the list\n ctrlprintpresets                             ; prints Controller Presets (CC Presets) to the console\n ctrlprintpresets \"./my_ctrlpresets.txt\"      ; appends Controller Presets (CC Presets) to a file\nend3:\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 6000\nf1 0 8192 10 1\ni42 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlpreset/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrlpreset/#credits","title":"Credits","text":"<p>Authors: John ffitch and Richard Boulanger</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/ctrlprint/","title":"Ctrlprint","text":""},{"location":"opcodes/ctrlprint/#ctrlprint","title":"ctrlprint","text":"<p>Print the saved values of MIDI controllers from an array to the console or a file.</p>"},{"location":"opcodes/ctrlprint/#syntax","title":"Syntax","text":"<pre><code>ctrlprint kcont[][, Sfile]\n</code></pre>"},{"location":"opcodes/ctrlprint/#initialization","title":"Initialization","text":"<p>Sfile -- File name to receive the values. If omitted it writes to the console.</p>"},{"location":"opcodes/ctrlprint/#performance","title":"Performance","text":"<p>kcont -- the array of controls as saved by ctrlsave.</p>"},{"location":"opcodes/ctrlprint/#examples","title":"Examples","text":"<p>Here is an example of the ctrlprint opcode. It uses the file ctrls.csd.</p> Example of the ctrlprint opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n// -o dac -M hw:1,0,0  ; Terminal\n// -Mhw:1,0,0 -+rtmidi=NULL --daemon -dm0 ;  Bela\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; by John ffitch and Richard Boulanger\nctrlinit  1, 21,101, 22,11, 23,12, 24,16, 25,0, 26,82      ; Starting Preset\ninstr 42   ; A Bank of Controller Presets - selected by ASCII Key Numbers 1-&gt;9 and a,b,c,d in instr 1 below\n\nkpre1  ctrlpreset  0, 1, 21, 101, 22, 94, 23, 01, 24, 06, 25, 14, 26, 02 ; Preset 1 = ASCII 1\nkpre2  ctrlpreset  0, 1, 21, 102, 22, 57, 23, 76, 24, 55, 25, 77, 26, 12 ; Preset 2 = ASCII 2\nkpre3  ctrlpreset  0, 1, 21, 103, 22, 12, 23, 13, 24, 16, 25, 84, 26, 22 ; Preset 3 = ASCII 3\nkpre4  ctrlpreset  0, 1, 21, 104, 22, 83, 23, 18, 24, 13, 25, 24, 26, 32 ; Preset 4 = ASCII 4\nkpre5  ctrlpreset  0, 1, 21, 105, 22, 20, 23, 48, 24, 33, 25, 94, 26, 42 ; Preset 5 = ASCII 5\nkpre6  ctrlpreset  0, 1, 21, 106, 22, 52, 23, 10, 24, 03, 25, 68, 26, 52 ; Preset 6 = ASCII 6\nkpre7  ctrlpreset  0, 1, 21, 107, 22, 09, 23, 02, 24, 07, 25, 01, 26, 02 ; Preset 7 = ASCII 7\nkpre8  ctrlpreset  0, 1, 21, 108, 22, 34, 23, 10, 24, 96, 25, 44, 26, 42 ; Preset 8 = ASCII 8\nkpre9  ctrlpreset  0, 1, 21, 109, 22, 04, 23, 91, 24, 66, 25, 04, 26, 92 ; Preset 9 = ASCII 9\nkpre10 ctrlpreset  0, 1, 21, 110, 22, 04, 23, 10, 24, 66, 25, 44, 26, 22 ; Preset 10 = ASCII 'a'\nkpre11 ctrlpreset  0, 1, 21, 111, 22, 07, 23, 46, 24, 45, 25, 17, 26, 32 ; Preset 11 = ASCII 'b'\nkpre12 ctrlpreset  0, 1, 21, 112, 22, 22, 23, 03, 24, 06, 25, 04, 26, 42 ; Preset 12 = ASCII 'c'\nkpre13 ctrlpreset  0, 1, 21, 113, 22, 43, 23, 98, 24, 93, 25, 94, 26, 52 ; Preset 13 = ASCII 'd'\nctrlprintpresets ; print the CC Presets in the console in response to the 'i42 0 0.1' note in score\nctrlprintpresets \"./my_ctrlpresets.txt\"   ; print the CC Presets to a file\nturnoff\nendin\ninstr  1\nkc[] init 6\nicps cpsmidi\niamp ampmidi 0.6\nkvol midic7  21, 0,1\nkcar midic7  22, 1,10\nkmod midic7  23, .1,10\nkndx midic7  24, 1,30\nkndx port    kndx,.1\niatk midic7  25, .01,1\nirel midic7  26, .01,2\nkpre midic7  28, 1,13   ; use CC 28 to select from the preset 1 - 13 above\nktrig changed2 kpre\nif ktrig == 1 then\nkpre = int(kpre)\n  ctrlselect kpre\n  printk2 kpre\nendif\nasig  foscil iamp, icps, kcar, kmod, kndx, 1\nkmgate linsegr 0, iatk, 1, irel, 0\nouts  (asig*kmgate)*kvol, (asig*kmgate)*kvol\nkc   ctrlsave 1, 21,22,23,24,25,26    ; MIDI Channel and CC values to read &amp; save (Chan1 &amp; CC21-&gt;CC26)\nkchar  sensekey                       ; CC values printed to console after playing next note\nif kchar != 65 goto end0              ; ASCII character \"65\" is the letter 'A' (shift-a)\n ctrlprint kc                         ; prints Controller Settings (CC Presets) to the console\n ctrlprint kc, \"./my_ctrlinits.txt\"   ; appends Controller Settings (CC Presets) to a file\nend0:\nif kchar&lt;49 || kchar&gt;57 goto end1     ; ASCII numbers 1 -&gt; 9\n kval = kchar - 48\n ctrlselect kval\nend1:\nif kchar &lt;97 || kchar&gt;122 goto end2   ; ASCII numbers 10 -&gt; 36 (lower-case letters a -&gt; z)\n  kval = (kchar - 97) + 10\n  ctrlselect kval\n end2:\nif kchar != 86  goto end3                     ; ASCII character \"86\" is the letter 'V' (shift-v)\n kk ctrlpreset 0,kc                           ; adding and numbering the current state as a preset to the list\n ctrlprintpresets                             ; prints Controller Presets (CC Presets) to the console\n ctrlprintpresets \"./my_ctrlpresets.txt\"      ; appends Controller Presets (CC Presets) to a file\nend3:\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 6000\nf1 0 8192 10 1\ni42 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlprint/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrlprint/#credits","title":"Credits","text":"<p>Authors: John ffitch and Richard Boulanger</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/ctrlprintpresets/","title":"Ctrlprintpresets","text":""},{"location":"opcodes/ctrlprintpresets/#ctrlprintpresets","title":"ctrlprintpresets","text":"<p>Prints the current collection of presets for MIDI controllers in a format that can be used in an orchestra, to the console or a file.</p>"},{"location":"opcodes/ctrlprintpresets/#syntax","title":"Syntax","text":"<pre><code>ctrlprintpresets [Sfilenam]\n</code></pre>"},{"location":"opcodes/ctrlprintpresets/#initialization","title":"Initialization","text":"<p>At initialisation time the existence of the internal data structure is checked.</p>"},{"location":"opcodes/ctrlprintpresets/#performance","title":"Performance","text":"<p>Sfilename -- (optional) file to which to print.  If omitted it uses the current output.</p>"},{"location":"opcodes/ctrlprintpresets/#examples","title":"Examples","text":"<p>Here is an example of the ctrlprintpresets opcode. It uses the file ctrls.csd.</p> Example of the ctrlprintpresets opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n// -o dac -M hw:1,0,0  ; Terminal\n// -Mhw:1,0,0 -+rtmidi=NULL --daemon -dm0 ;  Bela\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; by John ffitch and Richard Boulanger\nctrlinit  1, 21,101, 22,11, 23,12, 24,16, 25,0, 26,82      ; Starting Preset\ninstr 42   ; A Bank of Controller Presets - selected by ASCII Key Numbers 1-&gt;9 and a,b,c,d in instr 1 below\n\nkpre1  ctrlpreset  0, 1, 21, 101, 22, 94, 23, 01, 24, 06, 25, 14, 26, 02 ; Preset 1 = ASCII 1\nkpre2  ctrlpreset  0, 1, 21, 102, 22, 57, 23, 76, 24, 55, 25, 77, 26, 12 ; Preset 2 = ASCII 2\nkpre3  ctrlpreset  0, 1, 21, 103, 22, 12, 23, 13, 24, 16, 25, 84, 26, 22 ; Preset 3 = ASCII 3\nkpre4  ctrlpreset  0, 1, 21, 104, 22, 83, 23, 18, 24, 13, 25, 24, 26, 32 ; Preset 4 = ASCII 4\nkpre5  ctrlpreset  0, 1, 21, 105, 22, 20, 23, 48, 24, 33, 25, 94, 26, 42 ; Preset 5 = ASCII 5\nkpre6  ctrlpreset  0, 1, 21, 106, 22, 52, 23, 10, 24, 03, 25, 68, 26, 52 ; Preset 6 = ASCII 6\nkpre7  ctrlpreset  0, 1, 21, 107, 22, 09, 23, 02, 24, 07, 25, 01, 26, 02 ; Preset 7 = ASCII 7\nkpre8  ctrlpreset  0, 1, 21, 108, 22, 34, 23, 10, 24, 96, 25, 44, 26, 42 ; Preset 8 = ASCII 8\nkpre9  ctrlpreset  0, 1, 21, 109, 22, 04, 23, 91, 24, 66, 25, 04, 26, 92 ; Preset 9 = ASCII 9\nkpre10 ctrlpreset  0, 1, 21, 110, 22, 04, 23, 10, 24, 66, 25, 44, 26, 22 ; Preset 10 = ASCII 'a'\nkpre11 ctrlpreset  0, 1, 21, 111, 22, 07, 23, 46, 24, 45, 25, 17, 26, 32 ; Preset 11 = ASCII 'b'\nkpre12 ctrlpreset  0, 1, 21, 112, 22, 22, 23, 03, 24, 06, 25, 04, 26, 42 ; Preset 12 = ASCII 'c'\nkpre13 ctrlpreset  0, 1, 21, 113, 22, 43, 23, 98, 24, 93, 25, 94, 26, 52 ; Preset 13 = ASCII 'd'\nctrlprintpresets ; print the CC Presets in the console in response to the 'i42 0 0.1' note in score\nctrlprintpresets \"./my_ctrlpresets.txt\"   ; print the CC Presets to a file\nturnoff\nendin\ninstr  1\nkc[] init 6\nicps cpsmidi\niamp ampmidi 0.6\nkvol midic7  21, 0,1\nkcar midic7  22, 1,10\nkmod midic7  23, .1,10\nkndx midic7  24, 1,30\nkndx port    kndx,.1\niatk midic7  25, .01,1\nirel midic7  26, .01,2\nkpre midic7  28, 1,13   ; use CC 28 to select from the preset 1 - 13 above\nktrig changed2 kpre\nif ktrig == 1 then\nkpre = int(kpre)\n  ctrlselect kpre\n  printk2 kpre\nendif\nasig  foscil iamp, icps, kcar, kmod, kndx, 1\nkmgate linsegr 0, iatk, 1, irel, 0\nouts  (asig*kmgate)*kvol, (asig*kmgate)*kvol\nkc   ctrlsave 1, 21,22,23,24,25,26    ; MIDI Channel and CC values to read &amp; save (Chan1 &amp; CC21-&gt;CC26)\nkchar  sensekey                       ; CC values printed to console after playing next note\nif kchar != 65 goto end0              ; ASCII character \"65\" is the letter 'A' (shift-a)\n ctrlprint kc                         ; prints Controller Settings (CC Presets) to the console\n ctrlprint kc, \"./my_ctrlinits.txt\"   ; appends Controller Settings (CC Presets) to a file\nend0:\nif kchar&lt;49 || kchar&gt;57 goto end1     ; ASCII numbers 1 -&gt; 9\n kval = kchar - 48\n ctrlselect kval\nend1:\nif kchar &lt;97 || kchar&gt;122 goto end2   ; ASCII numbers 10 -&gt; 36 (lower-case letters a -&gt; z)\n  kval = (kchar - 97) + 10\n  ctrlselect kval\n end2:\nif kchar != 86  goto end3                     ; ASCII character \"86\" is the letter 'V' (shift-v)\n kk ctrlpreset 0,kc                           ; adding and numbering the current state as a preset to the list\n ctrlprintpresets                             ; prints Controller Presets (CC Presets) to the console\n ctrlprintpresets \"./my_ctrlpresets.txt\"      ; appends Controller Presets (CC Presets) to a file\nend3:\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 6000\nf1 0 8192 10 1\ni42 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlprintpresets/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrlprintpresets/#credits","title":"Credits","text":"<p>Authors: John ffitch and Richard Boulanger</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/ctrlsave/","title":"Ctrlsave","text":""},{"location":"opcodes/ctrlsave/#ctrlsave","title":"ctrlsave","text":"<p>Recovers the current values of MIDI controllers to a k-array.</p>"},{"location":"opcodes/ctrlsave/#syntax","title":"Syntax","text":"<pre><code>kconnt[] ctrlsave ichnl, ictlno1, [ictlno2] [, ictlno3] ...\n</code></pre>"},{"location":"opcodes/ctrlsave/#initialization","title":"Initialization","text":"<p>ichnl -- MIDI channel number (1-16)</p> <p>ictlno1, ictlno1, etc. -- MIDI controller numbers (0-127)</p>"},{"location":"opcodes/ctrlsave/#performance","title":"Performance","text":"<p>Sets the array kcontrl to the current values of MIDI controllers indicated.</p>"},{"location":"opcodes/ctrlsave/#examples","title":"Examples","text":"<p>Here is an example of the ctrlsave opcode. It uses the file ctrls.csd.</p> Example of the ctrlsave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n// -o dac -M hw:1,0,0  ; Terminal\n// -Mhw:1,0,0 -+rtmidi=NULL --daemon -dm0 ;  Bela\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; by John ffitch and Richard Boulanger\nctrlinit  1, 21,101, 22,11, 23,12, 24,16, 25,0, 26,82      ; Starting Preset\ninstr 42   ; A Bank of Controller Presets - selected by ASCII Key Numbers 1-&gt;9 and a,b,c,d in instr 1 below\n\nkpre1  ctrlpreset  0, 1, 21, 101, 22, 94, 23, 01, 24, 06, 25, 14, 26, 02 ; Preset 1 = ASCII 1\nkpre2  ctrlpreset  0, 1, 21, 102, 22, 57, 23, 76, 24, 55, 25, 77, 26, 12 ; Preset 2 = ASCII 2\nkpre3  ctrlpreset  0, 1, 21, 103, 22, 12, 23, 13, 24, 16, 25, 84, 26, 22 ; Preset 3 = ASCII 3\nkpre4  ctrlpreset  0, 1, 21, 104, 22, 83, 23, 18, 24, 13, 25, 24, 26, 32 ; Preset 4 = ASCII 4\nkpre5  ctrlpreset  0, 1, 21, 105, 22, 20, 23, 48, 24, 33, 25, 94, 26, 42 ; Preset 5 = ASCII 5\nkpre6  ctrlpreset  0, 1, 21, 106, 22, 52, 23, 10, 24, 03, 25, 68, 26, 52 ; Preset 6 = ASCII 6\nkpre7  ctrlpreset  0, 1, 21, 107, 22, 09, 23, 02, 24, 07, 25, 01, 26, 02 ; Preset 7 = ASCII 7\nkpre8  ctrlpreset  0, 1, 21, 108, 22, 34, 23, 10, 24, 96, 25, 44, 26, 42 ; Preset 8 = ASCII 8\nkpre9  ctrlpreset  0, 1, 21, 109, 22, 04, 23, 91, 24, 66, 25, 04, 26, 92 ; Preset 9 = ASCII 9\nkpre10 ctrlpreset  0, 1, 21, 110, 22, 04, 23, 10, 24, 66, 25, 44, 26, 22 ; Preset 10 = ASCII 'a'\nkpre11 ctrlpreset  0, 1, 21, 111, 22, 07, 23, 46, 24, 45, 25, 17, 26, 32 ; Preset 11 = ASCII 'b'\nkpre12 ctrlpreset  0, 1, 21, 112, 22, 22, 23, 03, 24, 06, 25, 04, 26, 42 ; Preset 12 = ASCII 'c'\nkpre13 ctrlpreset  0, 1, 21, 113, 22, 43, 23, 98, 24, 93, 25, 94, 26, 52 ; Preset 13 = ASCII 'd'\nctrlprintpresets ; print the CC Presets in the console in response to the 'i42 0 0.1' note in score\nctrlprintpresets \"./my_ctrlpresets.txt\"   ; print the CC Presets to a file\nturnoff\nendin\ninstr  1\nkc[] init 6\nicps cpsmidi\niamp ampmidi 0.6\nkvol midic7  21, 0,1\nkcar midic7  22, 1,10\nkmod midic7  23, .1,10\nkndx midic7  24, 1,30\nkndx port    kndx,.1\niatk midic7  25, .01,1\nirel midic7  26, .01,2\nkpre midic7  28, 1,13   ; use CC 28 to select from the preset 1 - 13 above\nktrig changed2 kpre\nif ktrig == 1 then\nkpre = int(kpre)\n  ctrlselect kpre\n  printk2 kpre\nendif\nasig  foscil iamp, icps, kcar, kmod, kndx, 1\nkmgate linsegr 0, iatk, 1, irel, 0\nouts  (asig*kmgate)*kvol, (asig*kmgate)*kvol\nkc   ctrlsave 1, 21,22,23,24,25,26    ; MIDI Channel and CC values to read &amp; save (Chan1 &amp; CC21-&gt;CC26)\nkchar  sensekey                       ; CC values printed to console after playing next note\nif kchar != 65 goto end0              ; ASCII character \"65\" is the letter 'A' (shift-a)\n ctrlprint kc                         ; prints Controller Settings (CC Presets) to the console\n ctrlprint kc, \"./my_ctrlinits.txt\"   ; appends Controller Settings (CC Presets) to a file\nend0:\nif kchar&lt;49 || kchar&gt;57 goto end1     ; ASCII numbers 1 -&gt; 9\n kval = kchar - 48\n ctrlselect kval\nend1:\nif kchar &lt;97 || kchar&gt;122 goto end2   ; ASCII numbers 10 -&gt; 36 (lower-case letters a -&gt; z)\n  kval = (kchar - 97) + 10\n  ctrlselect kval\n end2:\nif kchar != 86  goto end3                     ; ASCII character \"86\" is the letter 'V' (shift-v)\n kk ctrlpreset 0,kc                           ; adding and numbering the current state as a preset to the list\n ctrlprintpresets                             ; prints Controller Presets (CC Presets) to the console\n ctrlprintpresets \"./my_ctrlpresets.txt\"      ; appends Controller Presets (CC Presets) to a file\nend3:\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 6000\nf1 0 8192 10 1\ni42 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlsave/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrlsave/#credits","title":"Credits","text":"<p>Authors: John ffitch and Richard Boulanger</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/ctrlselect/","title":"Ctrlselect","text":""},{"location":"opcodes/ctrlselect/#ctrlselect","title":"ctrlselect","text":"<p>Loads a preset of values for MIDI controllers from a previous ctrlpreset call.</p>"},{"location":"opcodes/ctrlselect/#syntax","title":"Syntax","text":"<pre><code>ctrlselect kpre\n</code></pre>"},{"location":"opcodes/ctrlselect/#initialization","title":"Initialization","text":"<p>At initialisation time the existence of the internal data structure is checked.</p>"},{"location":"opcodes/ctrlselect/#performance","title":"Performance","text":"<p>kpre -- the numeric tag for the preset, as returned by ctrlpreset.</p>"},{"location":"opcodes/ctrlselect/#examples","title":"Examples","text":"<p>Here is an example of the ctrlselect opcode. It uses the file ctrls.csd.</p> Example of the ctrlselect opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n// -o dac -M hw:1,0,0  ; Terminal\n// -Mhw:1,0,0 -+rtmidi=NULL --daemon -dm0 ;  Bela\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n; by John ffitch and Richard Boulanger\nctrlinit  1, 21,101, 22,11, 23,12, 24,16, 25,0, 26,82      ; Starting Preset\ninstr 42   ; A Bank of Controller Presets - selected by ASCII Key Numbers 1-&gt;9 and a,b,c,d in instr 1 below\n\nkpre1  ctrlpreset  0, 1, 21, 101, 22, 94, 23, 01, 24, 06, 25, 14, 26, 02 ; Preset 1 = ASCII 1\nkpre2  ctrlpreset  0, 1, 21, 102, 22, 57, 23, 76, 24, 55, 25, 77, 26, 12 ; Preset 2 = ASCII 2\nkpre3  ctrlpreset  0, 1, 21, 103, 22, 12, 23, 13, 24, 16, 25, 84, 26, 22 ; Preset 3 = ASCII 3\nkpre4  ctrlpreset  0, 1, 21, 104, 22, 83, 23, 18, 24, 13, 25, 24, 26, 32 ; Preset 4 = ASCII 4\nkpre5  ctrlpreset  0, 1, 21, 105, 22, 20, 23, 48, 24, 33, 25, 94, 26, 42 ; Preset 5 = ASCII 5\nkpre6  ctrlpreset  0, 1, 21, 106, 22, 52, 23, 10, 24, 03, 25, 68, 26, 52 ; Preset 6 = ASCII 6\nkpre7  ctrlpreset  0, 1, 21, 107, 22, 09, 23, 02, 24, 07, 25, 01, 26, 02 ; Preset 7 = ASCII 7\nkpre8  ctrlpreset  0, 1, 21, 108, 22, 34, 23, 10, 24, 96, 25, 44, 26, 42 ; Preset 8 = ASCII 8\nkpre9  ctrlpreset  0, 1, 21, 109, 22, 04, 23, 91, 24, 66, 25, 04, 26, 92 ; Preset 9 = ASCII 9\nkpre10 ctrlpreset  0, 1, 21, 110, 22, 04, 23, 10, 24, 66, 25, 44, 26, 22 ; Preset 10 = ASCII 'a'\nkpre11 ctrlpreset  0, 1, 21, 111, 22, 07, 23, 46, 24, 45, 25, 17, 26, 32 ; Preset 11 = ASCII 'b'\nkpre12 ctrlpreset  0, 1, 21, 112, 22, 22, 23, 03, 24, 06, 25, 04, 26, 42 ; Preset 12 = ASCII 'c'\nkpre13 ctrlpreset  0, 1, 21, 113, 22, 43, 23, 98, 24, 93, 25, 94, 26, 52 ; Preset 13 = ASCII 'd'\nctrlprintpresets ; print the CC Presets in the console in response to the 'i42 0 0.1' note in score\nctrlprintpresets \"./my_ctrlpresets.txt\"   ; print the CC Presets to a file\nturnoff\nendin\ninstr  1\nkc[] init 6\nicps cpsmidi\niamp ampmidi 0.6\nkvol midic7  21, 0,1\nkcar midic7  22, 1,10\nkmod midic7  23, .1,10\nkndx midic7  24, 1,30\nkndx port    kndx,.1\niatk midic7  25, .01,1\nirel midic7  26, .01,2\nkpre midic7  28, 1,13   ; use CC 28 to select from the preset 1 - 13 above\nktrig changed2 kpre\nif ktrig == 1 then\nkpre = int(kpre)\n  ctrlselect kpre\n  printk2 kpre\nendif\nasig  foscil iamp, icps, kcar, kmod, kndx, 1\nkmgate linsegr 0, iatk, 1, irel, 0\nouts  (asig*kmgate)*kvol, (asig*kmgate)*kvol\nkc   ctrlsave 1, 21,22,23,24,25,26    ; MIDI Channel and CC values to read &amp; save (Chan1 &amp; CC21-&gt;CC26)\nkchar  sensekey                       ; CC values printed to console after playing next note\nif kchar != 65 goto end0              ; ASCII character \"65\" is the letter 'A' (shift-a)\n ctrlprint kc                         ; prints Controller Settings (CC Presets) to the console\n ctrlprint kc, \"./my_ctrlinits.txt\"   ; appends Controller Settings (CC Presets) to a file\nend0:\nif kchar&lt;49 || kchar&gt;57 goto end1     ; ASCII numbers 1 -&gt; 9\n kval = kchar - 48\n ctrlselect kval\nend1:\nif kchar &lt;97 || kchar&gt;122 goto end2   ; ASCII numbers 10 -&gt; 36 (lower-case letters a -&gt; z)\n  kval = (kchar - 97) + 10\n  ctrlselect kval\n end2:\nif kchar != 86  goto end3                     ; ASCII character \"86\" is the letter 'V' (shift-v)\n kk ctrlpreset 0,kc                           ; adding and numbering the current state as a preset to the list\n ctrlprintpresets                             ; prints Controller Presets (CC Presets) to the console\n ctrlprintpresets \"./my_ctrlpresets.txt\"      ; appends Controller Presets (CC Presets) to a file\nend3:\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 6000\nf1 0 8192 10 1\ni42 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ctrlselect/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/ctrlselect/#credits","title":"Credits","text":"<p>Authors: John ffitch and Richard Boulanger</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/cuserrnd/","title":"Cuserrnd","text":""},{"location":"opcodes/cuserrnd/#cuserrnd","title":"cuserrnd","text":"<p>Continuous USER-defined-distribution RaNDom generator.</p>"},{"location":"opcodes/cuserrnd/#syntax","title":"Syntax","text":"<pre><code>aout cuserrnd kmin, kmax, ktableNum\niout cuserrnd imin, imax, itableNum\nkout cuserrnd kmin, kmax, ktableNum\n</code></pre>"},{"location":"opcodes/cuserrnd/#initialization","title":"Initialization","text":"<p>imin -- minimum range limit</p> <p>imax -- maximum range limit</p> <p>itableNum -- number of table containing the random-distribution function.  Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2.</p>"},{"location":"opcodes/cuserrnd/#performance","title":"Performance","text":"<p>ktableNum -- number of table containing the random-distribution function.  Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2.</p> <p>kmin -- minimum range limit</p> <p>kmax -- maximum range limit</p> <p>cuserrnd (continuous user-defined-distribution random generator) generates random values according to a continuous random distribution created by the user. In this case the shape of the distribution histogram can be drawn or generated by any GEN routine. The table containing the shape of such histogram must then be translated to a distribution function by means of GEN40 (see GEN40 for more details). Then such function must be assigned to the XtableNum argument of cuserrnd.  The output range can then be rescaled according to the Xmin and Xmax arguments. cuserrnd linearly interpolates between table elements, so it is not recommended for discrete distributions (GEN41 and GEN42).</p> <p>For a tutorial about random distribution histograms and functions see:</p> <ul> <li>D. Lorrain. \"A panoply of stochastic cannons\". In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ul>"},{"location":"opcodes/cuserrnd/#examples","title":"Examples","text":"<p>Here is an example of the cuserrnd opcode. It uses the file cuserrnd.csd.</p> Example of the cuserrnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o cuserrnd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; every run time same values\n\nkuser cuserrnd 0, 100, 1\n      printk .2, kuser\nasig  poscil .5, 220+kuser, 3\n      outs asig, asig\nendin\n\ninstr 2 ; every run time different values\n\n      seed 0\nkuser cuserrnd 0, 100, 1\n      printk .2, kuser\nasig  poscil .5, 220+kuser, 3\n      outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16 -7 1 4 0 8 0 4 1       ;distrubution using GEN07\nf 2 0 16384 40 1                ;GEN40 is to be used with cuserrnd\nf 3 0 8192 10 1                 ;sine\n\ni 1 0 2\ni 2 3 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00067:    53.14918\ni   1 time     0.20067:     0.00000\ni   1 time     0.40067:     0.00000\ni   1 time     0.60067:    96.80406\ni   1 time     0.80067:    94.20729\ni   1 time     1.00000:     0.00000\ni   1 time     1.20067:    86.13032\ni   1 time     1.40067:    31.37096\ni   1 time     1.60067:    70.35889\ni   1 time     1.80000:     0.00000\ni   1 time     2.00000:    49.18914\n\nWARNING: Seeding from current time 2006647442\n\ni   2 time     3.00067:    21.45002\ni   2 time     3.20067:    44.32333\ni   2 time     3.40067:    46.05420\ni   2 time     3.60000:     0.00000\ni   2 time     3.80067:    41.32175\ni   2 time     4.00000:     0.00000\ni   2 time     4.20000:    63.72019\ni   2 time     4.40067:     0.00000\ni   2 time     4.60067:     0.00000\ni   2 time     4.80067:     0.00000\ni   2 time     5.00000:    74.49330\n</code></pre>"},{"location":"opcodes/cuserrnd/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/cuserrnd/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.16</p>"},{"location":"opcodes/dam/","title":"Dam","text":""},{"location":"opcodes/dam/#dam","title":"dam","text":"<p>A dynamic compressor/expander.</p> <p>This opcode dynamically modifies a gain value applied to the input sound ain by comparing its power level to a given threshold level. The signal will be compressed/expanded with different factors regarding that it is over or under the threshold.</p>"},{"location":"opcodes/dam/#syntax","title":"Syntax","text":"<pre><code>ares dam asig, kthreshold, icomp1, icomp2, irtime, iftime\n</code></pre>"},{"location":"opcodes/dam/#initialization","title":"Initialization","text":"<p>icomp1 -- compression ratio for upper zone.</p> <p>icomp2 -- compression ratio for lower zone</p> <p>irtime -- gain rise time in seconds. Time over which the gain factor is allowed to raise of one unit.</p> <p>iftime -- gain fall time in seconds. Time over which the gain factor is allowed to decrease of one unit.</p>"},{"location":"opcodes/dam/#performance","title":"Performance","text":"<p>asig -- input signal to be modified</p> <p>kthreshold -- level of input signal which acts as the threshold. Can be changed at k-time (e.g. for ducking)</p> <p>Note on the compression factors: A compression ratio of one leaves the sound unchanged. Setting the ratio to a value smaller than one will compress the signal (reduce its volume) while setting the ratio to a value greater than one will expand the signal (augment its volume).</p>"},{"location":"opcodes/dam/#examples","title":"Examples","text":"<p>Because the results of the dam opcode can be subtle, I recommend looking at them in a graphical audio editor program like audacity. audacity is available for Linux, Windows, and the MacOS and may be downloaded from http://audacity.sourceforge.net.</p> <p>Here is an example of the dam opcode. It uses the file dam.csd, and drumsMlp.wav.</p> An example of the dam opcode compressing an audio signal.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dam.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ;normal audio\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\n     outs asig, asig\n\nendin\n\n\ninstr 2 ; compressed audio\n\nkthreshold = 0.2\nicomp1 = 0.8\nicomp2 = 0.2\nirtime = 0.01\niftime = 0.5\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\nasig dam asig, kthreshold, icomp1, icomp2, irtime, iftime\n    outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 8.5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example compresses the audio file \u201cdrumsMlp.wav\u201d. You should hear a drum pattern repeat twice. The second time, the sound should be quieter (compressed) than the first.</p> <p>Here is another example of the dam opcode. It uses the file dam_expanded.csd, and drumsMlp.wav.</p> An example of the dam opcode expanding an audio signal.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dam_expanded.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 \n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\n     outs asig, asig\n\nendin\n\ninstr 2 ;expanded audio\n\nkthreshold = .5\nicomp1 = 2\nicomp2 = 3\nirtime = 0.01\niftime = 0.1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\nasig dam asig, kthreshold, icomp1, icomp2, irtime, iftime\n     outs asig*.2, asig*.2      ;adjust volume of expanded beat\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2.5 6.5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example expands the audio file \u201cdrumsMlp.wav\u201d. You should hear a drum pattern repeat twice. The second time, the sound should be louder (expanded) than the first. To prevent distortion the volume of the signal has been lowered.</p>"},{"location":"opcodes/dam/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/dam/#credits","title":"Credits","text":"<p>Author: Marc Resibois Belgium 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/date/","title":"Date","text":""},{"location":"opcodes/date/#date","title":"date","text":"<p>Returns the number seconds since a base date, using the operating system's clock.</p> <p>Plugin opcode in cs_date.</p> <p>The base is 1 January 1970 for Csound using doubles, and 1 January 2010 for versions using floats. On operating systemms with sufficient resolution the date includes fractional seconds.</p>"},{"location":"opcodes/date/#syntax","title":"Syntax","text":"<pre><code>ir[, inano] date\nkr[, knano] date\n</code></pre> <p>Initialization and Performance</p> <p>ir -- value at i-time, of the system clock in seconds since the start of the epoch.</p> <p>kr -- value at k-time, of the system clock in seconds since the start of the epoch.</p> <p>inano -- value at i-time of the nanoseconds since last second tick.</p> <p>knano -- value at k-time of the nanoseconds since last second tick.</p> <p>Note that the base date was originally 1970 bu since version 5.14 it has been changed as single precission floating point numbers are insufficient to indicate changes.</p> <p>The optional answer and resolution including fractions of a second introduced in version 6.07.</p>"},{"location":"opcodes/date/#examples","title":"Examples","text":"<p>Here is an example of the date opcode. It uses the file date.csd.</p> Example of the date opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o date.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n      ii,ij date\n      print ii\n      print ij\n      Sa dates ii\n      prints Sa\n      Ss dates -1\n      prints Ss\n      St dates 1\n      prints St \nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  ii = 1447337826.778\ninstr 1:  ij = 778279830.000\nThu Nov 12 14:17:07 2015\nThu Nov 12 14:17:06 2015\nThu Jan  1 01:00:01 1970\n</code></pre>"},{"location":"opcodes/date/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/date/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK December 2006</p> <p>New in Csound version 5.05</p> <p>Changed in Csound version 5.14</p>"},{"location":"opcodes/dates/","title":"Dates","text":""},{"location":"opcodes/dates/#dates","title":"dates","text":"<p>Returns as a string the date and time specified.</p> <p>Plugin opcode in cs_date.</p>"},{"location":"opcodes/dates/#syntax","title":"Syntax","text":"<pre><code>Sir dates [ itime]\n</code></pre>"},{"location":"opcodes/dates/#initialization","title":"Initialization","text":"<p>itime -- the time is seconds since the start of the epoch.  If omited or negative the current time is taken.</p> <p>Sir -- the date and time as a string.</p>"},{"location":"opcodes/dates/#examples","title":"Examples","text":"<p>Here is an example of the dates opcode. It uses the file dates.csd.</p> Example of the dates opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dates.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\nseed     0 ;each time different seed\n\ninstr 1\n;;generating a different filename each time csound renders\nitim     date\nStim     dates     itim\nSyear    strsub    Stim, 20, 24\nSmonth   strsub    Stim, 4, 7\nSday     strsub    Stim, 8, 10\niday     strtod    Sday\nShor     strsub    Stim, 11, 13\nSmin     strsub    Stim, 14, 16\nSsec     strsub    Stim, 17, 19\nSfilnam  sprintf  \"%s_%s_%02d_%s_%s_%s.wav\", Syear, Smonth, iday, Shor,Smin, Ssec\n;;rendering with random frequency, amp and pan, and writing to disk\nifreq    random    400, 1000\niamp     random    .1, 1\nipan     random    0, 1\nasin     oscils    iamp, ifreq, 0\naL, aR   pan2      asin, ipan\n         fout      Sfilnam, 14, aL, aR\n         outs      aL, aR\n         printf_i  \"File '%s' written to the same directory as this CSD file is!\\n\", 1, Sfilnam\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>File '2011_Jan_05_19_14_46.wav' written to the same directory as this CSD file is!\nClosing file '/home/user/csound/Output/2011_Jan_05_19_14_46.wav'...\n</code></pre>"},{"location":"opcodes/dates/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/dates/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK December 2006</p> <p>New in Csound version 5.05</p>"},{"location":"opcodes/db/","title":"Db","text":""},{"location":"opcodes/db/#db","title":"db","text":"<p>Returns the amplitude equivalent for a given decibel amount.</p> <p>This opcode is the same as ampdb.</p>"},{"location":"opcodes/db/#syntax","title":"Syntax","text":"<pre><code>db(x)\n</code></pre> <p>This function works at a-rate, i-rate, and k-rate.</p>"},{"location":"opcodes/db/#initialization","title":"Initialization","text":"<p>x -- a value expressed in decibels.</p>"},{"location":"opcodes/db/#performance","title":"Performance","text":"<p>Returns the amplitude for a given decibel amount.</p>"},{"location":"opcodes/db/#examples","title":"Examples","text":"<p>Here is an example of the db opcode. It uses the file db.csd.</p> Example of the db opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o db.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nidec = p4\niamp = db(idec)\n     print iamp\nasig vco2 iamp, 110                     ;sawtooth\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1 50\ni 1 + 1 &gt;\ni 1 + 1 &gt;\ni 1 + 1 85\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>instr 1:  iamp = 316.252\ninstr 1:  iamp = 1211.582\ninstr 1:  iamp = 4641.643\ninstr 1:  iamp = 17782.420\n</code></pre>"},{"location":"opcodes/db/#see-also","title":"See also","text":"<p>Amplitude Converters</p> <p>New in version 4.16</p>"},{"location":"opcodes/dbamp/","title":"Dbamp","text":""},{"location":"opcodes/dbamp/#dbamp","title":"dbamp","text":"<p>Returns the decibel equivalent of the raw amplitude x.</p>"},{"location":"opcodes/dbamp/#syntax","title":"Syntax","text":"<pre><code>dbamp(x)  (init-rate or control-rate args only)\n</code></pre>"},{"location":"opcodes/dbamp/#examples","title":"Examples","text":"<p>Here is an example of the dbamp opcode. It uses the file dbamp.csd.</p> Example of the dbamp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dbamp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\niamp = p4\nidb  = dbamp(iamp)\n     print idb\nasig vco2 iamp, 110     ;sawtooth\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1 100\ni 1 + 1 1000\ni 1 + 1 10000\ni 1 + 1 20000\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  idb = 40.000\ninstr 1:  idb = 60\ninstr 1:  idb = 80\ninstr 1:  idb = 86.021\n</code></pre>"},{"location":"opcodes/dbamp/#see-also","title":"See also","text":"<p>Amplitude Converters</p>"},{"location":"opcodes/dbfsamp/","title":"Dbfsamp","text":""},{"location":"opcodes/dbfsamp/#dbfsamp","title":"dbfsamp","text":"<p>Returns the decibel equivalent of the raw amplitude x, relative to full scale amplitude.</p> <p>Full scale is assumed to be 16 bit. New is Csound version 4.10.</p>"},{"location":"opcodes/dbfsamp/#syntax","title":"Syntax","text":"<pre><code>dbfsamp(x)  (init-rate or control-rate args only)\n</code></pre>"},{"location":"opcodes/dbfsamp/#examples","title":"Examples","text":"<p>Here is an example of the dbfsamp opcode. It uses the file dbfsamp.csd.</p> Example of the dbfsamp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dbfsamp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\niamp = p4\nidb  = dbfsamp(iamp)\n     print idb\nasig vco2 iamp, 110     ;sawtooth\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1 1\ni 1 + 1 100\ni 1 + 1 1000\ni 1 + 1 10000\ni 1 + 1 30000\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  idb = -90.309\ninstr 1:  idb = -50.309\ninstr 1:  idb = -30.309\ninstr 1:  idb = -10.309\ninstr 1:  idb = -0.767\n</code></pre>"},{"location":"opcodes/dbfsamp/#see-also","title":"See also","text":"<p>Amplitude Converters</p>"},{"location":"opcodes/dcblock/","title":"Dcblock","text":""},{"location":"opcodes/dcblock/#dcblock","title":"dcblock","text":"<p>Implements the DC blocking filter</p> <pre><code>Y[i] = X[i] - X[i-1] + (igain * Y[i-1])\n</code></pre> <p>Based on work by Perry Cook.</p>"},{"location":"opcodes/dcblock/#syntax","title":"Syntax","text":"<pre><code>ares dcblock ain [, igain]\n</code></pre>"},{"location":"opcodes/dcblock/#initialization","title":"Initialization","text":"<p>igain -- the gain of the filter, which defaults to 0.99</p>"},{"location":"opcodes/dcblock/#performance","title":"Performance","text":"<p>ain -- audio signal input</p> <p> Note</p> <p>The new dcblock2 opcode is an improved method of removing DC from an audio signal.</p>"},{"location":"opcodes/dcblock/#examples","title":"Examples","text":"<p>The result can be viewed in a graphical audio editor program like audacity. audacity is available for Linux, Windows, and the MacOS and may be downloaded from http://audacity.sourceforge.net.</p> <p>Here is an example of the dcblock opcode. It uses the file dcblock.csd, and drumsMlp.wav.</p> Example of the dcblock opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o dcblock.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1 ;add DC to \"drumsMlp.wav\"\n\nasig soundin \"drumsMlp.wav\"\nasig = asig+5000        ;adds DC of 5000\n     outs asig, asig\nendin\n\ninstr 2 ;dcblock audio\n\nasig soundin \"drumsMlp.wav\"\nasig = asig+5000        ;adds DC\nadc  dcblock asig       ;remove DC again\n     outs adc, adc\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dcblock/#see-also","title":"See also","text":"<p>Specialized Filters: High pass filters</p>"},{"location":"opcodes/dcblock/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.49</p> <p>February 2003: Thanks to a note from Anders Andersson, corrected the formula.</p>"},{"location":"opcodes/dcblock2/","title":"Dcblock2","text":""},{"location":"opcodes/dcblock2/#dcblock2","title":"dcblock2","text":"<p>Implements a DC blocking filter with improved DC attenuation.</p>"},{"location":"opcodes/dcblock2/#syntax","title":"Syntax","text":"<pre><code>ares dcblock2 ain [, iorder] [, iskip]\n</code></pre>"},{"location":"opcodes/dcblock2/#initialization","title":"Initialization","text":"<p>iorder --  filter order, minimum 4th order, defaults to 128.</p> <p>iskip -- set to 1 to skip initialization (defaults to 0).</p>"},{"location":"opcodes/dcblock2/#performance","title":"Performance","text":"<p>ares -- filered audio signal</p> <p>ain -- input audio signal</p> <p> Note</p> <p>Using a value for iorder less that ksmps will not reduce DC offset efficiently.</p>"},{"location":"opcodes/dcblock2/#examples","title":"Examples","text":"<p>The result can be viewed in a graphical audio editor program like audacity. audacity is available for Linux, Windows, and the MacOS and may be downloaded from http://audacity.sourceforge.net.</p> <p>Here is an example of the dcblock2 opcode. It uses the file dcblock2.csd, and drumsMlp.wav.</p> Example of the dcblock2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o dcblock2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1 ;add DC to \"drumsMlp.wav\"\n\nasig soundin \"drumsMlp.wav\"\nasig = asig+5000        ;adds DC of 5000\n     outs asig, asig\nendin\n\ninstr 2 ;dcblock audio\n\nasig soundin \"drumsMlp.wav\"\nasig = asig+5000        ;adds DC\nadc  dcblock2 asig      ;remove DC again\n     outs adc, adc\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dcblock2/#see-also","title":"See also","text":"<p>Specialized Filters: High pass filters</p>"},{"location":"opcodes/dcblock2/#credits","title":"Credits","text":"<p>By: Victor Lazzarini</p> <p>New in Csound version 5.09</p>"},{"location":"opcodes/dconv/","title":"Dconv","text":""},{"location":"opcodes/dconv/#dconv","title":"dconv","text":"<p>A direct convolution opcode.</p>"},{"location":"opcodes/dconv/#syntax","title":"Syntax","text":"<pre><code>ares dconv asig, isize, ifn\n</code></pre>"},{"location":"opcodes/dconv/#initialization","title":"Initialization","text":"<p>isize -- the size of the convolution buffer to use. If the buffer size is smaller than the size of ifn, then only the first isize values will be used from the table.</p> <p>ifn -- table number of a stored function containing the impulse response for convolution.</p>"},{"location":"opcodes/dconv/#performance","title":"Performance","text":"<p>Rather than the analysis/resynthesis method of the convolve opcode, dconv uses direct convolution to create the result.  For small tables it can do this quite efficiently, however larger table require much more time to run. dconv does (isize * ksmps) multiplies on every k-cycle. Therefore, reverb and delay effects are best done with other opcodes (unless the times are short).</p> <p>dconv was designed to be used with time varying tables to facilitate new realtime filtering capabilities.</p>"},{"location":"opcodes/dconv/#examples","title":"Examples","text":"<p>Here is an example of the dconv opcode. It uses the file dconv.csd.</p> Example of the dconv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o dconv.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n#define RANDI(A) #kout  randi   1, kfq, $A*.001+iseed, 1\n        tablew  kout, $A, itable#\n\ninstr 1\nitable  init    1\niseed   init    .6\nisize   init    ftlen(itable)\nkfq     line    1, p3, 10\n\n$RANDI(0)\n$RANDI(1)\n$RANDI(2)\n$RANDI(3)\n$RANDI(4)\n$RANDI(5)\n$RANDI(6)\n$RANDI(7)\n$RANDI(8)\n$RANDI(9)\n$RANDI(10)\n$RANDI(11)\n$RANDI(12)\n$RANDI(13)\n$RANDI(14)\n$RANDI(15)\n\nasig    rand    10000, .5, 1\nasig    butlp   asig, 5000\nasig    dconv   asig, isize, itable\n\n        out     asig *.5\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 16 10 1\ni1 0 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dconv/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/dconv/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss 2001</p> <p>New in version 4.12</p>"},{"location":"opcodes/deinterleave/","title":"Deinterleave","text":""},{"location":"opcodes/deinterleave/#deinterleave","title":"deinterleave","text":"<p>Deinterleaves arrays by picking alternate data from its input.</p>"},{"location":"opcodes/deinterleave/#syntax","title":"Syntax","text":"<pre><code>kout1[], kout2[] deinterleave kin[]\n</code></pre>"},{"location":"opcodes/deinterleave/#performance","title":"Performance","text":"<p>kout1[], kout2[] -- output arrays containing the deinterleaved output. They will be created if not existent.</p> <p>kin[] -- input array containing the values to be deinterleaved.</p>"},{"location":"opcodes/deinterleave/#examples","title":"Examples","text":"<p>Here is an example of the deinterleave opcode. It uses the file deinterleave.csd.</p> Example of the deinterleave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\nkInt[] fillarray 1,2,3,4,5,6,7,8\n\nkout1[],kout2[] deinterleave kInt\n\nprintf \"input: \\n%d %d %d %d %d %d %d %d\\n\", 1,\n         kInt[0], kInt[1], kInt[2], kInt[3],\n         kInt[4], kInt[5], kInt[6], kInt[7]\n\n\nprintf \"de-interleaved:\\n%d %d %d %d \\n%d %d %d %d\\n\", 1,\n         kout1[0], kout1[1], kout1[2], kout1[3],\n         kout2[0], kout2[1], kout2[2], kout2[3]\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1  \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deinterleave/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/deinterleave/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2018</p> <p>New in version 6.12</p>"},{"location":"opcodes/delay/","title":"Delay","text":""},{"location":"opcodes/delay/#delay","title":"delay","text":"<p>Delays an input signal by some time interval.</p> <p>A signal can be read from or written into a delay path, or it can be automatically delayed by some time interval.</p>"},{"location":"opcodes/delay/#syntax","title":"Syntax","text":"<pre><code>ares delay asig, idlt [, iskip]\n</code></pre>"},{"location":"opcodes/delay/#initialization","title":"Initialization","text":"<p>idlt -- requested delay time in seconds. This can be as large as available memory will permit. The space required for n seconds of delay is 4n * sr bytes. It is allocated at the time the instrument is first initialized, and returned to the pool at the end of a score section.</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (see reson). The default value is 0.</p>"},{"location":"opcodes/delay/#performance","title":"Performance","text":"<p>asig -- audio signal</p> <p>delay is a composite of delayr and delayw, both reading from and writing into its own storage area. It can thus accomplish signal time-shift, although modified feedback is not possible. There is no minimum delay period.</p>"},{"location":"opcodes/delay/#examples","title":"Examples","text":"<p>Here is an example of the delay opcode. It uses the file delay.csd.</p> Example of the delay opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o delay.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr    1\n\nadel    init 0\nilev    = p4                            ;level of direct sound\nidelay  = p5 *.001                      ;Delay in ms\nifd     = p6                            ;feedback\n\nain     diskin2 \"Mathews.wav\", 1, 1\nadel    delay   ain + (adel*ifd), idelay;ifd = amount of feedback\nasig    moogvcf adel, 1500, .6, 1       ;color feedback\n        outs    asig*ilev, ain\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;Delay is in ms\ni 1  0  5  1.5  200 .95 ;with feedback\ni 1  +  5  1.5  20  .95\ni 1  +  3  1.5  5   .95\ni 1  +  7  2    5    0  ;no feedback\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/delay/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/delay1/","title":"Delay1","text":""},{"location":"opcodes/delay1/#delay1","title":"delay1","text":"<p>Delays an input signal by one sample.</p>"},{"location":"opcodes/delay1/#syntax","title":"Syntax","text":"<pre><code>ares delay1 asig [, iskip]\n</code></pre>"},{"location":"opcodes/delay1/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of delay-loop data space (see reson). The default value is 0.</p>"},{"location":"opcodes/delay1/#performance","title":"Performance","text":"<p>delay1 is a special form of delay that serves to delay the audio signal asig by just one sample. It is thus functionally equivalent to the delay opcode but is more efficient in both time and space. This unit is particularly useful in the fabrication of generalized non-recursive filters.</p>"},{"location":"opcodes/delay1/#examples","title":"Examples","text":"<p>Here is an example of the delay and delay1 opcodes. It uses the file delay1.csd.</p> Example of the delay1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o delay1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2021, after Russel Pinkston\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1                             ; original sounds\n\nichoice =   p4\nif ichoice == 0 then\n        prints  \"\\n--**original beats**--\\n\\n\"\n    aout    diskin2 \"drumsMlp.wav\"\nelse\n        prints  \"\\n--**original noise**--\\n\\n\"\n    aout    rand .2\nendif\nouts    aout, aout\n\nendin\n\ninstr 2                             ; Finite Impulse Response (FIR) Filter\n\nichoice =   p4\nif ichoice == 0 then\n    prints  \"\\n--**FIRST-ORDER LOW-PASS on the beats**--\\n\\n\"\n    aout    diskin2 \"drumsMlp.wav\"\nelse\n    prints  \"\\n--**FIRST-ORDER LOW-PASS on the noise**--\\n\\n\"\n    aout    rand .2\nendif\n\nadel1   delay1  aout                ; delay 1 sample                            \nasig    =   (.5* aout)+(.5* adel1)      ; average 2 succesive inputs\nouts    asig, asig\n\nendin\n\n\ninstr 3                             ; Finite Impulse Response (FIR) Filter        \n\nichoice =   p4\nif ichoice == 0 then\n    prints  \"\\n--**FIRST-ORDER HIGH-PASS on the beats**--\\n\\n\"\n    aout    diskin2 \"drumsMlp.wav\"\nelse\n    prints  \"\\n--**FIRST-ORDER HIGH-PASS on the noise**--\\n\\n\"\n    aout    rand .2\nendif\n\nadel1   delay1  aout                ; delay 1 sample\nasig    =   (.5*aout)-(.5*adel1)        ; difference of 2 inputs\nouts    asig, asig\n\nendin\n\ninstr 4                             ; Finite Impulse Response (FIR) Filter        \n\nichoice =   p4\nif ichoice == 0 then\n    prints  \"\\n--**SECOND-ORDER NOTCH on the beats**--\\n\\n\"\n    aout    diskin2 \"drumsMlp.wav\"\nelse\n    prints  \"\\n--**SECOND-ORDER NOTCH on the noise**--\\n\\n\"\n    aout    rand .2\nendif\n\nadel1   delay1  aout                ; x(n - 1)\nadel2   delay1  adel1               ; x(n - 2)\nasig    =   (.5*aout)+(.5*adel2)        ; y(n) = .5x(n) + .5x(n - 2)\nouts    asig, asig\n\nendin\n\ninstr 5                             ; Finite Impulse Response (FIR) Filter        \n\nichoice =   p4\nif ichoice == 0 then\n    prints  \"\\n--**SECOND-ORDER BAND-PASS on the beats**--\\n\\n\"\n    aout    diskin2 \"drumsMlp.wav\"\nelse\n    prints  \"\\n--**SECOND-ORDER BAND-PASS on the noise**--\\n\\n\"\n    aout    rand .2\nendif\n\nadel1   delay1  aout                ; x(n - 1)\nadel2   delay1  adel1               ; x(n - 2)\nasig    =   (.5*aout)-(.5*adel2)        ; y(n) = .5x(n) - .5x(n - 2)\nouts    asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1   0     2    0   \ni1   3     2    1 \ns\ni2   1     2    0 \ni2   4     2    1   \ns\ni3   1     2    0 \ni3   4     2    1 \ns\ni4   1     2    0 \ni4   4     2    1 \ns\ni5   1     2    0 \ni5   4     2    1 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This shows the result of the example: 5 times the beats and the noise. 1.Original samples, 2.first-order lowpass, 3.first-order highpass, 4.second-order notch and 5.second-order bandpass.</p>"},{"location":"opcodes/delay1/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/delay1/#credits","title":"Credits","text":"<p>Author: Barry Vercoe</p>"},{"location":"opcodes/delayk/","title":"Delayk","text":""},{"location":"opcodes/delayk/#delayk","title":"delayk","text":"<p>Delays an input signal by some time interval.</p> <p>k-rate delay opcodes</p>"},{"location":"opcodes/delayk/#syntax","title":"Syntax","text":"<pre><code>kr delayk   ksig, idel[, imode]\nkr vdel_k   ksig, kdel, imdel[, imode]\n</code></pre>"},{"location":"opcodes/delayk/#initialization","title":"Initialization","text":"<p>idel -- delay time (in seconds) for delayk. It is rounded to the nearest integer multiple of a k-cycle (i.e. 1/kr).</p> <p>imode -- sum of 1 for skipping initialization (e.g. in tied notes) and 2 for holding the first input value during the initial delay, instead of outputting zero. This is mainly of use when delaying envelopes that do not start at zero.</p> <p>imdel -- maximum delay time for vdel_k, in seconds.</p>"},{"location":"opcodes/delayk/#performance","title":"Performance","text":"<p>kr -- the output signal. Note: neither of the opcodes interpolate the output.</p> <p>ksig -- the input signal.</p> <p>kdel -- delay time (in seconds) for vdel_k. It is rounded to the nearest integer multiple of a k-cycle (i.e. 1/kr).</p>"},{"location":"opcodes/delayk/#examples","title":"Examples","text":"<p>Here is an example of the delayk opcode. It uses the file delayk.csd.</p> Example of the delayk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o delayk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example shows \"delayk\" for fm index and \n;a second \"delayk\" for panning\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkenv1 transeg 0, .02, 0, 1, 3.98, -6, 0 ;envelope\nkenv2 delayk kenv1, 2                   ;delayed by two seconds\nkindx expon 5, p3, 1                    ;fm index decreasing over p3\nasig  foscili .6, 400, 1, 11/4, kindx, gisin\nkpan1 linseg 0, 4, 1                    ;panning for first sound\nkpan2 linseg 1, 4, 0                    ;panning for second sound ...\nkpan2 delayk kpan2, 2                   ;delayed by two seconds\na1 = asig * kenv1\na2 = asig * kenv2\n\naL1,aR1 pan2 a1, kpan1\naL2,aR2 pan2 a2, kpan2\n        outs aL1+aL2, aR1+aR2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/delayk/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/delayk/#credits","title":"Credits","text":"<p>Istvan Varga.</p>"},{"location":"opcodes/delayr/","title":"Delayr","text":""},{"location":"opcodes/delayr/#delayr","title":"delayr","text":"<p>Reads from an automatically established digital delay line.</p>"},{"location":"opcodes/delayr/#syntax","title":"Syntax","text":"<pre><code>ares delayr idlt [, iskip]\n</code></pre>"},{"location":"opcodes/delayr/#initialization","title":"Initialization","text":"<p>idlt -- requested delay time in seconds. This can be as large as available memory will permit. The space required for n seconds of delay is 4n * sr bytes. It is allocated at the time the instrument is first initialized, and returned to the pool at the end of a score section.</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (see reson). The default value is 0.</p>"},{"location":"opcodes/delayr/#performance","title":"Performance","text":"<p>delayr reads from an automatically established digital delay line, in which the signal retrieved has been resident for idlt seconds. This unit must be paired with and precede an accompanying delayw unit. Any other Csound statements can intervene.</p>"},{"location":"opcodes/delayr/#examples","title":"Examples","text":"<p>Here is an example of the delayr opcode. It uses the file delayr.csd.</p> Example of the delayr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o delayr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltap  .4              ;first tap (on left channel)\nadelM   deltap  1               ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    1, p3, .01      ;vary delay time\nadelR   deltap  .65 * kdel      ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/delayr/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/delayw/","title":"Delayw","text":""},{"location":"opcodes/delayw/#delayw","title":"delayw","text":"<p>Writes the audio signal to a digital delay line.</p>"},{"location":"opcodes/delayw/#syntax","title":"Syntax","text":"<pre><code>delayw asig\n</code></pre>"},{"location":"opcodes/delayw/#performance","title":"Performance","text":"<p>delayw writes asig into the delay area established by the preceding delayr unit. Viewed as a pair, these two units permit the formation of modified feedback loops, etc. However, there is a lower bound on the value of idlt, which must be at least 1 control period (or 1/kr).</p>"},{"location":"opcodes/delayw/#examples","title":"Examples","text":"<p>Here is an example of the delayw opcode. It uses the file delayw.csd.</p> Example of the delayw opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o delayw.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltap  .4              ;first tap (on left channel)\nadelM   deltap  1               ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    1, p3, .01      ;vary delay time\nadelR   deltap  .65 * kdel      ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/delayw/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltap/","title":"Deltap","text":""},{"location":"opcodes/deltap/#deltap","title":"deltap","text":"<p>Taps a delay line at variable offset times.</p>"},{"location":"opcodes/deltap/#syntax","title":"Syntax","text":"<pre><code>ares deltap kdlt\n</code></pre>"},{"location":"opcodes/deltap/#performance","title":"Performance","text":"<p>kdlt -- specifies the tapped delay time in seconds. Each can range from 1 control period to the full delay time of the read/write pair; however, since there is no internal check for adherence to this range, the user is wholly responsible. Each argument can be a constant, a variable, or a time-varying signal.</p> <p>deltap extracts sound by reading the stored samples directly.</p> <p>This opcode can tap into a delayr/delayw pair, extracting delayed audio from the idlt seconds of stored sound. There can be any number of deltap and/or deltapi units between a read/write pair. Each receives an audio tap with no change of original amplitude.</p> <p>This opcode can provide multiple delay taps for arbitrary delay path and feedback networks. They can deliver either constant-time or time-varying taps, and are useful for building chorus effects, harmonizers, and Doppler shifts. Constant-time delay taps (and some slowly changing ones) do not need interpolated readout; they are well served by deltap. Medium-paced or fast varying dlt's, however, will need the extra services of deltapi.</p> <p>delayr/delayw pairs may be interleaved. To associate a delay tap unit with a specific delayr unit, it not only has to be located between that delayr and the appropriate delayw unit, but must also precede any following delayr units. See Example 2. (This feature added in Csound version 3.57 by Jens Groh and John ffitch).</p> <p>N.B. k-rate delay times are not internally interpolated, but rather lay down stepped time-shifts of audio samples; this will be found quite adequate for slowly changing tap times. For medium to fast-paced changes, however, one should provide a higher resolution audio-rate timeshift as input.</p>"},{"location":"opcodes/deltap/#examples","title":"Examples","text":"deltap example #1<pre><code> asource  buzz      1, 440, 20, 1\n atime    linseg    1, p3/2,.01, p3/2,1   ; trace a distance in secs\n ampfac   =         1/atime/atime         ; and calc an amp factor\n adump    delayr    1                     ; set maximum distance\n amove    deltapi   atime                 ; move sound source past\n          delayw    asource               ; the listener\n          out       amove * ampfac\n</code></pre> deltap example #2<pre><code>  ainput1 = ..... \n  ainput2 = ..... \n  kdlyt1  = ..... \n  kdlyt2  = ..... \n\n;Read delayed signal, first delayr instance:\n  adump   delayr  4.0 \n  adly1   deltap  kdlyt1       ; associated with first delayr instance\n\n;Read delayed signal, second delayr instance:\n  adump   delayr  4.0 \n  adly2   deltap  kdlyt2       ; associated with second delayr instance\n\n;Do some cross-coupled manipulation:\n  afdbk1  =       0.7 * adly1 + 0.7 * adly2 + ainput1 \n  afdbk2  =       -0.7 * adly1 + 0.7 * adly2 + ainput2 \n\n;Feed back signal, associated with first delayr instance:\n          delayw  afdbk1 \n\n;Feed back signal, associated with second delayr instance:\n          delayw  afdbk2\n          outs    adly1, adly2\n</code></pre> <p>Here is yet another example of the deltap opcode. It uses the file deltap.csd.</p> Example of the deltap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltap  .4              ;first tap (on left channel)\nadelM   deltap  1               ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    1, p3, .01      ;vary delay time\nadelR   deltap  .65 * kdel      ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltap/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltap3/","title":"Deltap3","text":""},{"location":"opcodes/deltap3/#deltap3","title":"deltap3","text":"<p>Taps a delay line at variable offset times, uses cubic interpolation.</p>"},{"location":"opcodes/deltap3/#syntax","title":"Syntax","text":"<pre><code>ares deltap3 xdlt\n</code></pre>"},{"location":"opcodes/deltap3/#performance","title":"Performance","text":"<p>xdlt -- specifies the tapped delay time in seconds. Each can range from 1 control period to the full delay time of the read/write pair; however, since there is no internal check for adherence to this range, the user is wholly responsible. Each argument can be a constant, a variable, or a time-varying signal; the xdlt argument in deltap3 implies that an audio-varying delay is permitted there.</p> <p>deltap3 is experimental, and uses cubic interpolation. (New in Csound version 3.50.)</p> <p>This opcode can tap into a delayr/delayw pair, extracting delayed audio from the idlt seconds of stored sound. There can be any number of deltap and/or deltapi units between a read/write pair. Each receives an audio tap with no change of original amplitude.</p> <p>This opcode can provide multiple delay taps for arbitrary delay path and feedback networks. They can deliver either constant-time or time-varying taps, and are useful for building chorus effects, harmonizers, and Doppler shifts. Constant-time delay taps (and some slowly changing ones) do not need interpolated readout; they are well served by deltap. Medium-paced or fast varying dlt's, however, will need the extra services of deltapi.</p> <p>delayr/delayw pairs may be interleaved. To associate a delay tap unit with a specific delayr unit, it not only has to be located between that delayr and the appropriate delayw unit, but must also precede any following delayr units. See Example 2. (This feature added in Csound version 3.57 by Jens Groh and John ffitch).</p> <p>N.B. k-rate delay times are not internally interpolated, but rather lay down stepped time-shifts of audio samples; this will be found quite adequate for slowly changing tap times. For medium to fast-paced changes, however, one should provide a higher resolution audio-rate timeshift as input.</p>"},{"location":"opcodes/deltap3/#examples","title":"Examples","text":"deltap example #1<pre><code>asource  buzz      1, 440, 20, 1\natime    linseg    1, p3/2,.01, p3/2,1   ; trace a distance in secs\nampfac   =         1/atime/atime         ; and calc an amp factor\nadump    delayr    1                     ; set maximum distance\namove    deltapi   atime                 ; move sound source past\n         delayw    asource               ; the listener\n         out       amove * ampfac\n</code></pre> deltap example #2<pre><code>  ainput1 = ..... \n  ainput2 = ..... \n  kdlyt1  = ..... \n  kdlyt2  = ..... \n\n;Read delayed signal, first delayr instance:\n  adump   delayr  4.0 \n  adly1   deltap  kdlyt1       ; associated with first delayr instance\n\n;Read delayed signal, second delayr instance:\n  adump   delayr  4.0 \n  adly2   deltap  kdlyt2       ; associated with second delayr instance\n\n;Do some cross-coupled manipulation:\n  afdbk1  =       0.7 * adly1 + 0.7 * adly2 + ainput1 \n  afdbk2  =       -0.7 * adly1 + 0.7 * adly2 + ainput2 \n\n;Feed back signal, associated with first delayr instance:\n          delayw  afdbk1 \n\n;Feed back signal, associated with second delayr instance:\n          delayw  afdbk2\n          outs    adly1, adly2\n</code></pre> <p>Here is yet another example of the deltap3 opcode. It uses the file deltap3.csd.</p> Example of the deltap3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltap3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltap3 .4              ;first tap (on left channel)\nadelM   deltap3 1               ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    1, p3, .01      ;vary delay time\nadelR   deltap3 .65 * kdel      ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltap3/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltapi/","title":"Deltapi","text":""},{"location":"opcodes/deltapi/#deltapi","title":"deltapi","text":"<p>Taps a delay line at variable offset times, uses interpolation.</p>"},{"location":"opcodes/deltapi/#syntax","title":"Syntax","text":"<pre><code>ares deltapi xdlt\n</code></pre>"},{"location":"opcodes/deltapi/#performance","title":"Performance","text":"<p>xdlt -- specifies the tapped delay time in seconds. Each can range from 1 control period to the full delay time of the read/write pair; however, since there is no internal check for adherence to this range, the user is wholly responsible. Each argument can be a constant, a variable, or a time-varying signal; the xdlt argument in deltapi implies that an audio-varying delay is permitted there.</p> <p>deltapi extracts sound by interpolated readout. By interpolating between adjacent stored samples deltapi represents a particular delay time with more accuracy, but it will take about twice as long to run.</p> <p>This opcode can tap into a delayr/delayw pair, extracting delayed audio from the idlt seconds of stored sound. There can be any number of deltap and/or deltapi units between a read/write pair. Each receives an audio tap with no change of original amplitude.</p> <p>This opcode can provide multiple delay taps for arbitrary delay path and feedback networks. They can deliver either constant-time or time-varying taps, and are useful for building chorus effects, harmonizers, and Doppler shifts. Constant-time delay taps (and some slowly changing ones) do not need interpolated readout; they are well served by deltap. Medium-paced or fast varying dlt's, however, will need the extra services of deltapi.</p> <p>delayr/delayw pairs may be interleaved. To associate a delay tap unit with a specific delayr unit, it not only has to be located between that delayr and the appropriate delayw unit, but must also precede any following delayr units. See Example 2. (This feature added in Csound version 3.57 by Jens Groh and John ffitch).</p> <p>N.B. k-rate delay times are not internally interpolated, but rather lay down stepped time-shifts of audio samples; this will be found quite adequate for slowly changing tap times. For medium to fast-paced changes, however, one should provide a higher resolution audio-rate timeshift as input.</p>"},{"location":"opcodes/deltapi/#examples","title":"Examples","text":"deltap example #1<pre><code>asource  buzz      1, 440, 20, 1\natime    linseg    1, p3/2,.01, p3/2,1   ; trace a distance in secs\nampfac   =         1/atime/atime         ; and calc an amp factor\nadump    delayr    1                     ; set maximum distance\namove    deltapi   atime                 ; move sound source past\n         delayw    asource               ; the listener\n         out       amove * ampfac\n</code></pre> deltap example #1<pre><code>  ainput1 = ..... \n  ainput2 = ..... \n  kdlyt1  = ..... \n  kdlyt2  = ..... \n\n;Read delayed signal, first delayr instance:\n  adump   delayr  4.0 \n  adly1   deltap  kdlyt1       ; associated with first delayr instance\n\n;Read delayed signal, second delayr instance:\n  adump   delayr  4.0 \n  adly2   deltap  kdlyt2       ; associated with second delayr instance\n\n;Do some cross-coupled manipulation:\n  afdbk1  =       0.7 * adly1 + 0.7 * adly2 + ainput1 \n  afdbk2  =       -0.7 * adly1 + 0.7 * adly2 + ainput2 \n\n;Feed back signal, associated with first delayr instance:\n          delayw  afdbk1 \n\n;Feed back signal, associated with second delayr instance:\n          delayw  afdbk2\n          outs    adly1, adly2\n</code></pre> <p>Here is yet another example of the deltapi opcode. It uses the file deltapi.csd.</p> Example of the deltapi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltapi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltapi .4              ;first tap (on left channel)\nadelM   deltapi 1               ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    1, p3, .01      ;vary delay time\nadelR   deltapi .65 * kdel      ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltapi/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltapn/","title":"Deltapn","text":""},{"location":"opcodes/deltapn/#deltapn","title":"deltapn","text":"<p>Taps a delay line at variable offset times.</p>"},{"location":"opcodes/deltapn/#syntax","title":"Syntax","text":"<pre><code>ares deltapn xnumsamps\n</code></pre>"},{"location":"opcodes/deltapn/#performance","title":"Performance","text":"<p>xnumsamps -- specifies the tapped delay time in number of samples. Each can range from 1 control period to the full delay time of the read/write pair; however, since there is no internal check for adherence to this range, the user is wholly responsible. Each argument can be a constant, a variable, or a time-varying signal.</p> <p>deltapn is identical to deltapi, except delay time is specified in number of samples, instead of seconds (Hans Mikelson).</p> <p>This opcode can tap into a delayr/delayw pair, extracting delayed audio from the idlt seconds of stored sound. There can be any number of deltap and/or deltapi units between a read/write pair. Each receives an audio tap with no change of original amplitude.</p> <p>This opcode can provide multiple delay taps for arbitrary delay path and feedback networks. They can deliver either constant-time or time-varying taps, and are useful for building chorus effects, harmonizers, and Doppler shifts. Constant-time delay taps (and some slowly changing ones) do not need interpolated readout; they are well served by deltap. Medium-paced or fast varying dlt's, however, will need the extra services of deltapi.</p> <p>delayr/delayw pairs may be interleaved. To associate a delay tap unit with a specific delayr unit, it not only has to be located between that delayr and the appropriate delayw unit, but must also precede any following delayr units. See Example 2. (This feature added in Csound version 3.57 by Jens Groh and John ffitch).</p> <p>N.B. k-rate delay times are not internally interpolated, but rather lay down stepped time-shifts of audio samples; this will be found quite adequate for slowly changing tap times. For medium to fast-paced changes, however, one should provide a higher resolution audio-rate timeshift as input.</p>"},{"location":"opcodes/deltapn/#examples","title":"Examples","text":"<p>Here is an example of the deltapn opcode. It uses the file deltapn.csd.</p> Example of the deltapn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltap3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1   \n\ngasig  init 0   \ngidel  = 1              ;delay time in seconds\n\ninstr 1\n\nain  pluck .7, 440, 1000, 0, 1\n     outs ain, ain\n\nvincr gasig, ain        ;send to global delay\nendin\n\ninstr 2 \n\nifeedback = p4  \n\nabuf2   delayr  gidel\nadelL   deltapn 4000            ;first tap (on left channel)\nadelM   deltapn 44100           ;second tap (on middle channel)\n        delayw  gasig + (adelL * ifeedback)\n\nabuf3   delayr  gidel\nkdel    line    100, p3, 1      ;vary delay time\nadelR   deltapn  100 * kdel     ;one pitch changing tap (on the right chn.)\n        delayw  gasig + (adelR * ifeedback)\n;make a mix of all deayed signals       \n        outs    adelL + adelM, adelR + adelM\n\nclear   gasig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 1 3 1\ni 2 0 3  0      ;no feedback\ni 2 3 8 .8      ;lots of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltapn/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltapx/","title":"Deltapx","text":""},{"location":"opcodes/deltapx/#deltapx","title":"deltapx","text":"<p>Read from or write to a delay line with interpolation.</p> <p>deltapx is similar to deltapi or deltap3. However, it allows higher quality interpolation. This opcode can read from and write to a delayr/delayw delay line with interpolation.</p>"},{"location":"opcodes/deltapx/#syntax","title":"Syntax","text":"<pre><code>aout deltapx adel, iwsize\n</code></pre>"},{"location":"opcodes/deltapx/#initialization","title":"Initialization","text":"<p>iwsize -- interpolation window size in samples. Allowed values are integer multiplies of 4 in the range 4 to 1024. iwsize = 4 uses cubic interpolation. Increasing iwsize improves sound quality at the expense of CPU usage, and minimum delay time.</p>"},{"location":"opcodes/deltapx/#performance","title":"Performance","text":"<p>aout -- Output signal.</p> <p>adel -- Delay time in seconds.</p> <pre><code>a1  delayr   idlr\n    deltapxw a2, adl1, iws1\na3  deltapx  adl2, iws2\n    deltapxw a4, adl3, iws3\n    delayw   a5\n</code></pre> <p>Minimum and maximum delay times:</p> <pre><code>idlr &gt;= 1/kr                                Delay line length\n\nadl1 &gt;= (iws1/2)/sr                         Write before read\nadl1 &lt;= idlr - (1 + iws1/2)/sr              (allows shorter delays)\n\nadl2 &gt;= 1/kr + (iws2/2)/sr                  Read time\nadl2 &lt;= idlr - (1 + iws2/2)/sr\nadl2 &gt;= adl1 + (iws1 + iws2) / (2*sr)\nadl2 &gt;= 1/kr + adl3 + (iws2 + iws3) / (2*sr)\n\nadl3 &gt;= (iws3/2)/sr                         Write after read\nadl3 &lt;= idlr - (1 + iws3/2)/sr              (allows feedback)\n</code></pre> <p> Note</p> <p>Window sizes for opcodes other than deltapx are: deltap, deltapn: 1, deltapi: 2 (linear), deltap3: 4 (cubic)</p>"},{"location":"opcodes/deltapx/#examples","title":"Examples","text":"<p>Here is an example of the deltapx opcode. It uses the file deltapx.csd.</p> Example of the deltapx opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltapx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\na1      phasor   300\na1      =  a1 - 0.5\na_      delayr   1\nadel    phasor   4\nadel    =  sin(2 * 3.14159265 * adel) * 0.01 + 0.2\n        deltapxw a1, adel, 32\nadel    phasor   2\nadel    =  sin(2 * 3.14159265 * adel) * 0.01 + 0.2\n        deltapxw a1, adel, 32\nadel    =  0.3\na2      deltapx  adel, 32\na1      =  0\n        delayw   a1\n        outs     a2*.7, a2*.7\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltapx/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltapx/#credits","title":"Credits","text":"<p>Author: Istvan Varga August 2001</p> <p>New in version 4.13</p>"},{"location":"opcodes/deltapxw/","title":"Deltapxw","text":""},{"location":"opcodes/deltapxw/#deltapxw","title":"deltapxw","text":"<p>Mixes the input signal to a delay line.</p> <p>deltapxw mixes the input signal to a delay line. This opcode can be mixed with reading units (deltap, deltapn, deltapi, deltap3, and deltapx) in any order; the actual delay time is the difference of the read and write time. This opcode can read from and write to a delayr/delayw delay line with interpolation.</p>"},{"location":"opcodes/deltapxw/#syntax","title":"Syntax","text":"<pre><code>deltapxw ain, adel, iwsize\n</code></pre>"},{"location":"opcodes/deltapxw/#initialization","title":"Initialization","text":"<p>iwsize -- interpolation window size in samples. Allowed values are integer multiplies of 4 in the range 4 to 1024. iwsize = 4 uses cubic interpolation.  Increasing iwsize improves sound quality at the expense of CPU usage, and minimum delay time.</p>"},{"location":"opcodes/deltapxw/#performance","title":"Performance","text":"<p>ain -- Input signal.</p> <p>adel -- Delay time in seconds.</p> <pre><code>a1  delayr   idlr\n    deltapxw a2, adl1, iws1\na3  deltapx  adl2, iws2\n    deltapxw a4, adl3, iws3\n    delayw   a5\n</code></pre> <p>Minimum and maximum delay times:</p> <pre><code>idlr &gt;= 1/kr                                Delay line length\n\nadl1 &gt;= (iws1/2)/sr                         Write before read\nadl1 &lt;= idlr - (1 + iws1/2)/sr              (allows shorter delays)\n\nadl2 &gt;= 1/kr + (iws2/2)/sr                  Read time\nadl2 &lt;= idlr - (1 + iws2/2)/sr\nadl2 &gt;= adl1 + (iws1 + iws2) / (2*sr)\nadl2 &gt;= 1/kr + adl3 + (iws2 + iws3) / (2*sr)\n\nadl3 &gt;= (iws3/2)/sr                         Write after read\nadl3 &lt;= idlr - (1 + iws3/2)/sr              (allows feedback)\n</code></pre> <p> Note</p> <p>Window sizes for opcodes other than deltapx are: deltap, deltapn: 1, deltapi: 2 (linear), deltap3: 4 (cubic)</p>"},{"location":"opcodes/deltapxw/#examples","title":"Examples","text":"<p>Here is an example of the deltapxw opcode. It uses the file deltapxw.csd.</p> Example of the deltapxw opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o deltapxw.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\na1      phasor   300\na1      =  a1 - 0.5\na_      delayr   1\nadel    phasor   4\nadel    =  sin(2 * 3.14159265 * adel) * 0.01 + 0.2\n        deltapxw a1, adel, 32\nadel    phasor   2\nadel    =  sin(2 * 3.14159265 * adel) * 0.01 + 0.2\n        deltapxw a1, adel, 32\nadel    =  0.3\na2      deltapx  adel, 32\na1      =  0\n        delayw   a1\n        outs     a2*.7, a2*.7\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/deltapxw/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/deltapxw/#credits","title":"Credits","text":"<p>Author: Istvan Varga August 2001</p> <p>New in version 4.13</p>"},{"location":"opcodes/denorm/","title":"Denorm","text":""},{"location":"opcodes/denorm/#denorm","title":"denorm","text":"<p>Mixes low level (~1e-20 for floats, and ~1e-56 for doubles) noise to a list of a-rate signals.</p> <p>Can be used before IIR filters and reverbs to avoid denormalized numbers which may otherwise result in significantly increased CPU usage.</p>"},{"location":"opcodes/denorm/#syntax","title":"Syntax","text":"<pre><code>denorm a1[, a2[, a3[, ... ]]]\n</code></pre>"},{"location":"opcodes/denorm/#performance","title":"Performance","text":"<p>a1[, a2[, a3[, ... ]]] -- signals to mix noise with</p> <p>Some processor architectures (particularly Pentium IVs) are very slow at processing extremely small numbers. These small numbers can appear as a result of some decaying feedback process like reverb and IIR filters. Low level noise can be added so that very small numbers are never reached, and they are 'absorbed' by this 'noise floor'.</p> <p>If CPU usage goes to 100% at the end of reverb tails, or you get audio glitches in processes that should not use too much CPU, using denorm before the culprit opcode or process might solve the problem.</p>"},{"location":"opcodes/denorm/#examples","title":"Examples","text":"<p>Here is an example of the denorm opcode. It uses the file denorm.csd.</p> Example of the denorm opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o denorm.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; slightly simplified example from Istvan Varga 2006\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngarvb init 0\n\ninstr 1\n\na1  oscils 0.6, 440, 0\na2  linsegr 0, 0.005, 1, 3600, 1, 0.08, 0\na1  =  a1 * a2\n    vincr garvb, a1\n    outs a1, a1\nendin\n\ninstr 99        ;\"Always on\"\n\n       denorm garvb\naL, aR reverbsc garvb * 0.5, garvb * 0.5, 0.92, 10000\n       clear garvb\n       outs aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 99 0 -1       ;held by a negative p3, means \"always on\" \ni 1 0 0.5\ni 1 4 0.5\ne 8             ;8 extra seconds after the performance\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/denorm/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/denorm/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/diff/","title":"Diff","text":""},{"location":"opcodes/diff/#diff","title":"diff","text":"<p>Modify a signal by differentiation.</p>"},{"location":"opcodes/diff/#syntax","title":"Syntax","text":"<pre><code>ares diff asig [, iskip]\nkres diff ksig [, iskip]\n</code></pre>"},{"location":"opcodes/diff/#initialization","title":"Initialization","text":"<p>iskip (optional) -- initial disposition of internal save space (see reson). The default value is 0.</p>"},{"location":"opcodes/diff/#performance","title":"Performance","text":"<p>integ and diff perform integration and differentiation on an input control signal or audio signal. Each is the converse of the other, and applying both will reconstruct the original signal. Since these units are special cases of low-pass and high-pass filters, they produce a scaled (and phase shifted) output that is frequency-dependent. Thus diff of a sine produces a cosine, with amplitude 2 * pi * Hz / sr that of the original (for each component partial); integ will inversely affect the magnitudes of its component inputs. With this understanding, these units can provide useful signal modification.</p>"},{"location":"opcodes/diff/#examples","title":"Examples","text":"<p>Here is an example of the diff opcode. It uses the file diff.csd.</p> Example of the diff opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o diff.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nasig diskin2 \"fox.wav\", 1\n     outs asig, asig\n\nendin\n\ninstr 2 ; with diff\n\nasig diskin2 \"fox.wav\", 1\nares diff asig\n     outs ares, ares\n\nendin\n\ninstr 3 ; with integ\n\nasig diskin2 \"fox.wav\", 1\naint integ asig\naint = aint*.05                 ;way too loud\n     outs aint, aint\n\nendin\n\ninstr 4 ; with diff and integ\n\nasig diskin2 \"fox.wav\", 1\nares diff asig\naint integ ares\n     outs aint, aint\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 2 1 1\ni 3 2 1\ni 4 3 1\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/diff/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/diode_ladder/","title":"Diode ladder","text":""},{"location":"opcodes/diode_ladder/#diode_ladder","title":"diode_ladder","text":"<p>Zero-delay feedback implementation of a 4 pole (24 dB/oct) diode low-pass filter.</p> <p>This filter design was originally used in the EMS VCS3 and was the resonant filter in the Roland TB-303.</p>"},{"location":"opcodes/diode_ladder/#syntax","title":"Syntax","text":"<pre><code>asig diode_ladder ain, xcf, xk [, inlp, isaturation, istor]\n</code></pre>"},{"location":"opcodes/diode_ladder/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/diode_ladder/#performance","title":"Performance","text":"<p>asig -- low-pass output signal.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>xk -- filter feedback value k (i-, k-, or a-rate) that controls resonance. Range 0.0-17.0 . Self-oscillation occurs at 17.0.</p> <p>knlp (optional, default=0) -- Non-linear processing method. 0 = no processing, 1 = higher-quality NLP, 2 = lower-quality NLP (faster). Method 1 uses (1.0 / tanh(ksaturation)) * tanh(ksaturation * input). Method 2 uses tanh(ksaturation * input). Enabling NLP may increase the overall output of filter above unity and should be compensated for outside of the filter.</p> <p>ksaturation (optional, default=1) -- saturation amount to use for non-linear processing. Values &gt; 1 increase the steepness of the NLP curve.</p>"},{"location":"opcodes/diode_ladder/#examples","title":"Examples","text":"<p>Here is an example of the diode_ladder opcode. It uses the file diode_ladder.csd.</p> Example of the diode_ladder opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr=44100\nksmps=16\nnchnls=2\n0dbfs=1\n\n\ngi_sine ftgen 0, 0, 65537, 10, 1\n\ngkcut init 6000\n\n\ninstr modulation \n  gkcut = lfo(4000, 0.1) + 6000 \nendin\n\ninstr bass       \n\n  iamp = ampdbfs(-12) \n  ipch = cps2pch(p4, 12)\n\n  asig = vco2(0.5, ipch, 0)\n\n  acut = expon:a(i(gkcut), p3, 200) \n  aout = diode_ladder(asig, acut, 8, 1, 4)\n\n  aout *= expseg:a(1.0, p3 - 0.05, 1.0, 0.05, 0.001) \n\n  aout = limit(aout, -1.0, 1.0)\n\n  outc(aout, aout)\n\nendin\n\n\ngipat[] init 8\ngipat[0] = 6.00\ngipat[1] = 7.00\ngipat[2] = 6.00\ngipat[3] = 7.00\ngipat[4] = 5.07\ngipat[5] = 6.07\ngipat[6] = 5.08\ngipat[7] = 6.08\n\n\ninstr player\n  indx = p4\n\n  ;; play instrument\n  if(gipat[indx] &gt; 0) then\n    schedule(\"bass\", 0, 0.2, gipat[indx])\n  endif\n\n  ;; temporal recursion\n  schedule(\"player\", 0.2, 0.1, (indx + 1) % lenarray(gipat))\n\nendin\n\nschedule(\"modulation\", 0, -1)\nschedule(\"player\", 0, 0.1, 0)\nevent_i(\"e\", 0, 0.1 * 128)\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;  \n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/diode_ladder/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-6:\u00a0Virtual Analog (VA) DiodeLadder Filter. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/diode_ladder/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/diode_ladder/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/diskgrain/","title":"Diskgrain","text":""},{"location":"opcodes/diskgrain/#diskgrain","title":"diskgrain","text":"<p>Synchronous granular synthesis, using a soundfile as source.</p> <p>The source sound for the grains is obtained by reading a soundfile containing the samples of the source waveform.</p>"},{"location":"opcodes/diskgrain/#syntax","title":"Syntax","text":"<pre><code>asig diskgrain Sfname, kamp, kfreq, kpitch, kgrsize, kprate, \\\n               ifun, iolaps [,imaxgrsize , ioffset]\n</code></pre>"},{"location":"opcodes/diskgrain/#initialization","title":"Initialization","text":"<p>Sfilename -- source soundfile.</p> <p>ifun -- grain envelope function table.</p> <p>iolaps -- maximum number of overlaps, max(kfreq)*max(kgrsize). Estimating a large value should not affect performance, but exceeding this value will probably have disastrous consequences.</p> <p>imaxgrsize -- max grain size in secs (default 1.0).</p> <p>ioffset -- start offset in secs from beginning of file (default: 0).</p>"},{"location":"opcodes/diskgrain/#performance","title":"Performance","text":"<p>kamp -- amplitude scaling</p> <p>kfreq -- frequency of grain generation, or density, in grains/sec.</p> <p>kpitch -- grain pitch scaling (1=normal pitch, &lt; 1 lower, &gt; 1 higher; negative, backwards)</p> <p>kgrsize -- grain size in secs.</p> <p>kprate -- readout pointer rate, in grains. The value of 1 will advance the reading pointer 1 grain ahead in the source table. Larger values will time-compress and smaller values will time-expand the source signal.  Negative values will cause the pointer to run backwards and zero will freeze it.</p> <p>The grain generator has full control of frequency (grains/sec), overall amplitude, grain pitch (a sampling increment) and grain size (in secs), both as fixed or time-varying (signal) parameters.  An extra parameter is the grain pointer speed (or rate), which controls which position the generator will start reading samples in the file for each successive grain. It is measured in fractions of grain size, so a value of 1 (the default) will make each successive grain read from where the previous grain should finish. A value of 0.5 will make the next grain start at the midway position from the previous grain start and finish, etc.. A value of 0 will make the generator read always from a fixed position (wherever the pointer was last at). A negative value will decrement pointer positions. This control gives extra flexibility for creating timescale modifications in the resynthesis.</p> <p>Diskgrain will generate any number of parallel grain streams (which will depend on grain density/frequency), up to the olaps value (default 100). The number of streams (overlapped grains) is determined by grainsize*grain_freq. More grain overlaps will demand more calculations and the synthesis might not run in realtime (depending on processor power).</p> <p>Diskgrain can simulate FOF-like formant synthesis, provided that a suitable shape is used as grain envelope and a sinewave as the grain wave. For this use, grain sizes of around 0.04 secs can be used. The formant centre frequency is determined by the grain pitch.  Since this is a sampling increment, in order to use a frequency in Hz, that value has to be scaled by tablesize/sr. Grain frequency will determine the fundamental.</p> <p>This opcode is a variation on the syncgrain opcode.</p> <p> Note</p> <p>diskgrain does not do any resampling, so if the sample rate of the source filename is not the same as csound's sr value there will be pitch shifts</p>"},{"location":"opcodes/diskgrain/#examples","title":"Examples","text":"<p>Here is an example of the diskgrain opcode. It uses the file diskgrain.csd.</p> Example of the diskgrain opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o diskgrain.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2022\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niolaps  = 2\nigrsize = 0.04\nifreq   = iolaps/igrsize\nips     = 1/iolaps\n\nistr = p4  /* timescale */\nipitch = p5 /* pitchscale */\n\na1 diskgrain \"marimba.aif\", 1, ifreq, ipitch, igrsize, ips*istr, 1, iolaps\nprints \"\\nmarimba is playing....\\n\\n\"\n   outs   a1, a1\n\nendin\n\ninstr 2\n\niolaps  = 5\nigrsize = 0.1\nifreq   = iolaps/igrsize\nips     = 1/iolaps\n\nistr = p4  /* timescale */\nipitch = p5 /* pitchscale */\n\na1 diskgrain \"singFemale.aif\", .5, ifreq, ipitch, igrsize, ips*istr, 1, iolaps\nprints \"\\nFemale is singing....\\n\\n\"\n   outs   a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 20 2 1  ;Hanning function\n\n;           timescale   pitchscale\ni 1   0   6     1           1           \ni 1   +   6     2           1\ni 1   +   6     1          0.75\ni 1   +   6     1.5        1.5\ni 1   +   6.25  0.5        1.5\n\n;           timescale   pitchscale\ni 2   31  4     1           1           \ni 2   +   4     2           1\ni 2   +   4     1          0.75\ni 2   +   5     1.5        1.5\ni 2   +   7.9   0.5        1.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/diskgrain/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/diskgrain/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini May 2007</p> <p>New in Csound 5.06</p>"},{"location":"opcodes/diskin/","title":"Diskin","text":""},{"location":"opcodes/diskin/#diskin","title":"diskin","text":"<p>Reads audio data from an external device or stream and can alter its pitch.</p>"},{"location":"opcodes/diskin/#syntax","title":"Syntax","text":"<p><pre><code>ar1 [, ar2 [, ar3 [, ... arN]]] diskin ifilcod[, kpitch[, iskiptim \\\n    [, iwraparound[, iformat[, iskipinit]]]]]\n</code></pre> Note the N was 24 in versions before 5.14, and 40 after. <pre><code>ar1[] diskin ifilcod[, kpitch[, iskiptim [, iwraparound[, iformat[, iskipinit]]]]]\n</code></pre> (in this version, the number of output channels is not limited.)</p>"},{"location":"opcodes/diskin/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.filcod ; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR. See also GEN01.</p> <p>iskptim (optional) -- time in seconds of input sound to be skipped. The default value is 0.</p> <p>iformat (optional) -- ignored if positive but if negative specifies the audio data file format of a raw file:</p> <ul> <li>-1 = 8-bit signed char (high-order 8 bits of a 16-bit integer)</li> <li>-2 = 8-bit A-law bytes</li> <li>-3 = 8-bit U-law bytes</li> <li>-4 = 16-bit short integers</li> <li>-5 = 32-bit long integers</li> <li>-6 = 32-bit floats</li> <li>-7 = 8-bit unsigned int (not available in Csound versions older than 5.00)</li> <li>-8 = 24-bit int (not available in Csound versions older than 5.00)</li> <li>-9 = 64-bit doubles (not available in Csound versions older than 5.00)</li> </ul> <p>iwraparound -- 1 = on, 0 = off (wraps around to end of file either direction, enabling looping)</p> <p>iskipinit switches off all initialisation if non zero (default =0).  This was introduced in 4_23f13 and csound5.</p> <p>If iformat = 0 it is taken from the soundfile header, and if no header from the Csound -o command-line flag. The default value is 0.</p>"},{"location":"opcodes/diskin/#performance","title":"Performance","text":"<p>a1 ... a24 -- output signals, in the range -0dbfs to 0dbfs. Any samples before the beginning (i.e. negative location) and after the end of the file are assumed to be zero, unless iwrap is non-zero. The number of output arguments must be the same as the number of sound file channels - which can be determined with the filenchnls opcode, otherwise an init error will occur.</p> <p>ar1[] --- output signals, in a-rate array of size N, where N is the number of channels in the file. Arrays are automatically allocated to the correct size.</p> <p>kpitch -- can be any real number. A negative number signifies backwards playback. The given number is a pitch ratio, where:</p> <ul> <li>1 = normal pitch (default)</li> <li>2 = 1 octave higher</li> <li>3 = 12th higher, etc.</li> <li>.5 = 1 octave lower</li> <li>.25 = 2 octaves lower, etc.</li> <li>-1 = normal pitch backwards</li> <li>-2 = 1 octave higher backwards, etc.</li> </ul> <p> Note to Windows users</p> <p>Windows users typically use back-slashes, \u201c\\\u201d, when specifying the paths of their files. As an example, a Windows user might use the path \u201cc:\\music\\samples\\loop001.wav\u201d. This is problematic because back-slashes are normally used to specify special characters.</p> <p>To correctly specify this path in Csound, one may alternately:</p> <ul> <li>Use forward slashes: c:/music/samples/loop001.wav</li> <li>Use back-slash special characters, \u201c\\\\\u201d: c:\\\\music\\\\samples\\\\loop001.wav</li> </ul>"},{"location":"opcodes/diskin/#examples","title":"Examples","text":"<p>Here is an example of the diskin opcode. It uses the file diskin.csd, drumsMlp.wav.</p> Example of the diskin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o diskin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nktrans linseg 1, 5, 2, 10, -2\na1     diskin \"drumsMlp.wav\", ktrans, 0, 1, 0, 32\n       outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 15\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/diskin/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/diskin/#credits","title":"Credits","text":"<p>Authors: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p> <p>New in version 3.46</p> <p>kpitch optional in version 6.06</p> <p>Warning to Windows users added by Kevin Conder, April 2002</p>"},{"location":"opcodes/diskin2/","title":"Diskin2","text":""},{"location":"opcodes/diskin2/#diskin2","title":"diskin2","text":"<p>Reads audio data from a file, and can alter its pitch using one of several available interpolation types, as well as convert the sample rate to match the orchestra sr setting.</p> <p>diskin2 can also read multichannel files with any number of channels in the range 1 to 24 in versions before 5.14, and 40 after.</p>"},{"location":"opcodes/diskin2/#syntax","title":"Syntax","text":"<pre><code>a1[, a2[, ... aN]] diskin2 ifilcod[, kpitch[, iskiptim \\\n    [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]\nar1[] diskin2 ifilcod[, kpitch[, iskiptim \\\n    [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]\n</code></pre> <p>(in the array output version, the number of output channels does not have an upper limit.)</p>"},{"location":"opcodes/diskin2/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.ifilcod; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought first in the current directory, then in those given by the environment variable SSDIR (if defined) then by SFDIR. See also GEN01. Note: files longer than 2<sup>31</sup>-1 sample frames may not be played correctly on 32-bit platforms; this means a maximum length about 3 hours with a sample rate of 192000 Hz.</p> <p>iskiptim (optional, defaults to zero) -- time in seconds of input sound to be skipped, assuming kpitch=1. Can be negative, to add -iskiptim/kpitch seconds of delay instead of skipping sound.</p> <p> Note</p> <p>If iwrap is not 0 (locations are wrapped), iskiptim will not delay the sound if a negative value is used. Instead, the negative value will be \"wrapped\" from the end of the file.</p> <p>iwrap (optional, defaults to zero) -- if set to any non-zero value, read locations that are negative or are beyond the end of the file are wrapped to the duration of the sound file instead of assuming zero samples. Useful for playing a file in a loop.</p> <p> Note</p> <p>If iwrap is enabled, the file length should not be shorter than the interpolation window size (see below), otherwise there may be clicks in the sound output.</p> <p>iformat (optional, defaults to zero) -- sets raw and sample format for raw (headerless) files. This parameter must be zero if the file has a header. Allowed values for raw files are are:</p> <ul> <li>1: 16-bit short integers</li> <li>2: 8-bit signed char (high-order 8 bits of a 16-bit integer)</li> <li>3: 8-bit A-law bytes</li> <li>4: 8-bit U-law bytes</li> <li>5: 16-bit short integers</li> <li>6: 32-bit long integers</li> <li>7: 32-bit floats</li> <li>8: 8-bit unsigned int</li> <li>9: 24-bit int</li> <li>10: 64-bit doubles</li> </ul> <p> Note</p> <p>This list is not the same as in GEN01</p> <p>iwsize (optional, defaults to zero) -- interpolation window size, in samples. Can be one of the following:</p> <ul> <li>1: round to nearest sample (no interpolation, for kpitch=1)</li> <li>2: linear interpolation</li> <li>4: cubic interpolation</li> <li>\u2265 8: iwsize point sinc interpolation with anti-aliasing (slow)</li> </ul> <p>Zero or negative values select the default, which is cubic interpolation.</p> <p> Note</p> <p>If interpolation is used, kpitch is automatically scaled by the ratio of the sample rate of the sound file and the orchestra, so that the file will always be played at the original pitch if kpitch is 1. However, the sample rate conversion is disabled if iwsize is 1.</p> <p>ibufsize (optional, defaults to 0) -- buffer size in mono samples (not sample frames). This is only the suggested value, the actual setting will be rounded so that the number of sample frames is an integer power of two and is in the range 128 (or iwsize if greater than 128) to 1048576. The default, which is 4096, and is enabled by zero or negative values, should be suitable for most uses, but for non-realtime mixing of many large sound files, a high buffer setting is recommended to improve the efficiency of disk reads. For real time audio output, reading the files from a fast RAM file system (on platforms where this option is available) with a small buffer size may be preferred.</p> <p>iskipinit (optional, defaults to 0) -- skip initialization if set to any non-zero value.</p>"},{"location":"opcodes/diskin2/#performance","title":"Performance","text":"<p>a1 ... a24 -- output signals, in the range -0dbfs to 0dbfs. Any samples before the beginning (i.e. negative location) and after the end of the file are assumed to be zero, unless iwrap is non-zero. The number of output arguments must be the same as the number of sound file channels - which can be determined with the filenchnls opcode, otherwise an init error will occur.</p> <p>ar1[] --- output signals, in a-rate array of size N, where N is the number of channels in the file. Arrays are automatically allocated to the correct size.</p> <p> Note</p> <p>It is more efficient to read a single file with many channels, than many files with only a single channel, especially with high iwsize settings.</p> <p>kpitch -- transpose the pitch of input sound by this factor (e.g. 0.5 means one octave lower, 2 is one octave higher, and 1 is the original pitch, which is the default value). Fractional and negative values are allowed (the latter results in playing the file backwards, however, in this case the skip time parameter should be set to some positive value, e.g. the length of the file, or iwrap should be non-zero, otherwise nothing would be played). If interpolation is enabled, and the sample rate of the file differs from the orchestra sample rate, the transpose ratio is automatically adjusted to make sure that kpitch=1 plays at the original pitch. Using a high iwsize setting (40 or more) can significantly improve sound quality when transposing up, although at the expense of high CPU usage.</p>"},{"location":"opcodes/diskin2/#examples","title":"Examples","text":"<p>Here is an example of the diskin2 opcode. It uses the file diskin2.csd, drumsMlp.wav.</p> Example of the diskin2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o diskin2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nktrans linseg 1, 5, 2, 10, -2\na1     diskin2 \"drumsMlp.wav\", ktrans, 0, 1, 0, 32\n       outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 15\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/diskin2/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/diskin2/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p> <p>New in version 5.00</p> <p>kpitch optional in version 6.06</p>"},{"location":"opcodes/dispfft/","title":"Dispfft","text":""},{"location":"opcodes/dispfft/#dispfft","title":"dispfft","text":"<p>Displays the Fourier Transform of an audio or control signal.</p> <p>These units will print orchestra init-values, or produce graphic display of orchestra control signals and audio signals. Uses X11 windows if enabled, else (or if -g flag is set) displays are approximated in ASCII characters.</p>"},{"location":"opcodes/dispfft/#syntax","title":"Syntax","text":"<pre><code>dispfft xsig, iprd, iwsiz [, iwtyp] [, idbout] [, iwtflg] [,imin] [,imax]\n</code></pre>"},{"location":"opcodes/dispfft/#initialization","title":"Initialization","text":"<p>iprd -- the period of display in seconds.</p> <p>iwsiz -- size of the input window in samples. A window of iwsiz points will produce a Fourier transform of iwsiz/2 points, spread linearly in frequency from 0 to sr/2. iwsiz must be a power of 2, with a minimum of 16 and a maximum of 4096. The windows are permitted to overlap.</p> <p>iwtyp (optional, default=0) -- window type. 0 = rectangular, 1 = Hanning. The default value is 0 (rectangular).</p> <p>idbout (optional, default=0) -- units of output for the Fourier coefficients. 0 = magnitude, 1 = decibels. The default is 0 (magnitude).</p> <p>iwtflg (optional, default=0) -- wait flag. If non-zero, each display is held until released by the user. The default value is 0 (no wait).</p> <p>imin (optional, default=0) -- minimum FFT bin used in display.</p> <p>imax (optional, default=winsize/2) -- maximum FFT bin to be used in display.</p>"},{"location":"opcodes/dispfft/#performance","title":"Performance","text":"<p>dispfft -- displays the Fourier Transform of an audio or control signal (asig or ksig) every iprd seconds using the Fast Fourier Transform method.</p>"},{"location":"opcodes/dispfft/#examples","title":"Examples","text":"<p>Here is an example of the dispfft opcode. It uses the file dispfft.csd.</p> Example of the dispfft opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dispfft.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;;be sure to NOT have -d in the CsOptions...\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkcps = 110\nifn  = 1\n\nknh     line p4, p3, p5\nasig    buzz 1, kcps, knh, ifn\n        outs asig, asig\n\ndispfft asig, .1, 2048, 0, 1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 3 20 20\ni 1 + 3 3 3\ni 1 + 3 150 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dispfft/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/display/","title":"Display","text":""},{"location":"opcodes/display/#display","title":"display","text":"<p>Displays the audio or control signals as an amplitude vs. time graph.</p> <p>These units will print orchestra init-values, or produce graphic display of orchestra control signals and audio signals. Uses X11 windows if enabled, else (or if -g flag is set) displays are approximated in ASCII characters.</p>"},{"location":"opcodes/display/#syntax","title":"Syntax","text":"<pre><code>display xsig, iprd [, inprds] [, iwtflg]\n</code></pre>"},{"location":"opcodes/display/#initialization","title":"Initialization","text":"<p>iprd -- the period of display in seconds.</p> <p>inprds (optional, default=1) -- Number of display periods retained in each display graph. A value of 2 or more will provide a larger perspective of the signal motion. The default value is 1 (each graph completely new). inprds is a scaling factor for the displayed waveform, controlling how many iprd-sized frames of samples are drawn in the window (the default and minimum value is 1.0). Higher inprds values are slower to draw (more points to draw) but will show the waveform scrolling through the window, which is useful with low iprd values.</p> <p>iwtflg (optional, default=0) -- wait flag. If non-zero, each display is held until released by the user. The default value is 0 (no wait).</p>"},{"location":"opcodes/display/#performance","title":"Performance","text":"<p>display -- displays the audio or control signal xsig every iprd seconds, as an amplitude vs. time graph.</p>"},{"location":"opcodes/display/#examples","title":"Examples","text":"<p>Here is an example of the display opcode. It uses the file display.csd.</p> Example of the display opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o display.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;;be sure to NOT have -d in the CsOptions...\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkcps = 110\nifn  = 1\n\nknh     line p4, p3, p5\nasig    buzz 1, kcps, knh, ifn\n        outs asig, asig\n\ndisplay asig, .1, 3\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 3 20 20\ni 1 + 3 3 3\ni 1 + 3 150 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/display/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/display/#credits","title":"Credits","text":"<p>Comments about the inprds parameter contributed by Rasmus Ekman.</p>"},{"location":"opcodes/distort/","title":"Distort","text":""},{"location":"opcodes/distort/#distort","title":"distort","text":"<p>Distort an audio signal via waveshaping and optional clipping.</p>"},{"location":"opcodes/distort/#syntax","title":"Syntax","text":"<pre><code>ar distort asig, kdist, ifn[, ihp, istor]\n</code></pre>"},{"location":"opcodes/distort/#initialization","title":"Initialization","text":"<p>ifn -- table number of a waveshaping function with extended guard point.  The function can be of any shape, but it should pass through 0 with positive slope at the table mid-point.  The table size need not be large, since it is read with interpolation.</p> <p>ihp -- (optional) half-power point (in cps) of an internal low-pass filter. The default value is 10.</p> <p>istor -- (optional) initial disposition of internal data space (see reson).  The default value is 0.</p>"},{"location":"opcodes/distort/#performance","title":"Performance","text":"<p>asig -- Audio signal to be processed</p> <p>kdist -- Amount of distortion (usually between 0 and 1)</p> <p>This unit distorts an incoming signal using a waveshaping function ifn and a distortion index kdist. The input signal is first compressed using a running rms, then passed through a waveshaping ```function which may modify its shape and spectrum. Finally it is rescaled to approximately its original power.</p> <p>The amount of distortion depends on the nature of the shaping function and on the value of kdist, which generally ranges from 0 to 1. For low values of kdist, we should like the shaping function to pass the signal almost unchanged.  This will be the case if, at the mid-point of the table, the shaping function is near-linear and is passing through 0 with positive slope.  A line function from  -1 to +1 will satisfy this requirement;  so too will a sigmoid (sinusoid from 270 to 90 degrees).  As kdist is increased, the compressed signal is expanded to encounter more and more of the shaping function, and if this becomes non-linear the signal is increasingly bent on read-through to cause distortion.</p> <p>When kdist becomes large enough, the read-through process will eventually hit the outer limits of the table.  The table is not read with wrap-around, but will \u201cstick\u201d at the end-points as the incoming signal exceeds them;  this introduces clipping, an additional form of signal distortion.  The point at which clipping begins will depend on the complexity (rms-to-peak value) of the input signal.  For a pure sinusoid, clipping will begin only as kdist exceeds 0.7;  for a more complex input, clipping might begin at a kdist of 0.5 or much less.  kdist can exceed the clip point by any amount, and may be greater than 1.</p> <p>The shaping function can be made arbitrarily complex for extra effect. It should generally be continuous, though this is not a requirement.  It should also be well-behaved near the mid-point, and roughly balanced positive-negative overall, else some excessive DC offset may result.  The user might experiment with more aggressive functions to suit the  purpose.  A generally positive slope allows the distorted signal to be mixed with the source without phase cancellation.</p> <p>distort is useful as an effects process, and is usually combined with reverb and chorusing on effects busses.  However, it can alternatively be used to good effect within a single instrument.</p>"},{"location":"opcodes/distort/#examples","title":"Examples","text":"<p>Here is an example of the distort opcode. It uses the file distort.csd.</p> Example of the distort opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o distort.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ngifn    ftgen   0,0, 257, 9, .5,1,270   ; define a sigmoid, or better \n;gifn   ftgen   0,0, 257, 9, .5,1,270,1.5,.33,90,2.5,.2,270,3.5,.143,90,4.5,.111,270\n\ninstr 1\n\nkdist   line    0, p3, 2                ; and over 10 seconds\nasig    poscil  0.3, 440, 1\naout    distort asig, kdist, gifn       ; gradually increase the distortion\n        outs    aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1\ni 1 0 10\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/distort/#see-also","title":"See also","text":"<p>Special Effects</p> <p>Waveshaping</p>"},{"location":"opcodes/distort/#credits","title":"Credits","text":"<p>Written by Barry L. Vercoe for Extended Csound and released in Csound5.</p>"},{"location":"opcodes/distort1/","title":"Distort1","text":""},{"location":"opcodes/distort1/#distort1","title":"distort1","text":"<p>Modified hyperbolic tangent distortion.</p> <p>distort1 can be used to generate wave shaping distortion based on a modification of the tanh function.</p> <pre><code>       exp(asig * (shape1 + pregain)) - exp(asig * (shape2 - pregain))\naout = ---------------------------------------------------------------\n       exp(asig * pregain)            + exp(-asig * pregain)\n</code></pre>"},{"location":"opcodes/distort1/#syntax","title":"Syntax","text":"<pre><code>ares distort1 asig, kpregain, kpostgain, kshape1, kshape2[, imode]\n</code></pre>"},{"location":"opcodes/distort1/#initialization","title":"Initialization","text":"<p>imode (Csound version 5.00 and later only; optional, defaults to 0) -- scales kpregain, kpostgain, kshape1, and kshape2 for use with audio signals in the range -32768 to 32768 (imode=0), -0dbfs to 0dbfs (imode=1), or disables scaling of kpregain and kpostgain and scales kshape1 by kpregain and kshape2 by -kpregain (imode=2).</p>"},{"location":"opcodes/distort1/#performance","title":"Performance","text":"<p>asig -- is the input signal.</p> <p>kpregain -- determines the amount of gain applied to the signal before waveshaping. A value of 1 gives slight distortion.</p> <p>kpostgain -- determines the amount of gain applied to the signal after waveshaping.</p> <p>kshape1 -- determines the shape of the positive part of the curve. A value of 0 gives a flat clip, small positive values give sloped shaping.</p> <p>kshape2 -- determines the shape of the negative part of the curve.</p>"},{"location":"opcodes/distort1/#examples","title":"Examples","text":"<p>Here is an example of the distort1 opcode. It uses the file distort1.csd.</p> Example of the distort1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o distort1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n\ngadist init 0\n\ninstr 1\n  iamp = p4\n  ifqc = cpspch(p5)\n  asig pluck iamp, ifqc, ifqc, 0, 1\n  gadist = gadist + asig\nendin\n\ninstr 50\n  kpre init p4\n  kpost init p5\n  kshap1 init p6\n  kshap2 init p7\n  aout distort1 gadist, kpre, kpost, kshap1, kshap2, 1\n\n  outs aout, aout\n\n  gadist = 0\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;   Sta  Dur  Amp    Pitch\ni1  0.0  3.0  0.5  6.00\ni1  0.5  2.5  0.5  7.00\ni1  1.0  2.0  0.5  7.07\ni1  1.5  1.5  0.5  8.00\n\n;   Sta  Dur  PreGain PostGain Shape1 Shape2\ni50 0    4      2       .5       0      0\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/distort1/#see-also","title":"See also","text":"<p>Special Effects</p> <p>Waveshaping</p>"},{"location":"opcodes/distort1/#credits","title":"Credits","text":"<p>Author: Hans Mikelson December 1998</p> <p>New in Csound version 3.50</p>"},{"location":"opcodes/divides/","title":"Divides","text":""},{"location":"opcodes/divides/#_1","title":"/","text":"<p>Division operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/divides/#syntax","title":"Syntax","text":"<pre><code>a / b  (no rate restriction)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/divides/#arguments","title":"Arguments","text":"<p>The arguments of / can be scalar values or k-rate one dimensional arrays (vectors), or any combination.  If one of the arguments is an array, so is the value.</p>"},{"location":"opcodes/divides/#examples","title":"Examples","text":"<p>Here is an example of the / operator. It uses the file divides.csd.</p> Example of the / operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o /.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidiv  = 1/p3 * p4\nktrm  oscil 1, idiv, 1                                          ;use oscil as an envelope\nprintf \"retrigger rate per note duration = %f\\n\",1, idiv\nkndx  line 5, p3, 1                                             ;vary index of FM\nasig  foscil ktrm, 200, 1, 1.4, kndx, 1\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1  0 4096 10   1    ;sine wave\n\ni 1 0 3 10   \ni 1 4 3 15      \ni 1 8 3 2 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>retrigger rate per note duration = 3.333333\nretrigger rate per note duration = 5.000000\nretrigger rate per note duration = 0.666667\n</code></pre>"},{"location":"opcodes/divides/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/divides/#credits","title":"Credits","text":"<p>Arithmetic on vectors is new in version 6.00</p>"},{"location":"opcodes/divz/","title":"Divz","text":""},{"location":"opcodes/divz/#divz","title":"divz","text":"<p>Safely divides two numbers.</p>"},{"location":"opcodes/divz/#syntax","title":"Syntax","text":"<pre><code>ares divz xa, xb, ksubst\nires divz ia, ib, isubst\nkres divz ka, kb, ksubst\n ... divz(ka, kb, ksubst)... (no rate restriction)\n</code></pre>"},{"location":"opcodes/divz/#initialization","title":"Initialization","text":"<p>Whenever b is not zero, set the result to the value a / b; when b is zero, set it to the value of subst instead.</p>"},{"location":"opcodes/divz/#examples","title":"Examples","text":"<p>Here is an example of the divz opcode. It uses the file divz.csd.</p> Example of the divz opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n   ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o divz.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nka init 200                                         ; Define the numbers to be divided.\nkb line 0, p3, 200                                  ; Linearly change the value of kb from 200 to 0.\nksubst init -1                                      ; If a \"divide by zero\" error occurs, substitute -1.\nkresults divz ka, kb, ksubst                        ; Safely divide the numbers.\nprintks \"%f / %f = %f\\\\n\", 0.1, ka, kb, kresults    ; Print out the results.\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>200.000000 / 0.000000 = -1.000000\n200.000000 / 66.757370 = 2.995924\n200.000000 / 133.514739 = 1.497962\n</code></pre>"},{"location":"opcodes/divz/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/divz/#credits","title":"Credits","text":"<p>Author: John ffitch after an idea by Barry L. Vercoe</p> <p>Example written by Kevin Conder.</p> <p>Functional form available in csound Version 6.00</p>"},{"location":"opcodes/doppler/","title":"Doppler","text":""},{"location":"opcodes/doppler/#doppler","title":"doppler","text":"<p>A fast and robust method for approximating sound propagation, achieving convincing Doppler shifts without having to solve equations.</p> <p>Plugin opcode in doppler.</p> <p>The method computes frequency shifts based on reading an input delay line at a delay time computed from the distance between source and mic and the speed of sound. One instance of the opcode is required for each dimension of space through which the sound source moves. If the source sound moves at a constant speed from in front of the microphone, through the microphone, to behind the microphone, then the output will be frequency shifted above the source frequency at a constant frequency while the source approaches, then discontinuously will be shifted below the source frequency at a constant frequency as the source recedes from the microphone. If the source sound moves at a constant speed through a point to one side of the microphone, then the rate of change of position will not be constant, and the familiar Doppler frequency shift typical of a siren or engine approaching and receding along a road beside a listener will be heard.</p>"},{"location":"opcodes/doppler/#syntax","title":"Syntax","text":"<pre><code>ashifted doppler asource, ksourceposition, kmicposition [, isoundspeed, \\\n                 ifiltercutoff]\n</code></pre>"},{"location":"opcodes/doppler/#initialization","title":"Initialization","text":"<p>isoundspeed (optional, default=340.29) -- Speed of sound in meters/second.</p> <p>ifiltercutoff (optional, default=6) -- Rate of updating the position smoothing filter, in cycles/second.</p>"},{"location":"opcodes/doppler/#performance","title":"Performance","text":"<p>asource -- Input signal at the sound source.</p> <p>ksourceposition -- Position of the source sound in meters. The distance between source and mic should not be changed faster than about 3/4 the speed of sound.</p> <p>kmicposition -- Position of the recording microphone in meters. The distance between source and mic should not be changed faster than about 3/4 the speed of sound.</p>"},{"location":"opcodes/doppler/#examples","title":"Examples","text":"<p>Here is an example of the doppler opcode. It uses the file doppler.csd.</p> Example of the doppler opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o doppler.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 48000\nksmps = 128\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\niattack       init    0.05\nirelease      init    0.05\nisustain      init    p3\np3            init    iattack + isustain + irelease\nkdamping      linseg  0.0, iattack, 1.0, isustain, 1.0, irelease, 0.0   \nkmic          init    4\n              ; Position envelope, with a changing rate of change of position.\n;             transeg a   dur   ty  b      dur    ty  c    dur    ty d\nkposition     transeg 4, p3*.4, 0, 120,   p3*.3, -3, 50,   p3*.3, 2, 4\nismoothinghz  init    6\nispeedofsound init    340.29\nasignal       vco2    0.5, 110\naoutput       doppler asignal, kposition, kmic, ispeedofsound, ismoothinghz\n              outs    aoutput*kdamping, aoutput * kdamping\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1      0.0     20      \ne1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/doppler/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/doppler/#credits","title":"Credits","text":"<p>Author of algorithm: Peter Brinkmann Author of opcode: Michael Gogins January 2010</p> <p>New in Csound version 5.11</p>"},{"location":"opcodes/dot/","title":"Dot","text":""},{"location":"opcodes/dot/#dot","title":"dot","text":"<p>Calculates the dot product of two arrays.</p>"},{"location":"opcodes/dot/#syntax","title":"Syntax","text":"<pre><code>kres/ires dot karr1[]/iarr1[], karr2[]/iarr2[]   (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/dot/#examples","title":"Examples","text":"<p>Here is an example of the dot opcode. It uses the file dota.csd.</p> Example of the dot opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n kArr1[] fillarray 1,3,2,7,4\n kArr2[] fillarray 2,3,1,2,5\n kd dot kArr1,kArr2\n printk2 kd\n turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dot/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/dot/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini</p> <p>New in version 6.09</p>"},{"location":"opcodes/downsamp/","title":"Downsamp","text":""},{"location":"opcodes/downsamp/#downsamp","title":"downsamp","text":"<p>Modify a signal by down-sampling.</p>"},{"location":"opcodes/downsamp/#syntax","title":"Syntax","text":"<pre><code>kres downsamp asig [, iwlen]\n</code></pre>"},{"location":"opcodes/downsamp/#initialization","title":"Initialization","text":"<p>iwlen (optional) -- window length in samples over which the audio signal is averaged to determine a downsampled value. Maximum length is ksmps; 0 and 1 imply no window averaging. The default value is 0.</p>"},{"location":"opcodes/downsamp/#performance","title":"Performance","text":"<p>downsamp converts an audio signal to a control signal by downsampling. It produces one kval for each audio control period. The optional window invokes a simple averaging process to suppress foldover.</p>"},{"location":"opcodes/downsamp/#examples","title":"Examples","text":"<p>Here is an example of the downsamp opcode. It uses the file downsamp.csd.</p> Example of the downsamp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o downsamp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr   1\n\nifrq    = cpspch(p4)\nain     diskin2 \"drumsMlp.wav\", 1\naenv    follow  ain, .001       ;take the amplitude every 1/1000th of a second\nalow    tone    aenv, 25        ;lowpass-filter (25 Hz) for a clean signal\nkenv    downsamp alow\nasig    pluck   kenv, ifrq, 15, 0, 1\n        outs    asig, asig\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2  9\ni 1 + .  7\ni 1 + .  5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/downsamp/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/dripwater/","title":"Dripwater","text":""},{"location":"opcodes/dripwater/#dripwater","title":"dripwater","text":"<p>Semi-physical model of a water drop.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/dripwater/#syntax","title":"Syntax","text":"<pre><code>ares dripwater kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n               [, ifreq1] [, ifreq2]\n</code></pre>"},{"location":"opcodes/dripwater/#initialization","title":"Initialization","text":"<p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 10.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.996 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.996 which means that the default value of idamp is 0. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 2.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value. Rasmus Ekman suggests a range of 1.4-1.75. He also suggests a maximum value of 1.9 instead of the theoretical limit of 2.0.</p> <p>imaxshake (optional, default=0) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p> <p>ifreq (optional) -- the main resonant frequency. The default value is 450.</p> <p>ifreq1 (optional) -- the first resonant frequency. The default value is 600.</p> <p>ifreq2 (optional) -- the second resonant frequency. The default value is 750.</p>"},{"location":"opcodes/dripwater/#performance","title":"Performance","text":"<p>kamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only an approximation.</p>"},{"location":"opcodes/dripwater/#examples","title":"Examples","text":"<p>Here is an example of the dripwater opcode. It uses the file dripwater.csd.</p> Example of the dripwater opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dripwater.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nimaxshake = p4\nifreq     = p5\nifreq1    = p6\nifreq2    = p7\n\n;low amplitude\nadrp dripwater .1, 0.09, 10, .9, imaxshake, ifreq, ifreq1, ifreq2 \nasig clip adrp, 2, 0.9  ; avoid drips that drip too loud\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n{100 CNT \n\ni1 [0.1 * $CNT] 0.5 0.5 430 1000 800 \n\n} \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dripwater/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/dripwater/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/dumpk/","title":"Dumpk","text":""},{"location":"opcodes/dumpk/#dumpk","title":"dumpk","text":"<p>Periodically writes an orchestra control-signal value to a named external file in a specific format.</p>"},{"location":"opcodes/dumpk/#syntax","title":"Syntax","text":"<pre><code>dumpk  ksig, ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/dumpk/#initialization","title":"Initialization","text":"<p>ifilname -- character string (in double quotes, spaces permitted) denoting the external file name. May either be a full path name with target directory specified or a simple filename to be created within the current directory</p> <p>iformat -- specifies the output data format:</p> <ul> <li>1 = 8-bit signed char (high order 8 bits of a 16-bit integer)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers</li> <li>8 = ASCII floats (2 decimal places)</li> </ul> <p>Note that A-law and U-law output are not available, and that all formats except the last two are binary. The output file contains no header information.</p> <p>iprd -- the period of ksig output in seconds, rounded to the nearest orchestra control period. A value of 0 implies one control period (the enforced minimum), which will create an output file sampled at the orchestra control rate.</p>"},{"location":"opcodes/dumpk/#performance","title":"Performance","text":"<p>ksig -- a control-rate signal</p> <p>This opcode allows a generated control signal value to be saved in a named external file. The file contains no self-defining header information. But it contains a regularly sampled time series, suitable for later input or analysis. There may be any number of dumpk opcodes in an instrument or orchestra but each must write to a different file.</p>"},{"location":"opcodes/dumpk/#examples","title":"Examples","text":"<p>Here is an example of the dumpk opcode. It uses the file dumpk.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the dumpk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o dumpk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 20\nnchnls = 1\n\n; By Andres Cabrera 2008\n\ninstr 1\n; Write fibonacci numbers to file \"fibonacci.txt\"\n; as ascii long integers (mode 7), using the orchestra's\n; control rate (iprd = 0)\n\nknumber init 0\nkoldnumber init 1\nktrans init 1\nktrans = knumber\nknumber = knumber + koldnumber\nkoldnumber = ktrans\ndumpk  knumber, \"fibonacci.txt\", 7, 0\nprintk2 knumber\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;Write to the file for 1 second. Since control rate is 20, 20 values will be written\n i 1 0 1\n\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the dumpk opcode. It uses the file dumpk-2.csd.</p> Example 2 of the dumpk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dumpk-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes a control signal to a file\nkfreq randh  100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\n      dumpk  kfreq, \"dumpk.txt\", 8, 1 ;writes the control signal\n      printk 1, kfreq                            ;prints it\nendin\n\ninstr 2 ;reads the file written by instr 1\nkfreq readk  \"dumpk.txt\", 8, 1\n      printk 1, kfreq ;prints it\naout  poscil .2, kfreq, giSine\n      outs   aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>WARNING: Seeding from current time 683384022\n\ni   1 time     1.00033:   463.64510\ni   1 time     2.00000:   463.64510\ni   1 time     3.00000:   483.14200\ni   1 time     4.00000:   567.55973\ni   1 time     5.00000:   576.37060\ni   1 time     6.00000:   460.66550\n\ni   2 time     6.00033:   463.64510\ni   2 time     7.00000:   463.64510\ni   2 time     8.00000:   483.14200\ni   2 time     9.00000:   567.55970\ni   2 time    10.00000:   576.37060\ni   2 time    11.00000:   460.66550\n</code></pre>"},{"location":"opcodes/dumpk/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/dumpk/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/dumpk2/","title":"Dumpk2","text":""},{"location":"opcodes/dumpk2/#dumpk2","title":"dumpk2","text":"<p>Periodically writes two orchestra control-signal values to a named external file in a specific format.</p>"},{"location":"opcodes/dumpk2/#syntax","title":"Syntax","text":"<pre><code>dumpk2 ksig1, ksig2, ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/dumpk2/#initialization","title":"Initialization","text":"<p>ifilname -- character string (in double quotes, spaces permitted) denoting the external file name. May either be a full path name with target directory specified or a simple filename to be created within the current directory</p> <p>iformat -- specifies the output data format:</p> <ul> <li>1 = 8-bit signed char (high order 8 bits of a 16-bit integer)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers</li> <li>8 = ASCII floats (2 decimal places)</li> </ul> <p>Note that A-law and U-law output are not available, and that all formats except the last two are binary. The output file contains no header information.</p> <p>iprd -- the period of ksig output in seconds, rounded to the nearest orchestra control period. A value of 0 implies one control period (the enforced minimum), which will create an output file sampled at the orchestra control rate.</p>"},{"location":"opcodes/dumpk2/#performance","title":"Performance","text":"<p>ksig1, ksig2 -- control-rate signals.</p> <p>This opcode allows two generated control signal values to be saved in a named external file. The file contains no self-defining header information. But it contains a regularly sampled time series, suitable for later input or analysis. There may be any number of dumpk2 opcodes in an instrument or orchestra but each must write to a different file.</p>"},{"location":"opcodes/dumpk2/#examples","title":"Examples","text":"<p>Here is an example of the dumpk2 opcode. It uses the file dumpk2.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the dumpk2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dumpk2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes two control signals to a file\nkfreq     randh     100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\nkdb       randh     12, 1, 2, 1, -12 ;amplitudes in dB between -24 and 0\n          dumpk2    kfreq, kdb, \"dumpk2.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kfreq = %f, kdb = %f\\n\", 1, kfreq, kdb  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkf,kdb    readk2    \"dumpk2.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kfreq = %f, kdb = %f\\n\", 1, kf, kdb  ;prints again\nkdb       lineto    kdb, .1 ;smoothing amp transition\naout      poscil    ampdb(kdb), kf, giSine\n          outs      aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>kfreq = 429.202551, kdb = -20.495694\nkfreq = 429.202551, kdb = -20.495694\nkfreq = 407.275258, kdb = -23.123776\nkfreq = 475.264472, kdb = -9.300846\nkfreq = 569.979181, kdb = -7.315527\nkfreq = 440.103457, kdb = -0.058331\n\nkfreq = 429.202600, kdb = -20.495700\nkfreq = 429.202600, kdb = -20.495700\nkfreq = 407.275300, kdb = -23.123800\nkfreq = 475.264500, kdb = -9.300800\nkfreq = 569.979200, kdb = -7.315500\nkfreq = 440.103500, kdb = -0.058300\n</code></pre>"},{"location":"opcodes/dumpk2/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/dumpk2/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/dumpk3/","title":"Dumpk3","text":""},{"location":"opcodes/dumpk3/#dumpk3","title":"dumpk3","text":"<p>Periodically writes three orchestra control-signal values to a named external file in a specific format.</p>"},{"location":"opcodes/dumpk3/#syntax","title":"Syntax","text":"<pre><code>dumpk3 ksig1, ksig2, ksig3, ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/dumpk3/#initialization","title":"Initialization","text":"<p>ifilname -- character string (in double quotes, spaces permitted) denoting the external file name. May either be a full path name with target directory specified or a simple filename to be created within the current directory</p> <p>iformat -- specifies the output data format:</p> <ul> <li>1 = 8-bit signed char (high order 8 bits of a 16-bit integer)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers</li> <li>8 = ASCII floats (2 decimal places)</li> </ul> <p>Note that A-law and U-law output are not available, and that all formats except the last two are binary. The output file contains no header information.</p> <p>iprd -- the period of ksig output in seconds, rounded to the nearest orchestra control period. A value of 0 implies one control period (the enforced minimum), which will create an output file sampled at the orchestra control rate.</p>"},{"location":"opcodes/dumpk3/#performance","title":"Performance","text":"<p>ksig1, ksig2, ksig3 -- control-rate signals</p> <p>This opcode allows three generated control signal values to be saved in a named external file. The file contains no self-defining header information. But it contains a regularly sampled time series, suitable for later input or analysis. There may be any number of dumpk3 opcodes in an instrument or orchestra but each must write to a different file.</p>"},{"location":"opcodes/dumpk3/#examples","title":"Examples","text":"<p>Here is an example of the dumpk3 opcode. It uses the file dumpk3.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the dumpk3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dumpk3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes three control signals to a file\nkfreq     randh     100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\nkdb       randh     12, 1, 2, 1, -12 ;amplitudes in dB between -24 and 0\nkpan      randh     .5, 1, 2, 1, .5 ;panning between 0 and 1\n          dumpk3    kfreq, kdb, kpan, \"dumpk3.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kfreq = %f, kdb = %f, kpan = %f\\n\", 1, kfreq, kdb, kpan  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkf,kdb,kp readk3    \"dumpk3.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kfreq = %f, kdb = %f, kpan = %f\\n\", 1, kf, kdb, kp  ;prints again\nkdb       lineto    kdb, .1 ;smoothing amp transition\nkp        lineto    kp, .1 ;smoothing pan transition\naout      poscil    ampdb(kdb), kf, giSine\naL, aR    pan2      aout, kp\n          outs      aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>WRITING:\nkfreq = 473.352855, kdb = -15.197657, kpan = 0.366764\nkfreq = 473.352855, kdb = -15.197657, kpan = 0.366764\nkfreq = 441.426368, kdb = -19.026206, kpan = 0.207327\nkfreq = 452.965140, kdb = -21.447486, kpan = 0.553270\nkfreq = 585.106328, kdb = -11.903852, kpan = 0.815665\nkfreq = 482.056760, kdb = -4.046744, kpan = 0.876537\n\nREADING:\nkfreq = 473.352900, kdb = -15.197700, kpan = 0.366800\nkfreq = 473.352900, kdb = -15.197700, kpan = 0.366800\nkfreq = 441.426400, kdb = -19.026200, kpan = 0.207300\nkfreq = 452.965100, kdb = -21.447500, kpan = 0.553300\nkfreq = 585.106300, kdb = -11.903900, kpan = 0.815700\nkfreq = 482.056800, kdb = -4.046700, kpan = 0.876500\n</code></pre>"},{"location":"opcodes/dumpk3/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/dumpk3/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/dumpk4/","title":"Dumpk4","text":""},{"location":"opcodes/dumpk4/#dumpk4","title":"dumpk4","text":"<p>Periodically writes four orchestra control-signal values to a named external file in a specific format.</p>"},{"location":"opcodes/dumpk4/#syntax","title":"Syntax","text":"<pre><code>dumpk4 ksig1, ksig2, ksig3, ksig4, ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/dumpk4/#initialization","title":"Initialization","text":"<p>ifilname -- character string (in double quotes, spaces permitted) denoting the external file name. May either be a full path name with target directory specified or a simple filename to be created within the current directory</p> <p>iformat -- specifies the output data format:</p> <ul> <li>1 = 8-bit signed char (high order 8 bits of a 16-bit integer)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers</li> <li>8 = ASCII floats (2 decimal places)</li> </ul> <p>Note that A-law and U-law output are not available, and that all formats except the last two are binary. The output file contains no header information.</p> <p>iprd -- the period of ksig output in seconds, rounded to the nearest orchestra control period. A value of 0 implies one control period (the enforced minimum), which will create an output file sampled at the orchestra control rate.</p>"},{"location":"opcodes/dumpk4/#performance","title":"Performance","text":"<p>ksig1, ksig2, ksig3, ksig4 -- control-rate signals</p> <p>This opcode allows four generated control signal values to be saved in a named external file. The file contains no self-defining header information. But it contains a regularly sampled time series, suitable for later input or analysis. There may be any number of dumpk4 opcodes in an instrument or orchestra but each must write to a different file.</p>"},{"location":"opcodes/dumpk4/#examples","title":"Examples","text":"<p>Here is an example of the dumpk4 opcode. It uses the file dumpk4.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the dumpk4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o dumpk4.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes four control signals to a file\nkcf       randh     950, 1, 2, 1, 1050 ;generates one random number between 100 and 2000 per second\nkq        randh     10, 1, 2, 1, 11 ;generates another random number between 1 and 21 per second\nkdb       randh     9, 1, 2, 1, -15 ;amplitudes in dB between -24 and -6\nkpan      randh     .5, 1, 2, 1, .5 ;panning between 0 and 1\n          dumpk4    kcf, kq, kdb, kpan, \"dumpk4.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kcf = %f, kq = %f, kdb = %f, kpan = %f\\n\", 1, kcf, kq, kdb, kpan  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkcf,kq,kdb,kp readk4 \"dumpk4.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kcf = %f, kq = %f, kdb = %f, kpan = %f\\n\", 1, kcf, kq, kdb, kp  ;prints values\nkdb       lineto    kdb, .1 ;smoothing amp transition\nkp        lineto    kp, .1 ;smoothing pan transition\nanoise    rand      ampdb(kdb), 2, 1\nkbw       =         kcf/kq ;bandwidth of resonant filter\nabp       reson     anoise, kcf, kbw\naout      balance   abp, anoise\naL, aR    pan2      aout, kp\n          outs      aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>WRITING:\nkcf = 1122.469723, kq = 11.762839, kdb = -14.313445, kpan = 0.538142\nkcf = 1122.469723, kq = 11.762839, kdb = -14.313445, kpan = 0.538142\nkcf = 1148.638412, kq = 12.040490, kdb = -14.061868, kpan = 0.552205\nkcf = 165.796855, kq = 18.523179, kdb = -15.816977, kpan = 0.901528\nkcf = 147.729960, kq = 13.071911, kdb = -11.924531, kpan = 0.982518\nkcf = 497.430113, kq = 13.605512, kdb = -21.586611, kpan = 0.179229\n\nREADING:\nWARNING: Seeding from current time 3308160476\n\nkcf = 1122.469700, kq = 11.762800, kdb = -14.313400, kpan = 0.538100\nkcf = 1122.469700, kq = 11.762800, kdb = -14.313400, kpan = 0.538100\nkcf = 1148.638400, kq = 12.040500, kdb = -14.061900, kpan = 0.552200\nkcf = 165.796900, kq = 18.523200, kdb = -15.817000, kpan = 0.901500\nkcf = 147.730000, kq = 13.071900, kdb = -11.924500, kpan = 0.982500\nkcf = 497.430100, kq = 13.605500, kdb = -21.586600, kpan = 0.179200\n</code></pre>"},{"location":"opcodes/dumpk4/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/dumpk4/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/duserrnd/","title":"Duserrnd","text":""},{"location":"opcodes/duserrnd/#duserrnd","title":"duserrnd","text":"<p>Discrete USER-defined-distribution RaNDom generator.</p>"},{"location":"opcodes/duserrnd/#syntax","title":"Syntax","text":"<pre><code>aout duserrnd ktableNum\niout duserrnd itableNum\nkout duserrnd ktableNum\n</code></pre>"},{"location":"opcodes/duserrnd/#initialization","title":"Initialization","text":"<p>itableNum -- number of table containing the random-distribution function.  Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2</p>"},{"location":"opcodes/duserrnd/#performance","title":"Performance","text":"<p>ktableNum -- number of table containing the random-distribution function.  Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2</p> <p>duserrnd (discrete user-defined-distribution random generator) generates random values according to a discrete random distribution created by the user. The user can create the discrete distribution histogram by using GEN41. In order to create that table, the user has to define an arbitrary amount of number pairs, the first number of each pair representing a value and the second representing its probability (see GEN41 for more details).</p> <p>When used  as a function, the rate of generation depends by the rate type of input variable XtableNum. In this case it can be embedded into any formula. Table number can be varied at k-rate, allowing to change the distribution histogram during the performance of a single note. duserrnd is designed be used in algorithmic music generation.</p> <p>duserrnd can also be used to generate values following a set of ranges of probabilities by using distribution functions generated by GEN42 (See GEN42 for more details). In this case, in order to simulate continuous ranges, the length of table XtableNum should be reasonably big, as duserrnd does not interpolate between table elements.</p> <p>For a tutorial about random distribution histograms and functions see:</p> <ul> <li>D. Lorrain. \"A panoply of stochastic cannons\". In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ul>"},{"location":"opcodes/duserrnd/#examples","title":"Examples","text":"<p>Here is an example of the duserrnd opcode. It uses the file duserrnd.csd.</p> Example of the duserrnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o duserrnd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   duserrnd 1\n     printk 0, k1\nasig poscil .5, 220*k1, 2       ;multiply frequency with random value\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 -20 -41  2 .1 8 .9 ;choose 2 at 10% probability, and 8 at 90%\n\nf2 0 8192 10 1\n\ni1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00067:     8.00000\ni   1 time     0.00133:     8.00000\ni   1 time     0.00200:     8.00000\ni   1 time     0.00267:     8.00000\ni   1 time     0.00333:     2.00000\ni   1 time     0.00400:     8.00000\ni   1 time     0.00533:     8.00000\ni   1 time     0.00600:     8.00000\n..........\n</code></pre>"},{"location":"opcodes/duserrnd/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/duserrnd/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.16</p>"},{"location":"opcodes/dust/","title":"Dust","text":""},{"location":"opcodes/dust/#dust","title":"dust","text":"<p>Generates random impulses from 0 to 1.</p>"},{"location":"opcodes/dust/#syntax","title":"Syntax","text":"<pre><code>ares dust kamp, kdensity\nkres dust kamp, kdensity\n</code></pre>"},{"location":"opcodes/dust/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kdensity -- average number of impulses per second.</p>"},{"location":"opcodes/dust/#examples","title":"Examples","text":"<p>Here is an example of the dust opcode. It uses the file dust.csd.</p> Example of the dust opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkdens expon 2, p3, 20000\naout  dust 0.5, kdens\nouts  aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dust/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/dust/#credits","title":"Credits","text":"<p>Based on James McCartney's Dust ugen (SuperCollider) Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p> <p>k-rate version fixed to documentation and SuperCollider, version 6.09</p>"},{"location":"opcodes/dust2/","title":"Dust2","text":""},{"location":"opcodes/dust2/#dust2","title":"dust2","text":"<p>Generates random impulses from -1 to 1.</p>"},{"location":"opcodes/dust2/#syntax","title":"Syntax","text":"<pre><code>ares dust2 kamp, kdensity\nkres dust2 kamp, kdensity\n</code></pre>"},{"location":"opcodes/dust2/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kdensity -- average number of impulses per second.</p>"},{"location":"opcodes/dust2/#examples","title":"Examples","text":"<p>Here is an example of the dust2 opcode. It uses the file dust2.csd.</p> Example of the dust2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkdens expon 2, p3, 20000\naout  dust2 0.5, kdens\nouts  aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/dust2/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/dust2/#credits","title":"Credits","text":"<p>Based on James McCartney's Dust2 (SuperCollider) Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p> <p>k-rate version fixed to documentation and SuperCollider, version 6.09</p>"},{"location":"opcodes/elapsedcycles/","title":"Elapsedcycles","text":""},{"location":"opcodes/elapsedcycles/#elapsedcycles","title":"elapsedcycles","text":"<p>Read absolute time, in k-rate cycles, since the start of the performance.</p>"},{"location":"opcodes/elapsedcycles/#syntax","title":"Syntax","text":"<pre><code>ires elapsedcycles\nkres elapsedcycles\n</code></pre>"},{"location":"opcodes/elapsedcycles/#performance","title":"Performance","text":"<p>elapsedcycles is for time in k-rate cycles. So with:</p> <pre><code> sr    = 44100\n kr    = 6300\n ksmps = 7\n</code></pre> <p>then after half a second, the elapsedcycles opcode would report 3150. It will always report an integer.</p> <p>elapsedcycles can produce a k-rate variable for output. There are no input parameters.</p> <p>elapsedcycles can also operate only at the start of the instance of the instrument. It produces an i-rate variable (starting with i or gi) as its output.</p> <p> Note</p> <p>elapsedcycles acts like timek but it returns the correct values instead of being one cycle late.</p>"},{"location":"opcodes/elapsedcycles/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/elapsedcycles/#credits","title":"Credits","text":"<p>Author: Eduardo Moguillansky August 2022</p>"},{"location":"opcodes/elapsedtime/","title":"Elapsedtime","text":""},{"location":"opcodes/elapsedtime/#elapsedtime","title":"elapsedtime","text":"<p>Read absolute time, in seconds, since the start of the performance.</p>"},{"location":"opcodes/elapsedtime/#syntax","title":"Syntax","text":"<pre><code>ires elapsedtime\nkres elapsedtime\n</code></pre>"},{"location":"opcodes/elapsedtime/#performance","title":"Performance","text":"<p>Time in seconds is available with elapsedtime. This would return 0.5 after half a second.</p> <p>elapsedtime can both produce a k-rate variable for output. There are no input parameters.</p> <p>elapsedtime can also operate at the start of the instance of the instrument. It produces an i-rate variable (starting with i or gi) as its output.</p> <p> Note</p> <p>elapsedtime acts like times but it returns the correct values instead of being one cycle late.</p>"},{"location":"opcodes/elapsedtime/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/elapsedtime/#credits","title":"Credits","text":"<p>Author: Eduardo Moguillansky August 2022</p>"},{"location":"opcodes/else/","title":"Else","text":""},{"location":"opcodes/else/#else","title":"else","text":"<p>Executes a block of code when an \"if...then\" condition is false.</p>"},{"location":"opcodes/else/#syntax","title":"Syntax","text":"<pre><code>else\n</code></pre>"},{"location":"opcodes/else/#performance","title":"Performance","text":"<p>else is used inside of a block of code between the \"if...then\" and endif opcodes. It defines which statements are executed when a \"if...then\" condition is false. Only one else statement may occur and it must be the last conditional statement before the endif opcode.</p>"},{"location":"opcodes/else/#examples","title":"Examples","text":"<p>Here is an example of the else opcode. It uses the file else.csd.</p> Example of the else opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o else.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nipch = cpspch(p4)\nienv = p5\n\n\nif (ienv == 0) then     \n        kenv adsr 0.01, 0.95, .7, .5\nelse\n        kenv linseg 0, p3 * .5, 1, p3 * .5, 0\nendif\n\naout vco2    .8, ipch, 10\naout moogvcf aout, ipch + (kenv * 6 * ipch) , .5\n\naout = aout * kenv\n    outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 8.00 0\ni 1 3 2 8.00 1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/else/#see-also","title":"See also","text":"<p>Program Flow Control</p> <p>More information on this opcode: http://www.csoundjournal.com/2006spring/controlFlow.html, written by Steven Yi</p>"},{"location":"opcodes/else/#credits","title":"Credits","text":"<p>New in version 4.21</p>"},{"location":"opcodes/elseif/","title":"Elseif","text":""},{"location":"opcodes/elseif/#elseif","title":"elseif","text":"<p>Defines another \"if...then\" condition when a \"if...then\" condition is false.</p>"},{"location":"opcodes/elseif/#syntax","title":"Syntax","text":"<pre><code>elseif xa R xb then\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where R is one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p>"},{"location":"opcodes/elseif/#performance","title":"Performance","text":"<p>elseif is used inside of a block of code between the \"if...then\" and endif opcodes. When a \"if...then\" condition is false, it defines another \"if...then\" condition to be met. Any number of elseif statements are allowed.</p>"},{"location":"opcodes/elseif/#examples","title":"Examples","text":"<p>Here is an example of the elseif opcode. It uses the file elseif.csd.</p> Example of the elseif opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o elseif.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nipch = cpspch(p4)\nienv = p5\n\n\nif (ienv == 0) then     \n        ;ADSR\n        kenv adsr 0.05, 0.05, .95, .05\nelseif (ienv == 1) then \n        ;Linear Triangular Envelope\n        kenv linseg 0, p3 * .5, 1, p3 * .5, 0\nelseif (ienv == 2) then \n        ;Ramp Up\n        kenv    linseg 0, p3 - .01, 1, .01, 0\nendif\n\naout    vco2    .8, ipch, 10\naout    moogvcf aout, ipch + (kenv * 5 * ipch) , .5\n\naout = aout * kenv\n\nouts aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 8.00 0\ni 1 3 2 8.00 1\ni 1 6 2 8.00 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/elseif/#see-also","title":"See also","text":"<p>Program Flow Control</p> <p>More information on this opcode: http://www.csoundjournal.com/2006spring/controlFlow.html, written by Steven Yi</p>"},{"location":"opcodes/elseif/#credits","title":"Credits","text":"<p>New in version 4.21</p>"},{"location":"opcodes/endif/","title":"Endif","text":""},{"location":"opcodes/endif/#endif","title":"endif","text":"<p>Closes a block of code that begins with an \"if...then\" statement.</p>"},{"location":"opcodes/endif/#syntax","title":"Syntax","text":"<pre><code>endif\n</code></pre>"},{"location":"opcodes/endif/#performance","title":"Performance","text":"<p>Any block of code that begins with an \"if...then\" statement must end with an endif statement.</p>"},{"location":"opcodes/endif/#examples","title":"Examples","text":"<p>Here is an example of the endif opcode. It uses the file endif.csd.</p> Example of the endif opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o endif.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n  ; Get the note value from the fourth p-field.\n  knote = p4\n\n  ; Does the user want a low note?\n  if (knote == 0) then\n    kcps = 220\n  ; Does the user want a middle note?\n  elseif (knote == 1) then\n    kcps = 440\n  ; Does the user want a high note?\n  elseif (knote == 2) then\n    kcps = 880\n  endif\n\n  ; Create the note.\n  kamp init .8\n  ifn = 1\n  a1 oscili kamp, kcps, ifn\n\n  outs a1, a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; p4: 0=low note, 1=middle note, 2=high note.\n; Play Instrument #1 for one second, low note.\ni 1 0 1 0\n; Play Instrument #1 for one second, middle note.\ni 1 1 1 1\n; Play Instrument #1 for one second, high note.\ni 1 2 1 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/endif/#see-also","title":"See also","text":"<p>Program Flow Control</p> <p>More information on this opcode: http://www.csoundjournal.com/2006spring/controlFlow.html, written by Steven Yi</p>"},{"location":"opcodes/endif/#credits","title":"Credits","text":"<p>New in version 4.21</p>"},{"location":"opcodes/envlpx/","title":"Envlpx","text":""},{"location":"opcodes/envlpx/#envlpx","title":"envlpx","text":"<p>Applies an envelope consisting of 3 segments.</p> <ol> <li>stored function rise shape</li> <li>modified exponential pseudo steady state</li> <li>exponential decay</li> </ol>"},{"location":"opcodes/envlpx/#syntax","title":"Syntax","text":"<pre><code>ares envlpx xamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]\nkres envlpx kamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]\n</code></pre>"},{"location":"opcodes/envlpx/#initialization","title":"Initialization","text":"<p>irise -- rise time in seconds. A zero or negative value signifies no rise modification.</p> <p>idur -- overall duration in seconds. A zero or negative value will cause initialization to be skipped.</p> <p>idec -- decay time in seconds. Zero means no decay. An idec &gt; idur will cause a truncated decay.</p> <p>ifn -- function table number of stored rise shape with extended guard point.</p> <p>iatss -- the ratio of the final value of the pseudo-steady-state period to the value at its beginning (i.e the attenuation from the end of the rise segment to the start of the decay). A ratio greater than 1 causes an exponential growth and a ratio less than 1 creates an exponential decay. A ratio of 1 will maintain a true steady state at the last rise value. Note that this attenuation is not at a fixed rate (as in a piano), but is sensitive to a note's duration. However, if iatss is negative (or if steady state &lt; 4 k-periods) a fixed attenuation rate of abs(iatss) per second will be used. 0 is illegal.</p> <p>iatdec --  the ratio of the value at the end of the decay period to the value at its beginning (the end of the steady-state segment) . It must be positive and is normally of the order of .01. A large or excessively small value is apt to produce a cutoff which is audible. A zero or negative value is illegal.</p> <p>ixmod (optional, between +- .9 or so) -- exponential curve modifier, influencing the steepness of the exponential trajectory during the steady state. Values less than zero will cause an accelerated growth or decay towards the target (e.g. subito piano). Values greater than zero will cause a retarded growth or decay. The default value is zero (unmodified exponential).</p>"},{"location":"opcodes/envlpx/#performance","title":"Performance","text":"<p>kamp, xamp -- input amplitude signal.</p> <p>Rise modifications are applied for the first irise seconds, and decay from time  idur - idec. If these periods are separated in time there will be a steady state during which amp will be modified by the first exponential pattern. If the overall duration idur is exceeded in performance, the final decay will continue on in the same direction, tending asymptotically to zero.</p>"},{"location":"opcodes/envlpx/#examples","title":"Examples","text":"<p>Here is an example of the envlpx opcode. It uses the file envlpx.csd.</p> Example of the envlpx opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o envlpx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n\ninstr 1\n\nirise = 0.2\nidec  = 0.5\nidur  = p3 - idec\n\nifn = 1\niatss = p5\niatdec = 0.01\n\nkenv envlpx .6, irise, idur, idec, ifn, iatss, iatdec\nkcps = cpspch(p4)\nasig vco2 kenv, kcps\n;apply envlpx to the filter cut-off frequency\nasig moogvcf asig, kcps + (kenv * 8 * kcps) , .5 ;the higher the pitch, the higher the filter cut-off frequency\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; a linear rising envelope\nf 1 0 129 -7 0 128 1\n\ni 1 0 2 7.00 .1\ni 1 + 2 7.02  1\ni 1 + 2 7.03  2\ni 1 + 2 7.05  3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/envlpx/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/envlpx/#credits","title":"Credits","text":"<p>Thanks goes to Luis Jure for pointing out a mistake with iatss.</p>"},{"location":"opcodes/envlpxr/","title":"Envlpxr","text":""},{"location":"opcodes/envlpxr/#envlpxr","title":"envlpxr","text":"<p>The envlpx opcode with a final release segment.</p> <p>envlpxr is the same as envlpx except that the final segment is entered only on sensing a MIDI note release. The note is then extended by the decay time.</p>"},{"location":"opcodes/envlpxr/#syntax","title":"Syntax","text":"<pre><code>ares envlpxr xamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]\nkres envlpxr kamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]\n</code></pre>"},{"location":"opcodes/envlpxr/#initialization","title":"Initialization","text":"<p>irise -- rise time in seconds. A zero or negative value signifies no rise modification.</p> <p>idec -- decay time in seconds. Zero means no decay.</p> <p>ifn -- function table number of stored rise shape with extended guard point.</p> <p>iatss --  attenuation factor determining the exponential change in value over time during the pseudo steady state period between the end of the rise and the beginning of the decay (at the note's release).  A factor greater than 1 causes an exponential growth and a factor less than 1 creates an exponential decay. A factor of 1 will maintain a true steady state at the last rise value; 0 is illegal. The value will change by abs(iatss) per second.</p> <p>iatdec --  the ratio of the value at the end of the decay period to the value at its beginning (when the note is released). It must be positive and is normally of the order of .01. A large or excessively small value is apt to produce a cutoff which is audible. A zero or negative value is illegal.</p> <p>ixmod (optional, between +- .9 or so) -- exponential curve modifier, influencing the steepness of the exponential trajectory during the steady state. Values less than zero will cause an accelerated growth or decay towards the target (e.g. subito piano). Values greater than zero will cause a retarded growth or decay. The default value is zero (unmodified exponential).</p> <p>irind _ (optional) -- independence flag. If left zero, the release time (_idec) will influence the extended life of the current note following a note-off. If non-zero, the idec time is quite independent of the note extension (see below). The default value is 0.</p>"},{"location":"opcodes/envlpxr/#performance","title":"Performance","text":"<p>kamp, xamp -- input amplitude signal.</p> <p>envlpxr is an example of the special Csound \u201cr\u201d units that contain a note-off sensor and release time extender. When each senses a score event termination or a MIDI noteoff, it will immediately extend the performance time of the current instrument by idec seconds unless it is made independent by irind. Then it will begin a decay from wherever it was at the time.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linsegr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using envlpxr, since the time is extended automatically.</p> <p>Multiple \u201cr\u201d units. When two or more \u201cr\u201d units occur in the same instrument it is usual to have only one of them influence the overall note duration. This is normally the master amplitude unit. Other units controlling, say, filter motion can still be sensitive to note-off commands while not affecting the duration by making them independent (irind non-zero). Depending on their own idec (release time) values, independent \u201cr\u201d units may or may not reach their final destinations before the instrument terminates. If they do, they will simply hold their target values until termination. If two or more \u201cr\u201d units are simultaneously master, note extension is by the greatest idec.</p>"},{"location":"opcodes/envlpxr/#examples","title":"Examples","text":"<p>Here is an example of the envlpxr opcode. It uses the file envlpxr.csd.</p> Example of the envlpxr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0   ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o envlpxr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nicps    cpsmidi          \niamp    ampmidi .5       \n\nkenv    envlpxr iamp, 0.2, 1, 1, 1, 0.01\nasig    pluck   kenv, icps, 200, 2, 1    \n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 129 -7 0 128 1\nf 2 0 4096 10 1 \n\nf0 30   ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/envlpxr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/envlpxr/#credits","title":"Credits","text":"<p>Thanks goes to Luis Jure for pointing out a mistake with iatss.</p>"},{"location":"opcodes/ephasor/","title":"Ephasor","text":""},{"location":"opcodes/ephasor/#ephasor","title":"ephasor","text":"<p>Produces two outputs: a periodic phase signal and a periodic exponential decaying signal.</p> <p>The latter is synchronised to the former, starting at 1 and then decreasing at the same time as the phase signal increases from 0 to 1. The rate of exponential decay can be controlled by the second parameter.</p>"},{"location":"opcodes/ephasor/#syntax","title":"Syntax","text":"<pre><code>aexp,aph ephasor kfreq, kR\n</code></pre>"},{"location":"opcodes/ephasor/#performance","title":"Performance","text":"<p>kfreq - the rate at which the phase and exponential signals are generated</p> <p>kR - a parameter controlling the decay rate of the exponential signal, 0 &lt; kR &lt; 1. Lower values produce faster decays.</p>"},{"location":"opcodes/ephasor/#examples","title":"Examples","text":"<p>Here is an example of the ephasor opcode. It uses the file ephasor.csd.</p> Example of the ephasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=64\nnchnls=2\n0dbfs = 1\n\ninstr 1\n\niamp = p4\nifr = p5\nkfr expon ifr,p3,2*ifr\n\nkfc expon 2000,p3, 4000\nkq = 10\nkbw = kfc/kq\nkR = 1 - $M_PI*(kbw/sr)\n\nk1 = kfc/kfr\nkn = int(k1)\nk1 = k1 - kn\n\namod,aph ephasor kfr,kR\naosc1 table aph*kn,-1,1,0,1\naosc2 table aph*(kn+1),-1,1,0,1\n\nasig = iamp*(aosc1*(1 - k1) + aosc2*k1)*amod\n  outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10 0.5 220\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ephasor/#see-also","title":"See also","text":"<p>Phasors</p>"},{"location":"opcodes/ephasor/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2008</p> <p>New in version 5.10</p>"},{"location":"opcodes/eqfil/","title":"Eqfil","text":""},{"location":"opcodes/eqfil/#eqfil","title":"eqfil","text":"<p>Equalizer filter</p> <p>The opcode eqfil is a 2nd order tunable equalisation filter based on Regalia and Mitra design (\"Tunable Digital Frequency Response Equalization Filters\", IEEE Trans. on Ac., Sp. and Sig Proc., 35 (1), 1987). It provides a peak/notch filter for building parametric/graphic equalisers.</p> <p>The amplitude response for this filter will be flat (=1) for kgain=1. With kgain bigger than 1, there will be a peak at the centre frequency, whose width is given by the kbw parameter, but outside this band, the response will tend towards 1. Conversely, if kgain is smaller than 1, a notch will be created around the CF.</p>"},{"location":"opcodes/eqfil/#syntax","title":"Syntax","text":"<pre><code>asig eqfil ain, kcf, kbw, kgain[, istor]\n</code></pre>"},{"location":"opcodes/eqfil/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/eqfil/#performance","title":"Performance","text":"<p>asig -- filtered output signal.</p> <p>ain -- input signal.</p> <p>kcf -- filter centre frequency.</p> <p>kbw -- peak/notch bandwidth (Hz).</p> <p>kgain -- peak/notch gain.</p>"},{"location":"opcodes/eqfil/#examples","title":"Examples","text":"<p>Here is an example of the eqfil opcode. It uses the file eqfil.csd.</p> Example of the eqfil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o eqfil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkcf     = p4\nkfe     expseg  10, p3*0.9, 1800, p3*0.1, 175\nkenv    linen   .03, 0.05, p3, 0.05 ;low amplitude is needed to avoid clipping\nasig    buzz    kenv, kfe, sr/(2*kfe), 1\nafil    eqfil   asig, kcf, 200, 10\n        outs    afil*20, afil*20\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; a sine wave.\nf 1 0 16384 10 1\n\ni 1 0 10 200    ;filter centre freq=200\ni 1 + 10 1500   ;filter centre freq=1500\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/eqfil/#see-also","title":"See also","text":"<p>Specialized Filters: Parametric EQ</p>"},{"location":"opcodes/eqfil/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini April 2007</p> <p>New in version 5.06</p>"},{"location":"opcodes/equals/","title":"Equals","text":""},{"location":"opcodes/equals/#_1","title":"==","text":"<p>Compares two values for equality.</p>"},{"location":"opcodes/equals/#syntax","title":"Syntax","text":"<pre><code>(a == b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/equals/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a is equal to b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2. (For convenience, a sole \"=\" will function as \"= =\".)</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/equals/#examples","title":"Examples","text":"<p>Here is an example of the == operator. It uses the file equals.csd.</p> Example of the == operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o equals.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nienv = p4                               ;choose envelope in score\n\nif (ienv == 0) kthen    \n  kenv adsr 0.05, 0.05, 0.95, 0.05      ;sustained envelope\nelseif (ienv == 1) kthen \n  kenv adsr 0.5, 1, 0.5, 0.5            ;triangular envelope\nelseif (ienv == 2) kthen \n  kenv adsr 1, 1, 1, 0                  ;ramp up\nendif\n\naout   vco2 .1, 110, 10\naout   = aout * kenv\n       outs aout, aout\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2  0\ni1 3 2  1\ni1 6 2  2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/equals/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/event/","title":"Event","text":""},{"location":"opcodes/event/#event","title":"event","text":"<p>Generates a score event from an instrument.</p>"},{"location":"opcodes/event/#syntax","title":"Syntax","text":"<pre><code>event \"scorechar\", kinsnum, kdelay, kdur, [, kp4] [, kp5] [, ...]\nevent \"scorechar\", \"insname\", kdelay, kdur, [, kp4] [, kp5] [, ...]\n</code></pre>"},{"location":"opcodes/event/#initialization","title":"Initialization","text":"<p>\u201cscorechar\u201d -- A string (in double-quotes) representing the first p-field in a score statement. This is usually \u201ce\u201d, \u201cf\u201d, or \u201ci\u201d.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p>"},{"location":"opcodes/event/#performance","title":"Performance","text":"<p>kinsnum -- The instrument to use for the event. This corresponds to the first p-field, p1, in a score statement.</p> <p>kdelay -- When (in seconds) the event will occur from the current performance time. This corresponds to the second p-field, p2, in a score statement.</p> <p>kdur -- How long (in seconds) the event will happen. This corresponds to the third p-field, p3, in a score statement.</p> <p>kp4, kp5, ... (optional) -- Parameters representing additional p-field in a score statement. It starts with the fourth p-field, p4.</p> <p> Note</p> <p>Note that the event opcode cannot accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/event/#examples","title":"Examples","text":"<p>Here is an example of the event opcode. It uses the file event.csd.</p> Example of the event opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o event.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - an oscillator with a high note.\ninstr 1\n  ; Create a trigger and set its initial value to 1.\n  ktrigger init 1\n\n  ; If the trigger is equal to 0, continue playing.\n  ; If not, schedule another event.\n  if (ktrigger == 0) goto contin\n    ; kscoreop=\"i\", an i-statement.\n    ; kinsnum=2, play Instrument #2.\n    ; kwhen=1, start at 1 second.\n    ; kdur=0.5, play for a half-second.\n    event \"i\", 2, 1, 0.5\n\n    ; Make sure the event isn't triggered again.\n    ktrigger = 0\n\ncontin:\n  a1 oscils 10000, 440, 1\n  out a1\nendin\n\n; Instrument #2 - an oscillator with a low note.\ninstr 2\n  a1 oscils 10000, 220, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Make sure the score plays for two seconds.\nf 0 2\n\n; Play Instrument #1 for a half-second.\ni 1 0 0.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the event opcode using a named instrument. It uses the file event_named.csd.</p> Example of the event opcode using a named instrument.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o event_named.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - an oscillator with a high note.\ninstr 1\n  ; Create a trigger and set its initial value to 1.\n  ktrigger init 1\n\n  ; If the trigger is equal to 0, continue playing.\n  ; If not, schedule another event.\n  if (ktrigger == 0) goto contin\n    ; kscoreop=\"i\", an i-statement.\n    ; kinsnum=\"low_note\", instrument named \"low_note\".\n    ; kwhen=1, start at 1 second.\n    ; kdur=0.5, play for a half-second.\n    event \"i\", \"low_note\", 1, 0.5\n\n    ; Make sure the event isn't triggered again.\n    ktrigger = 0\n\ncontin:\n  a1 oscils 10000, 440, 1\n  out a1\nendin\n\n; Instrument \"low_note\" - an oscillator with a low note.\ninstr low_note\n  a1 oscils 10000, 220, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Make sure the score plays for two seconds.\nf 0 2\n\n; Play Instrument #1 for a half-second.\ni 1 0 0.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/event/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/event/#credits","title":"Credits","text":"<p>Examples written by Kevin Conder.</p> <p>New in version 4.17</p> <p>Thanks goes to Matt Ingalls for helping to fix the example and to clarify the kwhen/kdelay parameter.</p>"},{"location":"opcodes/event_i/","title":"Event i","text":""},{"location":"opcodes/event_i/#event_i","title":"event_i","text":"<p>Generates a score event from an instrument.</p>"},{"location":"opcodes/event_i/#syntax","title":"Syntax","text":"<pre><code>event_i \"scorechar\", iinsnum, idelay, idur, [, ip4] [, ip5] [, ...]\nevent_i \"scorechar\", \"insname\", idelay, idur, [, ip4] [, ip5] [, ...]\n</code></pre>"},{"location":"opcodes/event_i/#initialization","title":"Initialization","text":"<p>\u201cscorechar\u201d -- A string (in double-quotes) representing the first p-field in a score statement. This is usually \u201ce\u201d, \u201cf\u201d, or \u201ci\u201d.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>iinsnum -- The instrument to use for the event. This corresponds to the first p-field, p1, in a score statement.</p> <p>idelay -- When (in seconds) the event will occur from the current performance time. This corresponds to the second p-field, p2, in a score statement.</p> <p>idur -- How long (in seconds) the event will happen. This corresponds to the third p-field, p3, in a score statement.</p> <p>ip4, ip5, ... (optional) -- Parameters representing additional p-field in a score statement. It starts with the fourth p-field, p4.</p>"},{"location":"opcodes/event_i/#performance","title":"Performance","text":"<p>The event is added to the queue at initialisation time.</p> <p> Note</p> <p>Note that the event_i opcode cannot accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/event_i/#examples","title":"Examples","text":"<p>Here is an example of the event_i opcode. It uses the file event_i.csd.</p> Example of the event_i opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o event_i.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;master instrument\n\nininstr = 10 ;number of called instances\nindx = 0\nloop:\nipan  random 0, 1\nifreq random 100, 1000\niamp  = 1/ininstr\nevent_i \"i\", 10, 0, p3, iamp, ifreq, ipan\nloop_lt indx, 1, ininstr, loop\n\nendin\n\ninstr 10\n\n      print p4, p5, p6\nipeak random 0, 1 ;where is the envelope peak\nasig  poscil3 p4, p5, gisine\naenv  transeg 0, p3*ipeak, 6, 1, p3-p3*ipeak, -6, 0\naL,aR pan2 asig*aenv, p6\n      outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ni1 8 10\ni1 16 15\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/event_i/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/event_i/#credits","title":"Credits","text":"<p>Written by Istvan Varga.</p> <p>New in Csound5</p>"},{"location":"opcodes/eventcycles/","title":"Eventcycles","text":""},{"location":"opcodes/eventcycles/#eventcycles","title":"eventcycles","text":"<p>Read absolute time in k-rate cycles, since the start of an instance of an instrument.</p> <p>Called at both i-time as well as k-time. NB: the returned value at k-time starts at 1</p>"},{"location":"opcodes/eventcycles/#syntax","title":"Syntax","text":"<pre><code>kres eventcycles\n</code></pre>"},{"location":"opcodes/eventcycles/#performance","title":"Performance","text":"<p>eventcycles is for time in k-rate cycles. So with:</p> <pre><code>sr    = 44100\nkr    = 6300\nksmps = 7\n</code></pre> <p>then after half a second, the eventcycles opcode would report 3150. It will always report an integer.</p> <p>eventcycles produces a k-rate variable for output. There are no input parameters.</p> <p>eventcycles is similar to elapsedcycles except it returns the time since the start of this instance of the instrument.</p> <p> Note</p> <p>eventcycles acts like timeinstk but it returns the correct values instead of being one cycle late.</p>"},{"location":"opcodes/eventcycles/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/eventcycles/#credits","title":"Credits","text":"<p>Author: Eduardo Moguillansky August 2022</p>"},{"location":"opcodes/eventtime/","title":"Eventtime","text":""},{"location":"opcodes/eventtime/#eventtime","title":"eventtime","text":"<p>Read absolute time, in seconds, since the start of an instance of an instrument.</p>"},{"location":"opcodes/eventtime/#syntax","title":"Syntax","text":"<pre><code>kres eventtime\n</code></pre>"},{"location":"opcodes/eventtime/#performance","title":"Performance","text":"<p>Time in seconds is available with eventtime. This would return 0.5 after half a second.</p> <p>eventtime produces a k-rate variable for output. There are no input parameters.</p> <p>eventtime is similar to elapsedtime except it returns the time since the start of this instance of the instrument.</p> <p> Note</p> <p>eventtime acts like timeinsts but it returns the correct values instead of being one cycle late.</p>"},{"location":"opcodes/eventtime/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/eventtime/#credits","title":"Credits","text":"<p>Author: Eduardo Moguillansky August 2022</p>"},{"location":"opcodes/exciter/","title":"Exciter","text":""},{"location":"opcodes/exciter/#exciter","title":"exciter","text":"<p>A non-linear filter system to excite the signal.</p> <p>Plugin opcode in exciter. \"Filtered distortion to add brilliance to a signal\"</p>"},{"location":"opcodes/exciter/#syntax","title":"Syntax","text":"<pre><code>ares exciter asig, kfreq, kceil, kharmonics, kblend\n</code></pre>"},{"location":"opcodes/exciter/#initialization","title":"Initialization","text":""},{"location":"opcodes/exciter/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>kfreq -- the lower end of the harmonics created.</p> <p>kceil -- the upper end of the harmonics created.</p> <p>kharmonics -- amount of harmonics in the range 0.1 - 10.</p> <p>kblend -- blend between 2nd and 3rd order harmonics in the range -10 - +10.</p> <p>exciter is a reimplementation of the calf exciter plugin.</p>"},{"location":"opcodes/exciter/#examples","title":"Examples","text":"<p>Here is an example of the exciter opcode. It uses the file exciter.csd.</p> Example of the exciter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;real-time audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o exciter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\nnchnls=2\n0dbfs =1\n\n; by Menno Knevel 2023\n\ninstr 1 ; excited sound + original sound\n\na1 diskin2 \"Mathews.wav\", 1, 3.5\na2 exciter a1, 3000, 20000, 10, 10      ;generate uneven harmonics at maximum setting\n     outs a2+a1, a2+a1\nendin\n\ninstr 2 ; original sound for comparison\n\na1 diskin2 \"Mathews.wav\", 1, 3.5\n   outs a1, a1\nendin\n\ninstr 3 ; the effect of the excited sound only\n\na1 diskin2 \"Mathews.wav\", 1, 3.5\na2 exciter a1, 3000, 20000, 10, 10      ;generate uneven harmonics at maximum setting\n   outs a2, a2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5\ni2 5 5\ni3 10 4.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/exciter/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/exciter/#credits","title":"Credits","text":"<p>Author: John ffitch after Markus Schmidt August 2014</p> <p>New in Csound version 6.04</p>"},{"location":"opcodes/exitnow/","title":"Exitnow","text":""},{"location":"opcodes/exitnow/#exitnow","title":"exitnow","text":"<p>Exit Csound as fast as possible, with no cleaning up.</p> <p>In Csound4 calls an exit function to leave Csound as fast as possible. On Csound5 and later it exits back to the driving code.</p>"},{"location":"opcodes/exitnow/#syntax","title":"Syntax","text":"<pre><code>exitnow [ivalue]\n</code></pre> <p>Initialisation</p> <p>Stops Csound on the initialisation cycle, returning the result ivalue, which defaults to zero. Note that it is usual for this opcode to be alone in an instrument.</p>"},{"location":"opcodes/exitnow/#examples","title":"Examples","text":"<p>Here is an example of the exitnow opcode. It uses the file exitnow.csd.</p> Example of the exitnow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o exitnow.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n; plays a sine wav, forces a stop after 2 seconds\ninstr 1\n        ; generate a line from 0 to 1 over 2 seconds\n        kStop line 0, 2, 1\n\n        ; launch instrument 2 once kStop signal is greater than 1\n        if(kStop&gt;=1) then\n                schedulek 2, 0, 1\n        endif\n\n        ; print kStop signal every .1 seconds\n        printk .1, kStop\n\n        ; make some noise\n        aSig oscil 1, 440\n        outs aSig, aSig\nendin\n\n; forces an instant exit of csound\ninstr 2\n        exitnow\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; play oscil instrument infinitely\ni 1 0 z\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/exitnow/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/exp/","title":"Exp","text":""},{"location":"opcodes/exp/#exp","title":"exp","text":"<p>Returns e raised to the xth power.</p>"},{"location":"opcodes/exp/#syntax","title":"Syntax","text":"<pre><code>exp(x) (no rate restriction)\nexp(k/i[]) (k- or i-arrays)\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/exp/#examples","title":"Examples","text":"<p>Here is an example of the exp opcode. It uses the file exp.csd.</p> Example of the exp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs =1\n\n\ninstr 1\ni1 = exp(2) \n; BASE = e (2,71828 18284 59045 23536...)\n; EXPONENT = 2\nprint i1\nendin\n\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>new alloc for instr 1:\ninstr 1:  i1 = 7.389\nB  0.000 ..  1.000 T  1.000 TT  1.000 M:  0.00000  0.00000\n.........\n</code></pre> <p>Here is another example of the exp opcode. It uses the file exp-musical.csd.</p> Musical example of the exp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o exp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs =1\n\ngisine    ftgen     0, 0, 2^10, 10, 1 ;table for a sine wave\n\ninstr 1 ;master instrument\nkoct      linseg    6, p3, 12 ; octave register straight rising from 6 to 12\nkexp      linseg    0, p3/3, 5, p3/3, 5, p3/3, 0 ;exponent goes from 0 to 5 and back\nkdens     =         exp(kexp) ;density is e to the power of kexp\n          printks   \"Generated events per second: %d\\n\", 1, kdens\nktrig     metro     kdens ;trigger single notes in kdens frequency\n if ktrig == 1 then\n;call instr 10 for 1/kdens duration, .5 amplitude and koct register\n          event     \"i\", 10, 0, 1/kdens, .5, koct\n endif\nendin\n\ninstr 10 ;performs one tone\nioct      rnd31     1, 0 ;random deviation maximum one octave plus/minus\naenv      transeg   p4, p3, -6, 0 ;fast decaying envelope for p4 amplitude\nasin      poscil    aenv, cpsoct(p5+ioct), gisine ;sine for p5 octave register plus random deviation\n          outs      asin, asin\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>Generated events per second: 1\nrtevent:     T  0.000 TT  0.000 M:  0.00000  0.00000\nnew alloc for instr 10:\nrtevent:     T  0.811 TT  0.811 M:  0.48906  0.48906\nnew alloc for instr 10:\nGenerated events per second: 2\nrtevent:     T  1.387 TT  1.387 M:  0.48611  0.48611\nrtevent:     T  1.833 TT  1.833 M:  0.48421  0.48421\nGenerated events per second: 3\nrtevent:     T  2.198 TT  2.198 M:  0.47536  0.47536\nrtevent:     T  2.506 TT  2.506 M:  0.46530  0.46530\nrtevent:     T  2.773 TT  2.773 M:  0.44986  0.44986\nGenerated events per second: 4\nrtevent:     T  3.009 TT  3.009 M:  0.48096  0.48096\n.........\n</code></pre>"},{"location":"opcodes/exp/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/exp/#credits","title":"Credits","text":"<p>New in version 4.21</p>"},{"location":"opcodes/expcurve/","title":"Expcurve","text":""},{"location":"opcodes/expcurve/#expcurve","title":"expcurve","text":"<p>Generates a normalised exponential curve in range 0 to 1 of arbitrary steepness.</p> <p>It is based on the Max / MSP work of Eric Singer (c) 1994. Steepness index less than 1.0 would result in Not-a-Number errors and cause unstable behavior so is treated as if it were 1.</p> <p>The formula used to calculate the curve is:</p> <pre><code>(exp(x * log(y))-1) / (y-1)\n</code></pre> <p>where x is equal to kindex and y is equal to ksteepness.</p>"},{"location":"opcodes/expcurve/#syntax","title":"Syntax","text":"<pre><code>kout expcurve kindex, ksteepness\n</code></pre>"},{"location":"opcodes/expcurve/#performance","title":"Performance","text":"<p>kindex -- Index value. Expected range 0 to 1.</p> <p>ksteepness -- Steepness of the generated curve. Values closer to 1.0 result in a straighter line while larger values steepen the curve.</p> <p>kout -- Scaled output.</p>"},{"location":"opcodes/expcurve/#examples","title":"Examples","text":"<p>Here is an example of the expcurve opcode. It uses the file expcurve.csd.</p> Example of the expcurve opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent\n-odac           -iadc     -n    ;;;realtime output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =   44100\nksmps   =   1000\nnchnls  =   2\n\n        instr   1   ; logcurve test\n\nkmod    phasor  1/p3\nkout    expcurve kmod, p4\n\nprintks \"mod = %f  out= %f\\\\n\", 0.5, kmod, kout\n\n        endin\n\n/*--- ---*/\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1  0   5  2\ni1  5   5  5\ni1  10  5  30\ni1  15  5  0.5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expcurve/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expcurve/#credits","title":"Credits","text":"<p>Author: David Akbari October 2006 Range check introduced in 6.16 by John ffitch</p>"},{"location":"opcodes/expon/","title":"Expon","text":""},{"location":"opcodes/expon/#expon","title":"expon","text":"<p>Trace an exponential curve between specified points.</p>"},{"location":"opcodes/expon/#syntax","title":"Syntax","text":"<pre><code>ares expon ia, idur, ib\nkres expon ia, idur, ib\n</code></pre>"},{"location":"opcodes/expon/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal for exponentials.</p> <p>ib -- value after idur seconds. For exponentials, must be non-zero and must agree in sign with ia.</p> <p>idur -- duration in seconds of the segment. A zero or negative value will cause all initialization to be skipped.</p>"},{"location":"opcodes/expon/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 specified points. The idur value may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the defined segment to continue on in the same direction.</p>"},{"location":"opcodes/expon/#examples","title":"Examples","text":"<p>Here is an example of the expon opcode. It uses the file expon.csd.</p> Example of the expon opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o expon.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nkpitch = p6\n;choose between expon or line\nif (kpitch == 0) then   \n  kpitch expon p4, p3, p5 \nelseif (kpitch == 1) then\n  kpitch line p4, p3, p5 \nendif\n\nasig   vco2 .6, kpitch \n       outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 2 300 600    0    ;if p6=0 then expon is used\ni 1 3 2 300 600    1    ;if p6=1 then line is used\ni 1 6 2 600 1200   0\ni 1 9 2 600 1200   1\ni 1 12 2 1200 2400 0\ni 1 15 2 1200 2400 1\ni 1 18 2 2400 30   0\ni 1 21 2 2400 30   1\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/expon/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/exprand/","title":"Exprand","text":""},{"location":"opcodes/exprand/#exprand","title":"exprand","text":"<p>Exponential distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/exprand/#syntax","title":"Syntax","text":"<pre><code>ares exprand klambda\nires exprand klambda\nkres exprand klambda\n</code></pre>"},{"location":"opcodes/exprand/#performance","title":"Performance","text":"<p>klambda -- reciprocal of lambda parameter for the exponential distribution.</p> <p>The probablity density function of an exponential distribution is an exponential curve, whose median is log(2)/lambda. For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. Second edition, section 11.1B4</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine . Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/exprand/#examples","title":"Examples","text":"<p>Here is an example of the exprand opcode. It uses the file exprand.csd.</p> Example of the exprand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o exprand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1         ; every run time same values\n\nklamda  exprand 20\n        printk  .2, klamda              ; look\naout    oscili  0.8, 440+klamda, 1      ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nklamda  exprand 20\n        printk  .2, klamda              ; look \naout    oscili  0.8, 440+klamda, 1      ; &amp; listen\n        outs    aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>i   1 time     0.00033:     4.09813\ni   1 time     0.20033:    56.39567\ni   1 time     0.40033:     3.23362\ni   1 time     0.60033:     0.24277\ni   1 time     0.80033:    13.71228\ni   1 time     1.00000:    12.71885\ni   1 time     1.20033:    32.36737\ni   1 time     1.40033:     0.29747\ni   1 time     1.60033:     4.04450\ni   1 time     1.80000:    35.75676\ni   1 time     2.00000:     3.69845\n\nSeeding from current time 3034472128\n\ni   2 time     3.00033:     6.67934\ni   2 time     3.20033:     2.72431\ni   2 time     3.40033:    14.51822\ni   2 time     3.60000:    12.10120\ni   2 time     3.80033:     1.12266\ni   2 time     4.00000:    26.90772\ni   2 time     4.20000:     0.43554\ni   2 time     4.40033:    28.59836\ni   2 time     4.60033:    27.01831\ni   2 time     4.80033:    18.19911\ni   2 time     5.00000:     4.45125\n</code></pre>"},{"location":"opcodes/exprand/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/exprand/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/exprandi/","title":"Exprandi","text":""},{"location":"opcodes/exprandi/#exprandi","title":"exprandi","text":"<p>Exponential distribution random number generator with interpolation (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/exprandi/#syntax","title":"Syntax","text":"<pre><code>ares exprandi klambda, xamp, xcps\nires exprandi klambda, xamp, xcps\nkres exprandi klambda, xamp, xcps\n</code></pre>"},{"location":"opcodes/exprandi/#performance","title":"Performance","text":"<p>klambda -- lambda parameter for the exponential distribution.</p> <p>The probablity density function of an exponential distribution is an exponential curve, whose mean is 0.69515/lambda. For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol> <p>xamp -- range over which random numbers are distributed.</p> <p>xcps -- the frequency which new random numbers are generated.</p>"},{"location":"opcodes/exprandi/#examples","title":"Examples","text":"<p>Here is an example of the exprandi opcode. It uses the file exprandi.csd.</p> Example of the exprandi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o exprand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nklambda exprandi        20, 1, 3\n        printk2 klambda         ; look\naout    oscili  0.8, 440+klambda, 1     ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 4\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/exprandi/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/exprandi/#credits","title":"Credits","text":"<p>Author: John ffitch Bath May 2011 New in version 5.14</p>"},{"location":"opcodes/expseg/","title":"Expseg","text":""},{"location":"opcodes/expseg/#expseg","title":"expseg","text":"<p>Trace a series of exponential segments between specified points.</p>"},{"location":"opcodes/expseg/#syntax","title":"Syntax","text":"<pre><code>ares expseg ia, idur1, ib [, idur2] [, ic] [...]\nkres expseg ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/expseg/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal for exponentials.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p>"},{"location":"opcodes/expseg/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.</p> <p>Note that the expseg opcode does not operate correctly at audio rate when segments are shorter than a k-period. Try the expsega opcode instead.</p>"},{"location":"opcodes/expseg/#examples","title":"Examples","text":"<p>Here is an example of the expseg opcode. It uses the file expseg.csd.</p> Example of the expseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n;-o expseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder, additions by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps = cpspch(p4)                            ; p4 = frequency in pitch-class notation.\nkenv expseg 0.01, p3*0.25, 1, p3*0.75, 0.001 ; amplitude envelope.\nkamp = kenv \na1   oscili kamp, kcps\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0.5 8.00\ni 1 1 0.5 8.01\ni 1 2 0.5 8.02\ni 1 3 2.0 8.03\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expseg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound 3.57</p>"},{"location":"opcodes/expsega/","title":"Expsega","text":""},{"location":"opcodes/expsega/#expsega","title":"expsega","text":"<p>An exponential segment generator operating at a-rate.</p> <p>This unit is almost identical to expseg, but more precise when defining segments with very short durations (i.e., in a percussive attack phase) at audio rate.</p>"},{"location":"opcodes/expsega/#syntax","title":"Syntax","text":"<pre><code>ares expsega ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/expsega/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal.</p> <p>ib, ic, etc. -- value after idur1 seconds, etc. must be non-zero and must agree in sign with ia.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last defined line or curve to be continued indefinitely in performance. The default is zero.</p>"},{"location":"opcodes/expsega/#performance","title":"Performance","text":"<p>This unit generate audio signals whose values can pass through two or more specified points. The sum of dur values may or may not equal the instrument's performance time. A shorter performance will truncate the specified pattern, while a longer one will cause the last defined segment to continue on in the same direction.</p>"},{"location":"opcodes/expsega/#examples","title":"Examples","text":"<p>Here is an example of the expsega opcode. It uses the file expsega.csd.</p> Example of the expsega opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o expsega.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder, Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expsega 0.01, 0.1, 1, 0.1, 0.01    ; Define a short percussive amplitude envelope\na1   oscili aenv, 440\n     outs a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ni 1 1 1\ni 1 2 1\ni 1 3 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expsega/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expsega/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound 3.57</p>"},{"location":"opcodes/expsegb/","title":"Expsegb","text":""},{"location":"opcodes/expsegb/#expsegb","title":"expsegb","text":"<p>Trace a series of exponential segments between specified absolute points.</p>"},{"location":"opcodes/expsegb/#syntax","title":"Syntax","text":"<pre><code>ares expsegb ia, itim1, ib [, itim2] [, ic] [...]\nkres expsegb ia, itim1, ib [, itim2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/expsegb/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal for exponentials.</p> <p>ib, ic, etc. -- value at tim1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia.</p> <p>itim1 -- time in seconds of end of first segment.</p> <p>itim2, itim3, etc. -- time in seconds of subsequent ends of segments.</p>"},{"location":"opcodes/expsegb/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The last tim value may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.</p> <p>Note that the expsegb opcode does not operate correctly at audio rate when segments are shorter than a k-period. Try the expsegba opcode instead.</p>"},{"location":"opcodes/expsegb/#examples","title":"Examples","text":"<p>Here is an example of the expsegb opcode. It uses the file expsegb.csd.</p> Example of the expsegb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o expseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr  = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; p4 = frequency in pitch-class notation.\n  kcps = cpspch(p4)\n\n  ; Create an amplitude envelope.\n  kenv expsegb 0.01, p3*0.25, 1, p3, 0.01\n  kamp = kenv * 30000\n\n  a1 oscil kamp, kcps, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for a half-second, p4=8.00\ni 1 0 0.5 8.00\n; Play Instrument #1 for a half-second, p4=8.01\ni 1 1 0.5 8.01\n; Play Instrument #1 for a half-second, p4=8.02\ni 1 2 0.5 8.02\n; Play Instrument #1 for a half-second, p4=8.03\ni 1 3 0.5 8.03\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expsegb/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expsegb/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini June 2011 </p> <p>New in version 5.14</p>"},{"location":"opcodes/expsegba/","title":"Expsegba","text":""},{"location":"opcodes/expsegba/#expsegba","title":"expsegba","text":"<p>An exponential segment generator operating at a-rate with absolute times.</p> <p>This unit is almost identical to expsegb, but more precise when defining segments with very short durations (i.e., in a percussive attack phase) at audio rate.</p>"},{"location":"opcodes/expsegba/#syntax","title":"Syntax","text":"<pre><code>ares expsegba ia, itim1, ib [, itim2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/expsegba/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal.</p> <p>ib, ic, etc. -- value after itim1 seconds, etc. must be non-zero and must agree in sign with ia.</p> <p>itim1 -- time in seconds at end of first segment.</p> <p>itim2, itim3, etc. -- time in seconds at the end of subsequent segments.</p>"},{"location":"opcodes/expsegba/#performance","title":"Performance","text":"<p>This unit generate audio signals whose values can pass through two or more specified points. The final _tim _ value may or may not equal the instrument's performance time. A shorter performance will truncate the specified pattern, while a longer one will cause the last defined segment to continue on in the same direction.</p>"},{"location":"opcodes/expsegba/#examples","title":"Examples","text":"<p>Here is an example of the expsegba opcode. It uses the file expsegba.csd.</p> Example of the expsegba opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o expsega.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr  = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Define a short percussive amplitude envelope that\n  ; goes from 0.01 to 20,000 and back.\n  aenv expsegba 0.01, 0.1, 20000, 0.2, 0.01\n\n  a1 oscil aenv, 440, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for one second.\ni 1 0 1\n; Play Instrument #1 for one second.\ni 1 1 1\n; Play Instrument #1 for one second.\ni 1 2 1\n; Play Instrument #1 for one second.\ni 1 3 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expsegba/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expsegba/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>June 2011</p> <p>New in Csound 5.14</p>"},{"location":"opcodes/expsegr/","title":"Expsegr","text":""},{"location":"opcodes/expsegr/#expsegr","title":"expsegr","text":"<p>Trace a series of exponential segments between specified points including a release segment.</p>"},{"location":"opcodes/expsegr/#syntax","title":"Syntax","text":"<pre><code>ares expsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres expsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\n</code></pre>"},{"location":"opcodes/expsegr/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal for exponentials.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p> <p>irel, iz -- duration in seconds and final value of a note releasing segment.</p>"},{"location":"opcodes/expsegr/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.</p> <p>expsegr is amongst the Csound \u201cr\u201d units that contain a note-off sensor and release time extender. When each senses an event termination or MIDI noteoff, it immediately extends the performance time of the current instrument by irel _seconds, and sets out to reach the value _iz by the end of that period (no matter which segment the unit is in). \u201cr\u201d units can also be modified by MIDI noteoff velocities. For two or more extenders in an instrument, extension is by the greatest period.</p> <p>You can use other pre-made envelopes which start ao release segment upon receiving a note off message, like linsegr and madsr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using expsegr, since the time is extended automatically.</p>"},{"location":"opcodes/expsegr/#examples","title":"Examples","text":"<p>Here is an example of the expsegr opcode. It uses the file expsegr.csd.</p> Example of the expsegr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0   ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o expsegr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n\nicps    cpsmidi      \niamp    ampmidi .3   \n\nkenv    expsegr 1, .05, 0.5, 1, .01\nasig    pluck   kenv, icps, 200, 1, 1    \n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ;sine wave\n\nf0 30           ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/expsegr/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/expsegr/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe</p> <p>New in Csound 3.47</p>"},{"location":"opcodes/fareylen/","title":"Fareylen","text":""},{"location":"opcodes/fareylen/#fareylen","title":"fareylen","text":"<p>Returns the length of a Farey Sequence.</p> <p>This opcode can be used in conjunction with GENfarey. It calculates the length of Farey Sequence F<sub>n</sub>. Its length is given by: |F<sub>n</sub>| = 1 + SUM over n phi(m) where phi(m) is Euler's totient function, which gives the number of integers \u2264 m that are coprime to m.</p> <p>Some values for the length of F<sub>n</sub> given n:</p> n F 1 2 2 3 3 5 4 7 5 11 6 13 7 19 8 23 9 29 10 33 11 43 12 47 13 59 14 65 15 73 16 81 17 97 18 103 19 121 20 129"},{"location":"opcodes/fareylen/#syntax","title":"Syntax","text":"<pre><code>kfl fareylen kfn\n</code></pre>"},{"location":"opcodes/fareylen/#performance","title":"Performance","text":"<p>The length of the identified Farey sequence is returned.</p> <p>kfn -- Integer identifying the sequence.</p>"},{"location":"opcodes/fareylen/#examples","title":"Examples","text":"<p>Here is an example of the fareylen opcode. It uses the file fareylen.csd.</p> Example of the fareylen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\nnchnls=1\n\n; by Stefano Cucchi and Menno Knevel - 2024\n\ninstr 10\n\nkfarnf randomi 1, 10, 4\nkfarn ceil kfarnf\n\nklenght fareylen kfarn  \nprintks \"farey length of %d = %d\\n\",.1,  kfarn, klenght\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 10 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fareylen/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/fareylen/#credits","title":"Credits","text":"<p>Author: Georg Boenn  University of Glamorgan, UK</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/fareyleni/","title":"Fareyleni","text":""},{"location":"opcodes/fareyleni/#fareyleni","title":"fareyleni","text":"<p>Returns the length of a Farey Sequence.</p> <p>This opcode can be used in conjunction with GENfarey. It calculates the length of Farey Sequence F<sub>n</sub>. Its length is given by: |F<sub>n</sub>| = 1 + SUM over n phi(m) where phi(m) is Euler's totient function, which gives the number of integers \u2264 m that are coprime to m.</p> <p>Some values for the length of F<sub>n</sub> given n:</p> n F 1 2 2 3 3 5 4 7 5 11 6 13 7 19 8 23 9 29 10 33 11 43 12 47 13 59 14 65 15 73 16 81 17 97 18 103 19 121 20 129"},{"location":"opcodes/fareyleni/#syntax","title":"Syntax","text":"<pre><code>ifl fareyleni ifn\n</code></pre> <p>Initialisation</p> <p>The length of the identified Farey sequence is returned.</p> <p>ifn -- Integer identifying the sequence.</p>"},{"location":"opcodes/fareyleni/#examples","title":"Examples","text":"<p>Here is an example of the fareyleni opcode. It uses the file fareyleni.csd.</p> Example of the fareyleni opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc for RT audio input as well \n; For Non-realtime ouput leave only the line below:\n; -o fareyleni.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n      ; initialise integer n for Farey Sequence F_8\n      gifarn init 8     \n\n      ; calculate length of F_8, it should return 23 for |F_8|\n      gires fareyleni gifarn  \n\n      ; convert to negative number for the GEN routine because\n      ; the table length won't be a power of 2 \n      ; (The length of a Farey Sequence of n &gt; 1 is always an odd number)\n      gilen init gires * -1 \n\n      ; create F_8 with GENfarey, the negative table number prevents \n      ; unnecessary normalisation (F_8 IS already normalised)\n      ;                             n      mode: \n      gifarey ftgen 100, 0, gilen, \"farey\", gifarn, 4\n      ; if mode=4 then 1 is added to each element of F_n.\n      ; Useful for creating just tuning tables that can be read by the cps2pch opcode.\n\ninstr 1\n      ; the very last element of F_n is not needed in the case of tuning tables\n      ires = gires - 1 \n      ; read out and print to file\n      kndx init 0 \n      if (kndx &lt; ires) then    \n         kelem tab kndx, gifarey\n         fprintks \"farey8_tuning.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\n\nendin\n\ninstr 2\n\nip   cps2pch p4, -100\nasig poscil .5, ip, 1\naenv linseg 0, 0.1, 1, p3-0.2, 1, 0.1, 0\n     outs asig * aenv, asig * aenv\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1  ;sine wave\n\ni1      0     .1\n\ni2      1       .5      8.00\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       .       &gt;\ni2      +       1       8.22\n\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fareyleni/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/fareyleni/#credits","title":"Credits","text":"<p>Author: Georg Boenn  University of Glamorgan, UK</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/ficlose/","title":"Ficlose","text":""},{"location":"opcodes/ficlose/#ficlose","title":"ficlose","text":"<p>Closes a previously opened file.</p>"},{"location":"opcodes/ficlose/#syntax","title":"Syntax","text":"<pre><code>ficlose ihandle\nficlose Sfilename\n</code></pre>"},{"location":"opcodes/ficlose/#initialization","title":"Initialization","text":"<p>ihandle -- a number which identifies this file (generated by a previous fiopen).</p> <p>Sfilename -- A string in double quotes or string variable with the filename. The full path must be given if the file directory is not in the system PATH and is not present in the current directory.</p>"},{"location":"opcodes/ficlose/#performance","title":"Performance","text":"<p>ficlose closes a file which was previously opened with fiopen. ficlose is only needed if you need to read a file written to during the same csound performance, since only when csound ends a performance does it close and save data in all open files. The opcode ficlose is useful for instance if you want to save presets within files which you want to be accesible without having to terminate csound.</p> <p> Note</p> <p>If you do not need this functionality it is safer not to call ficlose, and just let csound close the files when it exits.</p> <p>If a files closed with ficlose is being accessed by another opcode (like fout or foutk), it will be closed later when it is no longer being used.</p> <p> Warning</p> <p>This opcode should be used with care, as the file handle will become invalid, and will cause an init error when an opcode tries to access the closed file.</p>"},{"location":"opcodes/ficlose/#examples","title":"Examples","text":"<p>Here is an example of the ficlose opcode. It uses the file ficlose.csd.</p> Example of the ficlose opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ficlose.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"test1.txt\", 0 \n\ninstr 1\n\nires  random  0, 100\n      fouti gihand, 0, 1, ires \n      ficlose gihand \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 \n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/ficlose/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/ficlose/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 5.02</p>"},{"location":"opcodes/filebit/","title":"Filebit","text":""},{"location":"opcodes/filebit/#filebit","title":"filebit","text":"<p>Returns the number of bits in each sample in a sound file.</p>"},{"location":"opcodes/filebit/#syntax","title":"Syntax","text":"<pre><code>ir filebit ifilcod [, iallowraw]\n</code></pre>"},{"location":"opcodes/filebit/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>iallowraw -- (Optional) Allow raw sound files (default=1)</p>"},{"location":"opcodes/filebit/#performance","title":"Performance","text":"<p>filebit returns the number of bits in each sample in the sound file ifilcod. In the case of floating point samples the value -1 is returned for floats and -2 for doubles. For non-PCM formats the value is negative, and based on libsndfile's format encoding.</p>"},{"location":"opcodes/filebit/#examples","title":"Examples","text":"<p>Here is an example of the filebit opcode. It uses the file filebit.csd, and stereoJungle.wav.</p> <p>Example of the filebit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n   ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o filebit.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nibits filebit \"stereoJungle.wav\"\nprints  \"\\nbit depth = %d bit\\n\\n\", ibits\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> The output should include a line like this:</p> <pre><code>bit depth = 16 bit\n</code></pre>"},{"location":"opcodes/filebit/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filebit/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini July 1999</p> <p>New in Csound version 5.11</p>"},{"location":"opcodes/filelen/","title":"Filelen","text":""},{"location":"opcodes/filelen/#filelen","title":"filelen","text":"<p>Returns the length of a sound file.</p>"},{"location":"opcodes/filelen/#syntax","title":"Syntax","text":"<pre><code>ir filelen ifilcod, [iallowraw]\n</code></pre>"},{"location":"opcodes/filelen/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>iallowraw -- Allow raw sound files (default=1)</p>"},{"location":"opcodes/filelen/#performance","title":"Performance","text":"<p>filelen returns the length of the sound file ifilcod in seconds. filelen can return the length of convolve and PVOC files if the \"allow raw sound file\" flag is not zero (it is non-zero by default).</p>"},{"location":"opcodes/filelen/#examples","title":"Examples","text":"<p>Here is an example of the filelen opcode. It uses the file filelen.csd, Mathews.wav, and drumsSlp.wav.</p> Example of the filelen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n;-o filelen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; choose between mono or stereo file\n\nilen   filelen p4             ; calculate length of soundfile\nprints \"\\nlenght of sample = %2.3f seconds\\n\\n\", ilen\nichn filenchnls  p4           ; check number of channels\n\nif (ichn == 1) then           ; mono signal\n     asig diskin2 p4, 1 \n     outs    asig, asig\nelse\n     aL, aR diskin2 p4, 1     ; stereo signal \n     outs    aL, aR\nendif\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 8 \"Mathews.wav\"   ; mono signal\ni 1 8 4 \"drumsSlp.wav\"  ; stereo signal\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The mono audio file \u201cMathews.wav\u201d is about 2.8 seconds long, and the stereo file \u201cdrumsSlp.wav\u201d is 4.0 seconds. So filelen's output should include a line for the mono and the stereo file like this:</p> <pre><code>lenght of sample = 15.598 seconds\nlenght of sample = 4.000 seconds\n</code></pre>"},{"location":"opcodes/filelen/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filelen/#credits","title":"Credits","text":"<p>Author: Matt Ingalls July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/filenchnls/","title":"Filenchnls","text":""},{"location":"opcodes/filenchnls/#filenchnls","title":"filenchnls","text":"<p>Returns the number of channels in a sound file.</p>"},{"location":"opcodes/filenchnls/#syntax","title":"Syntax","text":"<pre><code>ir filenchnls ifilcod [, iallowraw]\n</code></pre>"},{"location":"opcodes/filenchnls/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>iallowraw -- (Optional) Allow raw sound files (default=1)</p>"},{"location":"opcodes/filenchnls/#performance","title":"Performance","text":"<p>filenchnls returns the number of channels in the sound file ifilcod. filechnls can return the number of channels of convolve and PVOC files if the iallowraw flag is not zero (it is non-zero by default).</p>"},{"location":"opcodes/filenchnls/#examples","title":"Examples","text":"<p>Here is an example of the filenchnls opcode. It uses the file filenchnls.csd, fox.wav, and drumsSlp.wav.</p> Example of the filenchnls opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o filenchnls.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2022\n\ninstr 1 ; choose between mono or stereo file\n\nichn filenchnls  p4                 ; check number of channels\nprints  \"\\nnumber of channels = %d\\n\\n\", ichn\n\nif (ichn == 1) then\n    asig diskin2 p4, 1              ; mono signal       \n    outs    asig, asig\nelse\n    aL, aR diskin2 p4, 1            ; stereo signal\n    outs    aL, aR\nendif\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 \"fox.wav\"       ;mono signal\ni 1 5 4 \"drumsSlp.wav\"  ;stereo signal\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The audio file \u201cfox.wav\u201d is monoaural (1 channel), while \u201cdrumsSlp.wav\u201d is stereo (2 channels) So filenchnls's output should include lines like this:</p> <pre><code>number of channels = 1\nnumber of channels = 2\n</code></pre>"},{"location":"opcodes/filenchnls/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filenchnls/#credits","title":"Credits","text":"<p>Author: Matt Ingalls July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/filepeak/","title":"Filepeak","text":""},{"location":"opcodes/filepeak/#filepeak","title":"filepeak","text":"<p>Returns the peak absolute value of a sound file.</p>"},{"location":"opcodes/filepeak/#syntax","title":"Syntax","text":"<pre><code>ir filepeak ifilcod [, ichnl]\n</code></pre>"},{"location":"opcodes/filepeak/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>ichnl (optional, default=0) -- channel to be used in calculating the peak value. Default is 0.</p> <ul> <li>ichnl = 0 returns peak value of all channels</li> <li>ichnl &gt; 0 returns peak value of ichnl</li> </ul>"},{"location":"opcodes/filepeak/#performance","title":"Performance","text":"<p>filepeak returns the peak absolute value of the sound file ifilcod.</p>"},{"location":"opcodes/filepeak/#examples","title":"Examples","text":"<p>Here is an example of the filepeak opcode. It uses the file filepeak.csd, and Church.wav.</p> Example of the filepeak opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o filepeak.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\niscaldb = p4 ;set peak amplitude in dB\nipeak   filepeak \"Church.wav\"\niscal   = ampdb(iscaldb)/ipeak ;calculate amp multiplier\nprintf_i \"\\nPeak value in file '%s' is %f (%.3f dB).\\n\\n\", 1, \"Church.wav\", ipeak, dbamp(ipeak)\n\nasnd soundin \"Church.wav\"\n     outs asnd, asnd\n; scale &amp; write file to disk\nasig = asnd*iscal ;scale to p4\nfout \"Church_norm.wav\", 14, asig\n\nendin\n\ninstr 2 ; play scaled file\n\naout   soundin  \"Church_norm.wav\"\nipknew filepeak \"Church_norm.wav\"\nprintf_i \"\\nPeak value in file '%s' is %f (%.3f dB).\\n\\n\", 1, \"Church_norm.wav\", ipknew, dbamp(ipknew)\n       outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 -6 ; normalize audio to -6 dB\ni 2 2 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The filepeak's output should include lines like this:</p> <pre><code>Peak value in file 'Church.wav' is 0.909363 (-0.825 dB).\nPeak value in file 'Church_norm.wav' is 0.501190 (-6.000 dB).\n</code></pre>"},{"location":"opcodes/filepeak/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filepeak/#credits","title":"Credits","text":"<p>Author: Matt Ingalls July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/filesr/","title":"Filesr","text":""},{"location":"opcodes/filesr/#filesr","title":"filesr","text":"<p>Returns the sample rate of a sound file.</p>"},{"location":"opcodes/filesr/#syntax","title":"Syntax","text":"<pre><code>ir filesr ifilcod [, iallowraw]\n</code></pre>"},{"location":"opcodes/filesr/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>iallowraw -- (Optional) Allow raw sound files (default=1)</p>"},{"location":"opcodes/filesr/#performance","title":"Performance","text":"<p>filesr returns the sample rate of the sound file ifilcod. filesr can return the sample rate of convolve and PVOC files if the iallowraw flag is not zero (it is non-zero by default).</p>"},{"location":"opcodes/filesr/#examples","title":"Examples","text":"<p>Here is an example of the filesr opcode. It uses the file filesr.csd, and drumsMlp.wav.</p> Example of the filesr opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o filesr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n;after an example from Jonathan Murphy\n\ninstr 1 \n;load sound into an ftable\n  Sfile     strcpy    \"drumsMlp.wav\" \n  ilen      filelen   Sfile \n  isr       filesr    Sfile \n  isamps    =  ilen * isr \n;adjust the length of the table to be a power of two closest\n;to the actual size of the sound \n  isize     init      1 \nloop: \n  isize     =  isize * 2 \n  if (isize &lt; isamps) igoto loop \n  itab      ftgen     0, 0, isize, 1, Sfile, 0, 0, 0 \nprints  \"sample rate = %f, size = %f\\n\", isr, isize ;prints them\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \ni1 0 2\ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>The audio file \u201cdrumsMlp.wav\u201d was sampled at 44.1 KHz. So filesr's output should include a line like this:</p> <pre><code>sample rate = 44100.000000, size = 131072.000000\n</code></pre>"},{"location":"opcodes/filesr/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filesr/#credits","title":"Credits","text":"<p>Author: Matt Ingalls July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/filevalid/","title":"Filevalid","text":""},{"location":"opcodes/filevalid/#filevalid","title":"filevalid","text":"<p>Checks that a file can be read at initialisation or performance time.</p> <p>Returns 1 if the sound file exists and is readable, or 0 if not.</p>"},{"location":"opcodes/filevalid/#syntax","title":"Syntax","text":"<pre><code>ir filevalid ifilcod\nkr filevalid ifilcod\n</code></pre>"},{"location":"opcodes/filevalid/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p> <p>ir -- return code (1 if the sound file ifilcod can be read).</p>"},{"location":"opcodes/filevalid/#performance","title":"Performance","text":"<p>kr -- return code (1 if the sound file ifilcod can be read).</p>"},{"location":"opcodes/filevalid/#examples","title":"Examples","text":"<p>Here is an example of the filevalid opcode. It uses the file filevalid.csd.</p> Example of the filevalid opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o filevalid.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nSfile     strget    p4\nivld      filevalid Sfile\n\nif ivld&gt;0 then\nasig      diskin2   Sfile, 1\n          outs      asig, asig\nelse\n          printf_i  \"Audiofile '%s' does not exist!\\n\", 1, Sfile\nendif\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 \"frox.wav\";file does not exist!!!\ni 1 + 3 \"fox.wav\" ;but this one certainly does...\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include a line like this:</p> <pre><code>Audiofile 'frox.wav' does not exist!\n</code></pre>"},{"location":"opcodes/filevalid/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/filevalid/#credits","title":"Credits","text":"<p>Author: Matt Ingalls July 2010</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/fillarray/","title":"Fillarray","text":""},{"location":"opcodes/fillarray/#fillarray","title":"fillarray","text":"<p>Generate a vector (one-dimensional k-rate array) with a sequence of numeric or string values.</p>"},{"location":"opcodes/fillarray/#syntax","title":"Syntax","text":"<pre><code>karray[] fillarray ival1, ival2,.....ivaln\nkarray fillarray ival1, ival2,.....ivaln\nkarray fillarray kval1, kval2,.....kvaln\n</code></pre>"},{"location":"opcodes/fillarray/#initialization","title":"Initialization","text":"<p>ival1,...ivaln -- values to place in the vector.</p> <p>In the second form the answer array must be pre-declared, and it may be a multidimensional array which if filled in row-major order.</p>"},{"location":"opcodes/fillarray/#performance","title":"Performance","text":"<p>In the third form the vector is regenerated at k-rate with values kval1,..., kvaln.</p>"},{"location":"opcodes/fillarray/#examples","title":"Examples","text":"<p>Here is an example of the fillarray opcode. It uses the file fillarray.csd.</p> Example of the fillarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n  kS[] fillarray 1,7,5\n       printk 0, kS[0]\n       printk 0, kS[1]\n       printk 0, kS[2]\n  turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fillarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/fillarray/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2013</p> <p>New in version 6.00</p> <p>Third, k-rate, form new in 6.12</p>"},{"location":"opcodes/filter2/","title":"Filter2","text":""},{"location":"opcodes/filter2/#filter2","title":"filter2","text":"<p>General purpose custom filter.</p> <p>Performs filtering using a transposed form-II digital filter lattice with no time-varying control. The filter coefficients implement the following difference equation:</p> \\[ (1) y(n) = b_0 x[n] + b_1 x[n-1] + ... + b_M x[n-M] - a_1 y[n-1] - ... - a_N y[n-N] \\] <p>the system function for which is represented by:</p> \\[ H(z) = \\frac{B(z)}{A(z)} = \\frac{b_0 + b_1 z^{-1} + ... + b_M z^{-M}}{1 + a_1 z^{-1} + ... + a_N z^{-N}} \\]"},{"location":"opcodes/filter2/#syntax","title":"Syntax","text":"<pre><code>ares filter2 asig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN\nkres filter2 ksig, ibcoefs, iacoefs, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN\n</code></pre>"},{"location":"opcodes/filter2/#initialization","title":"Initialization","text":"<p>ibcoefs -- number of feedforward coefficients including b0.</p> <p>iacoefs -- number of feedback coefficients</p> <p>ib0, ... ibM -- feedforward coefficients including b0.</p> <p>ia1, ... iaN -- feedback coefficients</p> <p>At initialization the number of zeros and poles of the filter are specified along with the corresponding zero and pole coefficients. The coefficients must be obtained by an external filter-design application such as Matlab and specified directly or loaded into a table via GEN01.</p>"},{"location":"opcodes/filter2/#performance","title":"Performance","text":"<p>The filter2 opcodes perform filtering using a transposed form-II digital filter lattice with no time-varying control.</p> <p>Since filter2 implements generalized recursive filters, it can be used to specify a large range of general DSP algorithms. For example, a digital waveguide can be implemented for musical instrument modeling using a pair of delayr and delayw opcodes in conjunction with the filter2 opcode.</p>"},{"location":"opcodes/filter2/#examples","title":"Examples","text":"<p>A first-order linear-phase lowpass FIR filter operating on a k-rate signal:</p> <pre><code>k1 filter2 ksig, 2, 0, 0.5, 0.5   ;; k-rate FIR filter\n</code></pre> <p>Here is another example of the filter2 opcode. It uses the file filter2.csd.</p> Example of the filter2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o filter2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1  ; 2 saw waves of which one is slightly detuned\n\nib1   = p5  \nivol  = p6                              ;volume to compensate                                               \nkcps  init cpspch(p4)\nasig1 vco2 .05, kcps                    ;saw 1\nasaw1 filter2 asig1, 1, 1, 1, ib1       ;filter 1 \nasig2 vco2 .05, kcps+1                  ;saw 2                      \nasaw2 filter2 asig2, 1, 1, 1, ib1       ;filter 2\naout  = (asaw1+asaw2)*ivol              ;mix\n      outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 6.00 -.001 5    ;different filter values\ni 1 + 4 6.00 -.6   2    ;and different volumes\ni 1 + 4 6.00 -.95 .3    ;to compensate\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/filter2/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/filter2/#credits","title":"Credits","text":"<p>Author: Michael A. Casey M.I.T. Cambridge, Mass. 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/fin/","title":"Fin","text":""},{"location":"opcodes/fin/#fin","title":"fin","text":"<p>Read signals from a file at a-rate.</p>"},{"location":"opcodes/fin/#syntax","title":"Syntax","text":"<pre><code>fin ifilename, iskipframes, iformat, ain1 [, ain2] [, ain3] [,...]\nfin ifilename, iskipframes, iformat, arr[]\n</code></pre>"},{"location":"opcodes/fin/#initialization","title":"Initialization","text":"<p>ifilename -- input file name (can be a string or a handle number generated by fiopen).</p> <p>iskipframes -- number of frames to skip at the start (every frame contains a sample of each channel)</p> <p>iformat -- a number specifying the input file format for headerless files.</p> <ul> <li>-2 - 32 bit floating points without header</li> <li>-1 - 16 bit integers without header</li> <li>0 - take values from the header</li> </ul>"},{"location":"opcodes/fin/#performance","title":"Performance","text":"<p>fin (file input) is the complement of fout: it reads a multichannel file to generate audio rate signals. The user must be sure that the number of channels of the input file is the same as the number of ainX arguments.</p> <p> Note</p> <p>Please note that since this opcode generates its output using input parameters (on the right side of the opcode), these variables must be initialized before use, otherwise a 'used before defined' error will occur. You can use the init opcode for this.</p>"},{"location":"opcodes/fin/#examples","title":"Examples","text":"<p>Here is an example of the fin opcode. It uses the file fin.csd and fox.wav.</p> Example of the fin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasnd init 0                     ;input of fin must be initialized\n     fin  \"fox.wav\", 0, 0, asnd ;read audiofile\naenv follow asnd, 0.01          ;envelope follower\nkenv downsamp aenv\nasig rand kenv                  ;gate the noise with audiofile\n     outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fin/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fin/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999 Author: John ffitch NUIM, 2013</p> <p>New in Csound version 3.56</p> <p>Array version new in 6.01</p> <p>Meaning of format parameter changed in 6.15</p>"},{"location":"opcodes/fini/","title":"Fini","text":""},{"location":"opcodes/fini/#fini","title":"fini","text":"<p>Read signals from a file at i-rate.</p>"},{"location":"opcodes/fini/#syntax","title":"Syntax","text":"<pre><code>fini ifilename, iskipframes, iformat, in1 [, in2] [, in3] [, ...]\n</code></pre>"},{"location":"opcodes/fini/#initialization","title":"Initialization","text":"<p>ifilename -- input file name (can be a string or a handle number generated by fiopen)</p> <p>iskipframes -- number of frames to skip at the start (every frame contains a sample of each channel)</p> <p>iformat -- a number specifying the input file format. If a header is found, this argument is ignored.</p> <ul> <li>0 - floating points in text format (loop; see below)</li> <li>1 - floating points in text format (no loop; see below)</li> <li>2 - 32 bit floating points in binary format (no loop)</li> </ul>"},{"location":"opcodes/fini/#performance","title":"Performance","text":"<p>fini is the complement of fouti and foutir. It reads the  values each time the corresponding instrument note is activated. When iformat is set to 0 and the end of file is reached, the file pointer is zeroed. This restarts the scan from the beginning. When iformat is set to 1 or 2, no looping is enabled and at the end of file the corresponding variables will be filled with zeroes.</p> <p> Note</p> <p>Please note that since this opcode generates its output using input parameters (on the right side of the opcode), these variables must be initialized before use, otherwise a 'used before defined' error will occur. You can use the init opcode for this.</p>"},{"location":"opcodes/fini/#examples","title":"Examples","text":"<p>Here is an example of the fini opcode. It uses the file fini.csd.</p> Example of the fini opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fini.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"test.txt\", 1\n\ninstr 1\n\n ihz  init 0\n      fini gihand, 0, 1, ihz \n ar   oscil 0.5, ihz\n      outs  ar, ar\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 \n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fini/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fini/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/fink/","title":"Fink","text":""},{"location":"opcodes/fink/#fink","title":"fink","text":"<p>Read signals from a file at k-rate.</p>"},{"location":"opcodes/fink/#syntax","title":"Syntax","text":"<pre><code>fink ifilename, iskipframes, iformat, kin1 [, kin2] [, kin3] [,...]\n</code></pre>"},{"location":"opcodes/fink/#initialization","title":"Initialization","text":"<p>ifilename -- input file name (can be a string or a handle number generated by fiopen)</p> <p>iskipframes -- number of frames to skip at the start (every frame contains a sample of each channel)</p> <p>iformat -- a number specifying the input file format. If a header is found, this argument is ignored.</p> <ul> <li>0 -  32 bit floating points without header</li> <li>1 - 16 bit integers without header</li> </ul>"},{"location":"opcodes/fink/#performance","title":"Performance","text":"<p>fink is the same as fin but operates at k-rate.</p> <p> Note</p> <p>Please note that since this opcode generates its output using input parameters (on the right side of the opcode), these variables must be initialized before use, otherwise a 'used before defined' error will occur. You can use the init opcode for this.</p>"},{"location":"opcodes/fink/#examples","title":"Examples","text":"<p>Here is an example of the fink opcode. It uses the file fink.csd.</p> Example of the fink opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fink.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"test.txt\", 1\n\ninstr 1\n\n khz  init 0\n      fink gihand, 0, 1, khz \n ar   oscil 0.5, khz\n      outs  ar, ar\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 \n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fink/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fink/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/fiopen/","title":"Fiopen","text":""},{"location":"opcodes/fiopen/#fiopen","title":"fiopen","text":"<p>Opens a file in a specific mode.</p>"},{"location":"opcodes/fiopen/#syntax","title":"Syntax","text":"<pre><code>ihandle fiopen ifilename, imode\n</code></pre>"},{"location":"opcodes/fiopen/#initialization","title":"Initialization","text":"<p>ihandle -- a number which specifies this file.</p> <p>ifilename -- the target file's name (in double-quotes).</p> <p>imode -- choose the mode of opening the file. imode can be a value chosen among the following:</p> <ul> <li>0 - open a text file for writing</li> <li>1 - open a text file for reading</li> <li>2 - open a binary file for writing</li> <li>3 - open a binary file for reading</li> </ul>"},{"location":"opcodes/fiopen/#performance","title":"Performance","text":"<p>fiopen opens a file to be used by the fout family of opcodes. It is safer to use it in the header section, external to any instruments. It returns a number, ihandle, which unequivocally refers to the opened file.</p> <p>If fiopen is called on an already open file, it just returns the same handle again, and does not close the file.</p> <p>Notice that fout and foutk can use either a string containing a file pathname, or a handle-number generated by fiopen. Whereas, with fouti and foutir, the target file can be only specified by means of a handle-number.</p>"},{"location":"opcodes/fiopen/#examples","title":"Examples","text":"<p>Here is an example of the fiopen opcode. It uses the file fiopen.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the fiopen opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fiopen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"test1.txt\", 0 \n\ninstr 1\n\nires  random  0, 100\n      fouti gihand, 0, 1, ires \n      ficlose gihand \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 \n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fiopen/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fiopen/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/flanger/","title":"Flanger","text":""},{"location":"opcodes/flanger/#flanger","title":"flanger","text":"<p>A user controlled flanger.</p>"},{"location":"opcodes/flanger/#syntax","title":"Syntax","text":"<pre><code>ares flanger asig, adel, kfeedback [, imaxd]\n</code></pre>"},{"location":"opcodes/flanger/#initialization","title":"Initialization","text":"<p>imaxd(optional) -- maximum delay in seconds (needed for inital memory allocation)</p>"},{"location":"opcodes/flanger/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>adel -- delay in seconds</p> <p>kfeedback -- feedback amount (in normal tasks this should not exceed 1, even if bigger values are allowed)</p> <p>This unit is useful for generating choruses and flangers. The delay must be varied at a-rate, for example by connecting adel to an oscillator output. The feedback can vary at k-rate.  This opcode is implemented to allow kr different than sr (else delay could not be lower than ksmps) enhancing realtime performance. This unit is very similar to wguide1, the only difference is flanger does not have the lowpass filter or the requirement that the delay be varied at a-rate.</p>"},{"location":"opcodes/flanger/#examples","title":"Examples","text":"<p>Here is an example of the flanger opcode. It uses the file flanger.csd.</p> Example of the flanger opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o flanger.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nkfeedback = p4\nasnd vco2 .2, 50\nadel linseg 0, p3*.5, 0.02, p3*.5, 0    ;max delay time =20ms   \naflg flanger asnd, adel, kfeedback, 1\nasig clip aflg, 1, 1\n     outs asig+asnd, asig+asnd          ;mix flanger with original\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1.1 0 10 .2\ni 1.1 10 10 .8  ;lot of feedback\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/flanger/#see-also","title":"See also","text":"<p>Special Effects</p> <p>More information on flanging on Wikipedia: http://en.wikipedia.org/wiki/Flanger</p>"},{"location":"opcodes/flanger/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/flashtxt/","title":"Flashtxt","text":""},{"location":"opcodes/flashtxt/#flashtxt","title":"flashtxt","text":"<p>Allows text to be displayed from instruments like sliders etc. (only on Unix and Windows at present)</p> <p>Plugin opcode in control.</p>"},{"location":"opcodes/flashtxt/#syntax","title":"Syntax","text":"<pre><code>flashtxt  iwhich, String\n</code></pre>"},{"location":"opcodes/flashtxt/#initialization","title":"Initialization","text":"<p>iwhich -- the number of the window.</p> <p>String -- the string to be displayed.</p>"},{"location":"opcodes/flashtxt/#performance","title":"Performance","text":"<p>Note that this opcode is not available on Windows due to the implimentation of pipes on that system.</p> <p>A window is created, identified by the iwhich argument, with the text string displayed.  If the text is replaced by a number then the window id deleted.  Note that the text windows are globally numbered so different instruments can change the text, and the window survives the instance of the instrument.</p>"},{"location":"opcodes/flashtxt/#examples","title":"Examples","text":"<p>Here is an example of the flashtxt opcode. It uses the file flashtxt.csd.</p> Example of the flashtxt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o flashtxt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\ninstr 1\n  flashtxt 1, \"Instr 1 live\"\n  ao oscil 4000, 440, 1\n  out ao\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table 1: an ordinary sine wave.\nf 1 0 32768 10 1 \n\n; Play Instrument #1 for three seconds.\ni 1 0 3\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/flashtxt/#see-also","title":"See also","text":"<p>Sensing and Control: TCL/TK widgets</p>"},{"location":"opcodes/flashtxt/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.11</p>"},{"location":"opcodes/flhvsbox/","title":"Flhvsbox","text":""},{"location":"opcodes/flhvsbox/#flhvsbox","title":"FLhvsBox","text":"<p>Displays a box with a grid useful for visualizing two-dimensional Hyper Vectorial Synthesis.</p> <p>Plugin opcode in widgets. This opcode is part of the plugin repository and has to be installed separately. These FLTK widgets do not work on the Mac. The plugin repository can be found here: https://github.com/csound/plugins.</p> <p>FLhvsBox displays a box with a grid useful for visualizing two-dimensional Hyper Vectorial Synthesis.</p>"},{"location":"opcodes/flhvsbox/#syntax","title":"Syntax","text":"<pre><code>ihandle FLhvsBox inumlinesX, inumlinesY, iwidth, iheight, ix, iy\n</code></pre>"},{"location":"opcodes/flhvsbox/#initialization","title":"Initialization","text":"<p>ihandle \u2013 an integer number used a univocally-defined handle for identifying a specific HVS box (see below).</p> <p>inumlinesX, inumlinesY - number of vertical and horizontal lines delimiting the HVS squared areas</p> <p>iwidth, iheight - width and height of the HVS box</p> <p>ix, iy - the position of the HVS box</p>"},{"location":"opcodes/flhvsbox/#performance","title":"Performance","text":"<p>FLhvsBox is a widget able to visualize current position of the HVS cursor in an HVS box (i.e. a squared area containing a grid). The number of  horizontal and vertical lines of the grid can be defined with the inumlinesX, inumlinesY arguments. This opcode has to be declared inside an FLpanel - FLpanelEnd block. See the entry for hvs2 for an example of usage of FLhvsBox.</p> <p>FLhvsBoxSetValue is used to set the cursor position of an FLhvsBox widget.</p>"},{"location":"opcodes/flhvsbox/#see-also","title":"See Also","text":"<p>hvs2, FLhvsBoxSetValue</p>"},{"location":"opcodes/flhvsbox/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/flooper/","title":"Flooper","text":""},{"location":"opcodes/flooper/#flooper","title":"flooper","text":"<p>Function-table-based crossfading looper.</p> <p>This opcode reads audio from a function table and plays it back in a loop with user-defined start time, duration and crossfade time. It also allows the pitch of the loop to be controlled, including reversed playback. It accepts non-power-of-two tables, such as deferred-allocation GEN01 tables, with one or two channels.</p>"},{"location":"opcodes/flooper/#syntax","title":"Syntax","text":"<pre><code>asig1[, asig2] flooper kamp, kpitch, istart, idur, ifad, ifn\n</code></pre>"},{"location":"opcodes/flooper/#initialization","title":"Initialization","text":"<p>_istart _ -- loop start pos in seconds</p> <p>_idur _ -- loop duration in seconds</p> <p>_ifad _ -- crossfade duration in seconds</p> <p>_ifn _ -- function table number, generally created using GEN01</p>"},{"location":"opcodes/flooper/#performance","title":"Performance","text":"<p>asig[,asig2] -- output sig (mono or stereo)</p> <p>kamp -- amplitude control</p> <p>kpitch -- pitch control (transposition ratio); negative values play the loop back in reverse</p>"},{"location":"opcodes/flooper/#examples","title":"Examples","text":"<pre><code>aout flooper 16000, 1, 1, 4, 0.05, 1  ; loop starts at 1 sec, for 4 secs, 0.05 crossfade\n     out     aout\n</code></pre> <p>The example above shows the basic operation of flooper. Pitch can be controlled at the k-rate, as well as amplitude. The example assumes table 1 to contain at least 5.05 seconds of audio (4 secs loop duration, starting 1 sec into the table, using 0.05 secs after the loop end for the crossfade).</p> <p>Here is another example of the flooper opcode. It uses the file flooper.csd and fox.wav.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o flooper.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkpitch  line    1, p3, .9 ;lower pitch a bit during the note\naout    flooper .9, kpitch, 1, .53, 0.05, 1  ; loop starts at 1 sec, for .53 secs, 0.05 crossfade\n        outs    aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;table size is deferred,\n; and format taken from the soundfile header\nf 1 0 0 1 \"fox.wav\" 0 0 0\n\ni 1 0 8.2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/flooper/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/flooper/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini April 2005 </p> <p>New plugin in version 5</p> <p>April 2005.</p>"},{"location":"opcodes/flooper2/","title":"Flooper2","text":""},{"location":"opcodes/flooper2/#flooper2","title":"flooper2","text":"<p>Function-table-based crossfading looper.</p> <p>This opcode implements a crossfading looper with variable loop parameters and three looping modes, optionally using a table for its crossfade shape. It accepts non-power-of-two tables for its source sounds, such as deferred-allocation GEN01 tables, with one or two channels.</p>"},{"location":"opcodes/flooper2/#syntax","title":"Syntax","text":"<pre><code>asig1[,asig2] flooper2 kamp, kpitch, kloopstart, kloopend, kcrossfade, ifn \\\n                       [, istart, imode, ifenv, iskip]\n</code></pre>"},{"location":"opcodes/flooper2/#initialization","title":"Initialization","text":"<p>_ifn _ -- sound source function table number, generally created using GEN01</p> <p>_istart _ -- playback start pos in seconds</p> <p>_imode _ -- loop modes: 0 forward, 1 backward, 2 back-and-forth [def: 0]</p> <p>_ifenv _ -- if non-zero, crossfade envelope shape table number. The default, 0, sets the crossfade to linear.</p> <p>_iskip _ -- if 1, the opcode initialisation is skipped, for tied notes, performance continues from the position in the loop where the previous note stopped. The default, 0, does not skip initialisation</p>"},{"location":"opcodes/flooper2/#performance","title":"Performance","text":"<p>asig1[, asig2] -- output sig (mono or stereo).</p> <p>kamp -- amplitude control</p> <p>kpitch -- pitch control (transposition ratio); negative values are not allowed.</p> <p>kloopstart -- loop start point (secs). Note that although k-rate, loop parameters such as this are only updated once per loop cycle.</p> <p>kloopend -- loop end point (secs), updated once per loop cycle.</p> <p>_kcrossfade _ -- crossfade length (secs), updated once per loop cycle and limited to loop length.</p> <p>Mode 1 for _imode _ will only loop backwards from the end point to the start point.</p>"},{"location":"opcodes/flooper2/#examples","title":"Examples","text":"<pre><code>aout flooper2 16000, 1, 1, 5, 0.05, 1  ; loop starts at 1 sec, for 4 secs, 0.05 crossfade\n     out      aout\n</code></pre> <p>The example above shows the basic operation of flooper2. Pitch can be controlled at the k-rate, as well as amplitude and loop parameters. The example assumes table 1 to contain at least 5.05 seconds of audio (4 secs loop duration, starting 1 sec into the table, using 0.05 secs after the loop end for the crossfade). Looping is in mode 0 (normal forward loop).</p> <p>Here is another example of the flooper2 opcode. It uses the file flooper2.csd and fox.wav.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o flooper2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n; looping back and forth,  0.05 crossfade \nkst  line     .2, p3, 2 ;vary loopstartpoint\naout flooper2 .8, 1, 0, kst, 0.05, 1, 0, 2  \n     outs     aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Its table size is deferred,\n; and format taken from the soundfile header\nf 1 0 0 1 \"fox.wav\" 0 0 0\n\ni 1 0 12\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/flooper2/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/flooper2/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini July 2006 </p> <p>New plugin in version 5</p> <p>July 2006.</p>"},{"location":"opcodes/floor/","title":"Floor","text":""},{"location":"opcodes/floor/#floor","title":"floor","text":"<p>Returns the largest integer not greater than x</p>"},{"location":"opcodes/floor/#syntax","title":"Syntax","text":"<pre><code>floor(x) (init-, control-, or audio-rate arg allowed)\nfloor(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/floor/#examples","title":"Examples","text":"<p>Here is an example of the floor opcode. It uses the file floor.csd.</p> Example of the floor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o floor.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidiv init 1\n\nloop:\ninumber = 9\ni1  = inumber / idiv\nifl = floor(i1)\nprint inumber, idiv, ifl ;print number / idiv = result using floor\nidiv = idiv + 1\nif (idiv &lt;= 10) igoto loop\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>instr 1:  inumber = 9.000  idiv = 1.000  ifl = 9.000\ninstr 1:  inumber = 9.000  idiv = 2.000  ifl = 4.000\ninstr 1:  inumber = 9.000  idiv = 3.000  ifl = 3.000\ninstr 1:  inumber = 9.000  idiv = 4.000  ifl = 2.000\ninstr 1:  inumber = 9.000  idiv = 5.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 6.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 7.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 8.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 9.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 10.000  ifl = 0.000\n</code></pre> <p>Here is another example of the floor opcode. It uses the file floor2.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o floor.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2024\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n0dbfs  = 1\nnchnls = 2\n\ninstr 1\n\ngkrandom randomh 1, 45, 300, 2,  3 ; generate some random numbers\ngkrandomFLOOR = floor (gkrandom)   ; take the integer part\ngkrandomFRAC = frac (gkrandom)     ; take the fractional part\n\nendin\n\ninstr 10\n\n  ktrigger metro 4\n  kmintim = 0\n  kmaxnum = 10\n  kinsnum = 20\n  kwhen = 0\n  kdur = ktrigger*0.25\n  schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur\n\nendin\n\ninstr 20\n\n  irandomFLOOR = i(gkrandomFLOOR) \n  irandomFRAC = i(gkrandomFRAC)\n\n  ; Use the integer part to control the number of harmonics of every note\n  ; after converting (k) value to (i)\n  prints \"generated value = %f\\n\", i(gkrandom)\n  prints \"--&gt; floor value = %d\\n\", irandomFLOOR\n  a1 buzz 0.5, 120, irandomFLOOR, 1 \n\n  kenvelope linseg 0, p3*0.1, 1, p3*0.8, 1, p3*0.1, 0\n\n  a1 = a1*kenvelope\n\n  aL, aR pan2 a1, irandomFRAC, 1 ; use the fractional part to control the pan position \n  outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 16384 10 1\n\ni 1 0 10\ni 10 0 10 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the rounding-group, comparing the different rounding opcodes. It uses the file rounding-group.csd.</p> Example of the rounding group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac       ;   \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n\n; by tgrey 2020\ninstr 1\n\niLoopStart = p4\niLoopEnd   = p5\niOffset    = p6\n\niCount init iLoopStart\n\n\nif(iLoopStart&lt;iLoopEnd) then            ; loop going up\n        while iCount &lt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount + 1             \n        od\n\nelseif(iLoopEnd&lt;iLoopStart) then        ; loop going down\n        while iCount &gt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount - 1             \n        od\nendif\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 .1 0 10 .5\ni1 .2 .1 0 -10 .5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/floor/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/floor/#credits","title":"Credits","text":"<p>Author: Istvan Varga New in Csound 5 2005</p>"},{"location":"opcodes/fluidAllOut/","title":"fluidAllOut","text":""},{"location":"opcodes/fluidAllOut/#fluidallout","title":"fluidAllOut","text":"<p>Collects all audio from all Fluidsynth engines in a performance.</p>"},{"location":"opcodes/fluidAllOut/#syntax","title":"Syntax","text":"<pre><code>aleft, aright fluidAllOut\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/fluidAllOut/#performance","title":"Performance","text":"<p>aleft -- Left channel audio output.</p> <p>aright -- Right channel audio output.</p> <p>Invoke fluidAllOut in an instrument definition numbered higher than any fluidcontrol instrument definitions. All SoundFonts send their audio output to this one opcode. Send a note with an indefinite duration to this instrument to turn the SoundFonts on for as long as required.</p> <p>In this implementation, SoundFont effects such as chorus or reverb are used if and only if they are defaults for the preset. There is no means of turning such effects on or off, or of changing their parameters, from Csound.</p>"},{"location":"opcodes/fluidAllOut/#examples","title":"Examples","text":"<p>Here is an example of the fluidAllOut opcodes. It uses the file fluidAllOut.csd. Example of the fluidAllOut opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidAllOut.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiengine1 fluidEngine\nisfnum1   fluidLoad \"sf_GMbank.sf2\", giengine1, 1\n          fluidProgramSelect giengine1, 1, isfnum1, 0, 0\n\ngiengine2 fluidEngine\n; soundfont path to manual/examples\nisfnum2   fluidLoad \"22Bassoon.sf2\", giengine2, 1\n          fluidProgramSelect giengine2, 1, isfnum2, 0, 70\n\ninstr 1\n\n     mididefault   60, p3\n     midinoteonkey p4, p5\nikey init p4\nivel init p5\n     fluidNote giengine1, 1, ikey, ivel\n\nendin\n\ninstr 2\n\n     mididefault   60, p3\n     midinoteonkey p4, p5\nikey init p4\nivel init p5\n     fluidNote giengine2, 1, ikey, ivel\n\nendin\n\ninstr 100\n\nimvol init 7 ;amplify a bit\nasigl, asigr fluidAllOut\n      outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 60 127 ;play one note on instr 1\ni 2 2 2 60 127 ;play another note on instr 2 and...\ni 100 0 60     ;play virtual midi keyboard\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre></p>"},{"location":"opcodes/fluidAllOut/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidAllOut/#credits","title":"Credits","text":"<p>Opcode by Michael Gogins (gogins at pipeline dot com). Thanks to Peter Hanappe for Fluidsynth, and to Steven Yi for seeing that it is necessary to break up the Fluidsynth into several different Csound opcodes.</p>"},{"location":"opcodes/fluidCCi/","title":"fluidCCi","text":""},{"location":"opcodes/fluidCCi/#fluidcci","title":"fluidCCi","text":"<p>Sends a MIDI controller data message to fluid.</p>"},{"location":"opcodes/fluidCCi/#syntax","title":"Syntax","text":"<pre><code>fluidCCi iEngineNumber, iChannelNumber, iControllerNumber, iValue\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>Sends a MIDI controller data (MIDI controller number and value to use) message to a fluid engine by number on the user specified MIDI channel number.</p>"},{"location":"opcodes/fluidCCi/#initialization","title":"Initialization","text":"<p>iEngineNumber -- engine number assigned from fluidEngine</p> <p>iChannelNumber -- MIDI channel number to which the Fluidsynth program is assigned: from 0 to 255. MIDI channels numbered 16 or higher are virtual channels.</p> <p>iControllerNumber -- MIDI controller number to use for this message</p> <p>iValue -- value to set for controller (usually 0-127)</p>"},{"location":"opcodes/fluidCCi/#performance","title":"Performance","text":"<p>This opcode is useful for setting controller values at init time. For continous changes, use fluidCCk.</p>"},{"location":"opcodes/fluidCCi/#examples","title":"Examples","text":"<p>Here is an example of the fluidCCi opcode. It uses the file fluidCCi.csd.</p> Example of the fluidCCi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual  -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidCCi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"19Trumpet.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 56\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidCCi giengine, 1, 93, 127   ;full chorus &amp;\n        fluidCCi giengine, 1, 91, 127   ;full reverb!\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5 60 100 ;play one note from score and...\ni 99 0 60      ;play virtual keyboard for 60 sec.\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fluidCCi/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidCCi/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p>"},{"location":"opcodes/fluidCCk/","title":"fluidCCk","text":""},{"location":"opcodes/fluidCCk/#fluidcck","title":"fluidCCk","text":"<p>Sends a MIDI controller data message to fluid.</p>"},{"location":"opcodes/fluidCCk/#syntax","title":"Syntax","text":"<pre><code>fluidCCk iEngineNumber, iChannelNumber, iControllerNumber, kValue\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>Sends a MIDI controller data (MIDI controller number and value to use) message to a fluid engine by number on the user specified MIDI channel number.</p>"},{"location":"opcodes/fluidCCk/#initialization","title":"Initialization","text":"<p>iEngineNumber -- engine number assigned from fluidEngine</p> <p>iChannelNumber -- MIDI channel number to which the Fluidsynth program is assigned: from 0 to 255. MIDI channels numbered 16 or higher are virtual channels.</p> <p>iControllerNumber -- MIDI controller number to use for this message</p>"},{"location":"opcodes/fluidCCk/#performance","title":"Performance","text":"<p>kValue -- value to set for controller (usually 0-127)</p>"},{"location":"opcodes/fluidCCk/#examples","title":"Examples","text":"<p>Here is an example of the fluidCCk opcode. It uses the file fluidCCk.csd.</p> Example of the fluidCCk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidCCk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"22Bassoon.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 70\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\nkpan    line 0, p3, 127 ;panning from left to right\n        fluidCCk giengine, 1, 10, kpan ;CC 10 = pan\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 48 100\ni 1 4 2 50 120\ni 1 6 1 53 80\ni 1 7 1 45 70\ni 1 8 1.5 48 80\n\ni 99 0 10      ;keep instr 99 active\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fluidCCk/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidCCk/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p>"},{"location":"opcodes/fluidControl/","title":"fluidControl","text":""},{"location":"opcodes/fluidControl/#fluidcontrol","title":"fluidControl","text":"<p>Sends MIDI note on, note off, and other messages to a SoundFont preset.</p>"},{"location":"opcodes/fluidControl/#syntax","title":"Syntax","text":"<pre><code>fluidControl ienginenum, kstatus, kchannel, kdata1, kdata2 [,imsgs]\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>The fluid opcodes provide a simple Csound opcode wrapper around Peter Hanappe's Fluidsynth SoundFont2 synthesizer. This implementation accepts any MIDI note on, note off, controller, pitch bend, or program change message at k-rate. Maximum polyphony is 4096 simultaneously sounding voices. Any number of SoundFonts may be loaded and played simultaneously.</p>"},{"location":"opcodes/fluidControl/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine</p> <p>imsgs -- if zero suppresses printing of messages when commands arrive.  Default value is 1.</p>"},{"location":"opcodes/fluidControl/#performance","title":"Performance","text":"<p>kstatus -- MIDI channel message status byte: 128 for note off, 144 for note on, 176 for control change, 192 for program change, or 224 for pitch bend.</p> <p>kchannel -- MIDI channel number to which the Fluidsynth program is assigned: from 0 to 255. MIDI channels numbered 16 or higher are virtual channels.</p> <p>kdata1 -- For note on, MIDI key number: from 0 (lowest) to 127 (highest), where 60 is middle C. For continuous controller messages, controller number.</p> <p>kdata2 -- For note on, MIDI key velocity: from 0 (no sound) to 127 (loudest). For continous controller messages, controller value.</p> <p>Invoke fluidControl in instrument definitions that actually play notes and send control messages. Each instrument definition must consistently use one MIDI channel that was assigned to a Fluidsynth program using fluidLoad.</p> <p>In this implementation, SoundFont effects such as chorus or reverb are used if and only if they are defaults for the preset. There are some ways of turning effects chorus and reverb on or off using fluidEngine, and of changing some of their parameters with fluidCCi and fluidCCk.</p>"},{"location":"opcodes/fluidControl/#examples","title":"Examples","text":"<p>Here is a more complex example of the fluidsynth opcodes written by Istvan Varga. It uses the file fluidControl-advanced.csd.</p> A more complex example of the fluidsynth opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;Anna.mid is a midi file, a song by The Beatles and can be found on the internet\n-odac -T -F  Anna.mid;;;realtime audio I/O and midifile in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fluidControl-advanced.csd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; Example by Istvan Varga\n\n; disable triggering of instruments by MIDI events\n\nichn = 1\nlp1:\n        massign   ichn, 0\n        loop_le   ichn, 1, 16, lp1\n        pgmassign 0, 0\n\n; initialize FluidSynth\n\ngifld   fluidEngine\ngisf2   fluidLoad \"sf_GMbank.sf2\", gifld, 1\n\n; k-rate version of fluidProgramSelect\n\nopcode fluidProgramSelect_k, 0, kkkkk\n  keng, kchn, ksf2, kbnk, kpre xin\n        igoto     skipInit\n  doInit:\n        fluidProgramSelect i(keng), i(kchn), i(ksf2), i(kbnk), i(kpre)\n        reinit    doInit\n        rireturn\n  skipInit:\nendop\n\ninstr 1\n  ; initialize channels\n  kchn  init 1\n  if (kchn == 1) then\nlp2:\n        fluidControl gifld, 192, kchn - 1, 0, 0\n        fluidControl gifld, 176, kchn - 1, 7, 100\n        fluidControl gifld, 176, kchn - 1, 10, 64\n        loop_le   kchn, 1, 16, lp2\n  endif\n\n  ; send any MIDI events received to FluidSynth\nnxt:\n  kst, kch, kd1, kd2 midiin\n  if (kst != 0) then\n    if (kst != 192) then\n        fluidControl gifld, kst, kch - 1, kd1, kd2\n    else\n        fluidProgramSelect_k gifld, kch - 1, gisf2, 0, kd1\n    endif\n      kgoto nxt\n  endif\n\n; get audio output from FluidSynth\n  ivol   init 3 ;a bit louder\n  aL, aR fluidOut gifld\n         outs     aL*ivol, aR*ivol\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3600\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fluidControl/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidControl/#credits","title":"Credits","text":"<p>Opcodes by Michael Gogins (gogins at pipeline dot com). Thanks to Peter Hanappe for Fluidsynth, and to Steven Yi for seeing that it is necessary to break up the Fluidsynth into several different Csound opcodes.</p> <p>New in Csound5.00</p> <p>Optional imsgs parameter introduced in version 6.14.</p>"},{"location":"opcodes/fluidEngine/","title":"fluidEngine","text":""},{"location":"opcodes/fluidEngine/#fluidengine","title":"fluidEngine","text":"<p>Instantiates a fluidsynth engine.</p>"},{"location":"opcodes/fluidEngine/#syntax","title":"Syntax","text":"<pre><code>ienginenum fluidEngine [iChorusEnabled] [, iRevervEnabled] [, iNumChannels] [, iPolyphony]\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>Instantiates a fluidsynth engine, and returns ienginenum to identify the engine. ienginenum is passed to other other opcodes for loading and playing SoundFonts and gathering the generated sound.</p>"},{"location":"opcodes/fluidEngine/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine.</p> <p>iChorusEnabled -- optionally set to 0 to disable any chorus effect in the loaded SoundFonts.</p> <p>iReverbEnabled -- optionally set to 0 to disable any reverb effect in the loaded SoundFonts.</p> <p>iNumChannels -- number of channels to use; range is 16-256 and Csound default is 256 (Fluidsynth's default is 16).</p> <p>iPolyphony -- number of voices to be played in parallel; range is 16-4096 and Csound default is 4096 (Fluidsynth's default is 256). Note: this is not the number of notes played at the same time as a single note may use create multiple voices depending on instrument zones and velocity/key of played note.</p>"},{"location":"opcodes/fluidEngine/#examples","title":"Examples","text":"<p>Here is example of the fluidsynth opcodes using 2 engines. It uses the file fluidEngine.csd and midichn_advanced.mid.</p> Example of the fluidsynth opcodes using 2 engines.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -F  midichn_advanced.mid ;;;reatime audio out and midifile in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fluidEngine.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\n; LOAD SOUNDFONTS\ngienginenum1    fluidEngine\ngienginenum2    fluidEngine\nisfnum1 fluidLoad \"sf_GMbank.sf2\", gienginenum1, 1\n                ; Piano 2, program 1, channel 1\n                fluidProgramSelect      gienginenum1, 1, isfnum1, 0, 1\n                ; Piano 3, program 2, channel 2\n                fluidProgramSelect      gienginenum1, 2, isfnum1, 0, 2\nisfnum2 fluidLoad \"19Trumpet.sf2\", gienginenum2, 1\n                ; Trumpet, program 56, channel 3\n                fluidProgramSelect      gienginenum2, 3, isfnum2, 0, 56\n\n;Look for midifile in folder manual/examples\n;\"midichn_advanced.mid\" sends notes to the soundfonts\n\ninstr 1 ; GM soundfont\n  ; INITIALIZATION\n        mididefault     60, p3 ; Default duration of 60 -- overridden by score.\n        midinoteonkey   p4, p5 ; Channels MIDI input to pfields.\n  ; Use channel assigned in fluidload.\n  ichannel   = 1\n  ikey       = p4\n  ivelocity  = p5\n        fluidNote gienginenum1, ichannel, ikey, ivelocity\nendin\n\ninstr 2 ; GM soundfont\n  ; INITIALIZATION\n         mididefault   60, p3 ; Default duration of 60 -- overridden by score.\n         midinoteonkey p4, p5 ; Channels MIDI input to pfields.\n  ; Use channel assigned in fluidload.\n  ichannel   = 2\n  ikey       = p4\n  ivelocity  = p5\n         fluidNote gienginenum1, ichannel, ikey, ivelocity\nendin\n\ninstr 3 ; Trumpet\n  ; INITIALIZATION\n         mididefault   60, p3 ; Default duration of 60 -- overridden by score.\n         midinoteonkey p4, p5 ; Channels MIDI input to pfields.\n  ; Use channel assigned in fluidload.\n  ichannel   = 3\n  ikey       = p4\n  ivelocity  = p5\n         fluidNote gienginenum2, ichannel, ikey, ivelocity\nendin\n\n; COLLECT AUDIO FROM ALL SOUNDFONTS\n\ninstr 100 ; Fluidsynth output\n\n  iamplitude1 = 7\n  iamplitude2 = 7\n\n; AUDIO\naleft1, aright1 fluidOut   gienginenum1\naleft2, aright2 fluidOut   gienginenum2\n                outs       (aleft1 * iamplitude1) + (aleft2 * iamplitude2),  \\\n                           (aright1 * iamplitude1) + (aright2 * iamplitude2)\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3  60  100\ni 2 1 3  60  100\ni 3 3 3  63  100\ni 100 0 10              ;run for 10 seconds \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fluidEngine/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidEngine/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p> <p>Optional iNumChannels and iPolyphony parameters added in 5.07</p> <p>Order of arguments corrected in manual August 2019.</p>"},{"location":"opcodes/fluidLoad/","title":"fluidLoad","text":""},{"location":"opcodes/fluidLoad/#fluidload","title":"fluidLoad","text":"<p>Loads a SoundFont into a fluidEngine, optionally listing banks and presets for SoundFont.</p>"},{"location":"opcodes/fluidLoad/#syntax","title":"Syntax","text":"<pre><code>isfnum fluidLoad soundfont, ienginenum[, ilistpresets]\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/fluidLoad/#initialization","title":"Initialization","text":"<p>isfnum -- number assigned to just-loaded soundfont.</p> <p>soundfont -- string specifying a SoundFont filename. Note that any number of SoundFonts may be loaded (obviously, by different invocations of fluidLoad).</p> <p>ienginenum -- engine number assigned from fluidEngine</p> <p>ilistpresets -- optional, if specified, lists all Fluidsynth programs for the just-loaded SoundFont. A Fluidsynth program is a combination of SoundFont ID, bank number, and preset number that is assigned to a MIDI channel.</p>"},{"location":"opcodes/fluidLoad/#performance","title":"Performance","text":"<p>Invoke fluidLoad in the orchestra header, any number of times. The same SoundFont may be invoked to assign programs to MIDI channels any number of times; the SoundFont is only loaded the first time.</p>"},{"location":"opcodes/fluidLoad/#examples","title":"Examples","text":"<p>Here is an example of the fluidLoad opcode. It uses the file fluidLoad.csd and 07AcousticGuitar.sf2.</p> Example of the fluidLoad opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -+rtmidi=virtual  -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidLoad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"07AcousticGuitar.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 0\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 60 100 ;play one note from score and...\ni 99 0 60      ;play virtual keyboard for 60 sec.\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include a line like this:</p> <pre><code>SoundFont:   1  Bank:   0  Preset:   0  Seagul Acoustic Git\n</code></pre>"},{"location":"opcodes/fluidLoad/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidLoad/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p> <p>New in Csound5.00</p>"},{"location":"opcodes/fluidNote/","title":"fluidNote","text":""},{"location":"opcodes/fluidNote/#fluidnote","title":"fluidNote","text":"<p>Plays a note on a channel in a fluidSynth engine.</p>"},{"location":"opcodes/fluidNote/#syntax","title":"Syntax","text":"<pre><code>fluidNote ienginenum, ichannelnum, imidikey, imidivel\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/fluidNote/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine</p> <p>ichannelnum -- which channel number to play a note on in the given fluidEngine</p> <p>imidikey -- MIDI key for note (0-127)</p> <p>imidivel -- MIDI velocity for note (0-127)</p>"},{"location":"opcodes/fluidNote/#examples","title":"Examples","text":"<p>Here is an example of the fluidNote opcode. It uses the file fluidNote.csd and 19Trumpet.sf2.</p> Example of the fluidNote opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -+rtmidi=virtual  -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidNote.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"19Trumpet.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 56\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 60 100 ;play one note from score and...\ni 99 0 60      ;play virtual keyboard for 60 sec.\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include a line like this:</p> <pre><code>SoundFont:   1  Bank:   0  Preset:  56  Trumpet metallic\n</code></pre>"},{"location":"opcodes/fluidNote/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidNote/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p>"},{"location":"opcodes/fluidOut/","title":"fluidOut","text":""},{"location":"opcodes/fluidOut/#fluidout","title":"fluidOut","text":"<p>Outputs sound from a given fluidEngine.</p>"},{"location":"opcodes/fluidOut/#syntax","title":"Syntax","text":"<pre><code>aleft, aright fluidOut ienginenum\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/fluidOut/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine</p>"},{"location":"opcodes/fluidOut/#performance","title":"Performance","text":"<p>aleft -- Left channel audio output.</p> <p>aright -- Right channel audio output.</p> <p>Invoke fluidOut in an instrument definition numbered higher than any fluidcontrol instrument definitions. All SoundFonts used in the fluidEngine numbered ienginenum send their audio output to this one opcode. Send a note with an indefinite duration to this instrument to turn the SoundFonts on for as long as required.</p>"},{"location":"opcodes/fluidOut/#examples","title":"Examples","text":"<p>Here is an example of the fluidOut opcode with two fluidOuts. It uses the file fluidOut.csd, 01hpschd.sf2 and 22Bassoon.sf2.</p> Example of the fluidOut opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -+rtmidi=virtual  -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidOut.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine1 fluidEngine\n; soundfont path to manual/examples\nisfnum1  fluidLoad \"01hpschd.sf2\", giengine1, 1\n         fluidProgramSelect giengine1, 1, isfnum1, 0, 0\n\ngiengine2 fluidEngine\n; soundfont path to manual/examples\nisfnum2  fluidLoad \"22Bassoon.sf2\", giengine2, 1\n         fluidProgramSelect giengine2, 1, isfnum2, 0, 70\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidNote giengine1, 1, ikey, ivel\n\nendin\n\ninstr 2\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidNote giengine2, 1, ikey, ivel\n\nendin\n\ninstr 98\n\nimvol  init 7\nasigl, asigr fluidOut giengine1\n       outs asigl*imvol, asigr*imvol\nendin\n\ninstr 99\n\nimvol init 4\nasigl, asigr fluidOut giengine2          ;add a stereo flanger\nadelL linseg 0, p3*.5, 0.02, p3*.5, 0    ;max delay time =20ms\nadelR linseg 0.02, p3*.5, 0, p3*.5, 0.02 ;max delay time =20ms          \nasigL flanger asigl, adelL, .6\nasigR flanger asigr, adelR, .6\n      outs asigL*imvol, asigR*imvol\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 60 100 ;play one note of instr 1\ni 2 2 2 60 100 ;play another note of instr 2 and...\ni 98 0 60      ;play virtual keyboard for 60 sec.\ni 99 0 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>The output should include lines like these:</p> <pre><code>chnl 1 using instr 1\nchnl 2 using instr 2\n\nSoundFont:   1  Bank:   0  Preset:   0  Harpsichord I-8\nSoundFont:   1  Bank:   0  Preset:  70  Ethan Bassoon mono\n</code></pre>"},{"location":"opcodes/fluidOut/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidOut/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p> <p>New in Csound5.00</p>"},{"location":"opcodes/fluidProgramSelect/","title":"fluidProgramSelect","text":""},{"location":"opcodes/fluidProgramSelect/#fluidprogramselect","title":"fluidProgramSelect","text":"<p>Assigns a preset from a SoundFont to a channel on a fluidEngine.</p>"},{"location":"opcodes/fluidProgramSelect/#syntax","title":"Syntax","text":"<pre><code>fluidProgramSelect ienginenum, ichannelnum, isfnum, ibanknum, ipresetnum\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/fluidProgramSelect/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine</p> <p>ichannelnum -- which channel number to use for the preset in the given fluidEngine</p> <p>isfnum -- number of the SoundFont from which the preset is assigned</p> <p>ibanknum -- number of the bank in the SoundFont from which the preset is assigned</p> <p>ipresetnum -- number of the preset to assign</p>"},{"location":"opcodes/fluidProgramSelect/#examples","title":"Examples","text":"<p>Here is an example of the fluidProgramSelect opcode. It uses the file fluidProgramSelect.csd.</p> Example of the fluidProgramSelect opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -+rtmidi=virtual  -M0    ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidProgramSelect.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"19Trumpet.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 56\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 60 100 ;play one note from score and...\ni 99 0 60      ;play virtual keyboard for 60 sec.\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another more complex example of the fluidsynth opcodes written by Istvan Varga. It uses the file fluidcomplex.csd.</p> Another more complex example of the fluidsynth opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;Anna.mid is a midi file, a song by The Beatles and can be found on the internet\n-odac -T -F  Anna.mid;;;realtime audio I/O and midifile in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fluidcomplex.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; Example by Istvan Varga\n\n; disable triggering of instruments by MIDI events\n\nichn = 1\nlp1:\n        massign   ichn, 0\n        loop_le   ichn, 1, 16, lp1\n        pgmassign 0, 0\n\n; initialize FluidSynth\n\ngifld   fluidEngine\ngisf2   fluidLoad \"sf_GMbank.sf2\", gifld, 1\n\n; k-rate version of fluidProgramSelect\n\nopcode fluidProgramSelect_k, 0, kkkkk\n  keng, kchn, ksf2, kbnk, kpre xin\n        igoto     skipInit\n  doInit:\n        fluidProgramSelect i(keng), i(kchn), i(ksf2), i(kbnk), i(kpre)\n        reinit    doInit\n        rireturn\n  skipInit:\nendop\n\ninstr 1\n  ; initialize channels\n  kchn  init 1\n  if (kchn == 1) then\nlp2:\n        fluidControl gifld, 192, kchn - 1, 0, 0\n        fluidControl gifld, 176, kchn - 1, 7, 100\n        fluidControl gifld, 176, kchn - 1, 10, 64\n        loop_le   kchn, 1, 16, lp2\n  endif\n\n  ; send any MIDI events received to FluidSynth\nnxt:\n  kst, kch, kd1, kd2 midiin\n  if (kst != 0) then\n    if (kst != 192) then\n        fluidControl gifld, kst, kch - 1, kd1, kd2\n    else\n        fluidProgramSelect_k gifld, kch - 1, gisf2, 0, kd1\n    endif\n      kgoto nxt\n  endif\n\n; get audio output from FluidSynth\n  ivol   init 3 ;a bit louder\n  aL, aR fluidOut gifld\n         outs     aL*ivol, aR*ivol\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3600\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fluidProgramSelect/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidProgramSelect/#credits","title":"Credits","text":"<p>Michael Gogins (gogins at pipeline dot com), Steven Yi. Thanks to Peter Hanappe for Fluidsynth.</p>"},{"location":"opcodes/fluidSetInterpMethod/","title":"fluidSetInterpMethod","text":""},{"location":"opcodes/fluidSetInterpMethod/#fluidsetinterpmethod","title":"fluidSetInterpMethod","text":"<p>Set interpolation method for channel in Fluid Engine.</p>"},{"location":"opcodes/fluidSetInterpMethod/#syntax","title":"Syntax","text":"<pre><code>fluidSetInterpMethod ienginenum, ichannelnum, iInterpMethod\n</code></pre> <p>Plugin opcode in fluidOpcodes. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>Lower order interpolation methods will render faster at lower fidelity while higher order interpolation methods will render slower at higher fidelity. Default interpolation for a channel is 4th order interpolation.</p>"},{"location":"opcodes/fluidSetInterpMethod/#initialization","title":"Initialization","text":"<p>ienginenum -- engine number assigned from fluidEngine</p> <p>ichannelnum -- which channel number to use for the preset in the given fluidEngine</p> <p>iInterpMethod -- interpolation method, can be any of the following</p> <ul> <li>0 -- No Interpolation</li> <li>1 -- Linear Interpolation</li> <li>4 -- 4th Order Interpolation (Default)</li> <li>7 -- 7th Order Interpolation (Highest)</li> </ul>"},{"location":"opcodes/fluidSetInterpMethod/#examples","title":"Examples","text":"<p>Here is an example of the fluidSetInterpMethod opcode. It uses the file fluidSetInterpMethod.csd and 07AcousticGuitar.sf2.</p> Example of the fluidSetInterpMethod opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o fluidSetInterpMethod.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"07AcousticGuitar.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 0\n\ninstr 1\n\n        mididefault   60, p3\n        midinoteonkey p4, p5\nikey    init p4\nivel    init p5\niInterpMethod = p6\nfluidSetInterpMethod giengine, 1, iInterpMethod\n        fluidNote giengine, 1, ikey, ivel\n\nendin\n\ninstr 99\n\nimvol  init 7\nasigl, asigr fluidOut giengine\n       outs asigl*imvol, asigr*imvol\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;hear the difference\ni 1 0 2 60 120 0 ;no interpolation\ni 1 3 2 72 120 0\ni 1 6 2 60 120 7 ;7th order interpolation\ni 1 9 2 72 120 7\n\ni 99 0 12    \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fluidSetInterpMethod/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/fluidSetInterpMethod/#credits","title":"Credits","text":"<p>Author: Steven Yi</p> <p>New in version 5.07</p>"},{"location":"opcodes/fmanal/","title":"Fmanal","text":""},{"location":"opcodes/fmanal/#fmanal","title":"fmanal","text":"<p>AM/FM analysis from quadrature signal.</p> <p>This opcode attempts to extract the AM and FM signals off a quadrature signal (e.g. from a Hilbert transform).</p>"},{"location":"opcodes/fmanal/#syntax","title":"Syntax","text":"<pre><code>am, af fmanal are, aim\n</code></pre>"},{"location":"opcodes/fmanal/#performance","title":"Performance","text":"<p>are -- real (cosine-phase) input signal</p> <p>aim -- imaginary (sine-phase) input signal</p> <p>am -- amplitude modulation envelope</p> <p>af -- frequency modulation envelope</p> <p>fmanal takes a signal in quadrature (real, imag) and outputs the estimate AM and FM signals. The former is the modulus of each input sample pair (|re + jim|) and the latter the derivative of arg(re + jim). Each sample of the output is the estimated instantaneous amplitude and frequency of the input signal.</p>"},{"location":"opcodes/fmanal/#example","title":"Example","text":"<p>Here is an example of the fmanal opcode. It uses the file fmanal.csd.</p> Example of the fmanal opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 64\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nasig oscili p4, p5\na1,a2 hilbert2 asig,1024,256\nam,afm fmanal a1,a2\nktrig metro 2\nprintf \"AM=%.3f FM=%.1f\\n\",ktrig,k(am),k(afm)\n  outs a1, a2\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10 0.5 440\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmanal/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/fmanal/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017</p>"},{"location":"opcodes/fmax/","title":"Fmax","text":""},{"location":"opcodes/fmax/#fmax","title":"fmax","text":"<p>Returns the maximum of its two arguments.</p>"},{"location":"opcodes/fmax/#syntax","title":"Syntax","text":"<pre><code>ires[] fmax iarg1[], iarg2[]\nkres[] fmax karg1[], karg2[]\nires[] fmax iarg1[], iarg2\nkres[] fmax karg[], karg2\n</code></pre>"},{"location":"opcodes/fmax/#initialization","title":"Initialization","text":"<p>iarg[]1/2, iarg2 -- the operands.</p>"},{"location":"opcodes/fmax/#performance","title":"Performance","text":"<p>karg[]1/2, karg2 -- the operands</p>"},{"location":"opcodes/fmax/#examples","title":"Examples","text":"<p>Here is an example of the fmax opcode. It uses the file fmax.csd.</p> Example of the fmax opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg1[] fillarray 1,8,3\niArg2[] fillarray 4,5,6\niRes[] fmax iArg1,iArg2\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmax/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/fmax/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017</p>"},{"location":"opcodes/fmb3/","title":"Fmb3","text":""},{"location":"opcodes/fmb3/#fmb3","title":"fmb3","text":"<p>Uses FM synthesis to create a Hammond B3 organ sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmb3/#syntax","title":"Syntax","text":"<pre><code>ares fmb3 kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\\n          ifn4, ivfn]\n</code></pre>"},{"location":"opcodes/fmb3/#initialization","title":"Initialization","text":"<p>fmb3 takes 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. The last table should usually be a sine wave.  These all default to a sine wave table.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- sine wave</li> <li>ifn3 -- sine wave</li> <li>ifn4 -- sine wave</li> </ul>"},{"location":"opcodes/fmb3/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Total mod index</li> <li>kc2 -- Crossfade of two modulators</li> <li>Algorithm -- 4</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmb3/#examples","title":"Examples","text":"<p>Here is an example of the fmb3 opcode. It uses the file fmb3.csd.</p> Example of the fmb3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmb3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 220\nkc1 = p4\nkc2 = p5\nkvrate = 6\n\nkvdpth line 0, p3, p6\nasig   fmb3 .4, kfreq, kc1, kc2, kvdpth, kvrate\n       outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 32768 10 1\n\ni 1 0 2  5  5 0.1\ni 1 3 2 .5 .5 0.01\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmb3/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmb3/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fmbell/","title":"Fmbell","text":""},{"location":"opcodes/fmbell/#fmbell","title":"fmbell","text":"<p>Uses FM synthesis to create a tublar bell sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmbell/#syntax","title":"Syntax","text":"<pre><code>ares fmbell kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \\\n            ifn4, ivfn, isus]\n</code></pre>"},{"location":"opcodes/fmbell/#initialization","title":"Initialization","text":"<p>All these opcodes take 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. These all default to a siewave table.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- sine wave</li> <li>ifn3 -- sine wave</li> <li>ifn4 -- sine wave</li> </ul> <p>The optional argument isus controls how long the sound lasts, or how quickly it decays.  It defaults to 4.</p>"},{"location":"opcodes/fmbell/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Mod index 1</li> <li>kc2 -- Crossfade of two outputs</li> <li>Algorithm -- 5</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmbell/#examples","title":"Examples","text":"<p>Here is an example of the fmbell opcode. It uses the file fmbell.csd.</p> Example of the fmbell opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmbell.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = p4\nkfreq = 880\nkc1 = p5\nkc2 = p6\nkvdepth = 0.005\nkvrate = 6\n\nasig fmbell kamp, kfreq, kc1, kc2, kvdepth, kvrate\n     outs asig, asig\nendin\n\ninstr 2\n\nkamp = p4\nkfreq = 880\nkc1 = p5\nkc2 = p6\nkvdepth = 0.005\nkvrate = 6\n\nasig fmbell kamp, kfreq, kc1, kc2, kvdepth, kvrate, 1, 1, 1, 1, 1, p7\n     outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 32768 10 1\n\ni 1 0 3 .2  5 5 \ni 1 + 4 .3 .5 1\ns\ni 2 0 12 .2  5 5 16\ni 2 + 12 .3 .5 1 12\n\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmbell/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmbell/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p> <p>Optional argument new in 5.16</p> <p>More optional argument new in 6.0</p>"},{"location":"opcodes/fmin/","title":"Fmin","text":""},{"location":"opcodes/fmin/#fmin","title":"fmin","text":"<p>Returns the minimum of its two arguments.</p>"},{"location":"opcodes/fmin/#syntax","title":"Syntax","text":"<pre><code>ires[] fmin iarg1[], iarg2[]\nkres[] fmin karg1[], karg2[]\nires[] fmin iarg1[], iarg2\nkres[] fmin karg[], karg2\n</code></pre>"},{"location":"opcodes/fmin/#initialization","title":"Initialization","text":"<p>iarg[]1/2, iarg2 -- the operands.</p>"},{"location":"opcodes/fmin/#performance","title":"Performance","text":"<p>karg[]1/2, karg2 -- the operands</p>"},{"location":"opcodes/fmin/#examples","title":"Examples","text":"<p>Here is an example of the fmin opcode. It uses the file fmin.csd.</p> Example of the fmin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg1[] fillarray 1,8,3\niArg2[] fillarray 4,5,6\niRes[] fmin iArg1,iArg2\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmin/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/fmin/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017 </p>"},{"location":"opcodes/fmmetal/","title":"Fmmetal","text":""},{"location":"opcodes/fmmetal/#fmmetal","title":"fmmetal","text":"<p>Uses FM synthesis to create a \u201cHeavy Metal\u201d sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmmetal/#syntax","title":"Syntax","text":"<pre><code>ares fmmetal kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\\n             ifn4, ivfn\n</code></pre>"},{"location":"opcodes/fmmetal/#initialization","title":"Initialization","text":"<p>All these opcodes take 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. The last table should usually be a sine wave.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- twopeaks.aiff</li> <li>ifn3 -- twopeaks.aiff</li> <li>ifn4 -- sine wave</li> </ul> <p> Note</p> <p>The file \u201ctwopeaks.aiff\u201d is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p>"},{"location":"opcodes/fmmetal/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Total mod index</li> <li>kc2 -- Crossfade of two modulators</li> <li>Algorithm -- 3</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmmetal/#examples","title":"Examples","text":"<p>Here is an example of the fmmetal opcode. It uses the file fmmetal.csd, and twopeaks.aiff.</p> Example of the fmmetal opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmmetal.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 440\nkvdepth = 0\nkvrate = 0\nifn1 = 1\nifn2 = 2\nifn3 = 2\nifn4 = 1\nivfn = 1\nkc2  = p5\n\nkc1  line p4, p3, 1\nasig fmmetal .5, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 32768 10 1\n; the \"twopeaks.aiff\" audio file.\nf 2 0 256 1 \"twopeaks.aiff\" 0 0 0 \n\n\ni 1 0 4 6 5 \ni 1 5 4 .2 10 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmmetal/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmmetal/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fmod/","title":"Fmod","text":""},{"location":"opcodes/fmod/#fmod","title":"fmod","text":"<p>Computes the remainder of the division of its first argument by the second.</p>"},{"location":"opcodes/fmod/#syntax","title":"Syntax","text":"<pre><code>ires[] fmod iarg1[], iarg2[]\nkres[] fmod karg1[], karg2[]\nires[] fmod iarg1[], iarg2\nkres[] fmod karg[], karg2\n</code></pre>"},{"location":"opcodes/fmod/#initialization","title":"Initialization","text":"<p>iarg[]1/2, iarg2 -- the operands.</p>"},{"location":"opcodes/fmod/#performance","title":"Performance","text":"<p>karg[]1/2, karg2 -- the operands</p>"},{"location":"opcodes/fmod/#examples","title":"Examples","text":"<p>Here is an example of the fmod opcode. It uses the file fmod.csd.</p> Example of the fmod opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg1[] fillarray 10,8,22\niArg2[] fillarray 4,5,6\niRes[] fmod iArg1,iArg2\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmod/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/fmod/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017</p>"},{"location":"opcodes/fmpercfl/","title":"Fmpercfl","text":""},{"location":"opcodes/fmpercfl/#fmpercfl","title":"fmpercfl","text":"<p>Uses FM synthesis to create a percussive flute sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmpercfl/#syntax","title":"Syntax","text":"<pre><code>ares fmpercfl kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, \\\n              ifn3, ifn4, ivfn]\n</code></pre>"},{"location":"opcodes/fmpercfl/#initialization","title":"Initialization","text":"<p>All these opcodes take 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. These all default to a sine wave table.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- sine wave</li> <li>ifn3 -- sine wave</li> <li>ifn4 -- sine wave</li> </ul>"},{"location":"opcodes/fmpercfl/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Total mod index</li> <li>kc2 -- Crossfade of two modulators</li> <li>Algorithm -- 4</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmpercfl/#examples","title":"Examples","text":"<p>Here is an example of the fmpercfl opcode. It uses the file fmpercfl.csd.</p> Example of the fmpercfl opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmpercfl.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 220\nkc1 = 5\nkvdepth = .01\nkvrate = 6\n\nkc2  line 5, p3, p4\nasig fmpercfl .5, kfreq, kc1, kc2, kvdepth, kvrate\n     outs asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 32768 10 1\n\ni 1 0 4 5\ni 1 5 8 .1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmpercfl/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmpercfl/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fmrhode/","title":"Fmrhode","text":""},{"location":"opcodes/fmrhode/#fmrhode","title":"fmrhode","text":"<p>Uses FM synthesis to create a Fender Rhodes electric piano sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmrhode/#syntax","title":"Syntax","text":"<pre><code>ares fmrhode kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, \\\n             ifn3, ifn4, ivfn\n</code></pre>"},{"location":"opcodes/fmrhode/#initialization","title":"Initialization","text":"<p>All these opcodes take 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. The last table should usually be a sine wave.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- sine wave</li> <li>ifn3 -- sine wave</li> <li>ifn4 -- fwavblnk.aiff</li> </ul> <p> Note</p> <p>The file \u201cfwavblnk.aiff\u201d is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p>"},{"location":"opcodes/fmrhode/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Mod index 1</li> <li>kc2 -- Crossfade of two outputs</li> <li>Algorithm -- 5</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmrhode/#examples","title":"Examples","text":"<p>Here is an example of the fmrhode opcode. It uses the file fmrhode.csd, and fwavblnk.aiff.</p> Example of the fmrhode opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmrhode.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 220\nkc1 = p4\nkc2 = p5\nkvdepth = 0.01\nkvrate = 3\nifn1 = 1\nifn2 = 1\nifn3 = 1\nifn4 = 2\nivfn = 1\n\nasig fmrhode .5, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;  sine wave.\nf 1 0 32768 10 1\n; audio file.\nf 2 0 256 1 \"fwavblnk.aiff\" 0 0 0\n\ni 1 0 3 6 0\ni 1 + . 6 3\ni 1 + . 20 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmrhode/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmrhode/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fmvoice/","title":"Fmvoice","text":""},{"location":"opcodes/fmvoice/#fmvoice","title":"fmvoice","text":"<p>FM Singing Voice Synthesis</p>"},{"location":"opcodes/fmvoice/#syntax","title":"Syntax","text":"<pre><code>ares fmvoice kamp, kfreq, kvowel, ktilt, kvibamt, kvibrate[, ifn1, \\\n             ifn2, ifn3, ifn4, ivibfn]\n</code></pre>"},{"location":"opcodes/fmvoice/#initialization","title":"Initialization","text":"<p>ifn1, ifn2, ifn3,ifn3, ivibfn -- Tables, usually of sinewaves.  The last is for vibrato</p>"},{"location":"opcodes/fmvoice/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kvowel -- the vowel being sung, in the range 0-64</p> <p>ktilt -- the spectral tilt of the sound in the range 0 to 99</p> <p>kvibamt -- Depth of vibrato</p> <p>kvibrate -- Rate of vibrato</p>"},{"location":"opcodes/fmvoice/#examples","title":"Examples","text":"<p>Here is an example of the fmvoice opcode. It uses the file fmvoice.csd.</p> Example of the fmvoice opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmvoice.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 110\nkvowel = p4     ; p4 = vowel (0 - 64)\nktilt  = p5\nkvibamt = 0.005\nkvibrate = 6\n\nasig fmvoice .5, kfreq, kvowel, ktilt, kvibamt, kvibrate\nouts asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;  sine wave.\nf 1 0 16384 10 1\n\ni 1 0 1 1  0    ; tilt=0\ni 1 1 1 &gt;  .\ni 1 2 1 &gt;  .\ni 1 3 1 &gt;  .\ni 1 4 1 &gt;  .\ni 1 5 1 &gt;  .\ni 1 6 1 &gt;  .\ni 1 7 1 12 .\n\ni 1 10 1 1  90  ; tilt=90\ni 1 11 1 &gt;  .\ni 1 12 1 &gt;  .\ni 1 13 1 &gt;  .\ni 1 14 1 &gt;  .\ni 1 15 1 &gt;  .\ni 1 16 1 &gt;  .\ni 1 17 1 12 .\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmvoice/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmvoice/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fmwurlie/","title":"Fmwurlie","text":""},{"location":"opcodes/fmwurlie/#fmwurlie","title":"fmwurlie","text":"<p>Uses FM synthesis to create a Wurlitzer electric piano sound.</p> <p>It comes from a family of FM sounds, all using 4 basic oscillators and various architectures, as used in the TX81Z synthesizer.</p>"},{"location":"opcodes/fmwurlie/#syntax","title":"Syntax","text":"<pre><code>ares fmwurlie kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \\\n              ifn4, ivfn\n</code></pre>"},{"location":"opcodes/fmwurlie/#initialization","title":"Initialization","text":"<p>All these opcodes take 5 tables for initialization. The first 4 are the basic inputs and the last is the low frequency oscillator (LFO) used for vibrato. The last table should usually be a sine wave.</p> <p>The initial waves should be:</p> <ul> <li>ifn1 -- sine wave</li> <li>ifn2 -- sine wave</li> <li>ifn3 -- sine wave</li> <li>ifn4 -- fwavblnk.aiff</li> </ul> <p> Note</p> <p>The file \u201cfwavblnk.aiff\u201d is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p>"},{"location":"opcodes/fmwurlie/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kc1, kc2 -- Controls for the synthesizer:</p> <ul> <li>kc1 -- Mod index 1</li> <li>kc2 -- Crossfade of two outputs</li> <li>Algorithm -- 5</li> </ul> <p>kvdepth -- Vibrator depth</p> <p>kvrate -- Vibrator rate</p>"},{"location":"opcodes/fmwurlie/#examples","title":"Examples","text":"<p>Here is an example of the fmwurlie opcode. It uses the file fmwurlie.csd, and fwavblnk.aiff.</p> Example of the fmwurlie opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fmwurlie.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 440\nkc1 = p4\nkc2 = 1\nkvdepth = 0.05\nkvrate = 6\nifn1 = 1\nifn2 = 1\nifn3 = 1\nifn4 = 2\nivfn = 1\n\nasig fmwurlie .5, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, ifn4, ivfn\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 32768 10 1\n; audio file\nf 2 0 256 1 \"fwavblnk.aiff\" 0 0 0\n\ni 1 0 3 6\ni 1 + 3 30\ni 1 + 2 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fmwurlie/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fmwurlie/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/fof/","title":"Fof","text":""},{"location":"opcodes/fof/#fof","title":"fof","text":"<p>Produces sinusoid bursts useful for formant and granular synthesis.</p> <p>Audio output is a succession of sinusoid bursts initiated at frequency xfund with a spectral peak at xform. For xfund above 25 Hz these bursts produce a speech-like formant with spectral characteristics determined by the k-input parameters. For lower fundamentals this generator provides a special form of granular synthesis.</p>"},{"location":"opcodes/fof/#syntax","title":"Syntax","text":"<pre><code>ares fof xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\\n         ifna, ifnb, itotdur [, iphs] [, ifmode] [, iskip]\n</code></pre>"},{"location":"opcodes/fof/#initialization","title":"Initialization","text":"<p>iolaps -- number of preallocated spaces needed to hold overlapping burst data. Overlaps are frequency dependent, and the space required depends on the maximum value of xfund * kdur. Can be over-estimated at no computation cost. Uses less than 50 bytes of memory per iolap.</p> <p>ifna, ifnb -- table numbers of two stored functions. The first is a sine table for sineburst synthesis (size of at least 4096 recommended). The second is a rise shape, used forwards and backwards to shape the sineburst rise and decay; this may be linear (GEN07) or perhaps a sigmoid (GEN19).</p> <p>itotdur -- total time during which this fof will be active. Normally set to p3. No new sineburst is created if it cannot complete its kdur within the remaining itotdur.</p> <p>iphs (optional, default=0) -- initial phase of the fundamental, expressed as a fraction of a cycle (0 to 1). The default value is 0.</p> <p>ifmode (optional, default=0) -- formant frequency mode. If zero, each sineburst keeps the xform frequency it was launched with. If non-zero, each is influenced by xform continuously. The default value is 0.</p> <p>iskip (optional, default=0) -- If non-zero, skip initialisation (allows legato use).</p>"},{"location":"opcodes/fof/#performance","title":"Performance","text":"<p>xamp -- peak amplitude of each sineburst, observed at the true end of its rise pattern. The rise may exceed this value given a large bandwidth (say, Q &lt; 10) and/or when the bursts are overlapping.</p> <p>xfund -- the fundamental frequency (in Hertz) of the impulses that create new sinebursts.</p> <p>xform -- the formant frequency, i.e. freq of the sinusoid burst induced by each xfund impulse. This frequency can be fixed for each burst or can vary continuously (see ifmode).</p> <p>koct -- octaviation index, normally zero. If greater than zero, lowers the effective xfund frequency by attenuating odd-numbered sinebursts. Whole numbers are full octaves, fractions transitional.</p> <p>kband -- the formant bandwidth (at -6dB), expressed in Hz. The bandwidth determines the rate of exponential decay throughout the sineburst, before the enveloping described below is applied.</p> <p>kris, kdur, kdec -- rise, overall duration, and decay times (in seconds) of the sinusoid burst. These values apply an enveloped duration to each burst, in similar fashion to a Csound linen generator but with rise and decay shapes derived from the ifnb input. kris inversely determines the skirtwidth (at -40 dB) of the induced formant region. kdur affects the density of sineburst overlaps, and thus the speed of computation. Typical values for vocal imitation are .003,.02,.007.</p> <p>Csound's fof generator is loosely based on Michael Clarke's C-coding of IRCAM's CHANT program (Xavier Rodet et al.). Each fof produces a single formant, and the output of four or more of these can be summed to produce a rich vocal imitation. fof synthesis is a special form of granular synthesis, and this implementation aids transformation between vocal imitation and granular textures. Computation speed depends on kdur, xfund, and the density of any overlaps.</p>"},{"location":"opcodes/fof/#examples","title":"Examples","text":"<p>Here is an example of the fof opcode. It uses the file fof.csd.</p> Example of the fof opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fof.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n\ninstr 1\n  ; Combine five formants together to create \n  ; a transformation from an alto-\"a\" sound\n  ; to an alto-\"i\" sound.\n  ; Values common to all of the formants.\n  kfund init 261.659\n  koct init 0\n  kris init 0.003\n  kdur init 0.02\n  kdec init 0.007\n  iolaps = 100\n  ifna = 1\n  ifnb = 2\n  itotdur = p3\n\n  ; First formant.\n  k1amp = ampdb(0)\n  k1form line 800, p3, 350\n  k1band line 80, p3, 50\n\n  ; Second formant.\n  k2amp line ampdb(-4), p3, ampdb(-20)\n  k2form line 1150, p3, 1700\n  k2band line 90, p3, 100\n\n  ; Third formant.\n  k3amp line ampdb(-20), p3, ampdb(-30)\n  k3form line 2800, p3, 2700\n  k3band init 120\n\n  ; Fourth formant.\n  k4amp init ampdb(-36)\n  k4form line 3500, p3, 3700\n  k4band line 130, p3, 150\n\n  ; Fifth formant.\n  k5amp init ampdb(-60)\n  k5form init 4950\n  k5band line 140, p3, 200\n\n  a1 fof k1amp, kfund, k1form, koct, k1band, kris, \\\n         kdur, kdec, iolaps, ifna, ifnb, itotdur\n  a2 fof k2amp, kfund, k2form, koct, k2band, kris, \\\n         kdur, kdec, iolaps, ifna, ifnb, itotdur\n  a3 fof k3amp, kfund, k3form, koct, k3band, kris, \\\n         kdur, kdec, iolaps, ifna, ifnb, itotdur\n  a4 fof k4amp, kfund, k4form, koct, k4band, kris, \\\n         kdur, kdec, iolaps, ifna, ifnb, itotdur\n  a5 fof k5amp, kfund, k5form, koct, k5band, kris, \\\n         kdur, kdec, iolaps, ifna, ifnb, itotdur\n\n  ; Combine all of the formants together\nasig sum (a1+a2+a3+a4+a5) * 13000\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 4096 10 1\n; sigmoid wave\nf 2 0 1024 19 0.5 0.5 270 0.5\n\ni 1 0 1\ni 1 2 5 ; same but slower\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The formant values for the alto-\"a\" sound were taken from the Formant Values Appendix.</p> <p>Two musical examples featuring the fof opcode: TheElectricPriest_Enhus.csd by Tobias Enhus, and BuzzFof_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/fof/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/fof/#credits","title":"Credits","text":"<p>Added in version 1 (1990)</p>"},{"location":"opcodes/fof2/","title":"Fof2","text":""},{"location":"opcodes/fof2/#fof2","title":"fof2","text":"<p>Produces sinusoid bursts including k-rate incremental indexing with each successive burst.</p> <p>Audio output is a succession of sinusoid bursts initiated at frequency xfund with a spectral peak at xform. For xfund above 25 Hz these bursts produce a speech-like formant with spectral characteristics determined by the k-input parameters. For lower fundamentals this generator provides a special form of granular synthesis.</p> <p>fof2 implements k-rate incremental indexing into ifna function with each successive burst.</p>"},{"location":"opcodes/fof2/#syntax","title":"Syntax","text":"<pre><code>ares fof2 xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \\\n          ifna, ifnb, itotdur, kphs, kgliss [, iskip]\n</code></pre>"},{"location":"opcodes/fof2/#initialization","title":"Initialization","text":"<p>iolaps -- number of preallocated spaces needed to hold overlapping burst data. Overlaps are frequency dependent, and the space required depends on the maximum value of xfund * kdur. Can be over-estimated at no computation cost. Uses less than 50 bytes of memory per iolap.</p> <p>ifna, ifnb -- table numbers of two stored functions. The first is a sine table for sineburst synthesis (size of at least 4096 recommended). The second is a rise shape, used forwards and backwards to shape the sineburst rise and decay; this may be linear (GEN07) or perhaps a sigmoid (GEN19).</p> <p>itotdur -- total time during which this fof will be active. Normally set to p3. No new sineburst is created if it cannot complete its kdur within the remaining itotdur.</p> <p>iskip (optional, default=0) -- If non-zero, skip initialization (allows legato use).</p>"},{"location":"opcodes/fof2/#performance","title":"Performance","text":"<p>xamp -- peak amplitude of each sineburst, observed at the true end of its rise pattern. The rise may exceed this value given a large bandwidth (say, Q &lt; 10) and/or when the bursts are overlapping.</p> <p>xfund -- the fundamental frequency (in Hertz) of the impulses that create new sinebursts.</p> <p>xform -- the formant frequency, i.e. freq of the sinusoid burst induced by each xfund impulse. This frequency can be fixed for each burst or can vary continuously.</p> <p>koct -- octaviation index, normally zero. If greater than zero, lowers the effective xfund frequency by attenuating odd-numbered sinebursts. Whole numbers are full octaves, fractions transitional.</p> <p>kband -- the formant bandwidth (at -6dB), expressed in Hz. The bandwidth determines the rate of exponential decay throughout the sineburst, before the enveloping described below is applied.</p> <p>kris, kdur, kdec -- rise, overall duration, and decay times (in seconds) of the sinusoid burst. These values apply an enveloped duration to each burst, in similar fashion to a Csound linen generator but with rise and decay shapes derived from the ifnb input. kris inversely determines the skirtwidth (at -40 dB) of the induced formant region. kdur affects the density of sineburst overlaps, and thus the speed of computation. Typical values for vocal imitation are .003,.02,.007.</p> <p>kphs -- allows k-rate indexing of function table ifna with each successive burst, making it suitable for time-warping applications. Values of kphs are normalized from 0 to 1, 1 being the end of the function table ifna.</p> <p>kgliss -- sets the end pitch of each grain relative to the initial pitch, in octaves. Thus kgliss = 2 means that the grain ends two octaves above its initial pitch, while kgliss = -3/4 has the grain ending a major sixth below. Each 1/12 added to kgliss raises the ending frequency one half-step.  If you want no glissando, set kgliss to 0.</p> <p>Csound's fof generator is loosely based on Michael Clarke's C-coding of IRCAM's CHANT program (Xavier Rodet et al.). Each fof produces a single formant, and the output of four or more of these can be summed to produce a rich vocal imitation. fof synthesis is a special form of granular synthesis, and this implementation aids transformation between vocal imitation and granular textures. Computation speed depends on kdur, xfund, and the density of any overlaps.</p> <p> Note</p> <p>The ending frequency of any grain is equal to kform * (2 ^ kgliss), so setting kgliss too high may result in aliasing.  For example, kform = 3000 and kgliss = 3 places the ending frequency over the Nyquist if sr = 44100.  It is a good idea to scale kgliss accordingly.</p>"},{"location":"opcodes/fof2/#examples","title":"Examples","text":"<p>Here is an example of the fof2 opcode. It uses the file fof2.csd.</p> Example of the fof2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o fof2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n\n;By Andres Cabrera 2007\n\n    instr 1            ;table-lookup vocal synthesis\n\nkris init p12\nkdur init p13\nkdec init p14\n\niolaps init p15\n\nifna init 1  ; Sine wave\nifnb init 2  ; Straight line rise shape\n\nitotdur init p3\n\nkphs init 0  ; No phase modulation (constant kphs)\n\n\nkfund line p4, p3, p5\nkform line p6, p3, p7\nkoct line p8, p3, p9\nkband line p10, p3, p11\nkgliss line p16, p3, p17\n\nkenv linen 5000, 0.03, p3, 0.03  ;to avoid clicking\n\n\naout    fof2    kenv, kfund, kform, koct, kband, kris, kdur, kdec, iolaps, \\\n      ifna, ifnb, itotdur, kphs, kgliss\n\n\n    outs    aout, aout\n    endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\nf2 0 4096 7 0 4096 1\n\n;              kfund1  kfund2  kform1  kform2  koct1  koct2  kband1 kband2 kris  kdur  kdec  iolaps  kgliss1 kgliss2\ni1    0    4    220     220      510     510       0      0      30   30   0.01  0.03  0.01   20       1        1\ni1    +    .    220     220      510     910       0      0      30   30   0.01  0.03  0.01   20       1        1\ni1    +    .    220     220      510     510       0      0     100   30   0.01  0.03  0.01   20       1        1\ni1    +    .    220     220      510     510       0      1      30   30   0.01  0.03  0.01   20       1        1\ni1    +    .    220     220      510     510       0      0      30   30   0.01  0.03  0.01   20       1        2\ni1    +    .    220     220      510     510       0      0      30   30   0.01  0.03  0.01   20       0.5      1\ni1    +    .    220     220      510     510       0      0      30   30   0.01  0.05  0.01   100      1        1\ni1    +    .    220     440      510     510       0      0      30   30   0.01  0.05  0.01   100      1        1\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the fof2 opcode, which generates vowel tones using formants generated by fof2 coinciding with values from the Formant Values appendix. It uses the file fof2-2.csd.</p> Example of the fof2 opcode to produce vowel sounds.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o fof2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n\n; Example by Chuckk Hubbard 2007\n\n    instr 1            ;table-lookup vocal synthesis\n\niolaps    =    120\nifna    =    1        ;f1 - sine wave\nifnb    =    2        ;f2 - linear rise shape\nitotdur    =    p3\niamp    =    p4 * 0dbfs\nifreq1    =    p5        ;starting frequency\nifreq2    =    p6        ;ending frequency\n\nkamp    linseg    0, .003, iamp, itotdur-.007, iamp, .003, 0, .001, 0\nkfund    expseg    ifreq1, itotdur, ifreq2\nkoct    init    0\nkris    init    .003\nkdur    init    .02\nkdec    init    .007\nkphs    init    0\nkgliss    init    0\n\niforma    =    p7        ;starting spectrum\niformb    =    p8        ;ending spectrum\n\niform1a    tab_i    0, iforma        ;read values of 5 formants for 1st spectrum\niform2a    tab_i    1, iforma\niform3a    tab_i    2, iforma\niform4a    tab_i    3, iforma\niform5a    tab_i    4, iforma\nidb1a    tab_i    5, iforma        ;read decibel levels for same 5 formants\nidb2a    tab_i    6, iforma\nidb3a    tab_i    7, iforma\nidb4a    tab_i    8, iforma\nidb5a    tab_i    9, iforma\niband1a    tab_i    10, iforma    ;read bandwidths for same 5 formants\niband2a    tab_i    11, iforma\niband3a    tab_i    12, iforma\niband4a    tab_i    13, iforma\niband5a    tab_i    14, iforma\niamp1a    =    ampdb(idb1a)    ;convert db to linear multipliers\niamp2a    =    ampdb(idb2a)\niamp3a    =    ampdb(idb3a)\niamp4a    =    ampdb(idb4a)\niamp5a    =    ampdb(idb5a)\n\niform1b    tab_i    0, iformb        ;values of 5 formants for 2nd spectrum\niform2b    tab_i    1, iformb\niform3b    tab_i    2, iformb\niform4b    tab_i    3, iformb\niform5b    tab_i    4, iformb\nidb1b    tab_i    5, iformb        ;decibel levels for 2nd set of formants\nidb2b    tab_i    6, iformb\nidb3b    tab_i    7, iformb\nidb4b    tab_i    8, iformb\nidb5b    tab_i    9, iformb\niband1b    tab_i    10, iformb    ;bandwidths for 2nd set of formants\niband2b    tab_i    11, iformb\niband3b    tab_i    12, iformb\niband4b    tab_i    13, iformb\niband5b    tab_i    14, iformb\niamp1b    =    ampdb(idb1b)    ;convert db to linear multipliers\niamp2b    =    ampdb(idb2b)\niamp3b    =    ampdb(idb3b)\niamp4b    =    ampdb(idb4b)\niamp5b    =    ampdb(idb5b)\n\nkform1    line    iform1a, itotdur, iform1b    ;transition between formants\nkform2    line    iform2a, itotdur, iform2b\nkform3    line    iform3a, itotdur, iform3b\nkform4    line    iform4a, itotdur, iform4b\nkform5    line    iform5a, itotdur, iform5b\nkband1    line    iband1a, itotdur, iband1b    ;transition of bandwidths\nkband2    line    iband2a, itotdur, iband2b\nkband3    line    iband3a, itotdur, iband3b\nkband4    line    iband4a, itotdur, iband4b\nkband5    line    iband5a, itotdur, iband5b\nkamp1    line    iamp1a, itotdur, iamp1b    ;transition of amplitudes of formants\nkamp2    line    iamp2a, itotdur, iamp2b\nkamp3    line    iamp3a, itotdur, iamp3b\nkamp4    line    iamp4a, itotdur, iamp4b\nkamp5    line    iamp5a, itotdur, iamp5b\n\n;5 formants for each spectrum\na1    fof2    kamp1, kfund, kform1, koct, kband1, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss\na2    fof2    kamp2, kfund, kform2, koct, kband2, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss\na3    fof2    kamp3, kfund, kform3, koct, kband3, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss\na4    fof2    kamp4, kfund, kform4, koct, kband4, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss\na5    fof2    kamp5, kfund, kform5, koct, kband5, kris, kdur, kdec, iolaps, ifna, ifnb, itotdur, kphs, kgliss\n\naout    =    (a1+a2+a3+a4+a5) * kamp/5    ;sum and scale\n\naenv linen 1, 0.05, p3, 0.05  ;to avoid clicking\n\n    outs    aout*aenv, aout*aenv\n    endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\nf2 0 4096 7 0 4096 1\n\n;****************************************************************\n; tables of formant values adapted from MiscFormants.html\n; 100's: soprano  200's: alto  300's: countertenor  400's: tenor  500's: bass\n; -01: \"a\" sound  -02: \"e\" sound  -03: \"i\" sound  -04: \"o\" sound  -05: \"u\" sound\n; p-5 through p-9: frequencies of 5 formants\n; p-10 through p-14: decibel levels of 5 formants\n; p-15 through p-19: bandwidths of 5 formants\n\n;              formant frequencies       decibel levels         bandwidths\n;soprano\nf101 0 16 -2 800 1150 2900 3900 4950  0.001  -6 -32 -20 -50  80  90 120 130 140\nf102 0 16 -2 350 2000 2800 3600 4950  0.001 -20 -15 -40 -56  60 100 120 150 200\nf103 0 16 -2 270 2140 2950 3900 4950  0.001 -12 -26 -26 -44  60  90 100 120 120\nf104 0 16 -2 450  800 2830 3800 4950  0.001 -11 -22 -22 -50  40  80 100 120 120\nf105 0 16 -2 325  700 2700 3800 4950  0.001 -16 -35 -40 -60  50  60 170 180 200\n;alto\nf201 0 16 -2 800 1150 2800 3500 4950  0.001  -4 -20 -36 -60  80  90 120 130 140\nf202 0 16 -2 400 1600 2700 3300 4950  0.001 -24 -30 -35 -60  60  80 120 150 200\nf203 0 16 -2 350 1700 2700 3700 4950  0.001 -20 -30 -36 -60  50 100 120 150 200\nf204 0 16 -2 450  800 2830 3500 4950  0.001  -9 -16 -28 -55  70  80 100 130 135\nf205 0 16 -2 325  700 2530 3500 4950  0.001 -12 -30 -40 -64  50  60 170 180 200\n;countertenor\nf301 0 16 -2 660 1120 2750 3000 3350  0.001  -6 -23 -24 -38  80  90 120 130 140\nf302 0 16 -2 440 1800 2700 3000 3300  0.001 -14 -18 -20 -20  70  80 100 120 120\nf303 0 16 -2 270 1850 2900 3350 3590  0.001 -24 -24 -36 -36  40  90 100 120 120\nf304 0 16 -2 430  820 2700 3000 3300  0.001 -10 -26 -22 -34  40  80 100 120 120\nf305 0 16 -2 370  630 2750 3000 3400  0.001 -20 -23 -30 -34  40  60 100 120 120\n;tenor\nf401 0 16 -2 650 1080 2650 2900 3250  0.001  -6  -7  -8 -22  80  90 120 130 140\nf402 0 16 -2 400 1700 2600 3200 3580  0.001 -14 -12 -14 -20  70  80 100 120 120\nf403 0 16 -2 290 1870 2800 3250 3540  0.001 -15 -18 -20 -30  40  90 100 120 120\nf404 0 16 -2 400  800 2600 2800 3000  0.001 -10 -12 -12 -26  70  80 100 130 135\nf405 0 16 -2 350  600 2700 2900 3300  0.001 -20 -17 -14 -26  40  60 100 120 120\n;bass\nf501 0 16 -2 600 1040 2250 2450 2750  0.001  -7  -9  -9 -20  60  70 110 120 130\nf502 0 16 -2 400 1620 2400 2800 3100  0.001 -12  -9 -12 -18  40  80 100 120 120\nf503 0 16 -2 250 1750 2600 3050 3340  0.001 -30 -16 -22 -28  60  90 100 120 120\nf504 0 16 -2 400  750 2400 2600 2900  0.001 -11 -21 -20 -40  40  80 100 120 120\nf505 0 16 -2 350  600 2400 2675 2950  0.001 -20 -32 -28 -36  40  80 100 120 120\n;****************************************************************\n\n;    start dur  amp    start freq    end freq    start formant   end formant\ni1    0    1    .8        440         412.5          201           203\ni1    +    .    .8        412.5       550            201           204\ni1    +    .    .8        495         330            202           205\n\ni1    +    .    .8        110         103.125        501           503\ni1    +    .    .8        103.125     137.5          501           504\ni1    +    .    .8        123.75       82.5          502           505\n\ni1    7    .    .4        440         412.5          201           203\ni1    8    .    .4        412.5       550            201           204\ni1    9    .    .4        495         330            202           205\ni1    7    .    .4        110         103.125        501           503\ni1    8    .    .4        103.125     137.5          501           504\ni1    9    .    .4        123.75       82.5          502           505\ni1    +    .    .4        440         412.5          101           103\ni1    +    .    .4        412.5       550            101           104\ni1    +    .    .4        495         330           102            105\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fof2/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/fof2/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman fof2 is a modification of fof by Rasmus Ekman</p> <p>New in Csound 3.45</p>"},{"location":"opcodes/fofilter/","title":"Fofilter","text":""},{"location":"opcodes/fofilter/#fofilter","title":"fofilter","text":"<p>Formant filter.</p> <p>Fofilter generates a stream of overlapping sinewave grains, when fed with a pulse train. Each grain is the impulse response of a combination of two BP filters. The grains are defined by their attack time (determining the skirtwidth of the formant region at -60dB) and decay time (-6dB bandwidth). Overlapping will occur when 1/freq &lt; decay, but, unlike FOF, there is no upper limit on the number of overlaps. The original idea for this opcode came from J McCartney's formlet class in SuperCollider, but this is possibly implemented differently(?).</p>"},{"location":"opcodes/fofilter/#syntax","title":"Syntax","text":"<pre><code>asig fofilter ain, xcf, xris, xdec[, istor]\n</code></pre>"},{"location":"opcodes/fofilter/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/fofilter/#performance","title":"Performance","text":"<p>asig -- input signal.</p> <p>xcf -- filter centre frequency</p> <p>xris -- impulse response attack time (secs).</p> <p>xdec -- impulse response decay time (secs).</p>"},{"location":"opcodes/fofilter/#examples","title":"Examples","text":"<p>Here is an example of the fofilter opcode. It uses the file fofilter.csd.</p> Example of the fofilter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fofilter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfe  expseg 10, p3*0.9, 180, p3*0.1, 175\nkenv linen .1, 0.05, p3, 0.05\nasig buzz  kenv, kfe, sr/(2*kfe), 1\nafil fofilter asig, 900, 0.007, 0.04\n     outs  afil, afil \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fofilter/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/fofilter/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini January 2005</p> <p>New plugin in version 5</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/fog/","title":"Fog","text":""},{"location":"opcodes/fog/#fog","title":"fog","text":"<p>Audio output is a succession of grains derived from data in a stored function table</p> <p>The local envelope of these grains and their timing is based on the model of fof synthesis and permits detailed control of the granular synthesis.</p>"},{"location":"opcodes/fog/#syntax","title":"Syntax","text":"<pre><code>ares fog xamp, xdens, xtrans, aspd, koct, kband, kris, kdur, kdec, \\\n         iolaps, ifna, ifnb, itotdur [, iphs] [, itmode] [, iskip]\n</code></pre>"},{"location":"opcodes/fog/#initialization","title":"Initialization","text":"<p>iolaps -- number of pre-located spaces needed to hold overlapping grain data. Overlaps are density dependent, and the space required depends on the maximum value of xdens * kdur. Can be over-estimated at no computation cost. Uses less than 50 bytes of memory per iolap.</p> <p>ifna, ifnb -- table numbers of two stored functions. The first is the data used for granulation, usually from a soundfile (GEN01). The second is a rise shape, used forwards and backwards to shape the grain rise and decay; this is normally a sigmoid (GEN19) but may be linear (GEN05).</p> <p>itotdur -- total time during which this fog will be active. Normally set to p3. No new grain is created if it cannot complete its kdur within the remaining itotdur.</p> <p>iphs (optional) -- initial phase of the fundamental, expressed as a fraction of a cycle (0 to 1). The default value is 0.</p> <p>itmode (optional) -- transposition mode. If zero, each grain keeps the xtrans value it was launched with. If non-zero, each is influenced by xtrans continuously. The default value is 0.</p> <p>iskip (optional, default=0) -- If non-zero, skip initialization (allows legato use).</p>"},{"location":"opcodes/fog/#performance","title":"Performance","text":"<p>xamp -- amplitude factor. Amplitude is also dependent on the number of overlapping grains, the interaction of the rise shape (ifnb) and the exponential decay (kband), and the scaling of the grain waveform (ifna). The actual amplitude may therefore exceed xamp.</p> <p>xdens -- density. The frequency of grains per second.</p> <p>xtrans -- transposition factor. The rate at which data from the stored function table ifna is read within each grain. This has the effect of transposing the original material. A value of 1 produces the original pitch. Higher values transpose upwards, lower values downwards. Negative values result in the function table being read backwards.</p> <p>aspd -- Starting index pointer. aspd is the normalized index (0 to 1) to table ifna that determines the movement of a pointer used as the starting point for reading data within each grain. (xtrans determines the rate at which data is read starting from this pointer.)</p> <p>koct -- octaviation index. The operation of this parameter is identical to that in fof.</p> <p>kband, kris, kdur, kdec -- grain envelope shape. These parameters determine the exponential decay (kband), and the rise (kris), overall duration (kdur,) and decay (kdec ) times of the grain envelope. Their operation is identical to that of the local envelope parameters in fof.</p>"},{"location":"opcodes/fog/#examples","title":"Examples","text":"<p>Here is an example of the fog opcode. It uses the file fog.csd.</p> Example of the fog opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fog.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n;p4 = transposition factor\n;p5 = speed factor\n;p6 = function table for grain data\ni1    =  sr/ftlen(1)   ;scaling to reflect sample rate and table length\na1    phasor i1*p5     ;index for speed\nasigl fog    .5, 15, p4, a1, 1, 0, .01, .5, .01, 30, 1, 2, p3         ;left channel\nasigr fog    .4, 25, p4+.2, a1, 1, 0, .01, .5, .01, 30, 1, 2, p3, .5  ;right channel\n      outs   asigl, asigr\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 131072 1 \"fox.wav\" 0 0 0\nf 2 0 1024 19 .5 .5 270 .5\n\ni 1 0 10 .7  .1\ni 1 + 4  1.2  2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fog/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/fog/#credits","title":"Credits","text":"<p>Author: Michael Clark Huddersfield May 1997</p> <p>New in version 3.46</p> <p>The Csound fog generator is by Michael Clarke, extending his earlier work based on IRCAM's FOF algorithm.</p> <p>Added notes by Rasmus Ekman on September 2002.</p>"},{"location":"opcodes/fold/","title":"Fold","text":""},{"location":"opcodes/fold/#fold","title":"fold","text":"<p>Adds artificial foldover to an audio signal.</p>"},{"location":"opcodes/fold/#syntax","title":"Syntax","text":"<pre><code>ares fold asig, kincr\n</code></pre>"},{"location":"opcodes/fold/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>kincr -- amount of foldover expressed in multiple of sampling rate. Must be &gt;= 1</p> <p>fold is an opcode which creates artificial foldover.  For example, when kincr is equal to 1 with sr=44100, no foldover is added. When kincr is set to 2, the foldover is equivalent to a downsampling to 22050, when it is set to 4, to 11025 etc. Fractional values of kincr are possible, allowing a continuous variation of foldover amount. This can be used for a wide range of special effects.</p>"},{"location":"opcodes/fold/#examples","title":"Examples","text":"<p>Here is an example of the fold opcode. It uses the file fold.csd.</p> Example of the fold opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fold.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig  poscil3 .8, 400, 1 ;very clean sine\nkincr line p4, p3, p5\nasig  fold asig, kincr\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0  4 2  2 \ni 1 5  4 5  5 \ni 1 10 4 10 10 \ni 1 15 4 1 100  ; Vary the fold-over amount from 1 to 100\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fold/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/fold/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/follow/","title":"Follow","text":""},{"location":"opcodes/follow/#follow","title":"follow","text":"<p>Envelope follower unit generator.</p>"},{"location":"opcodes/follow/#syntax","title":"Syntax","text":"<pre><code>ares follow asig, idt\n</code></pre>"},{"location":"opcodes/follow/#initialization","title":"Initialization","text":"<p>idt -- This is the period, in seconds, that the average amplitude of asig is reported. If the frequency of asig is low then idt must be large (more than half the period of asig )</p>"},{"location":"opcodes/follow/#performance","title":"Performance","text":"<p>asig -- This is the signal from which to extract the envelope.</p>"},{"location":"opcodes/follow/#examples","title":"Examples","text":"<p>Here is an example of the follow opcode. It uses the file follow.csd, and drumsMlp.wav.</p> Example of the follow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o follow.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig soundin \"drumsMlp.wav\"\n     outs asig, asig\n\nendin\n\ninstr 2 ;envelope follower\n\nas   soundin \"drumsMlp.wav\"\nas   = as*.7            ;reduce volume a bit\nat   tone    as, 500    ;smooth estimated envelope\naf   follow  at, p4\nasin poscil3 .5, 440, 1\n; \"drumsMlp.wav\" provides amplitude for poscil\nasig balance asin, af\n     outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 32768 10 1\n\ni 1 0 2\ni 2 2 2 0.001 ;follow quickly\ni 2 5 3 0.2   ;follow slowly\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>To avoid zipper noise, by discontinuities produced from complex envelope tracking, a lowpass filter could be used, to smooth the estimated envelope.</p>"},{"location":"opcodes/follow/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/follow/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/follow2/","title":"Follow2","text":""},{"location":"opcodes/follow2/#follow2","title":"follow2","text":"<p>Another controllable envelope extractor using the algorithm attributed to Jean-Marc Jot.</p>"},{"location":"opcodes/follow2/#syntax","title":"Syntax","text":"<pre><code>ares follow2 asig, katt, krel\n</code></pre>"},{"location":"opcodes/follow2/#performance","title":"Performance","text":"<p>asig -- the input signal whose envelope is followed</p> <p>katt -- the attack rate (60dB attack time in seconds)</p> <p>krel -- the decay rate (60dB decay time in seconds)</p> <p>The output tracks the amplitude envelope of the input signal. The rate at which the output grows to follow the signal is controlled by the katt, and the rate at which it decreases in response to a lower amplitude, is controlled by the krel. This gives a smoother envelope than follow.</p>"},{"location":"opcodes/follow2/#examples","title":"Examples","text":"<p>Here is an example of the follow2 opcode. It uses the file follow2.csd, and drumsMlp.wav.</p> Example of the follow2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o follow2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig soundin \"drumsMlp.wav\"\n     outs asig, asig\nendin\n\ninstr 2 ;using follow2\n\nas soundin \"drumsMlp.wav\"\naf follow2 as, p4, p5\nar rand 44100   ;noise\n; \"drumsMlp.wav\" provides amplitude for noise\nasig balance ar, af\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2 0.001 0.01 ;quick attack &amp; deacy\ni 2 5 2  0.1   0.5  ;slow attack &amp; deacy        \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/follow2/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/follow2/#credits","title":"Credits","text":"<p>Author: John ffitch The algorithm for the follow2 is attributed to Jean-Marc Jot. University of Bath, Codemist Ltd. Bath, UK February 2000</p> <p>New in Csound version 4.03</p> <p>Added notes by Rasmus Ekman on September 2002.</p>"},{"location":"opcodes/foscil/","title":"Foscil","text":""},{"location":"opcodes/foscil/#foscil","title":"foscil","text":"<p>A basic frequency modulated oscillator.</p>"},{"location":"opcodes/foscil/#syntax","title":"Syntax","text":"<pre><code>ares foscil xamp, kcps, xcar, xmod, kndx [, ifn , iphs]\n</code></pre>"},{"location":"opcodes/foscil/#initialization","title":"Initialization","text":"<p>ifn (optional) -- function table number. Requires a wrap-around guard point.  Defaults to a sine wave.</p> <p>iphs (optional, default=0) -- initial phase of waveform in table ifn, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/foscil/#performance","title":"Performance","text":"<p>xamp -- the amplitude of the output signal.</p> <p>kcps -- a common denominator, in cycles per second, for the carrier and modulating frequencies.</p> <p>xcar -- a factor that, when multiplied by the kcps parameter, gives the carrier frequency.</p> <p>xmod -- a factor that, when multiplied by the kcps parameter, gives the modulating frequency.</p> <p>kndx -- the modulation index.</p> <p>foscil is a composite unit that effectively banks two oscil opcodes in the familiar Chowning FM setup, wherein the audio-rate output of one generator is used to modulate the frequency input of another (the \u201ccarrier\u201d). Effective carrier frequency = kcps * xcar, and modulating frequency = kcps * xmod. For integral values of xcar and xmod, the perceived fundamental will be the minimum positive value of kcps * (xcar - n * xmod), n = 0,1,2,... The input kndx is the index of modulation (usually time-varying and ranging 0 to 4 or so) which determines the spread of acoustic energy over the partial positions given by n = 0,1,2,.., etc. ifn should point to a stored sine wave. Previous to version 3.50, xcar and xmod could be k-rate only.</p> <p>The actual formula used for this implementation of FM synthesis is xamp * cos(2\u03c0 * t * kcps * xcar + kndx * sin(2\u03c0 * t * kcps * xmod) - \u03c0), assuming that the table is a sine wave.</p>"},{"location":"opcodes/foscil/#examples","title":"Examples","text":"<p>Here is an example of the foscil opcode. It uses the file foscil.csd.</p> Example of the foscil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o foscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps = 440\nkcar = 1\nkmod = p4\nkndx line 0, p3, 20    ;intensivy sidebands\n\nasig foscil .5, kcps, kcar, kmod, kndx, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine\nf 1 0 16384 10 1\n\ni 1 0  9 .01    ;vibrato\ni 1 10 .  1\ni 1 20 . 1.414  ;gong-ish\ni 1 30 5 2.05   ;with \"beat\"\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/foscil/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/foscili/","title":"Foscili","text":""},{"location":"opcodes/foscili/#foscili","title":"foscili","text":"<p>Basic frequency modulated oscillator with linear interpolation.</p>"},{"location":"opcodes/foscili/#syntax","title":"Syntax","text":"<pre><code>ares foscili xamp, kcps, xcar, xmod, kndx [, ifn, iphs]\n</code></pre>"},{"location":"opcodes/foscili/#initialization","title":"Initialization","text":"<p>ifn (optional) -- function table number. Requires a wrap-around guard point. Defaults to a sine wave.</p> <p>iphs (optional, default=0) -- initial phase of waveform in table ifn, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/foscili/#performance","title":"Performance","text":"<p>xamp -- the amplitude of the output signal.</p> <p>kcps -- a common denominator, in cycles per second, for the carrier and modulating frequencies.</p> <p>xcar -- a factor that, when multiplied by the kcps parameter, gives the carrier frequency.</p> <p>xmod -- a factor that, when multiplied by the kcps parameter, gives the modulating frequency.</p> <p>kndx -- the modulation index.</p> <p>foscili differs from foscil in that the standard procedure of using a truncated phase as a sampling index is here replaced by a process that interpolates between two successive lookups. Interpolating generators will produce a noticeably cleaner output signal, but they may take as much as twice as long to run. Adequate accuracy can also be gained without the time cost of interpolation by using large stored function tables of 2K, 4K or 8K points if the space is available.</p>"},{"location":"opcodes/foscili/#examples","title":"Examples","text":"<p>Here is an example of the foscili opcode. It uses the file foscili.csd.</p> Example of the foscili opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o foscili.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps = 440\nkcar = 1\nkmod = p4\nkndx line 0, p3, 20    ;intensivy sidebands\n\nasig foscili .5, kcps, kcar, kmod, kndx, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine\nf 1 0 16384 10 1\n\ni 1 0  9 .01    ;vibrato\ni 1 10 .  1\ni 1 20 . 1.414  ;gong-ish\ni 1 30 5 2.05   ;with \"beat\"\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/foscili/#see-also","title":"See Also","text":"<p>FM Synthesis</p> <p>More information about frequency modulation on Wikipedia: http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</p>"},{"location":"opcodes/fout/","title":"Fout","text":""},{"location":"opcodes/fout/#fout","title":"fout","text":"<p>Outputs a-rate signals to a specified file of an arbitrary number of channels.</p>"},{"location":"opcodes/fout/#syntax","title":"Syntax","text":"<pre><code>fout ifilename, iformat, aout1 [, aout2, aout3,...,aoutN]\nfout ifilename, iformat, array[]\n</code></pre>"},{"location":"opcodes/fout/#initialization","title":"Initialization","text":"<p>ifilename -- the output file's name (in double-quotes).</p> <p>iformat -- a flag to choose output file format (note: Csound versions older than 5.0 may only support formats 0, 1, and 2):</p> <ul> <li>-1 - format exactly as per global csound output format flags (-A, -W, --format=..., etc).</li> <li>0 - 32-bit floating point samples without header (binary PCM multichannel file)</li> <li>1 - 16-bit integers without header (binary PCM multichannel file)</li> <li>2 - 16-bit integers with a header. The header type depends on the render (-o) format. For example, if the user chooses the AIFF format (using the -A flag), the header format will be AIFF type.</li> <li>3 - u-law samples with a header (see iformat=2).</li> <li>4 - 16-bit integers with a header (see iformat=2).</li> <li>5 - 32-bit integers with a header (see iformat=2).</li> <li>6 - 32-bit floats with a header (see iformat=2).</li> <li>7 - 8-bit unsigned integers with a header (see iformat=2).</li> <li>8 - 24-bit integers with a header (see iformat=2).</li> <li>9 - 64-bit floats with a header (see iformat=2).</li> <li>50 - ogg-vorbis format.</li> </ul> <p>In addition, Csound versions 5.0 and later allow for explicitly selecting a particular header type by specifying the format as 10 * fileType + sampleFormat, where fileType may be 1 for WAV, 2 for AIFF, 3 for raw (headerless) files, and 4 for IRCAM; sampleFormat is one of the above values in the range 0 to 9, except sample format 0 is taken from the command line (-o), format 1 is 8-bit signed integers, and format 2 is a-law. So, for example, iformat=25 means 32-bit integers with AIFF header.</p>"},{"location":"opcodes/fout/#performance","title":"Performance","text":"<p>aout1,... aoutN -- signals to be written to the file. In the case of raw files, the expected range of audio signals is determined by the selected sample format; for sound files with a header like WAV and AIFF, the audio signals should be in the range -0dbfs to 0dbfs.</p> <p>fout (file output) writes samples of audio signals to a file with any number of channels. Channel number depends by the number of aoutN variables (i.e. a mono signal with only an a-rate argument, a stereo signal with two a-rate arguments etc.) Maximum number of channels is fixed to 64. Multiple fout opcodes can be present in the same instrument, referring to different files.</p> <p>Notice that, unlike out, outs and outq, fout does not zero the audio variable so you must zero it after calling it. If polyphony is to be used, you can use vincr and clear opcodes for this task.</p> <p>Notice that fout and foutk uses a string containing a file pathname. Whereas, with fouti and foutir, the target file can be only specified by means of a handle-number.</p> <p> Note</p> <p>If you are using fout to generate an audio file for the global output of csound, you might want to use the monitor opcode, which can tap the output buffer, to avoid having to route</p>"},{"location":"opcodes/fout/#examples","title":"Examples","text":"<p>Here is a simple example of the fout opcode. It uses the file fout.csd.</p> Example of the fout opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fout.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nasig poscil3 .5, 880, giSine\n;write a raw file: 32 bits with header\n     fout \"fout_880.wav\", 15, asig      \n     outs asig, asig\n\nendin\n\ninstr 2\n\nklfo lfo 1, 2, 0\nasig poscil3 .5*klfo, 220, giSine\n;write an aiff file: 32 bits with header\n     fout \"fout_aif.aiff\", 25, asig     \n;        fout \"fout_all3.wav\", 14, asig\n     outs asig, asig\n\nendin\n\ninstr 99 ;read the stereo csound output buffer\n\nallL, allR monitor\n;write the output of csound to an audio file\n;to a wav file: 16 bits with header\n           fout \"fout_all.wav\", 14, allL, allR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 0 3\ni 99 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of fout, using it to save the contents of a table to an audio file. It uses the file fout_ftable.csd and drumsMlp.wav.</p> Example of the fout opcode to save the contents of an f-table.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o fout_ftable.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; By: Jonathan Murphy 2007\n\n  gilen         =               131072\n  gicps         =               sr/gilen\n  gitab         ftgen           1, 0, gilen, 10, 1\n\n                instr 1\n\n  /******** write file to table ********/\n\n  ain           diskin2         \"drumsMlp.wav\", 1, 0, 1\n  aphs          phasor          gicps\n  andx          =               aphs * gilen\n                tablew          ain, andx, gitab\n\n  /******** write table to file ********/\n\n  aosc          table           aphs, gitab, 1\n                out             aosc\n                fout            \"drumsMlp_copy.wav\", 6, aosc\n\n                endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/fout/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fout/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999 Author: John ffitch NUIM, 2013</p> <p>New in Csound version 3.56</p> <p>October 2002. Added a note from Richard Dobson.</p> <p>Array version new in 6.01</p>"},{"location":"opcodes/fouti/","title":"Fouti","text":""},{"location":"opcodes/fouti/#fouti","title":"fouti","text":"<p>Outputs i-rate signals of an arbitrary number of channels to a specified file.</p>"},{"location":"opcodes/fouti/#syntax","title":"Syntax","text":"<pre><code>fouti ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]\n</code></pre>"},{"location":"opcodes/fouti/#initialization","title":"Initialization","text":"<p>ihandle -- a number which specifies this file.</p> <p>iformat -- a flag to choose output file format:</p> <ul> <li>0 - floating point in text format</li> <li>1 - 32-bit floating point in binary format</li> </ul> <p>iflag -- choose the mode of writing to the ASCII file (valid only in ASCII mode; in binary mode iflag has no meaning, but it must be present anyway). iflag can be a value chosen among the following:</p> <ul> <li>0 - line of text without instrument prefix</li> <li>1 - line of text with instrument prefix (see below)</li> <li>2 - reset the time of instrument prefixes to zero (to be used only in some particular cases. See below)</li> </ul> <p>iout,..., ioutN -- values to be written to the file</p>"},{"location":"opcodes/fouti/#performance","title":"Performance","text":"<p>fouti and foutir write i-rate values to a file. The main use of these opcodes is to generate a score file during a realtime session. For this purpose, the user should set iformat to 0 (text file output) and iflag to 1, which enable the output of a prefix consisting of the strings inum, actiontime, and duration, before the values of iout1...ioutN arguments. The arguments in the prefix refer to instrument number, action time and duration of current note.</p> <p>Notice that fout and foutk can use either a string containing a file pathname, or a handle-number generated by fiopen. Whereas, with fouti and foutir, the target file can be only specified by means of a handle-number.</p>"},{"location":"opcodes/fouti/#examples","title":"Examples","text":"<p>Here is an example of the fouti opcode. It uses the file fouti.csd.</p> Example of the fouti opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o fouti.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"test.txt\", 0 \n\ninstr 1\n\nires  random  0, 10 \n      fouti gihand, 0, 1, ires \n      ficlose gihand\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 \n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/fouti/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fouti/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/foutir/","title":"Foutir","text":""},{"location":"opcodes/foutir/#foutir","title":"foutir","text":"<p>Outputs i-rate signals from an arbitrary number of channels to a specified file.</p>"},{"location":"opcodes/foutir/#syntax","title":"Syntax","text":"<pre><code>foutir ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]\n</code></pre>"},{"location":"opcodes/foutir/#initialization","title":"Initialization","text":"<p>ihandle -- a number which specifies this file.</p> <p>iformat -- a flag to choose output file format:</p> <ul> <li>0 - floating point in text format</li> <li>1 - 32-bit floating point in binary format</li> </ul> <p>iflag -- choose the mode of writing to the ASCII file (valid only in ASCII mode; in binary mode iflag has no meaning, but it must be present anyway). iflag can be a value chosen among the following:</p> <ul> <li>0 - line of text without instrument prefix</li> <li>1 - line of text with instrument prefix (see below)</li> <li>2 - reset the time of instrument prefixes to zero (to be used only in some particular cases. See below)</li> </ul> <p>iout,..., ioutN -- values to be written to the file</p>"},{"location":"opcodes/foutir/#performance","title":"Performance","text":"<p>fouti and foutir write i-rate values to a file. The main use of these opcodes is to generate a score file during a realtime session. For this purpose, the user should set iformat to 0 (text file output) and iflag to 1, which enable the output of a prefix consisting of the strings inum, actiontime, and duration, before the values of iout1...ioutN arguments. The arguments in the prefix refer to instrument number, action time and duration of current note.</p> <p>The difference between fouti and foutir is that, in the case of fouti, when iflag is set to 1, the duration of the first opcode is undefined (so it is replaced by a dot). Whereas, foutir is defined at the end of note, so the corresponding text line is written only at the end of the current note (in order to recognize its duration). The corresponding file is linked by the ihandle value generated by the fiopen opcode. So fouti and foutir can be used to generate a Csound score while playing  a realtime session.</p> <p>Notice that fout and foutk can use either a string containing a file pathname, or a handle-number generated by fiopen. Whereas, with fouti and foutir, the target file can be only specified by means of a handle-number.</p>"},{"location":"opcodes/foutir/#examples","title":"Examples","text":"<p>Here is an example of the foutir opcode. It uses the file foutir.csdand creates a list \"foutir.sco\". It can be used as a score file.</p> Example of the foutir opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0  ;;;realtime audio out and midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o foutir.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngihand fiopen \"foutir.sco\", 0 \n\ninstr 1 ; play virtual midi keyboard\n\ninot  notnum  ;just for priting on screen\nicps  cpsmidi    \niamp  ampmidi 1\n\n      foutir  gihand, 0, 1, icps, iamp \n      prints  \"WRITING:\\n\"\n      prints  \"note = %f,velocity = %f\\n\", icps, iamp  ;prints them\n      ficlose gihand\nasig  pluck   iamp, icps, 1000, 0, 1\n      outs    asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\nf 0 10\n\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/foutir/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/foutir/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/foutk/","title":"Foutk","text":""},{"location":"opcodes/foutk/#foutk","title":"foutk","text":"<p>Outputs k-rate signals of an arbitrary number of channels to a specified file, in raw (headerless) format.</p>"},{"location":"opcodes/foutk/#syntax","title":"Syntax","text":"<pre><code>foutk ifilename, iformat, kout1 [, kout2, kout3,....,koutN]\n</code></pre>"},{"location":"opcodes/foutk/#initialization","title":"Initialization","text":"<p>ifilename -- the output file's name (in double-quotes).</p> <p>iformat -- a flag to choose output file format (note: Csound versions older than 5.0 may only support formats 0 and 1):</p> <ul> <li>0 - 32-bit floating point samples without header (binary PCM multichannel file)</li> <li>1 - 16-bit integers without header (binary PCM multichannel file)</li> <li>2 - 16-bit integers without header (binary PCM multichannel file)</li> <li>3 - u-law samples without header</li> <li>4 - 16-bit integers without header</li> <li>5 - 32-bit integers without header</li> <li>6 - 32-bit floats without header</li> <li>7 - 8-bit unsigned integers without header</li> <li>8 - 24-bit integers without header</li> <li>9 - 64-bit floats without header</li> </ul>"},{"location":"opcodes/foutk/#performance","title":"Performance","text":"<p>kout1,...koutN -- control-rate signals to be written to the file. The expected range of the signals is determined by the selected sample format.</p> <p>foutk operates in the same way as fout, but with k-rate signals. iformat can be set only in the range 0 to 9, or 0 to 1 with an old version of Csound.</p> <p>Notice that fout and foutk can use either a string containing a file pathname, or a handle-number generated by fiopen. Whereas, with fouti and foutir, the target file can be only specified by means of a handle-number.</p>"},{"location":"opcodes/foutk/#examples","title":"Examples","text":"<p>Here is an example of the foutk opcode. It uses the file foutk.csd.</p> Example of the foutk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o foutk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Stefano Cucchi - 2020\n\n; Sing in your microphone for 10''\n; Estimated pitch &amp; amplitude are written on 2 files \"amp\" 6 \"pitch\"\n; After 10'' a sawtooth is played with these values\n\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1 ;use pitch\n\niupdte = 0.001\nilo = 6\nihi = 10\nidbthresh = 10\nifrqs = 24\niconf = 10\nistrt = 8\n\nasig1, asig2 inch 1, 2\nkoct, kamp pitch asig1, iupdte, ilo, ihi, idbthresh, ifrqs, iconf, istrt ; pitch &amp; amplitude tracking\n\nkcps = cpsoct(koct)\nkamp = kamp*0.00002\nfoutk \"amp\", 6, kamp ; write amplitude values on a file - 32-bit floats without header\nfoutk \"pitch\", 6, kcps ;  write pitch values on a file - 32-bit floats without header\n\nendin\n\ninstr 2\n\nkamp readk \"amp\", 6, p4 ; read amplitude values fro the file\nkcps readk \"pitch\", 6, p4 ; read pitchvalues fro the file\n\nkcps portk kcps, 0.008\nasig oscili kamp, kcps*p5, 1 ; use amplitude &amp; pitch to play a sawtooth\nkdeclick linseg 0, 0.2, 1, p3 -0.4, 1, 0.2, 0\n\nouts asig*kdeclick, asig*kdeclick\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ;sawtooth\n\ni 1 0 10 \ni 2 10 10 0.001 1 ;\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>To avoid zipper noise, by discontinuities produced from complex envelope tracking, a lowpass filter could be used, to smooth the estimated envelope.</p>"},{"location":"opcodes/foutk/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/foutk/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/fprintks/","title":"Fprintks","text":""},{"location":"opcodes/fprintks/#fprintks","title":"fprintks","text":"<p>Similar to printks but prints to a file.</p>"},{"location":"opcodes/fprintks/#syntax","title":"Syntax","text":"<pre><code>fprintks \"filename\", \"string\", [, kval1] [, kval2] [...]\n</code></pre>"},{"location":"opcodes/fprintks/#initialization","title":"Initialization","text":"<p>\"filename\" -- name of the output file.</p> <p>\"string\" -- the text string to be printed. Can be up to 8192 characters and must be in double quotes.</p>"},{"location":"opcodes/fprintks/#performance","title":"Performance","text":"<p>kval1, kval2, ... (optional) -- The k-rate values to be printed. These are specified in \u201cstring\u201d with the standard C value specifier (%f, %d, etc.) in the order given.</p> <p>fprintks is similar to the printks opcode except it outputs to a file and does not have a itime parameter. For more information about output formatting, please look at printks's documentation.</p>"},{"location":"opcodes/fprintks/#examples","title":"Examples","text":"<p>Here is an example of the fprintks opcode. It uses the file fprintks.csd.</p> Example of the fprintks opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n          ; no sound       \n; For Non-realtime ouput leave only the line below:\n; -o fprintks.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Matt Ingalls, edited by Kevin Conder &amp; Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; a score generator\n\nkstart init 0\nkdur linrand 10\nkpitch linrand 8\nkpitch  *=  100\n; Printing to a file called \"my.sco\".\nfprintks \"my.sco\", \"i1\\\\t%2.2f\\\\t%2.2f\\\\t%2.2f\\\\n\", kstart, kdur, kpitch\n\nknext linrand 1\nkstart = kstart + knext\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.003\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example will generate a file called \u201cmy.sco\u201d. It should contain lines like this:</p> <pre><code>i1  0.00    1.35    668.01\ni1  0.13    2.21    246.53\ni1  0.22    1.88    437.51\ni1  1.18    9.65    126.09\n</code></pre> <p>Here is an example of the fprintks opcode, which converts a standard MIDI file to a csound score. It uses the file fprintks-2.csd.</p> Example of the fprintks opcode to convert a MIDI file to a csound score.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n; -odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n-n -Fmidichn_advanced.mid\n;Don't write audio ouput to disk and use the file midichn_advanced.mid as MIDI input\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  sr        =  48000\n  ksmps     =  16\n  nchnls    =  2\n\n  ;Example by Jonathan Murphy 2007\n\n            ; assign all midi events to instr 1000\n            massign   0, 1000\n            pgmassign   0, 1000\n\n    instr 1000\n\n  ktim  timeinsts\n\n  kst, kch, kd1, kd2  midiin\nif (kst != 0) then\n;  p4 = MIDI event type   p5 = channel   p6= data1    p7= data2\n            fprintks  \"MIDI2cs.sco\", \"i1\\\\t%f\\\\t%f\\\\t%d\\\\t%d\\\\t%d\\\\t%d\\\\n\", ktim, 1/kr, kst, kch, kd1, kd2\nendif\n\n    endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1000 0 10000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example will generate a file called \u201cMIDI2cs.sco\u201d containing i-events according to the MIDI file</p> <p>Here is an advanced example of the fprintks opcode, which generates scores for Csound. It uses the file scogen.csd.</p> Example of the fprintks opcode to create a Csound score file generator using Csound.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n; -odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n-n\n;Don't write audio ouput to disk\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;===========================================================\n;        scogen.csd       by: Matt Ingalls\n;\n;    a \"port\" of sorts\n;      of the old \"mills\" score generator (scogen)\n;\n;    this instrument creates a schottstaedt.sco file\n;    to be used with the schottstaedt.orc file\n;\n;    as long as you dont save schottstaedt.orc as a .csd\n;    file, you should be able to keep it open in MacCsound\n;    and render each newly generated .sco file.\n;\n;===========================================================\n\n\ngScoName = \"schottstaedt.sco\"     ; the name of the file to be generated\n\n    sr    =    100     ; this defines our temporal resolution,\n                ; an sr of 100 means we will generate p2 and p3 values\n                ; to the nearest 1/100th of a second\n\n    ksmps =    1     ; set kr=sr so we can do everything at k-rate\n\n\n; some print opcodes\nopcode PrintInteger, 0, k\n    kval    xin\n        fprintks    gScoName, \"%d\", kval\nendop\n\nopcode PrintFloat, 0, k\n    kval    xin\n        fprintks    gScoName, \"%f\", kval\nendop\n\nopcode PrintTab, 0, 0\n    fprintks    gScoName, \"%n\"\nendop\n\nopcode PrintReturn, 0, 0\n    fprintks    gScoName, \"%r\"\nendop\n\n\n; recursively calling opcode to handle all the optional parameters\nopcode ProcessAdditionalPfields, 0, ikio\n    iPtable, kndx, iNumPfields, iPfield xin\n\n    ; additional pfields start at 5, we use a default 0 to identify the first call\n    iPfield = (iPfield == 0 ? 5 : iPfield)\n\n    if (iPfield &gt; iNumPfields) goto endloop\n        ; find our tables\n        iMinTable table    2*iPfield-1, iPtable\n        iMaxTable table    2*iPfield, iPtable\n\n        ; get values from our tables\n        kMin tablei    kndx, iMinTable\n        kMax tablei    kndx, iMaxTable\n\n        ; find a random value in the range and write it to the score\n        fprintks gScoName, \"%t%f\", kMin + rnd(kMax-kMin)\n\n        ; recursively call for any additional pfields.\n        ProcessAdditionalPfields iPtable, kndx, iNumPfields, iPfield + 1\n    endloop:\n\nendop\n\n\n/* ===========================================================\n    Generate a gesture of i-statements\n\n    p2 = start of the gesture\n    p3 = duration of the gesture\n    p4 = number of a function that contains a list of all\n        function table numbers used to define the\n        pfield random distribution\n    p5 = scale generated p4 values according to density (0=off, 1=on) [todo]\n    p6 = let durations overlap gesture duration (0=off, 1=on) [todo]\n    p7 = seed for random number generator seed [todo]\n  ===========================================================\n*/\ninstr Gesture\n\n    ; initialize\n    iResolution = 1/sr\n\n    kNextStart init p2\n    kCurrentTime init p2\n\n    iNumPfields table        0, p4\n    iInstrMinTable table    1, p4\n    iInstrMaxTable table    2, p4\n    iDensityMinTable table    3, p4\n    iDensityMaxTable table    4, p4\n    iDurMinTable table    5, p4\n    iDurMaxTable table    6, p4\n    iAmpMinTable table    7, p4\n    iAmpMaxTable table    8, p4\n\n    ; check to make sure there is enough data\n    print iNumPfields\n    if iNumPfields &lt; 4 then\n        prints \"%dError: At least 4 p-fields (8 functions) need to be specified.%n\", iNumPfields\n        turnoff\n    endif\n\n    ; initial comment\n    fprints    gScoName, \"%!Generated Gesture from %f to %f seconds%n %!%t%twith a p-max of %d%n%n\", p2, p3, iNumPfields\n\n    ; k-rate stuff\n    if (kCurrentTime &gt;= kNextStart) then ; write a new note!\n\n        kndx = (kCurrentTime-p2)/p3\n\n        ; get the required pfield ranges\n        kInstMin tablei    kndx, iInstrMinTable\n        kInstMax tablei    kndx, iInstrMaxTable\n        kDensMin tablei    kndx, iDensityMinTable\n        kDensMax tablei    kndx, iDensityMaxTable\n        kDurMin tablei    kndx, iDurMinTable\n        kDurMax tablei    kndx, iDurMaxTable\n        kAmpMin tablei    kndx, iAmpMinTable\n        kAmpMax tablei    kndx, iAmpMaxTable\n\n        ; find random values for all our required parameters and print the i-statement\n        fprintks gScoName, \"i%d%t%f%t%f%t%f\", kInstMin + rnd(kInstMax-kInstMin), kNextStart, kDurMin + rnd(kDurMax-kDurMin), kAmpMin + rnd(kAmpMax-kAmpMin)\n\n        ; now any additional pfields\n        ProcessAdditionalPfields p4, kndx, iNumPfields\n\n        PrintReturn\n\n        ; calculate next starttime\n        kDensity = kDensMin + rnd(kDensMax-kDensMin)\n        if (kDensity &lt; iResolution) then\n            kDensity = iResolution\n        endif\n        kNextStart = kNextStart + kDensity\n    endif\n\n    kCurrentTime = kCurrentTime + iResolution\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n/*\n===========================================================\n  scogen.sco\n\n    this csound module generates a score file\n    you specify a gesture of notes by giving\n    the \"gesture\" instrument a number to a\n    (negative) gen2 table.\n\n    this table stores numbers to pairs of functions.\n    each function-pair represents a range (min-max)\n    of randomness for every pfield for the notes to\n    be generated.\n===========================================================\n*/\n\n\n; common tables for pfield ranges\nf100    0    2    -7    0 2 0    ; static 0\nf101    0    2    -7    1 2 1    ; static 1\nf102    0    2    -7    0 2 1 ; ramp 0-&gt;1\nf103    0    2    -7    1 2 0 ; ramp 1-&gt;0\nf105    0    2    -7    10 2 10 ; static 10\nf106    0    2    -7    .1 2 .1 ; static .1\n\n; specific pfield ranges\nf10    0    2    -7       .8 2 .01 ; density\nf11    0    2    -7       8 2 4 ; pitchmin\nf12    0    2    -7       8 2 12 ; pitchmax\n\n\n;=== table containing the function numbers used for all the p-field distributions\n;\n;    p1 -     table number\n;    p2 -     time table is instantiated\n;    p3 -     size of table (must be &gt;= p5!)\n;    p4 -     gen# (should be = -2)\n;    p5 -     number of pfields of each note to be generated\n;    p6 -     table number of the function representing the minimum possible note number (p1) of a generated note\n;    p7 -     table number of the function representing the maximum possible note number (p1) of a generated note\n;    p8 -     table number of the function representing the minimum possible noteon-to-noteon time (p2 density) of a generated note\n;    p9 -     table number of the function representing the maximum possible noteon-to-noteon time (p2 density) of a generated note\n;    p10 -    table number of the function representing the minimum possible duration (p3) of a generated note\n;    p11 -    table number of the function representing the maximum possible duration (p3) of a generated note\n;    p12 -    table number of the function representing the maximum possible amplitude (p4) of a generated note\n;    p13 -    table number of the function representing the maximum possible amplitude (p5) of a generated note\n;    p14,p16.. -    table number of the function representing the minimum possible value for additional pfields (p5,p6..) of a generated note\n;    p15,p17.. -    table number of the function representing the maximum possible value for additional pfields (p5,p6..) of a generated note\n\n;        siz    2    #pds p1min    p1max p2min    p2max p3min    p3max p4min    p4max p5min    p5max p6min    p6max\nf1    0    32    -2    6    101    101    10    10 101    105    100    106    11    12    100    101\n\n\n;gesture definitions\n;        start    dur    pTble    scale    overlap seed\ni\"Gesture\"     0    60    1 ;todo--&gt;0    0    123\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example will generate a file called \u201cschottstaedt.sco\u201d which can be used as a score together with  schottstaedt.orc</p>"},{"location":"opcodes/fprintks/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fprintks/#credits","title":"Credits","text":"<p>Author: Matt Ingalls January 2003</p>"},{"location":"opcodes/fprints/","title":"Fprints","text":""},{"location":"opcodes/fprints/#fprints","title":"fprints","text":"<p>Similar to prints but prints to a file.</p>"},{"location":"opcodes/fprints/#syntax","title":"Syntax","text":"<pre><code>fprints &amp;quot;filename&amp;quot;, &amp;quot;string&amp;quot; [, ival1] [, ival2] [...]\n</code></pre>"},{"location":"opcodes/fprints/#initialization","title":"Initialization","text":"<p>\"filename\" -- name of the output file.</p> <p>\"string\" -- the text string to be printed. Can be up to 8192 characters and must be in double quotes.</p> <p>ival1, ival2, ... (optional) -- The i-rate values to be printed. These are specified in \u201cstring\u201d with the standard C value specifier (%f, %d, etc.) in the order given.</p>"},{"location":"opcodes/fprints/#performance","title":"Performance","text":"<p>fprints is similar to the prints opcode except it outputs to a file. For more information about output formatting, please look at printks's documentation.</p>"},{"location":"opcodes/fprints/#examples","title":"Examples","text":"<p>Here is an example of the fprints opcode. It uses the file fprints.csd. Note that the example must be run from a directory for which the user has write access.</p> Example of the fprints opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n   ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o fprints.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Matt Ingalls, edited by Kevin Conder. \n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; a score generator\n\nfprints \"my.sco\", \"%!Generated score by ma++\\\\n \\\\n\"    ; Print to the file \"my.sco\".\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.001\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This example will generate a file called \u201cmy.sco\u201d. It should contain a line like this:</p> <pre><code>;Generated score by ma++\n</code></pre>"},{"location":"opcodes/fprints/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/fprints/#credits","title":"Credits","text":"<p>Author: Matt Ingalls January 2003</p>"},{"location":"opcodes/frac/","title":"Frac","text":""},{"location":"opcodes/frac/#frac","title":"frac","text":"<p>Returns the fractional part of a decimal number.</p>"},{"location":"opcodes/frac/#syntax","title":"Syntax","text":"<pre><code>frac(x) (init-rate or control-rate args; also works at audio rate in Csound5)\nfrac(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/frac/#examples","title":"Examples","text":"<p>Here is an example of the frac opcode. It uses the file frac.csd.</p> Example of the frac opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o frac.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = 16 / 5\n  i2 = frac(i1)\n\n  print i2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i2 = 0.200\n</code></pre> <p>Here is another example of the frac opcode. It uses the file frac2.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o frac.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2024\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n0dbfs  = 1\nnchnls = 2\n\ninstr 1\n\ngkrandom randomh 1, 45, 300, 2,  3 ; generate some random numbers\ngkrandomFLOOR = floor (gkrandom)   ; take the integer part\ngkrandomFRAC = frac (gkrandom)     ; take the fractional part\n\nendin\n\ninstr 10\n\n  ktrigger metro 4\n  kmintim = 0\n  kmaxnum = 10\n  kinsnum = 20\n  kwhen = 0\n  kdur = ktrigger*0.25\n\n  schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur\n\nendin\n\ninstr 20\n\n  irandomFLOOR = i(gkrandomFLOOR) \n  irandomFRAC = i(gkrandomFRAC)\n\n  ; Use the integer part to control the number of harmonics of every note\n  ; after converting (k) value to (i)\n  prints \"generated value = %f\\n\", i(gkrandom)\n  prints \"fractional part = %f\\n\", irandomFRAC\n  a1 buzz 0.5, 120, irandomFLOOR, 1 \n  kenvelope linseg 0, p3*0.1, 1, p3*0.8, 1, p3*0.1, 0\n  a1 = a1*kenvelope\n  aL, aR pan2 a1, irandomFRAC, 1 ; use the fractional part to control the pan position \n  outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 16384 10 1\n\ni 1 0 10\ni 10 0 10 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/frac/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/frac/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/fractalnoise/","title":"Fractalnoise","text":""},{"location":"opcodes/fractalnoise/#fractalnoise","title":"fractalnoise","text":"<p>A fractal noise generator.</p> <p>Plugin opcode in fractalnoise.</p> <p>Implemented as a white noise filtered by a cascade of 15 first-order filters.</p>"},{"location":"opcodes/fractalnoise/#syntax","title":"Syntax","text":"<pre><code>ares fractalnoise kamp, kbeta\n</code></pre>"},{"location":"opcodes/fractalnoise/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kbeta -- spectral parameter related to the fractal dimension</p> <ul> <li>0 - white</li> <li>1 - pink</li> <li>2 - brown</li> </ul>"},{"location":"opcodes/fractalnoise/#examples","title":"Examples","text":"<p>Here is an example of the fractalnoise opcode. It uses the file fractalnoise.csd.</p> Example of the fractalnoise opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkbeta linseg 0, p3/4, 2, p3/4, 0, p3*0.1, 2, p3*0.15, 0\nseed  20120124\naout  fractalnoise 0.05, kbeta \nouts  aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>References</p> <ol> <li>R. Saletti. A comparison between two methods to generate 1/(f^gamma) noise. In Proc. IEEE, volume 74, pp. 1595-1596, November 1986.</li> <li>G. Corsini and R. Saletti. A 1/(f^gamma) power spectrum noise sequence generator. IEEE Trans. on Instrumentation and Measurement, 37(4):615-619, December 1988.</li> <li>The Sounding Object, edited by Davide Rocchesso and Federico Fontana, Edizioni di Mondo Estremo. Chapter 8 by Federico Avanzini, pp. 154-157.</li> </ol>"},{"location":"opcodes/fractalnoise/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/fractalnoise/#credits","title":"Credits","text":"<p>Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p>"},{"location":"opcodes/freeverb/","title":"Freeverb","text":""},{"location":"opcodes/freeverb/#freeverb","title":"freeverb","text":"<p>Opcode version of Jezar's Freeverb</p> <p>freeverb is a stereo reverb unit based on Jezar's public domain C++ sources, composed of eight parallel comb filters on both channels, followed by four allpass units in series. The filters on the right channel are slightly detuned compared to the left channel in order to create a stereo effect.</p>"},{"location":"opcodes/freeverb/#syntax","title":"Syntax","text":"<pre><code>aoutL, aoutR freeverb ainL, ainR, kRoomSize, kHFDamp[, iSRate[, iSkip]]\n</code></pre>"},{"location":"opcodes/freeverb/#initialization","title":"Initialization","text":"<p>iSRate (optional, defaults to 44100): adjusts the reverb parameters for use with the specified sample rate (this will affect the length of the delay lines in samples, and, as of the latest CVS version, the high frequency attenuation). Only integer multiples of 44100 will reproduce the original character of the reverb exactly, so it may be useful to set this to 44100 or 88200 for an orchestra sample rate of 48000 or 96000 Hz, respectively. While iSRate is normally expected to be close to the orchestra sample rate, different settings may be useful for special effects.</p> <p>iSkip (optional, defaults to zero): if non-zero, initialization of the opcode will be skipped, whenever possible.</p>"},{"location":"opcodes/freeverb/#performance","title":"Performance","text":"<p>ainL, ainR -- input signals; usually both are the same, but different inputs can be used for special effect</p> <p> Note</p> <p>It is recommended to process the input signal(s) with the denorm opcode in order to avoid denormalized numbers which could significantly increase CPU usage in some cases</p> <p>aoutL, aoutR -- output signals for left and right channel</p> <p>kRoomSize (range: 0 to 1) -- controls the length of the reverb, a higher value means longer reverb. Settings above 1 may make the opcode unstable.</p> <p>kHFDamp (range: 0 to 1): high frequency attenuation; a value of zero means all  frequencies decay at the same rate, while higher settings will result in a faster decay of the high frequency range.</p>"},{"location":"opcodes/freeverb/#examples","title":"Examples","text":"<p>Here is an example of the freeverb opcode. It uses the file freeverb.csd.</p> An example of the freeverb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o freeverb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr      =  44100\nksmps   =  32\nnchnls  =  2\n0dbfs   =  1\n\n        instr 1\na1      vco2 0.75, 440, 10\nkfrq    port 100, 0.008, 20000\na1      butterlp a1, kfrq\na2      linseg 0, 0.003, 1, 0.01, 0.7, 0.005, 0, 1, 0\na1      =  a1 * a2\n        denorm a1\naL, aR  freeverb a1, a1, 0.9, 0.35, sr, 0\n        outs a1 + aL, a1 + aR\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/freeverb/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/freeverb/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/ftaudio/","title":"Ftaudio","text":""},{"location":"opcodes/ftaudio/#ftaudio","title":"ftaudio","text":"<p>Write a previously-allocated table to an audio file in a variety of formats.</p>"},{"location":"opcodes/ftaudio/#syntax","title":"Syntax","text":"<pre><code>ians ftaudio ifn, \"filename\", iformat[, ibeg, iend]\nkans ftaudio ktrig, kfn, \"filename\", kformat [, isync, kbeg, kend]\n</code></pre>"},{"location":"opcodes/ftaudio/#initialization","title":"Initialization","text":"<p>ifn, kfn -- Number of table to write.</p> <p>\"filename\" -- A quoted string containing the name of the file to save.</p> <p>iformat, kformat -- Format of the file to save.</p> <ul> <li>-1 - format exactly as per global csound output format flags (-A, -W, --format=..., etc).</li> <li>0 - 32-bit floating point samples without header (binary PCM multichannel file)</li> <li>1 - 16-bit integers without header (binary PCM multichannel file)</li> <li>2 - 16-bit integers with a header. The header type depends on the render (-o) format. For example, if the user chooses the AIFF format (using the -A flag), the header format will be AIFF type.</li> <li>3 - u-law samples with a header (see iformat=2).</li> <li>4 - 16-bit integers with a header (see iformat=2).</li> <li>5 - 32-bit integers with a header (see iformat=2).</li> <li>6 - 32-bit floats with a header (see iformat=2).</li> <li>7 - 8-bit unsigned integers with a header (see iformat=2).</li> <li>8 - 24-bit integers with a header (see iformat=2).</li> <li>9 - 64-bit floats with a header (see iformat=2).</li> <li>50 - ogg-vorbis format.</li> </ul> <p>In addition Csound allows for explicitly selecting a particular header type by specifying the format as 10 * fileType + sampleFormat, where fileType may be 1 for WAV, 2 for AIFF, 3 for raw (headerless) files, and 4 for IRCAM; sampleFormat is one of the above values in the range 0 to 9, except sample format 0 is taken from the command line (-o), format 1 is 8-bit signed integers, and format 2 is a-law. So, for example, iformat=25 means 32-bit integers with AIFF header.</p> <p>isync -- if zero the k-rate version waits for the write to finish.  If non-zero (default) the writing of data is delegated to a separate thread which then allows Csound to continue with the rendering.</p> <p>ibeg,iend,kbeg,kend -- gives limits to start and end of section of the table to write, in samples. Default values of zero means from start to end.</p> <p>ians, kans -- returns zero if the operation fails or 1 on success.  In the asynchronous mode this is updated when the writing finishes, until when it has the value -1</p>"},{"location":"opcodes/ftaudio/#performance","title":"Performance","text":"<p>ktrig -- the k-rate version only happens on a k-cycle when ktrig is non-zero.</p>"},{"location":"opcodes/ftaudio/#examples","title":"Examples","text":"<p>Here is an example of the ftaudio opcode. It uses the file ftaudio.csd.</p> Example of the ftaudio opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ftsave.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n     ktrig init    1\n     asig  poscil3 .5, 880, giSine\n     kans  ftaudio ktrig, 100, \"k_ftaudio.wav\", 15, 1\n     ktrig =       0\n           outs    asig, asig\nendin\n\ninstr 2\n     ians  ftaudio 100, \"i_ftaudio.wav\", 15, p4, p5\n           turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf100 0 0 -1 \"drumsMlp.wav\" 0 0 0\ni 1 0 2\ni 2 0 1 11025 33075; 0.5 seconds cut\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftaudio/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftaudio/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>Example written by John ffitch.</p> <p>New in version 6.12</p> <p>Limit to range bnew in 6.13</p>"},{"location":"opcodes/ftchnls/","title":"Ftchnls","text":""},{"location":"opcodes/ftchnls/#ftchnls","title":"ftchnls","text":"<p>Returns the number of channels in a stored function table.</p>"},{"location":"opcodes/ftchnls/#syntax","title":"Syntax","text":"<pre><code>ftchnls(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/ftchnls/#performance","title":"Performance","text":"<p>Returns the number of channels of a GEN01 table, determined from the header of the original file.  If the original file has no header or the table was not created by these GEN01, ftchnls returns -1.</p>"},{"location":"opcodes/ftchnls/#examples","title":"Examples","text":"<p>Here is an example of the ftchnls opcode. It uses the files ftchnls.csd, drumsMlp.wav, and drumsSlp.wav.</p> Example of the ftchnls opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o ftchnls.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nichnls = ftchnls(p4)\nprints  \"\\nnumber of channels = %d\\n\\n\", ichnls\n\nif (ichnls == 1) then\n   asigL loscil3 .8, 1, p4, 1          ; sample loops between 1 and end loop point at 2 secs.\n   asigR =      asigL\nelseif (ichnls == 2) then\n   asigL, asigR loscil3 .8, 1, p4, 1   ; sample loops between 2 and end loop point at 3 secs.\nelse                                   ; safety precaution if not mono or stereo\n   asigL = 0\n   asigR = 0\nendif\n        outs asigL, asigR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\nf 2 0 0 1 \"drumsSlp.wav\" 0 0 0\n\ni 1 0 3 1 ;mono file\ni 1 + 8 2 ;stereo file\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The audio file \u201cdrumsMlp.wav\u201d is monophonic, the audio file \u201cdrumsSlp.wav\u201d is stereophonic, so its output should include lines like these:</p> <pre><code>number of channels = 1\nnumber of channels = 2\n</code></pre>"},{"location":"opcodes/ftchnls/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftchnls/#credits","title":"Credits","text":"<p>Author: Chris McCormick Perth, Australia December 2001</p>"},{"location":"opcodes/ftconv/","title":"Ftconv","text":""},{"location":"opcodes/ftconv/#ftconv","title":"ftconv","text":"<p>Low latency multichannel convolution, using a function table as impulse response source.</p> <p>The algorithm is to split the impulse response to partitions of length determined by the iplen parameter, and delay and mix partitions so that the original, full length impulse response is reconstructed without gaps. The output delay (latency) is iplen samples, and does not depend on the control rate, unlike in the case of other convolve opcodes.</p>"},{"location":"opcodes/ftconv/#syntax","title":"Syntax","text":"<pre><code>a1[, a2[, a3[, ... a8]]] ftconv ain, ift, iplen[, iskipsamples \\\n                                [, iirlen[, iskipinit]]]\n</code></pre>"},{"location":"opcodes/ftconv/#initialization","title":"Initialization","text":"<p>ift -- source ftable number. The table is expected to contain interleaved multichannel audio data, with the number of channels equal to the number of output variables (a1, a2, etc.). An interleaved table can be created from a set of mono tables with GEN52.</p> <p>iplen -- length of impulse response partitions, in sample frames; must be an integer power of two. Lower settings allow for shorter output delay, but will increase CPU usage.</p> <p>iskipsamples (optional, defaults to zero) -- number of sample frames to skip at the beginning of the table. Useful for reverb responses that have some amount of initial delay. If this delay is not less than iplen samples, then setting iskipsamples to the same value as iplen will eliminate any additional latency by ftconv.</p> <p>iirlen (optional) -- total length of impulse response, in sample frames. The default is to use all table data (not including the guard point).</p> <p>iskipinit (optional, defaults to zero) -- if set to any non-zero value, skip initialization whenever possible without causing an error.</p>"},{"location":"opcodes/ftconv/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>a1 ... a8 -- output signal(s).</p>"},{"location":"opcodes/ftconv/#example","title":"Example","text":"<p>Here is an example of the ftconv opcode. It uses the file ftconv.csd.</p> Example of the ftconv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ftconv.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr      =  48000\nksmps   =  32\nnchnls  =  2\n0dbfs   =  1\n\ngarvb   init 0\ngaW     init 0\ngaX     init 0\ngaY     init 0\n\nitmp    ftgen   1, 0, 64, -2, 2, 40, -1, -1, -1, 123,           \\\n               1, 13.000, 0.05, 0.85, 20000.0, 0.0, 0.50, 2,   \\\n               1,  2.000, 0.05, 0.85, 20000.0, 0.0, 0.25, 2,   \\\n               1, 16.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1,  9.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1, 12.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1,  8.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2\n\nitmp    ftgen 2, 0, 262144, -2, 0\n       spat3dt 2, -0.2, 1, 0, 1, 1, 2, 0.005\n\nitmp    ftgen 3, 0, 262144, -52, 3, 2, 0, 4, 2, 1, 4, 2, 2, 4\n\n       instr 1\n\na1      vco2 1, 440, 10\nkfrq    port 100, 0.008, 20000\na1      butterlp a1, kfrq\na2      linseg 0, 0.003, 1, 0.01, 0.7, 0.005, 0, 1, 0\na1      =  a1 * a2 * 2\n       denorm a1\n       vincr garvb, a1\naw, ax, ay, az  spat3di a1, p4, p5, p6, 1, 1, 2\n       vincr gaW, aw\n       vincr gaX, ax\n       vincr gaY, ay\n\n       endin\n\n       instr 2\n\n       denorm garvb\n; skip as many samples as possible without truncating the IR\narW, arX, arY   ftconv garvb, 3, 2048, 2048, (65536 - 2048)\naW      =  gaW + arW\naX      =  gaX + arX\naY      =  gaY + arY\ngarvb   =  0\ngaW     =  0\ngaX     =  0\ngaY     =  0\n\naWre, aWim      hilbert aW\naXre, aXim      hilbert aX\naYre, aYim      hilbert aY\naWXr    =  0.0928*aXre + 0.4699*aWre\naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre\naL      =  aWXr + aWXiYr\naR      =  aWXr - aWXiYr\n\n       outs aL, aR\n\n       endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0.5  0.0  2.0 -0.8\ni 1 1 0.5  1.4  1.4 -0.6\ni 1 2 0.5  2.0  0.0 -0.4\ni 1 3 0.5  1.4 -1.4 -0.2\ni 1 4 0.5  0.0 -2.0  0.0\ni 1 5 0.5 -1.4 -1.4  0.2\ni 1 6 0.5 -2.0  0.0  0.4\ni 1 7 0.5 -1.4  1.4  0.6\ni 1 8 0.5  0.0  2.0  0.8\ni 2 0 10\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftconv/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/ftconv/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/ftcps/","title":"Ftcps","text":""},{"location":"opcodes/ftcps/#ftcps","title":"ftcps","text":"<p>Returns the base frequency of a stored function table in Hz.</p>"},{"location":"opcodes/ftcps/#syntax","title":"Syntax","text":"<pre><code>ftcps(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/ftcps/#performance","title":"Performance","text":"<p>Returns the base frequency of stored function table, number x.  ftcps is designed for tables storing audio waveforms read from files (see GEN01).</p> <p>ftcps returns -1 in case of an error (no base frequency set in table or non-existent table).</p>"},{"location":"opcodes/ftcps/#examples","title":"Examples","text":"<p>Here is an example of the ftcps opcode.</p> Example of the ftcps opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ftlen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Print out the base frequency of Table #1.\n  ; if it has been set in the original file.\n  icps = ftcps(1)\n  print icps\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: Use an audio file, Csound will determine its base frequency, if set.\nf 1 0 0 1 \"sample.wav\" 0 0 0\n\n; Play Instrument #1 for 1 second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftcps/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftcps/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2010</p> <p>Example written by Victor Lazzarini</p>"},{"location":"opcodes/ftexists/","title":"Ftexists","text":""},{"location":"opcodes/ftexists/#ftexists","title":"ftexists","text":"<p>Query if a given table exists</p> <p>Plugin opcode in emugens.</p> <p>Returns 1 if a given index refers to an existing table, 0 if the table does not exist. Works at i-time if output is an ivariable, at k-time otherwise</p>"},{"location":"opcodes/ftexists/#syntax","title":"Syntax","text":"<pre><code>iexists ftexists ifn\nkexists ftexists kfn / ifn\n</code></pre>"},{"location":"opcodes/ftexists/#arguments","title":"Arguments","text":"<p>ifn / kfm - The table to query</p>"},{"location":"opcodes/ftexists/#output","title":"Output","text":"<p>iexists / kexists - 1 if the table exists, 0 otherwise</p>"},{"location":"opcodes/ftexists/#examples","title":"Examples","text":"<p>Here is an example of the ftexists opcode. It uses the file ftexists.csd.</p> Example of the ftexists opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n--nosound \n\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\n; This is the example file for ftexists\n\n/*\n\n  ftexists\n\n  Returns 1 if a given table index refers to an existing\n  ftable\n\n  iexists  ftexists  ifn\n  kexists  ftexists  kfn\n\n  Args:\n        ifn / kfn: the table index to query\n\n  Returns:\n    iexists / kexists: 1 if a table with index ifn exists, 0 otherwise\n\n*/\n\ngifn1 ftgen 0, 0, 8, 2, 0\n\ninstr 1\n    iexists1 ftexists gifn1\n    print iexists1\n\n    iexists2 ftexists 2\n    print iexists2\n\n    kexists ftexists 3\n    printf \"table 3 exists at time %f\", kexists, timeinsts()\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\nf 2 0 8 2 0\nf 3 1.5 8 2 0\n\ni 1 0 2\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftexists/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftexists/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2019</p> <p>New plugin in version 6.14</p>"},{"location":"opcodes/ftfree/","title":"Ftfree","text":""},{"location":"opcodes/ftfree/#ftfree","title":"ftfree","text":"<p>Deletes function table.</p>"},{"location":"opcodes/ftfree/#syntax","title":"Syntax","text":"<pre><code>ftfree ifno, iwhen\n</code></pre>"},{"location":"opcodes/ftfree/#initialization","title":"Initialization","text":"<p>ifno -- the number of the table to be deleted</p> <p>iwhen -- if zero the table is deleted at init time; otherwise the table number is registered for being deleted at note deactivation.</p> <p> Note</p> <p>If the table is deleted at init time it is possible that an earlier opcode that uses the table will fail or crash on a performance cycle.  It is the user's responsibility to avoid this error.</p>"},{"location":"opcodes/ftfree/#examples","title":"Examples","text":"<p>Here is an example of the ftfree opcode. It uses the file ftfree.csd.</p> Example of the ftfree opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftfree.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngitempTable ftgen 0, 0, 65537, 10, 1\n\ninstr 1\n\naout oscili .5, 440, gitempTable\n     outs aout, aout\n\n;free temp table at deinit time\nftfree gitempTable, 1\nprint  gitempTable\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 5\n\ni 1 0 .1\ni 1 3 1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <pre><code>instr 1:  gitempTable = 101.000\nB  0.000 ..  3.000 T  3.000 TT  3.000 M:  0.50000  0.50000\nINIT ERROR in instr 1: Invalid ftable no. 101.000000\ninstr 1:  gitempTable = 101.000\nError deleting ftable 101\nB  3.000 - note deleted.  i1 had 1 init errors\nB  3.000 ..  5.000 T  5.000 TT  5.000 M:  0.00000  0.00000\n</code></pre>"},{"location":"opcodes/ftfree/#see-also","title":"See also","text":"<p>Function Table Control</p>"},{"location":"opcodes/ftfree/#credits","title":"Credits","text":"<p>Authors: Steven Yi, Istvan Varga 2005</p>"},{"location":"opcodes/ftgen/","title":"Ftgen","text":""},{"location":"opcodes/ftgen/#ftgen","title":"ftgen","text":"<p>Generate a score function table from within the orchestra.</p>"},{"location":"opcodes/ftgen/#syntax","title":"Syntax","text":"<pre><code>gir ftgen ifn, itime, isize, igen, iarga [, iargb ] [...]\ngir ftgen ifn, itime, isize, igen, iarray\n</code></pre>"},{"location":"opcodes/ftgen/#initialization","title":"Initialization","text":"<p>gir -- either a requested or automatically assigned table number above 100.</p> <p>ifn -- requested table number If ifn is zero, the number is assigned automatically and the value placed in gir. Any other value is used as the table number</p> <p>itime -- is ignored, but otherwise corresponds to p2 in the score f statement.</p> <p>isize -- table size. Corresponds to p3 of the score f statement.</p> <p>igen -- function table GEN routine. Corresponds to p4 of the score f statement.</p> <p>iarga, iargb, ... -- function table arguments. Correspond to p5 through p_n_ of the score f statement.</p> <p>iarray -- ane dimensionl array holding the function table arguments. Correspond to p5 through pn of the score f statement.</p>"},{"location":"opcodes/ftgen/#performance","title":"Performance","text":"<p>This is equivalent to table generation in the score with the f statement.</p> <p> Note</p> <p>Csound was originally designed to support tables with power of two sizes only. Though this has changed in recent versions (you can use any size by using a negative number), many opcodes will not accept them.</p> <p> Warning</p> <p>Although Csound will not protest if ftgen is used inside instr-endin statements, this is not the intended or supported use, and must be handled with care as it has global effects. (In particular, a different size usually leads to relocation of the table, which may cause a crash or otherwise erratic behaviour).</p>"},{"location":"opcodes/ftgen/#examples","title":"Examples","text":"<p>Here is an example of the ftgen opcode. It uses the file ftgen.csd.</p> Example of the ftgen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftgen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ngisine   ftgen 1, 0, 16384, 10, 1       ;sine wave\ngisquare ftgen 2, 0, 16384, 10, 1, 0 , .33, 0, .2 , 0, .14, 0 , .11, 0, .09 ;odd harmonics\ngisaw    ftgen 3, 0, 16384, 10, 0, .2, 0, .4, 0, .6, 0, .8, 0, 1, 0, .8, 0, .6, 0, .4, 0,.2 ;even harmonics\n\ninstr 1\n\nifn = p4\nasig poscil .6, 200, ifn\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 1 ;sine wave\ni 1 3 2 2 ;odd harmonics\ni 1 6 2 3 ;even harmonics\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the ftgen opcode. It uses the file ftgen-2.csd.</p> Example of the ftgen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ftgen-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  sr        =  48000\n  ksmps     =  16\n  nchnls    =  2\n\n;Example by Jonathan Murphy 2007\n\n  0dbfs     =  1\n\n    instr 1\n\n  Sfile     =    \"drumsMlp.wav\"\n\n  ilen      filelen   Sfile  ; Find length\n  isr       filesr    Sfile  ; Find sample rate\n\n  isamps    =  ilen * isr  ; Total number of samples\n  isize     init      1\n\nloop:\n  isize     =  isize * 2\n; Loop until isize is greater than number of samples\nif (isize &lt; isamps) igoto loop\n\n  itab      ftgen     0, 0, isize, 1, Sfile, 0, 0, 0\n            print     isize\n            print     isamps\n\n  turnoff\n    endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftgen/#see-also","title":"See also","text":"<p>GEN routine overview</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/ftgen/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe M.I.T., Cambridge, Mass 1997</p> <p>Added warning April 2002 by Rasmus Ekman</p>"},{"location":"opcodes/ftgenonce/","title":"Ftgenonce","text":""},{"location":"opcodes/ftgenonce/#ftgenonce","title":"ftgenonce","text":"<p>Generate a function table from within an instrument definition, without duplication of data.</p> <p>Plugin opcode in signalflowgraph.</p> <p>The ftgenonce opcode is designed to simplify writing instrument definitions that can be re-used in different orchestras simply by #including them and plugging them into some output instrument. There is no need to define function tables either in the score, or in the orchestra header.</p> <p>The ftgenonce opcode is similar to ftgentmp, and has identical arguments. However, function tables are neither duplicated nor deleted. Instead, all of the arguments to the opcode are concatenated to form the key to a lookup table that points to the function table number. Thus, every request to ftgenonce with the same arguments receives the same instance of the function table data. Every change in the value of any ftgenonce argument causes the creation of a new function table.</p>"},{"location":"opcodes/ftgenonce/#syntax","title":"Syntax","text":"<pre><code>ifno ftgenonce ip1, ip2dummy, isize, igen, iarga, iargb, ...\n</code></pre>"},{"location":"opcodes/ftgenonce/#initialization","title":"Initialization","text":"<p>ifno --  an automatically assigned table number.</p> <p>ip1 -- the number of the table to be generated or 0 if the number is to be assigned.</p> <p>ip2dummy -- ignored.</p> <p>isize -- table size. Corresponds to p3 of the score f statement.</p> <p>igen -- function table GEN routine. Corresponds to p4 of the score f statement.</p> <p>iarga, iargb, ... -- function table arguments. Correspond to p5 through p_n_ of the score f statement.</p> <p> Note</p> <p>Csound was originally designed to support tables with power of two sizes only. Though this has changed in recent versions (you can use any size by using a negative number), many opcodes will not accept them.</p>"},{"location":"opcodes/ftgenonce/#examples","title":"Examples","text":"<p>Here is an example of the ftgenonce opcode. It uses the file ftgenonce.csd.</p> Example of the ftgenonce opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftgenonce.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt; \n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n; Use ftgenonce instead of ftgen, ftgentmp, or f statement\niHz     = p4\nisine   ftgenonce 0, 0, 1024, 10, 1 \naoscili pluck .7, iHz, 100, isine, 1 \naadsr   adsr 0.015, 0.07, 0.6, 0.3\nasig    = aoscili * aadsr\n        outs asig, asig\nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 1 220 \ni 1 2 1 261 \ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/ftgenonce/#see-also","title":"See also","text":"<p>Signal Flow Graph Opcodes</p>"},{"location":"opcodes/ftgenonce/#credits","title":"Credits","text":"<p>Authors: Michael Gogins 2009</p>"},{"location":"opcodes/ftgentmp/","title":"Ftgentmp","text":""},{"location":"opcodes/ftgentmp/#ftgentmp","title":"ftgentmp","text":"<p>Generate a score function table from within the orchestra, which is deleted at the end of the note.</p>"},{"location":"opcodes/ftgentmp/#syntax","title":"Syntax","text":"<pre><code>ifno ftgentmp ip1, ip2dummy, isize, igen, iarga, iargb, ...\n</code></pre>"},{"location":"opcodes/ftgentmp/#initialization","title":"Initialization","text":"<p>ifno --  either a requested or automatically assigned table number above 100.</p> <p>ip1 -- the number of the table to be generated or 0 if the number is to be assigned, in which case the table is deleted at the end of the note activation.</p> <p>ip2dummy -- ignored.</p> <p>isize -- table size. Corresponds to p3 of the score f statement.</p> <p>igen -- function table GEN routine. Corresponds to p4 of the score f statement.</p> <p>iarga, iargb, ... -- function table arguments. Correspond to p5 through pn of the score f statement.</p> <p> Note</p> <p>Csound was originally designed to support tables with power of two sizes only. Though this has changed in recent versions (you can use any size by using a negative number), many opcodes will not accept them.</p>"},{"location":"opcodes/ftgentmp/#examples","title":"Examples","text":"<p>Here is an example of the ftgentmp opcode. It uses the file ftgentmp.csd.</p> Example of the ftgentmp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1\n\ninstr 1\nifno  ftgentmp  0, 0, 512, 10, 1\nprint ifno\nendin\n\ninstr 2\nprint ftlen(p4)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 10\ni 2 2 1 101\ni 1 5 10\ni 2 7 1 102\ni 2 12 1 101 \ni 2 17 1 102 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output of this csd shows that the tables are destroyed after the instrument instances that created them terminates, causing an init error if the tables are queried.</p> <pre><code>SECTION 1:\nnew alloc for instr 1:\nftable 101:\ninstr 1:  ifno = 101.000\nB  0.000 ..  2.000 T  2.000 TT  2.000 M:  0.00000  0.00000\nnew alloc for instr 2:\ninstr 2:  #i0 = 512.000\nB  2.000 ..  5.000 T  5.001 TT  5.001 M:  0.00000  0.00000\nnew alloc for instr 1:\nftable 102:\ninstr 1:  ifno = 102.000\nB  5.000 ..  7.000 T  7.001 TT  7.001 M:  0.00000  0.00000\ninstr 2:  #i0 = 512.000\nB  7.000 .. 12.000 T 11.999 TT 11.999 M:  0.00000  0.00000\nINIT ERROR in instr 2: Invalid ftable no. 101.000000\n#i0     ftlen.i p4\ninstr 2:  #i0 = -1.000\nB 12.000 - note deleted.  i2 had 1 init errors\nB 12.000 .. 17.000 T 17.000 TT 17.000 M:  0.00000  0.00000\nINIT ERROR in instr 2: Invalid ftable no. 102.000000\n#i0     ftlen.i p4\ninstr 2:  #i0 = -1.000\nB 17.000 - note deleted.  i2 had 1 init errors\n</code></pre>"},{"location":"opcodes/ftgentmp/#see-also","title":"See also","text":"<p>Function Table Control</p>"},{"location":"opcodes/ftgentmp/#credits","title":"Credits","text":"<p>Authors: Istvan Varga 2005</p>"},{"location":"opcodes/ftlen/","title":"Ftlen","text":""},{"location":"opcodes/ftlen/#ftlen","title":"ftlen","text":"<p>Returns the size of a stored function table.</p>"},{"location":"opcodes/ftlen/#syntax","title":"Syntax","text":"<pre><code>ftlen(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/ftlen/#performance","title":"Performance","text":"<p>Returns the size (number of points, excluding guard point) of stored function table, number x. While most units referencing a stored table will automatically take its size into account (so tables can be of arbitrary length), this function reports the actual size if that is needed. Note that ftlen will always return a power-of-2 value, i.e. the function table guard point (see f Statement) is not included.As of Csound version 3.53, ftlen works with deferred function tables (see GEN01).</p> <p>ftlen differs from nsamp in that nsamp gives the number of sample frames loaded, while ftlen gives the total number of samples without the guard point. For example, with a stereo sound file of 10000 samples, ftlen() would return 19999 (i.e. a total of 20000 mono samples, not including a guard point), but nsamp() returns 10000.</p>"},{"location":"opcodes/ftlen/#examples","title":"Examples","text":"<p>Here is an example of the ftlen opcode. It uses the file ftlen.csd, fox.wav and drumsMlp.wav.</p> Example of the ftlen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftlen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ninstr 1\n\nift  = ftlen(p4)\n     print ift\naout loscil3 .8, 4, p4\n     outs aout, aout\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \nf 1 0 0 1 \"fox.wav\" 0 0 0 ;Csound computes tablesize\nf 2 0 0 1 \"drumsMlp.wav\" 0 0 0 ;Csound computes tablesize\n\ni 1 0 3 1 ;\"fox.wav\"\ni 1 3 3 2 ;\"drumsMlp.wav\"\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The audio file \u201cfox.wav\u201d is 121569 samples long, \u201cdrumsMlp.wav\u201d has a length of 88200 samples. The ftlen opcode reports them as 121568 and 88199 samples, because it reserves 1 point for the guard point. Its output should include lines like these:</p> <pre><code>instr 1:  ift = 121568.000\ninstr 1:  ift = 88199.000\n</code></pre>"},{"location":"opcodes/ftlen/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftlen/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe MIT Cambridge, Massachussetts 1997</p>"},{"location":"opcodes/ftload/","title":"Ftload","text":""},{"location":"opcodes/ftload/#ftload","title":"ftload","text":"<p>Load a set of previously-allocated tables from a file.</p>"},{"location":"opcodes/ftload/#syntax","title":"Syntax","text":"<pre><code>ftload Sfilename, iflag, ifn1 [, ifn2] [...]\n</code></pre>"},{"location":"opcodes/ftload/#initialization","title":"Initialization","text":"<p>Sfilename; -- A string value denoting name of the file to load.</p> <p>iflag -- Type of the file to load/save. (0 = binary file, Non-zero = text file)</p> <p>ifn1, ifn2, ... -- Numbers of tables to load.</p>"},{"location":"opcodes/ftload/#performance","title":"Performance","text":"<p>ftload loads a list of tables from a file. (The tables have to be already allocated though.) The file's format can be binary or text.</p> <p> Warning</p> <p>The file's format is not compatible with a WAV-file and is not endian-safe.</p>"},{"location":"opcodes/ftload/#examples","title":"Examples","text":"<p>See the example for ftsave.</p>"},{"location":"opcodes/ftload/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftload/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 4.21</p>"},{"location":"opcodes/ftloadk/","title":"Ftloadk","text":""},{"location":"opcodes/ftloadk/#ftloadk","title":"ftloadk","text":"<p>Load a set of previously-allocated tables from a file.</p>"},{"location":"opcodes/ftloadk/#syntax","title":"Syntax","text":"<pre><code>ftloadk Sfilename, ktrig, iflag, ifn1 [, ifn2] [...]\n</code></pre>"},{"location":"opcodes/ftloadk/#initialization","title":"Initialization","text":"<p>Sfilename -- A string value denoting the name of the file to load.</p> <p>iflag -- Type of the file to load/save. (0 = binary file, Non-zero = text file)</p> <p>ifn1, ifn2, ... -- Numbers of tables to load.</p>"},{"location":"opcodes/ftloadk/#performance","title":"Performance","text":"<p>ktrig -- The trigger signal. Load the file each time it is non-zero.</p> <p>ftloadk loads a list of tables from a file. (The tables have to be already allocated though.) The file's format can be binary or text. Unlike ftload, the loading operation can be repeated numerous times within the same note by using a trigger signal.</p> <p> Warning</p> <p>The file's format is not compatible with a WAV-file and is not endian-safe.</p>"},{"location":"opcodes/ftloadk/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftloadk/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 4.21</p>"},{"location":"opcodes/ftlptim/","title":"Ftlptim","text":""},{"location":"opcodes/ftlptim/#ftlptim","title":"ftlptim","text":"<p>Returns the loop segment start-time of a stored function table number.</p>"},{"location":"opcodes/ftlptim/#syntax","title":"Syntax","text":"<pre><code>ftlptim(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/ftlptim/#performance","title":"Performance","text":"<p>Returns the loop segment start-time (in seconds) of stored function table number x. This reports the duration of the direct recorded attack and decay parts of a sound sample, prior to its looped segment. Returns zero (and a warning message) if the sample does not contain loop points.</p>"},{"location":"opcodes/ftlptim/#examples","title":"Examples","text":"<p>Here is an example of the ftlptim opcode. It uses the files ftlptim.csd, and Church.wav.</p> Example of the ftlptim opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftlptim.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ninstr 1\n\nitim = ftlptim(1)\n     print itim\naout loscil3 .8, 40, 1\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"Church.wav\" 0 0 0 ;Csound computes tablesize\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The audio file \u201cChurch.wav\u201d is a looped sample, its output should include lines like these:</p> <pre><code>Base Note : 60  Detune    : 0\nLow  Note : 0   High Note : 127\nLow  Vel. : 0   High Vel. : 127\nGain      : 1   Count     : 1\nmode      : 801\nstart     : 4529    end       : 4912    count  :0\nmode      : 0\nstart     : 0   end       : 0   count  :0\n</code></pre>"},{"location":"opcodes/ftlptim/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftlptim/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe MIT Cambridge, Massachussetts 1997</p>"},{"location":"opcodes/ftmorf/","title":"Ftmorf","text":""},{"location":"opcodes/ftmorf/#ftmorf","title":"ftmorf","text":"<p>Uses an index into a table of ftable numbers to morph between adjacent tables in the list. This morphed function is written into the table referenced by iresfn on every k-cycle.</p>"},{"location":"opcodes/ftmorf/#syntax","title":"Syntax","text":"<pre><code>ftmorf kftndx, iftfn, iresfn\n</code></pre>"},{"location":"opcodes/ftmorf/#initialization","title":"Initialization","text":"<p>iftfn -- The table containing the numbers of any existing tables which are used for the morphing.</p> <p>iresfn -- Table number of the morphed function</p> <p>The length of all the tables in iftfn must equal the length of iresfn.</p>"},{"location":"opcodes/ftmorf/#performance","title":"Performance","text":"<p>kftndx -- the index into the iftfn table.</p> <p>If iftfn contains (6, 4, 6, 8, 7, 4):</p> <ul> <li>kftndx=4 will write the contents of f7 into iresfn.</li> <li>kftndx=4.5 will write the average of the contents of f7 and f4 into iresfn.</li> </ul> <p> Note</p> <p>iresfn is only updated if the morfing index changes it's value, if kftindx is static, no writing to iresfn will occur.</p>"},{"location":"opcodes/ftmorf/#examples","title":"Examples","text":"<p>Here is an example of the ftmorf opcode. It uses the file ftmorf.csd.</p> Example of the ftmorf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ftmorf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ninstr 1\n\nkndx  line   0, p3, 7\n      ftmorf kndx, 1, 2\nasig  oscili .8, 440, 2\n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 8 -2 3 4 5 6 7 8 9 10\nf2 0 1024 10 1 /*contents of f2 dont matter */\nf3 0 1024 10 1\nf4 0 1024 10 0 1\nf5 0 1024 10 0 0 1\nf6 0 1024 10 0 0 0 1\nf7 0 1024 10 0 0 0 0 1\nf8 0 1024 10 0 0 0 0 0 1\nf9 0 1024 10 0 0 0 0 0 0 1\nf10 0 1024 10 1 1 1 1 1 1 1\n\ni1 0 15\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Two musical examples featuring the ftmorf opcode: FtmorfRandomh_Cucchi.csd and Ftmorf_Cucchi.csd, both by Stefano Cucchi.</p>"},{"location":"opcodes/ftmorf/#see-also","title":"See also","text":"<p>Convolution and Morphing</p> <p>Read/Write Operations</p>"},{"location":"opcodes/ftmorf/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss University of Texas at Austin Austin, Texas USA Jan. 2002</p> <p>New in version 4.18</p>"},{"location":"opcodes/ftom/","title":"Ftom","text":""},{"location":"opcodes/ftom/#ftom","title":"ftom","text":"<p>Convert frequency to midi note number, taking global value of A4 into account.</p> <p>Plugin opcode in emugens.</p>"},{"location":"opcodes/ftom/#syntax","title":"Syntax","text":"<pre><code>imidi ftom ifreq [,irnd]\nkmidi ftom kfreq [,irnd]\nimidis[] ftom ifreqs[] [,irnd]\nkmidis[] ftom kfreqs[] [,irnd]\n</code></pre>"},{"location":"opcodes/ftom/#performance","title":"Performance","text":"<p>kfreq / ifreq -- Frequency</p> <p>irnd -- Optional, if non-zero the result is rounded to the nearest integer (default zero).</p> <p>kmidi / imidi -- Corresponding midi note number</p> <p> Note</p> <p>Set the global A4 value at the header to modify the tuning</p>"},{"location":"opcodes/ftom/#examples","title":"Examples","text":"<p>Here is an example of the ftom opcode. It uses the file mtof-ftom.csd.</p> Example of the ftom opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\nA4 = 440\n\ninstr 1\n  kfreq = mtof(69)\n  printks2 \"midi 69   -&gt; %f\\n\", kfreq\n\n  kmidi = ftom(442)\n  printks2 \"freq 442  -&gt; %f\\n\", kmidi\n\n  kmidi = ftom(442,1)\n  printks2 \"freq 442  -&gt; %f rounded\\n\", kmidi\n\n  kfreq = mtof(kmidi)\n  printks \"midi %f -&gt; %f\\n\", 1, kmidi, kfreq\n\n  imidi = ftom:i(440)\n  print imidi\n\n  ifreq = mtof:i(60)\n  print ifreq\n\n  turnoff\nendin\n\ninstr 2\n  imidis0[] fillarray 60, 62, 64, 69\n  ifreqs0[] mtof imidis0\n  printarray ifreqs0, \"\", \"ifreqs0\"\n\n  kfreqs[] fillarray 220, 440, 880\n  kmidis[] ftom kfreqs\n  puts \"kfreqs\", 1\n  printarray kmidis, 1, \"%.2f\", \"kmidis\"\n  turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ni 2 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftom/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/ftom/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p> <p>New in version 6.09</p> <p>Rounding option new in 6.12</p> <p>Array version new in 6.13</p>"},{"location":"opcodes/ftprint/","title":"Ftprint","text":""},{"location":"opcodes/ftprint/#ftprint","title":"ftprint","text":"<p>Print the contents of a table (for debugging)</p> <p>Plugin opcode in emugens.</p> <p>It works at k-time, a trigger controls when to print (use ktrig=1, which is the default, to print only at i-time)</p>"},{"location":"opcodes/ftprint/#syntax","title":"Syntax","text":"<pre><code>ftprint ifn [, ktrig, kstart, kend, kstep, inumcols ]\n</code></pre>"},{"location":"opcodes/ftprint/#initialization","title":"Initialization","text":"<p>ifn - The table to print</p> <p>inumcols - The number of elements to print in one column (default = 10)</p>"},{"location":"opcodes/ftprint/#performance","title":"Performance","text":"<p>ktrig - The table will be printed whenever this value changes from 0 to possitive. Can be used together with metro to print at a given time interval. A value of -1 indicates to print at each k-cycle (default = 1)</p> <p>kstart - The first index to print. (default = 0)</p> <p>kend - The end index to print (non inclusive). (default = length of table)</p> <p>kstep - How many elements to skip (default = 1)</p>"},{"location":"opcodes/ftprint/#examples","title":"Examples","text":"<p>Here is an example of the ftprint opcode. It uses the file ftprint.csd.</p> Example of the ftprint opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n--nosound\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; This is the example file for ftprint\n\n/*\n\n  ftprint\n\n  Print the contents of an f-table\n  (mostly for debuggin purposes)\n\n  ftprint ifn, ktrig=1, kstart=0, kend=0, kstep=1, inumcols=0\n\n  ifn: the table to print\n  ktrig: table will be printed whenever this changes\n         from non-positive to positive\n  kstart: start index\n  kend: end index (non inclusive)\n  kstep: number of elements to skip\n  inumcols: number of elements to print per line\n\n  See also: printarray\n\n*/\n\ninstr 1\n  ifn   ftgentmp 0, 0, -13, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n  ; print all elements\n  ftprint ifn\n\n  ; print all elements in columns of 4 elements\n  ftprint ifn, 1, 0, 0, 1, 4\n\n  ; assume that a table holds a 2D matrix, print the matrix \n  imatrix  ftgentmp 0, 0, 0, -2, \\\n      00, 01, 02, 03, 04,  \\\n      10, 11, 12, 13, 14,  \\\n      20, 21, 22, 23, 24,  \\\n      30, 31, 32, 33, 34\n\n  ; print the whole matrix, 5 columns per line\n  ftprint imatrix, 1, 0, 0, 1, 5\n\n  ; print one row\n  irow = 2\n  inumcols = 5\n  ftprint imatrix, 1, 2*inumcols, 3*inumcols\n\n  ; print one column\n  ftprint imatrix, 1, 3, 0, inumcols, 1\n\n  turnoff\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni 1 0 0.01\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftprint/#see-also","title":"See also","text":"<p>Printing and Display</p> <p>Read/Write Operations</p>"},{"location":"opcodes/ftprint/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/ftsamplebank/","title":"Ftsamplebank","text":""},{"location":"opcodes/ftsamplebank/#ftsamplebank","title":"ftsamplebank","text":"<p>Reads a directory for sound files and loads them to a series of GEN01 function tables.</p> <p>Plugin opcode in ftsamplebank.</p>"},{"location":"opcodes/ftsamplebank/#syntax","title":"Syntax","text":"<pre><code>iNumberOfFile ftsamplebank SDirectory, iFirstTableNumber, iSkipTime, iFormat, \\\n                           iChannel,\nkNumberOfFile ftsamplebank SDirectory, kFirstTableNumber, kTrigger, kSkipTime, \\\n                           kFormat, kChannel,\n</code></pre>"},{"location":"opcodes/ftsamplebank/#initialization","title":"Initialization","text":"<p>SDirectory -- a string that identifies the directory to browse for files</p> <p>FirstTableNumber -- this sets the number of the first table into which a soundfile will be loaded</p> <p>Trigger -- updates the tables when kTrigger is 1, only applicable to k-rate version.</p> <p>SkipTime -- begin reading at skiptime seconds into the file.</p> <p>Format -- specifies the audio data-file format:</p> <pre><code>1 - 8-bit signed character    4 - 16-bit short integers\n2 - 8-bit A-law bytes         5 - 32-bit long integers\n3 - 8-bit U-law bytes         6 - 32-bit floats\n</code></pre> <p>Channel -- channel number to read in. 0 denotes read all channels.</p> <p>If format = 0 the sample format is taken from the soundfile header, or by default from the CSound -o command-line flag.</p>"},{"location":"opcodes/ftsamplebank/#performance","title":"Performance","text":"<p>iNumberOfFile -- the number of tables that have been created</p> <p>kNumberOfFile -- the number of tables that have been created</p> <p> Note</p> <p>Loading a lot of sound files into function tables at k-rate may cause some audio dropouts.</p>"},{"location":"opcodes/ftsamplebank/#examples","title":"Examples","text":"<p>This example shows ftsamplebank browsing for samples in a fixed location. It loads all samples it finds into GEN01 function tables and then playsa them back in a sequence, one every second. It uses the file ftsamplebank.csd.</p> Example of the ftsamplebank opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o diskin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\n;load all samples in a given directory into function tables and play them using instrument 1000\ninstr 1\n   iFirstTableNumber = 60;\n   iFileCount init 1\n   iNumberOfFiles ftsamplebank \".\", iFirstTableNumber, 0, 4, 1\n\n   until iFileCount&gt;=iNumberOfFiles do\n        event_i \"i\", 1000, iFileCount, 1, iFirstTableNumber+iFileCount\n        iFileCount = iFileCount+1\n   enduntil\n\nendin\n\ninstr 1000\n   iTable = p4\n   aOut loscil3 1, 1, iTable, 1, 0;\n   outs aOut, aOut\nendin \n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftsamplebank/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftsamplebank/#credits","title":"Credits","text":"<p>Author: Rory Walsh 2015</p>"},{"location":"opcodes/ftsave/","title":"Ftsave","text":""},{"location":"opcodes/ftsave/#ftsave","title":"ftsave","text":"<p>Save a set of previously-allocated tables to a file.</p>"},{"location":"opcodes/ftsave/#syntax","title":"Syntax","text":"<pre><code>ftsave \"filename\", iflag, ifn1 [, ifn2] [...]\n</code></pre>"},{"location":"opcodes/ftsave/#initialization","title":"Initialization","text":"<p>\"filename\" -- A quoted string containing the name of the file to save.</p> <p>iflag -- Type of the file to save. (0 = binary file, Non-zero = text file)</p> <p>ifn1, ifn2, ... -- Numbers of tables to save.</p>"},{"location":"opcodes/ftsave/#performance","title":"Performance","text":"<p>ftsave saves a list of tables to a file. The file's format can be binary or text.</p> <p> Warning</p> <p>The file's format is not compatible with a WAV-file and is not endian-safe.</p>"},{"location":"opcodes/ftsave/#examples","title":"Examples","text":"<p>Here is an example of the ftsave opcode. It uses the file ftsave.csd.</p> Example of the ftsave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ftsave.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Table #1, make a sine wave using the GEN10 routine.\ngitmp1 ftgen 1, 0, 32768, 10, 1\n; Table #2, create an empty table.\ngitmp2 ftgen 2, 0, 32768, 7, 0, 32768, 0\n\n; Instrument #1 - a basic oscillator.\ninstr 1\n  kamp = 20000\n  kcps = 440\n  ; Use Table #1.\n  ifn = 1\n\n  a1 oscil kamp, kcps, ifn\n  out a1\nendin\n\n\n; Instrument #2 - Load Table #1 into Table #2.\ninstr 2\n  ; Save Table #1 to a file called \"table1.ftsave\".\n  ftsave \"table1.ftsave\", 0, 1\n\n  ; Load the \"table1.ftsave\" file into Table #2.\n  ftload \"table1.ftsave\", 0, 2\n\n  kamp = 20000\n  kcps = 440\n  ; Use Table #2, it should contain Table #1's sine wave now.\n  ifn = 2\n\n  a1 oscil kamp, kcps, ifn\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 1 second.\ni 1 0 1\n; Play Instrument #2 for 1 second.\ni 2 2 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftsave/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftsave/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>Example written by Kevin Conder.</p> <p>New in version 4.21</p>"},{"location":"opcodes/ftsavek/","title":"Ftsavek","text":""},{"location":"opcodes/ftsavek/#ftsavek","title":"ftsavek","text":"<p>Save a set of previously-allocated tables to a file.</p>"},{"location":"opcodes/ftsavek/#syntax","title":"Syntax","text":"<pre><code>ftsavek \"filename\", ktrig, iflag, ifn1 [, ifn2] [...]\n</code></pre>"},{"location":"opcodes/ftsavek/#initialization","title":"Initialization","text":"<p>\"filename\" -- A quoted string containing the name of the file to save.</p> <p>iflag -- Type of the file to save. (0 = binary file, Non-zero = text file)</p> <p>ifn1, ifn2, ... -- Numbers of tables to save.</p>"},{"location":"opcodes/ftsavek/#performance","title":"Performance","text":"<p>ktrig -- The trigger signal. Save the file each time it is non-zero.</p> <p>ftsavek saves a list of tables to a file. The file's format can be binary or text. Unlike ftsave, the saving operation can be repeated numerous times within the same note by using a trigger signal.</p> <p> Warning</p> <p>The file's format is not compatible with a WAV-file and is not endian-safe.</p>"},{"location":"opcodes/ftsavek/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftsavek/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 4.21</p>"},{"location":"opcodes/ftset/","title":"Ftset","text":""},{"location":"opcodes/ftset/#ftset","title":"ftset","text":"<p>Sets multiple elements of a table to a given value</p> <p>All elements of the table, or a slice (start:end:step) can be set at once. If all parameters are i-time variables, ftset will run only at init-time. Otherwise ftset is executed at each cycle.</p> <p>Plugin opcode in emugens</p>"},{"location":"opcodes/ftset/#syntax","title":"Syntax","text":"<pre><code>ftset ktablenum, kvalue [, kstart=0, kend=0, kstep=1 ]\nftset itablenum, ivalue [, istart=0, iend=0, istep=1 ]\n</code></pre>"},{"location":"opcodes/ftset/#performance","title":"Performance","text":"<p>ktablenum -- the number of the table to be modified</p> <p>kvalue -- the value to write to the table</p> <p>kstart -- the start index to modify (defaults to 0)</p> <p>kend -- the end index to modify. Defaults to 0, which indicates the end of the table. A negative index can be used to count from the end, so for example -1 will modifiy the table without changing the last element.</p> <p>kstep -- the increment to use between modified indexes. Defaults to 1, which means to modify every element between start and end</p>"},{"location":"opcodes/ftset/#examples","title":"Examples","text":"<p>Here is an example of the ftset opcode. It uses the file ftset.csd.</p> Example of the ftset opcode.<pre><code>csdo&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example file ftset\n\n/*\n\nftset: \n\nWrite a value to the whole table, or a slice of it.\n\nSyntax:\n\nftset ktablenum, kvalue, kstart=0, kend=0, kstep=1\nftset itablenum, ivalue, istart=0, iend=0, istep=1\n\nktablenum / itablenum: \ntable to be modified\n\nkvalue / ivalue: \nvalue to write to the table\n\nkstart / istart: \n    the index to start modifying\n\nkend / iend: \n   the end index to stop modifying. This is NOT inclusive. 0=end of table\n   Any negative index will be interpreted as counting from the end of the \n   table, so -2 will modify the whole table but the last two elements \n\nkstep / istep: \n    how many elements to skip\n\nSee also: tablecopy, tableicopy, tab2array\n*/\n\ninstr 1\n  ; clear the table\n  itable ftgentmp 0, 0, 13, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n  ftset itable, 0\n  ; print it at perf-time\n  ftprint itable, -1\n  turnoff\nendin\n\ninstr 2\n  ; Set all elements but the last 5 to 99\n  itable ftgentmp 0, 0, 13, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n  ftset itable, 99, 0, -5\n  ftprint itable, -1\n  turnoff\nendin\n\ninstr 3\n  ; ftset works at k-time so it can be used inside an if clause\n  ; Set all even elements to 0 at the 10th k-cycle\n  itable ftgentmp 0, 0, 10, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n  kcycle = timeinstk()\n  if kcycle == 10 then\n    ftset itable, 0, 0, 0, 2\n  endif\n  println \"cycle num: %d\", kcycle\n  ftprint itable, -1  ; print at each cycle\n  ; turnoff the instrument if table was indeed modified\n  if tab:k(6, itable) == 0 then\n    println \"Table was modified, turning off\"\n    turnoff\n  endif\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   0.1\ni 2 +   0.1\ni 3 +   0.1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftset/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftset/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2020</p>"},{"location":"opcodes/ftslice/","title":"Ftslice","text":""},{"location":"opcodes/ftslice/#ftslice","title":"ftslice","text":"<p>Copy a slice from an f-table to another f-table at performance</p> <p>Plugin opcode in emugens.</p> <p>The ftslice opcode takes an f-table and copies a slice to a second f-table (similar to tab2array, but between tables). This action is done at performance (every cycle), so that it can be placed inside a k-time if clause / loop / etc. For an init-only version, see ftslicei</p>"},{"location":"opcodes/ftslice/#syntax","title":"Syntax","text":"<pre><code>ftslice ifnsource, ifndest [, kstart, kend, kstep ]\nftslice kfnsource, kfndest [, kstart, kend, kstep ]\n</code></pre>"},{"location":"opcodes/ftslice/#initialization","title":"Initialization","text":"<p>ifnsource -- The table number to copy data from</p> <p>ifndest -- The table number to copy data to</p>"},{"location":"opcodes/ftslice/#performance","title":"Performance","text":"<p>kstart -- The index to start copying from. Defaults to 0</p> <p>kend -- The end index to stop copying. This is NOT inclusive. 0 means copy to the end of the table. Defaults to end of table</p> <p>kstep -- How many elements to skip. Defaults to 1</p>"},{"location":"opcodes/ftslice/#examples","title":"Examples","text":"<p>Here is an example of the ftslice opcode. It uses the file ftslice.csd.</p> Example of the ftslice opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example file ftslice\n\n/*\n\nftslice: \n\nCopy slice from source table to destination table\n\nSyntax:\n\nftslice ifnsource, ifndest, kstart=0, kend=0, kstep=1\n\nifnsource: source table\nifndest: destination table\nkstart: the index to start copying from\nkend: the end index to stop copying. This is NOT inclusive. 0=end of table\nkstep: how many elements to skip\n\nSee also: tablecopy, tableicopy, tab2array\n*/\n\ninstr 1\n  ifn   ftgentmp 0, 0, -13, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n  idest ftgentmp 0, 0, -11, -2,  0   ; empty table of size 11\n\n  ; copy only even elements\n  ftslice ifn, idest, 0, 0, 2\n  ftprint idest\n\n  ; copy too many elements - only the elements which fit in the dest table\n  ; are copyed\n\n  ftslice ifn, idest\n  ftprint idest  \n\n  turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   0.1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftslice/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftslice/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/ftslicei/","title":"Ftslicei","text":""},{"location":"opcodes/ftslicei/#ftslicei","title":"ftslicei","text":"<p>Copy a slice from an f-table to another f-table at init</p> <p>Plugin opcode in emugens.</p> <p>The ftslicei opcode takes an f-table and copies a slice to a second f-table (similar to tab2array, but between tables). This action is done at init time. For a performance-time version, see ftslice</p>"},{"location":"opcodes/ftslicei/#syntax","title":"Syntax","text":"<pre><code>ftslicei ifnsource, ifndest [, istart, iend, istep ]\n</code></pre>"},{"location":"opcodes/ftslicei/#initialization","title":"Initialization","text":"<p>ifnsource -- The table number to copy data from</p> <p>ifndest -- The table number to copy data to</p> <p>istart -- The index to start copying from. Defaults to 0</p> <p>iend -- The end index to stop copying. This is NOT inclusive. 0 means copy to the end of the table. Defaults to end of table</p> <p>istep -- How many elements to skip. Defaults to 1</p>"},{"location":"opcodes/ftslicei/#examples","title":"Examples","text":"<p>For an example, refer to the ftslice opcode: ftslice.csd.</p> Example of the ftslice opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example file ftslice\n\n/*\n\nftslice: \n\nCopy slice from source table to destination table\n\nSyntax:\n\nftslice ifnsource, ifndest, kstart=0, kend=0, kstep=1\n\nifnsource: source table\nifndest: destination table\nkstart: the index to start copying from\nkend: the end index to stop copying. This is NOT inclusive. 0=end of table\nkstep: how many elements to skip\n\nSee also: tablecopy, tableicopy, tab2array\n*/\n\ninstr 1\n  ifn   ftgentmp 0, 0, -13, -2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n  idest ftgentmp 0, 0, -11, -2,  0   ; empty table of size 11\n\n  ; copy only even elements\n  ftslice ifn, idest, 0, 0, 2\n  ftprint idest\n\n  ; copy too many elements - only the elements which fit in the dest table\n  ; are copyed\n\n  ftslice ifn, idest\n  ftprint idest  \n\n  turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   0.1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ftslicei/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/ftslicei/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/ftsr/","title":"Ftsr","text":""},{"location":"opcodes/ftsr/#ftsr","title":"ftsr","text":"<p>Returns the sampling-rate of a stored function table.</p>"},{"location":"opcodes/ftsr/#syntax","title":"Syntax","text":"<pre><code>ftsr(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/ftsr/#performance","title":"Performance","text":"<p>Returns the sampling-rate of a GEN01 generated table. The sampling-rate is determined from the header of the original file. If the original file has no header or the table was not created by these GEN01, ftsr returns 0. New in Csound version 3.49.</p>"},{"location":"opcodes/ftsr/#examples","title":"Examples","text":"<p>Here is an example of the ftsr opcode. It uses the file ftsr.csd.</p> Example of the ftsr opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out \n; For Non-realtime ouput leave only the line below: \n; -o ftsr.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\n; by Menno Knevel 2022\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\nitab = p4\nisr = ftsr(itab)\nprints \"\\nsampling-rate of table number %d = %d\\n\\n\", itab, isr\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"drumsSlp.wav\" 0 0 0  ;stereo file\nf 2 0 0 1 \"ahh.aiff\" 0 0 0      ;&amp; different formats\nf 3 0 0 1 \"beats.mp3\" 0 0 0\nf 4 0 0 1 \"beats.ogg\" 0 0 0\n\ni 1 0 1 1\ni 1 + 1 2\ni 1 + 1 3\ni 1 + 1 4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>its output should lines like these:</p> <pre><code>sampling-rate of table number 1 = 44100\nsampling-rate of table number 2 = 22050\nsampling-rate of table number 3 = 44100\nsampling-rate of table number 4 = 44100\n</code></pre>"},{"location":"opcodes/ftsr/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/ftsr/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy October 1998</p>"},{"location":"opcodes/gain/","title":"Gain","text":""},{"location":"opcodes/gain/#gain","title":"gain","text":"<p>Adjusts the amplitude audio signal according to a root-mean-square value.</p>"},{"location":"opcodes/gain/#syntax","title":"Syntax","text":"<pre><code>ares gain asig, krms [, ihp] [, iskip]\n</code></pre>"},{"location":"opcodes/gain/#initialization","title":"Initialization","text":"<p>ihp (optional, default=10) -- half-power point (in Hz) of a special internal low-pass filter. The default value is 10.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space (see reson). The default value is 0.</p>"},{"location":"opcodes/gain/#performance","title":"Performance","text":"<p>asig -- input audio signal</p> <p>gain provides an amplitude modification of asig so that the output ares has rms power equal to krms. rms and gain used together (and given matching ihp values) will provide the same effect as balance.</p>"},{"location":"opcodes/gain/#examples","title":"Examples","text":"<p>Here is an example of the gain opcode. It uses the file gain.csd.</p> Example of the gain opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gain.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n  asrc buzz  .8, 440, sr/440, 1    ; band-limited pulse train.\n  a1   reson asrc, 1000, 100       ; Sent through\n  a2   reson a1, 3000, 500         ; 2 filters\n  krms rms   asrc                  ; then balanced\n  afin gain  a2, krms              ; with source\n       outs  afin, afin\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gain/#see-also","title":"See also","text":"<p>Amplitude Modifiers and Dynamic processing</p>"},{"location":"opcodes/gain/#see-also_1","title":"See Also","text":"<p>balance, rms</p>"},{"location":"opcodes/gainslider/","title":"Gainslider","text":""},{"location":"opcodes/gainslider/#gainslider","title":"gainslider","text":"<p>An implementation of a logarithmic gain curve which is similar to the gainslider~ object from Cycling 74 Max / MSP.</p> <p>This opcode is intended for use to multiply by an audio signal to give a console mixer like feel. There is no bounds in the source code so you can for example give higher than 127 values for extra amplitude but possibly clipped audio.</p>"},{"location":"opcodes/gainslider/#syntax","title":"Syntax","text":"<pre><code>kout gainslider kindex\n</code></pre>"},{"location":"opcodes/gainslider/#performance","title":"Performance","text":"<p>kindex -- Index value. Nominal range from 0-127. For example a range of 0-152 will give you a range from -\u221e to +18.0 dB.</p> <p>kout -- Scaled output.</p>"},{"location":"opcodes/gainslider/#examples","title":"Examples","text":"<p>Here is an example of the gainslider opcode. It uses the file gainslider.csd.</p> Example of the gainslider opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent\n-odac           -iadc     -d    ;;;realtime output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =  48000\nksmps   =  100\nnchnls  =  2\n\n            instr   1       ; gainslider test\n\n; uncomment for realtime midi\n;kmod   ctrl7   1, 1, 0, 127\n\n; uncomment for non realtime\nkm0d phasor 1/10\nkmod scale km0d, 127, 0\n\nkout    gainslider      kmod\n        printks \"kmod = %f  kout = %f\\\\n\", 0.1, kmod, kout\naout    diskin2 \"fox.wav\", 1, 0, 1\naout    =       aout*kout\n        outs    aout, aout\n\n            endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1      0       30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gainslider/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/gainslider/#credits","title":"Credits","text":"<p>Author: David Akbari October 2006</p>"},{"location":"opcodes/gauss/","title":"Gauss","text":""},{"location":"opcodes/gauss/#gauss","title":"gauss","text":"<p>Gaussian distribution random number generator.</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/gauss/#syntax","title":"Syntax","text":"<pre><code>ares gauss krange\nires gauss irange\nkres gauss krange\nares gauss kmean, ksdev\nires gauss imean, isdev\nkres gauss kmean, ksdev\n</code></pre>"},{"location":"opcodes/gauss/#performance","title":"Performance","text":"<p>krange -- the range of the random numbers (-krange to +krange). Outputs both positive and negative numbers.</p> <p>kmean -- normal distribution mean.</p> <p>ksdev -- normal distribution standard deviation.</p> <p>The first version of gauss returns random numbers following a normal distribution centered around 0.0 (mu = 0.0) with a variance (sigma) of krange / 3.83. Thus more than 99.99% of the random values generated are in the range -krange to +krange. If a mean value different of 0.0 is desired, this mean value has to be added to the generated numbers (see example below).</p> <p>The second version takes mean and standard deviation as parameters. They use the more mathematically sound Box-Muller algorithm to compute the normal distribution.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/gauss/#examples","title":"Examples","text":"<p>Here is an example of the gauss opcode. It uses the file gauss.csd.</p> Example of the gauss opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n  -d -o dac\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\ninstr 1\nirange   = p4\nimu      = p5\nisamples = p6\nindx     = 0\nicount   = 1\nix       = 0.0\nix2      = 0.0\n\nloop:\ni1       gauss   irange\ni1       =       i1 + imu\nix       =       ix + i1\nix2      =       ix2 + i1*i1\nif i1 &gt;= -(irange+imu) &amp;&amp; i1 &lt;= (irange+imu) then\n  icount = icount+1\nendif\n         loop_lt indx, 1, isamples, loop\n\nimean    =       ix / isamples                         ;mean value\nistd     =       sqrt(ix2/isamples - imean*imean)      ;standard deviation\n         prints \"mean = %3.3f, std = %3.3f, \", imean, istd\n         prints \"samples inside the given range: %3.3f\\%\\n\", icount*100.0/isamples\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   0.1 1.0   0   100000  ; range = 1, mu = 0.0, sigma = 1/3.83 = 0.261\ni 1 0.1 0.1 3.83  0   100000  ; range = 3.83, mu = 0.0, sigma = 1\ni 1 0.2 0.1 5.745 2.7 100000  ; range = 5.745, mu = 2.7, sigma = 5.745/3.83 = 1.5\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>mean = 0.000, std = 0.260, samples inside the given range: 99.993%\nmean = 0.005, std = 0.999, samples inside the given range: 99.998%\nmean = 2.700, std = 1.497, samples inside the given range: 100.000%\n</code></pre>"},{"location":"opcodes/gauss/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/gauss/#credits","title":"Credits","text":"<p>Author (first version): Paris Smaragdis  MIT, Cambridge 1995 Author (second version): Victor Lazzarini Maynooth University, Ireland 2020</p> <p>Precisions about mu and sigma added by Fran\u00e7ois Pinot after a discussion with Joachim Heintz on the Csound List, December 2010.</p> <p>Example written by Fran\u00e7ois Pinot, adapted from a csd file by Joachim Heintz, December 010.</p> <p>Existed in 3.30</p>"},{"location":"opcodes/gausstrig/","title":"Gausstrig","text":""},{"location":"opcodes/gausstrig/#gausstrig","title":"gausstrig","text":"<p>Random impulses around a certain frequency.</p>"},{"location":"opcodes/gausstrig/#syntax","title":"Syntax","text":"<pre><code>ares gausstrig kamp, kcps, kdev [, imode] [, ifrst1]\nkres gausstrig kamp, kcps, kdev [, imode] [, ifrst1]\n</code></pre>"},{"location":"opcodes/gausstrig/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- imode &gt; 0 means better frequency modulation. If the frequency changes, the delay before the next impulse is calculed again. With the default mode we have the classic behavior of the GaussTrig ugen in SuperCollider, where the frequency modulation is bypassed during the delay time that precedes the next impulse.</p> <p>ifrst1 (optional, default=0) -- ifrst1 &gt; 0 changes the original behavior of the GuassTrig ugen. By default, it always generates an impulse in the very beginning. Otherwise, the first impulse appearance is random and depends on kcps and kdev parameters.</p>"},{"location":"opcodes/gausstrig/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kcps -- the mean frequency over which random impulses are distributed.</p> <p>kdev -- random deviation from mean (0 &lt;= dev &lt; 1).</p>"},{"location":"opcodes/gausstrig/#examples","title":"Examples","text":"<p>Here is an example of the gausstrig opcode. It uses the file gausstrig.csd.</p> Example of the gausstrig opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkdev line 0, p3, 0.9\nseed 20120125\naimp gausstrig 0.5, 10, kdev\naenv filter2 aimp, 1, 1, 0.993, 0.993\nanoi fractalnoise 0.2, 1.7\nal   = anoi*aenv\nar   delay al, 0.02\nouts al, ar\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the gausstrig opcode with imode = 1. It uses the file gausstrig-2.csd.</p> Example of the gausstrig opcode with imode = 1.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfrq0 oscil 8, 0.25, 1\nktrig metro 1\nkfrq  samphold kfrq0+8, ktrig \nseed  20120125\naimp  gausstrig 0.5, kfrq, 0.5, 1\naenv  filter2 aimp, 1, 1, 0.993, 0.993\nanoi  fractalnoise 0.2, 1.7\nal    = anoi*aenv\nar    delay al, 0.02\nouts  al, ar\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\ni1 0 16\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gausstrig/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/gausstrig/#credits","title":"Credits","text":"<p>Based on Bhob Rainey's GaussTrig ugen (SuperCollider) Author: Tito Latini January 2012 Modification: Gleb Rogozinsky March 2015</p> <p>New in Csound version 5.16</p>"},{"location":"opcodes/gbuzz/","title":"Gbuzz","text":""},{"location":"opcodes/gbuzz/#gbuzz","title":"gbuzz","text":"<p>Output is a set of harmonically related cosine partials.</p>"},{"location":"opcodes/gbuzz/#syntax","title":"Syntax","text":"<pre><code>ares gbuzz xamp, xcps, knh, klh, kmul, ifn [, iphs]\n</code></pre>"},{"location":"opcodes/gbuzz/#initialization","title":"Initialization","text":"<p>ifn -- table number of a stored function containing a cosine wave. A large table of at least 8192 points is recommended.</p> <p>iphs (optional, default=0) -- initial phase of the fundamental frequency, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is zero</p>"},{"location":"opcodes/gbuzz/#performance","title":"Performance","text":"<p>The buzz units generate an additive set of harmonically related cosine partials of fundamental frequency xcps, and whose amplitudes are scaled so their summation peak equals xamp. The selection and strength of partials is determined by the following control parameters:</p> <p>knh -- total number of harmonics requested. If knh is negative, the absolute value is used. If knh is zero, a value of 1 is used.</p> <p>klh -- lowest harmonic present. Can be positive, zero or negative. In gbuzz the set of partials can begin at any partial number and proceeds upwards; if klh is negative, all partials below zero will reflect as positive partials without phase change (since cosine is an even function), and will add constructively to any positive partials in the set.</p> <p>kmul -- specifies the multiplier in the series of amplitude coefficients. This is a power series: if the klh_th partial has a strength coefficient of A, the (_klh + n)th partial will have a coefficient of A * (kmul ** n), i.e. strength values trace an exponential curve. kmul may be positive, zero or negative, and is not restricted to integers.</p> <p>buzz and gbuzz _are useful as complex sound sources in subtractive synthesis. _buzz is a special case of the more general gbuzz in which klh = kmul = 1; it thus produces a set of knh equal-strength harmonic partials, beginning with the fundamental. (This is a band-limited pulse train; if the partials extend to the Nyquist, i.e. knh = int (sr / 2 / fundamental freq.), the result is a real pulse train of amplitude xamp.)</p> <p>Although both knh and klh may be varied during performance, their internal values are necessarily integer and may cause \u201cpops\u201d due to discontinuities in the output. kmul, however, can be varied during performance to good effect. gbuzz can be amplitude- and/or frequency-modulated by either control or audio signals.</p> <p>N.B. This unit has its analog in GEN11, in which the same set of cosines can be stored in a function table for sampling by an oscillator. Although computationally more efficient, the stored pulse train has a fixed spectral content, not a time-varying one as above.</p>"},{"location":"opcodes/gbuzz/#examples","title":"Examples","text":"<p>Here is an example of the gbuzz opcode. It uses the file gbuzz.csd.</p> Example of the gbuzz opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gbuzz.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ninstr 1\n\nkcps = 220\nknh  = p4               ;total no. of harmonics\nklh  = p5               ;lowest harmonic\nkmul line 0, p3, 1      ;increase amplitude of\n                        ;higer partials\nasig gbuzz .6, kcps, knh, klh, kmul, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; a cosine wave\nf 1 0 16384 11 1\n\ni 1 0 3 3  1 ;3 harmonics, lowest harmonic=1\ni 1 + 3 30 1 ;30 harmonics, lowest harmonic=1\ni 1 + 3 3  2 ;3 harmonics, lowest harmonic=3\ni 1 + 3 30 2 ;30 harmonics, lowest harmonic=3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gbuzz/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/gbuzz/#credits","title":"Credits","text":"<p>September 2003. Thanks to Kanata Motohashi for correcting the mentions of the kmul parameter.</p>"},{"location":"opcodes/genarray/","title":"Genarray","text":""},{"location":"opcodes/genarray/#genarray","title":"genarray","text":"<p>Generate a vector (one-dimensional k-rate or i-rate array) with an arithmetic sequence.</p>"},{"location":"opcodes/genarray/#syntax","title":"Syntax","text":"<pre><code>karray genarray kstart, kens[, inc]\niarray genarray istart, iens[, inc]\n</code></pre>"},{"location":"opcodes/genarray/#initialization","title":"Initialization","text":"<p>istart -- value to place in first element.</p> <p>iend -- last value to place in array.</p> <p>inc -- amount to add to previous value (default 1).</p>"},{"location":"opcodes/genarray/#examples","title":"Examples","text":"<p>Here is an example of the genarray opcode. It uses the file genarray.csd.</p> Example of the genarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n;create and fill two arrays\niArr1[] genarray 1, 6\niArr2[] genarray 1, 6, 2/3\n\n;print the content of iArr1\n        printf  \"%s\", 1, \"iArr1: start=1, end=6, step=default\\n\"\nkndx    =       0\n  until kndx == lenarray(iArr1) do\n        printf  \"iArr[%d] = %f\\n\", kndx+1, kndx, iArr1[kndx]\nkndx    +=      1\n  od\n\n;print the content of iArr2\n        printf  \"%s\", 1, \"iArr2: start=1, end=6, step=2/3\\n\"\nkndx    =       0\n  until kndx == lenarray(iArr2) do\n        printf  \"iArr[%d] = %f\\n\", kndx+1, kndx, iArr2[kndx]\nkndx    +=      1\n  od\n\n        turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/genarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/genarray/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2013</p> <p>New in version 6.00</p>"},{"location":"opcodes/gendy/","title":"Gendy","text":""},{"location":"opcodes/gendy/#gendy","title":"gendy","text":"<p>Dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis.</p> <p>Implementation of the G\u00e9n\u00e9ration Dynamique Stochastique (GENDYN), a dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis.</p>"},{"location":"opcodes/gendy/#syntax","title":"Syntax","text":"<pre><code>ares gendy kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n           kampscl, kdurscl [, initcps] [, knum]\nkres gendy kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n           kampscl, kdurscl [, initcps] [, knum]\n</code></pre>"},{"location":"opcodes/gendy/#initialization","title":"Initialization","text":"<p>initcps (optional, default=12) -- max number of control points.</p>"},{"location":"opcodes/gendy/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kampdist -- choice of probability distribution for the next perturbation of the amplitude of a control point. The valid distributions are:</p> <ul> <li>0 - LINEAR</li> <li>1 - CAUCHY</li> <li>2 - LOGIST</li> <li>3 - HYPERBCOS</li> <li>4 - ARCSINE</li> <li>5 - EXPON</li> <li>6 - SINUS (external k-rate signal)</li> </ul> <p>If kampdist=6, the user can use an external k-rate signal through kadpar.</p> <p>kdurdist -- choice of distribution for the perturbation of the current inter control point duration. See kampdist for the valid distributions. If kdurdist=6, the user can use an external k-rate signal through kddpar.</p> <p>kadpar -- parameter for the kampdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kddpar -- parameter for the kdurdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kminfreq -- minimum allowed frequency of oscillation.</p> <p>kmaxfreq -- maximum allowed frequency of oscillation.</p> <p>kampscl -- multiplier for the distribution's delta value for amplitude (1.0 is full range).</p> <p>kdurscl -- multiplier for the distribution's delta value for duration.</p> <p>knum (optional, default=initcps) -- current number of utilized control points.</p> <p>The waveform is generated by knum - 1 segments and is repeated in the time. The vertexes (control points) are moved according to a stochastic action and they are limited within the boundaries of a mirror formed by an amplitude barrier and a time barrier.</p> A repetition of the generated waveform with _knum_=12."},{"location":"opcodes/gendy/#examples","title":"Examples","text":"<p>Here is an example of the gendy opcode. It uses the file gendy.csd.</p> Example of the gendy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naout gendy 0.7, 1, 1, 1, 1, 20, 1000, 0.5, 0.5\nouts aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the gendy opcode with some modulations. It uses the file gendy-2.csd.</p> Example of the gendy opcode with some modulations.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkenv expseg 0.01, p3*0.1, 1, p3*0.8, 1, p3*0.1, 0.001\nkosc oscil 0.1, 3/p3, 1\nseed 20120123\nkdis bexprnd kosc\nknum linseg 3, p3*0.75, 10, p3*0.20, 12, p3*0.05, 5\nasig gendy 0.2, kosc*60, 6, 0.7, kdis, 500*kenv, 4800, 0.23, 0.3, 12, knum\naflt resonz asig, 1400, 400\naout comb kenv*aflt*0.1, 0.9, 0.1\nouts aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1 0 .8 0 0 .3 0 0 0 .1\n\ni1 0 20\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>References</p> <ol> <li>Formalized Music (1992, Stuyvesant, NY: Pendragon Press), pp. 246 - 254, 289 - 322.</li> </ol>"},{"location":"opcodes/gendy/#see-also","title":"See Also","text":"<p>Models and Emulations, gendyc, gendyx</p>"},{"location":"opcodes/gendy/#credits","title":"Credits","text":"<p>Based on Nick Collins's Gendy1 ugen (SuperCollider) Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p>"},{"location":"opcodes/gendyc/","title":"Gendyc","text":""},{"location":"opcodes/gendyc/#gendyc","title":"gendyc","text":"<p>Dynamic stochastic approach to waveform synthesis using cubic interpolation.</p> <p>Implementation with cubic interpolation of the G\u00e9n\u00e9ration Dynamique Stochastique (GENDYN), a dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis.</p>"},{"location":"opcodes/gendyc/#syntax","title":"Syntax","text":"<pre><code>ares gendyc kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl [, initcps] [, knum]\nkres gendyc kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl [, initcps] [, knum]\n</code></pre>"},{"location":"opcodes/gendyc/#initialization","title":"Initialization","text":"<p>initcps (optional, default=12) -- max number of control points.</p>"},{"location":"opcodes/gendyc/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kampdist -- choice of probability distribution for the next perturbation of the amplitude of a control point. The valid distributions are:</p> <ul> <li>0 - LINEAR</li> <li>1 - CAUCHY</li> <li>2 - LOGIST</li> <li>3 - HYPERBCOS</li> <li>4 - ARCSINE</li> <li>5 - EXPON</li> <li>6 - SINUS (external k-rate signal)</li> </ul> <p>If kampdist=6, the user can use an external k-rate signal through kadpar.</p> <p>kdurdist -- choice of distribution for the perturbation of the current inter control point duration. See kampdist for the valid distributions. If kdurdist=6, the user can use an external k-rate signal through kddpar.</p> <p>kadpar -- parameter for the kampdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kddpar -- parameter for the kdurdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kminfreq -- minimum allowed frequency of oscillation.</p> <p>kmaxfreq -- maximum allowed frequency of oscillation.</p> <p>kampscl -- multiplier for the distribution's delta value for amplitude (1.0 is full range).</p> <p>kdurscl -- multiplier for the distribution's delta value for duration.</p> <p>knum (optional, default=initcps) -- current number of utilized control points.</p> <p>The waveform is generated by knum - 1 segments and is repeated in the time. The vertexes (control points) are moved according to a stochastic action and they are limited within the boundaries of a mirror formed by an amplitude barrier and a time barrier.</p>"},{"location":"opcodes/gendyc/#examples","title":"Examples","text":"<p>Here is an example of the gendyc opcode. It uses the file gendyc.csd.</p> Example of the gendyc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naout gendyc 0.5, 1, 1, 1, 1, 220, 440, 0.5, 0.5\nouts aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>References</p> <ol> <li>Formalized Music (1992, Stuyvesant, NY: Pendragon Press), pp. 246 - 254, 289 - 322.</li> </ol>"},{"location":"opcodes/gendyc/#see-also","title":"See Also","text":"<p>Models and Emulations, gendy, gendyx</p>"},{"location":"opcodes/gendyc/#credits","title":"Credits","text":"<p>Based on Nick Collins's Gendy1 and Bhob Rainey's Gendy4 (SuperCollider) Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p>"},{"location":"opcodes/gendyx/","title":"Gendyx","text":""},{"location":"opcodes/gendyx/#gendyx","title":"gendyx","text":"<p>Variation of the dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis.</p> <p>gendyx (gendy eXtended) is an implementation of the G\u00e9n\u00e9ration Dynamique Stochastique (GENDYN), a dynamic stochastic approach to waveform synthesis conceived by Iannis Xenakis, using curves instead of segments.</p>"},{"location":"opcodes/gendyx/#syntax","title":"Syntax","text":"<pre><code>ares gendyx kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]\nkres gendyx kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \\\n            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]\n</code></pre>"},{"location":"opcodes/gendyx/#initialization","title":"Initialization","text":"<p>initcps (optional, default=12) -- max number of control points.</p>"},{"location":"opcodes/gendyx/#performance","title":"Performance","text":"<p>kamp -- amplitude.</p> <p>kampdist -- choice of probability distribution for the next perturbation of the amplitude of a control point. The valid distributions are:</p> <ul> <li>0 - LINEAR</li> <li>1 - CAUCHY</li> <li>2 - LOGIST</li> <li>3 - HYPERBCOS</li> <li>4 - ARCSINE</li> <li>5 - EXPON</li> <li>6 - SINUS (external k-rate signal)</li> </ul> <p>If kampdist=6, the user can use an external k-rate signal through kadpar.</p> <p>kdurdist -- choice of distribution for the perturbation of the current inter control point duration. See kampdist for the valid distributions. If kdurdist=6, the user can use an external k-rate signal through kddpar.</p> <p>kadpar -- parameter for the kampdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kddpar -- parameter for the kdurdist distribution. Should be in the range of 0.0001 to 1.</p> <p>kminfreq -- minimum allowed frequency of oscillation.</p> <p>kmaxfreq -- maximum allowed frequency of oscillation.</p> <p>kampscl -- multiplier for the distribution's delta value for amplitude (1.0 is full range).</p> <p>kdurscl -- multiplier for the distribution's delta value for duration.</p> <p>kcurveup -- controls the curve for the increasing amplitudes between two points; it has to be non negative.</p> <ul> <li>0: step function (like a sample &amp; hold)</li> <li>&lt;1: concave</li> <li>1: linear (like gendy)</li> <li>&gt;1: convex</li> </ul> <p>kcurvedown -- controls the curve for the decreasing amplitudes between two points; it has to be non negative.</p> <ul> <li>0: step function</li> <li>&lt;1: convex</li> <li>1: linear</li> <li>&gt;1: concave</li> </ul> <p>knum (optional, default=initcps) -- current number of utilized control points.</p> <p>The waveform is generated by knum - 1 curves and is repeated in the time. The vertexes (control points) are moved according to a stochastic action and they are limited within the boundaries of a mirror formed by an amplitude barrier and a time barrier.</p> Extract of a waveform generated with _gendyx_."},{"location":"opcodes/gendyx/#examples","title":"Examples","text":"<p>Here is an example of the gendyx opcode. It uses the file gendyx.csd.</p> Example of the gendyx opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naout gendyx 0.7, 1, 1, 1, 1, 20, 1000, 0.5, 0.5, 4, 0.13\nouts aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the gendyx opcode with some modulations. It uses the file gendyx-2.csd.</p> Example of the gendyx opcode with some modulations.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkenv expseg 0.001, p3*0.05, 0.5, p3*0.9, 0.5, p3*0.05, 0.001\nkc1  linseg 1, p3/2, 12, p3/2, 3\nkc2  random 0, 4\nseed 20120124\nasig gendyx kenv, 1, 3, 0.7, 0.8, 120, 4300, 0.2, 0.7, kc1, kc2, 12, kc1\naout dcblock asig\nouts aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 20\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>References</p> <ol> <li>Formalized Music (1992, Stuyvesant, NY: Pendragon Press), pp. 246 - 254, 289 - 322.</li> </ol>"},{"location":"opcodes/gendyx/#see-also","title":"See Also","text":"<p>Models and Emulations, gendyc, gendy</p>"},{"location":"opcodes/gendyx/#credits","title":"Credits","text":"<p>Variation of the Nick Collins's Gendy1 ugen (SuperCollider) Author: Tito Latini January 2012</p> <p>New in Csound version 5.16</p>"},{"location":"opcodes/getcfg/","title":"Getcfg","text":""},{"location":"opcodes/getcfg/#getcfg","title":"getcfg","text":"<p>Return various configuration settings in Svalue as a string at init time.</p>"},{"location":"opcodes/getcfg/#syntax","title":"Syntax","text":"<pre><code>Svalue getcfg iopt\n</code></pre>"},{"location":"opcodes/getcfg/#initialization","title":"Initialization","text":"<p>iopt -- The parameter to be returned, can be one of:</p> <ul> <li>1: the maximum length of string variables in characters; this is at least the value of the -+max_str_len command line option - 1.</li> </ul> <p> Note</p> <p>In Csound6 there is no maximum string length so the returned value is meaningless</p> <ul> <li>2: the input sound file name (-i), or empty if there is no input file</li> <li>3: the output sound file name (-o), or empty if there is no output file</li> <li>4: return \"1\" if real time audio input or output is being used, and \"0\" otherwise</li> <li>5: return \"1\" if running in beat mode (-t command line option), and \"0\" otherwise</li> <li>6: the host operating system name</li> <li>7: return \"1\" if a callback function for the chnrecv and chnsend opcodes has been set, and \"0\" otherwise (which means these opcodes do nothing)</li> </ul>"},{"location":"opcodes/getcfg/#examples","title":"Examples","text":"<p>Here is an example of the getcfg opcode. It uses the file getcfg.csd.</p> Example of the getcfg opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nS1 getcfg 1     ; -+max_str_len \nS2 getcfg 2     ; -i \nS3 getcfg 3     ; -o \nS4 getcfg 4     ; RTaudio \nS5 getcfg 5     ; -t \nS6 getcfg 6     ; os system host \nS7 getcfg 7     ; callback \n\nprints \"------------------------------\" \nprints \"\\nMax string len : \" \nprints  S1 \nprints \"\\nInput file name (-i) : \" \nprints  S2 \nprints \"\\nOutput file name (-o) : \" \nprints  S3 \nprints \"\\nRTaudio (-odac) : \" \nprints  S4 \nprints \"\\nBeat mode (-t)? : \" \nprints  S5 \nprints \"\\nHost Op. Sys. : \" \nprints  S6 \nprints \"\\nCallback ? : \" \nprints  S7 \nprints \"\\n\" \nprints \"------------------------------\\n\" \n\nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \ni 1 0 0 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>The output should include lines like these:</p> <pre><code>------------------------------\nMax string len : 255\nInput file name (-i) : adc\nOutput file name (-o) : dac\nRTaudio (-odac) : 1\nBeat mode (-t)? : 0\nHost Op. Sys. : Linux\nCallback ? : 0\n------------------------------\n</code></pre>"},{"location":"opcodes/getcfg/#see-also","title":"See also","text":"<p>Sensing and Control: System</p>"},{"location":"opcodes/getcfg/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2006</p> <p>New in version 5.02</p>"},{"location":"opcodes/getcol/","title":"Getcol","text":""},{"location":"opcodes/getcol/#getcol","title":"getcol","text":"<p>Gets a given column from a 2-dimensional array as a vector.</p> <p>The output is an 1-d array with the contents of the requested column</p>"},{"location":"opcodes/getcol/#syntax","title":"Syntax","text":"<pre><code>i/kout[] getcol i/kin[], i/kcol\n</code></pre>"},{"location":"opcodes/getcol/#initialization","title":"Initialization","text":"<p>iout[] -- output array containing the extracted column. It will be created if it does not exist.</p> <p>iin[] -- input 2-dimensional array.</p> <p>icol -- column to be extracted.</p>"},{"location":"opcodes/getcol/#performance","title":"Performance","text":"<p>kout[] -- output array containing the extracted column. It will be created if it does not exist.</p> <p>kin[] -- input 2-dimensional array.</p> <p>kcol -- column to be extracted.</p>"},{"location":"opcodes/getcol/#examples","title":"Examples","text":"<p>Here is an example of the getcol opcode. It uses the file getcol.csd.</p> Example of the getcol opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n kcnt init 0\n kArr[] init 3,3\n kArr[] fillarray  0,1,2,0,1,2,0,1,2\n while kcnt &lt; 3 do\n  kVec[] getcol kArr,kcnt\n  printf \"column %d: %d %d %d\\n\",kcnt+1,kcnt,kVec[0],kVec[1],kVec[2] \n  kcnt += 1\n od\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/getcol/#see-also","title":"See Also","text":"<p>Vectorial Opcodes</p> <p>Array Opcodes</p>"},{"location":"opcodes/getcol/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2014</p> <p>New in version 6.04</p>"},{"location":"opcodes/getftargs/","title":"Getftargs","text":""},{"location":"opcodes/getftargs/#getftargs","title":"getftargs","text":"<p>Fill a string variable with the arguments used to create a function table at k-rate.</p> <p>Plugin opcode in getftargs.</p> <p>getftargs runs both at initialization and performance time.</p>"},{"location":"opcodes/getftargs/#syntax","title":"Syntax","text":"<pre><code>Sdst getftargs iftno, ktrig\n</code></pre>"},{"location":"opcodes/getftargs/#initialization","title":"Initialization","text":"<p>ifno -- Number of the table whose arguments we want to request.</p>"},{"location":"opcodes/getftargs/#performance","title":"Performance","text":"<p>Sdst -- output string variable.</p> <p>ktrig -- trigger signal, should be valid at i-time. The output string variable is filled at initialization time if ktrig is positive, and at performance time whenever ktrig is both positive and different from the previous value. Use a constant value of 1 to print once at note initialization.</p>"},{"location":"opcodes/getftargs/#examples","title":"Examples","text":"<p>Here is an example of the getftargs opcode. It uses the file getftargs.csd.</p> Example of the getftargs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o getftargs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nSargs getftargs 1, 1\nputs Sargs, 1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 \"quadbezier\" 0 0 0.5 200 0.8 450 0.33 600 0.1 800 0.4 1024 0\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include this line:</p> <pre><code>0 0 0.5 200 0.8 450 0.33 600 0.1 800 0.4 1024 0\n</code></pre>"},{"location":"opcodes/getftargs/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/getftargs/#credits","title":"Credits","text":"<p>Written by Guillermo Senna</p> <p>2016</p>"},{"location":"opcodes/getrow/","title":"Getrow","text":""},{"location":"opcodes/getrow/#getrow","title":"getrow","text":"<p>Gets a given row from a 2-dimensional array as a vector.</p> <p>The output is an 1-d array with the contents of the requested row.</p>"},{"location":"opcodes/getrow/#syntax","title":"Syntax","text":"<pre><code>i/kout[] getrow i/kin[], i/krow\n</code></pre>"},{"location":"opcodes/getrow/#initialization","title":"Initialization","text":"<p>iout[] -- output array containing the extracted row. It will be created if it does not exist.</p> <p>iin[] -- input 2-dimensional array.</p> <p>irow -- row to be extracted.</p>"},{"location":"opcodes/getrow/#performance","title":"Performance","text":"<p>kout[] -- output array containing the extracted row. It will be created if it does not exist.</p> <p>kin[] -- input 2-dimensional array.</p> <p>krow -- row to be extracted.</p>"},{"location":"opcodes/getrow/#examples","title":"Examples","text":"<p>Here is an example of the getrow opcode. It uses the file rfft.csd.</p> Example of the getrow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n-d -o dac\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n;ksmps needs to be an integer div of hopsize\nksmps = 64\n0dbfs=1\n\ninstr 1\n\n ihopsize = 256   ; hopsize\n ifftsize = 1024  ; FFT size\n iolaps = ifftsize/ihopsize ; overlaps\n ibw = sr/ifftsize ; bin bandwidth\n kcnt init 0    ; counting vars\n krow init 0\n\n kOla[] init ifftsize ; overlap-add buffer\n kIn[] init ifftsize  ; input buffer\n kSw[] init ifftsize\n kOut[][] init iolaps, ifftsize ; output buffers\n\n a1 diskin2 \"fox.wav\",1,0,1 ; audio input\n ks  expon  100, p3, 1000\n asw vco2  0.15, ks\n\n /* every hopsize samples */\n if kcnt == ihopsize then\n   /* window and take FFT */\n   kWin[] window kIn,krow*ihopsize\n   kSpec[] rfft kWin\n   kWin window kSw,krow*ihopsize\n   kSpec2[] rfft kWin\n   kProd[] cmplxprod kSpec, kSpec2\n\n   /* IFFT + window */\n   kRow[] rifft kProd + kSpec\n   kWin window kRow, krow*ihopsize\n   /* place it on out buffer */\n   kOut setrow kWin, krow\n\n   /* zero the ola buffer */\n   kOla = 0\n   /* overlap-add */\n   ki = 0\n   until ki == iolaps do\n     kRow getrow kOut, ki\n     kOla = kOla + kRow\n     ki += 1\n   od\n\n  /* update counters */\n  krow = (krow+1)%iolaps\n  kcnt = 0\n endif\n\n /* shift audio in/out of buffers */\n kIn shiftin a1\n kSw shiftin asw\n a2 shiftout kOla\n    out a2/iolaps\n\n /* increment counter */\n kcnt += ksmps\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 10\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/getrow/#see-also","title":"See Also","text":"<p>Vectorial Opcodes</p> <p>Array Opcodes</p>"},{"location":"opcodes/getrow/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2014</p> <p>New in version 6.04</p>"},{"location":"opcodes/getseed/","title":"Getseed","text":""},{"location":"opcodes/getseed/#getseed","title":"getseed","text":"<p>Reads the global seed value.</p> <p>Returns the global seed value used for all x-class noise generators.</p>"},{"location":"opcodes/getseed/#syntax","title":"Syntax","text":"<pre><code>ians getseed\nkans getseed\n</code></pre>"},{"location":"opcodes/getseed/#performance","title":"Performance","text":"<p>Reads the global seed value of the internal pseudo-random number generator.</p>"},{"location":"opcodes/getseed/#examples","title":"Examples","text":"<p>Here is an example of the getseed opcode. It uses the file getseed.csd.</p> Example of the getseed opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o getseed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel - 2021\n\nseed 0    ; use seed from system clock\n\ninstr 1   ; different values every time - value is derived from system clock\n\nkrnd  randomh 100, 400, 1               \n      printks2    \"different values every time Value = %d\\n \",  krnd    \naout  poscil 0.8, 440+krnd\n      outs aout, aout\nendin\n\ninstr 2   ; same values every time - captured by getseed\n\ngised getseed                 ; capture the clock seed value and make it a global value\nseed  gised                   ; so that it can be used in all instruments\nprint gised\nkrnd  randomh 100, 400, 1               \n      printks2    \"get seed value from time clock. Value = %d\\n \",  krnd        \naout  poscil 0.8, 440+krnd\n      outs aout, aout\nendin\n\ninstr 3 ; same values every time - captured by getseed\n\nprint gised                   ; check the global seed value\nseed  gised                   ; let the seed get this value\nkrnd  randomh 100, 400, 1               \n      printks2    \"re-uses seed value of instr 2. Value = %d\\n \",  krnd \naout  poscil 0.8, 440+krnd\n      outs aout, aout\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 3  ; 2 notes showing the different\ni1 5 3\n\ni2 10 3 ; 1 note &amp; get the seed value\n\ni3 15 3 ; 1 note and use that seed value again\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/getseed/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/getseed/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/NUIM/Codemist Ltd. Bath, UK August 2015</p> <p>New in Csound6.06</p>"},{"location":"opcodes/gogobel/","title":"Gogobel","text":""},{"location":"opcodes/gogobel/#gogobel","title":"gogobel","text":"<p>Audio output is a tone related to the striking of a cow bell or similar.</p> <p>The method is a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/gogobel/#syntax","title":"Syntax","text":"<pre><code>ares gogobel kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivfn\n</code></pre>"},{"location":"opcodes/gogobel/#initialization","title":"Initialization","text":"<p>ihrd -- the hardness of the stick used in the strike. A range of 0 to 1 is used. 0.5 is a suitable value.</p> <p>ipos -- where the block is hit, in the range 0 to 1.</p> <p>imp -- a table of the strike impulses. The file marmstk1.wav is a suitable function from measurements and can be loaded with a GEN01 table. It is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p> <p>ivfn -- shape of vibrato, usually a sine table, created by a function.</p>"},{"location":"opcodes/gogobel/#performance","title":"Performance","text":"<p>A note is played on a cowbell-like instrument, with the arguments as below.</p> <p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/gogobel/#examples","title":"Examples","text":"<p>Here is an example of the gogobel opcode. It uses the file gogobel.csd, and marmstk1.wav,</p> Example of the gogobel opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gogobel.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n   kfreq = 200\n   ihrd = 0.5\n   ipos = p4\n   kvibf = 6.0\n   kvamp = 0.3\n\nasig gogobel .9, kfreq, ihrd, ipos, 1, 6.0, 0.3, 2\n     outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;audio file\nf 1 0 256 1 \"marmstk1.wav\" 0 0 0\n;sine wave for the vibrato\nf 2 0 128 10 1\n\ni 1 0.5 0.5 0.01\ni 1 + 0.5 0.561\ni 1 + 0.5 0.9\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gogobel/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/gogobel/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/goto/","title":"Goto","text":""},{"location":"opcodes/goto/#goto","title":"goto","text":"<p>Transfer control to label on every pass. (Combination of igoto and kgoto)</p>"},{"location":"opcodes/goto/#syntax","title":"Syntax","text":"<pre><code>goto label\n</code></pre> <p>where label is in the same instrument block and is not an expression.</p> <p> Note</p> <p>Using goto not as part of an if statement (as in: goto end), will cause initialization to be skipped on all the code the goto jumps over. In performance, leaving some opcodes uninitialized will cause deletion of the note/event. In these cases, using kgoto (as in: kgoto end) might be preferred.</p>"},{"location":"opcodes/goto/#examples","title":"Examples","text":"<p>Here is an example of the goto opcode. It uses the file goto.csd.</p> Example of the goto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o goto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  a1 oscil 10000, 440, 1\n  goto playit\n\n  ; The goto will go to the playit label.\n  ; It will skip any code in between like this comment.\n\nplayit:\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/goto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/goto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p> <p>Added a note by Jim Aikin.</p>"},{"location":"opcodes/grain/","title":"Grain","text":""},{"location":"opcodes/grain/#grain","title":"grain","text":"<p>Generates granular synthesis textures.</p>"},{"location":"opcodes/grain/#syntax","title":"Syntax","text":"<pre><code>ares grain xamp, xpitch, xdens, kampoff, kpitchoff, kgdur, igfn, \\\n           iwfn, imgdur [, igrnd]\n</code></pre>"},{"location":"opcodes/grain/#initialization","title":"Initialization","text":"<p>igfn -- The ftable number of the grain waveform. This can be just a sine wave or a sampled sound.</p> <p>iwfn -- Ftable number of the amplitude envelope used for the grains (see also GEN20).</p> <p>imgdur -- Maximum grain duration in seconds. This is the biggest value to be assigned to kgdur.</p> <p>igrnd (optional) -- if non-zero, turns off grain offset randomness. This means that all grains will begin reading from the beginning of the igfn table. If zero (the default), grains will start reading from random igfn table positions.</p>"},{"location":"opcodes/grain/#performance","title":"Performance","text":"<p>xamp -- Amplitude of each grain.</p> <p>xpitch -- Grain pitch. To use the original frequency of the input sound, use the formula:</p> <pre><code>sndsr / ftlen(_igfn_)\n</code></pre> <p>where sndsr is the original sample rate of the igfn sound.</p> <p>xdens -- Density of grains measured in grains per second. If this is constant then the output is synchronous granular synthesis, very similar to fof. If xdens has a random element (like added noise), then the result is more like asynchronous granular synthesis.</p> <p>kampoff -- Maximum amplitude deviation from xamp. This means that the maximum amplitude a grain can have is xamp + kampoff and the minimum is xamp. If kampoff is set to zero then there is no random amplitude for each grain.</p> <p>kpitchoff -- Maximum pitch deviation from xpitch in Hz. Similar to kampoff.</p> <p>kgdur -- Grain duration in seconds. The maximum value for this should be declared in imgdur. If kgdur at any point becomes greater than imgdur, it will be truncated to imgdur.</p> <p>The grain generator is based primarily on work and writings of Barry Truax and Curtis Roads.</p>"},{"location":"opcodes/grain/#examples","title":"Examples","text":"<p>This example generates a texture with gradually shorter grains and wider amp and pitch spread. It uses the file grain.csd, and drumsMlp.wav.</p> Example of the grain opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too \n; For Non-realtime ouput leave only the line below: \n; -o grain.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1 \n\ninsnd   = 10 \nibasfrq = 44100 / ftlen(insnd) ; Use original sample rate of insnd file \n\nkamp   expseg .001, p3/2, .1, p3/2, .01 ;a swell in amplitude\nkpitch line ibasfrq, p3, ibasfrq * .8 \nkdens  line 600, p3, 100 \nkaoff  line 0, p3, .1\nkpoff  line 0, p3, ibasfrq * .5 \nkgdur  line .4, p3, .01\nimaxgdur =  .5 \n\nasigL  grain kamp, kpitch, kdens, kaoff, kpoff, kgdur, insnd, 5, imaxgdur, 0.0 \nasigR  grain kamp, kpitch, kdens, kaoff, kpoff, kgdur, insnd, 5, imaxgdur, 0.0 \n       outs asigL, asigR\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \nf5  0 512  20 2 ; Hanning window \nf10 0 16384 1  \"drumsMlp.wav\" 0 0 0 \n\ni1 0 15 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/grain/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/grain/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT May 1997</p>"},{"location":"opcodes/grain2/","title":"Grain2","text":""},{"location":"opcodes/grain2/#grain2","title":"grain2","text":"<p>Easy-to-use granular synthesis texture generator.</p> <p>Generate granular synthesis textures. grain2 is simpler to use, but grain3 offers more control.</p>"},{"location":"opcodes/grain2/#syntax","title":"Syntax","text":"<pre><code>ares grain2 kcps, kfmd, kgdur, iovrlp, kfn, iwfn [, irpow] \\\n            [, iseed] [, imode]\n</code></pre>"},{"location":"opcodes/grain2/#initialization","title":"Initialization","text":"<p>iovrlp -- (fixed) number of overlapping grains.</p> <p>iwfn -- function table containing window waveform (Use GEN20 to calculate iwfn).</p> <p>irpow (optional, default=0) -- this value controls the distribution of grain frequency variation.  If irpow is positive, the random distribution (x is in the range -1 to 1) is</p> <pre><code>abs(x) ^ ((1 / irpow) - 1);\n</code></pre> <p>for negative irpow values, it is <pre><code>(1 - abs(x)) ^ ((-1 / irpow) - 1)\n</code></pre></p> <p>Setting irpow to -1, 0, or 1 will result in uniform distribution (this is also faster to calculate). The image below shows some examples for irpow. The default value of irpow is 0.</p> A graph of distributions for different values of . <p>iseed (optional, default=0) -- seed value for random number generator (positive integer in the range 1 to 2147483646 (2<sup>31</sup> - 2)). Zero or negative value seeds from current time (this is also the default).</p> <p>imode (optional default=0) -- sum of the following values:</p> <ul> <li>8: interpolate window waveform (slower).</li> <li>4: do not interpolate grain waveform (fast, but lower quality).</li> <li>2: grain frequency is continuously modified by kcps and kfmd (by default, each grain keeps the frequency it was launched with). This may be slower at high control rates.</li> <li>1: skip initialization.</li> </ul>"},{"location":"opcodes/grain2/#performance","title":"Performance","text":"<p>ares -- output signal.</p> <p>kcps -- grain frequency in Hz.</p> <p>kfmd -- random variation (bipolar) in grain frequency in Hz.</p> <p>kgdur -- grain duration in seconds. kgdur also controls the duration of already active grains (actually the speed at which the window function is read). This behavior does not depend on the imode flags.</p> <p>kfn -- function table containing grain waveform. Table number can be changed at k-rate (this is useful to select from a set of band-limited tables generated by GEN30, to avoid aliasing).</p> <p> Note</p> <p>grain2 internally uses the same random number generator as rnd31. So reading its documentation is also recommended.</p>"},{"location":"opcodes/grain2/#examples","title":"Examples","text":"<p>Here is an example of the grain2 opcode. It uses the file grain2.csd.</p> Example of the grain2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o grain2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =  48000\nkr      =  750\nksmps   =  64\nnchnls  =  2\n\n/* square wave */\ni_      ftgen 1, 0, 4096, 7, 1, 2048, 1, 0, -1, 2048, -1\n/* window */\ni_      ftgen 2, 0, 16384, 7, 0, 4096, 1, 4096, 0.3333, 8192, 0\n/* sine wave */\ni_      ftgen 3, 0, 1024, 10, 1\n/* room parameters */\ni_      ftgen 7, 0, 64, -2, 4, 50, -1, -1, -1, 11,                      \\\n                            1, 26.833, 0.05, 0.85, 10000, 0.8, 0.5, 2,  \\\n                            1,  1.753, 0.05, 0.85,  5000, 0.8, 0.5, 2,  \\\n                            1, 39.451, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 33.503, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 36.151, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 29.633, 0.05, 0.85,  7000, 0.8, 0.5, 2\n\nga01  init 0\n\n/* generate bandlimited square waves */\n\ni0     =  0\nloop1:\nimaxh  =  sr / (2 * 440.0 * exp(log(2.0) * (i0 - 69) / 12))\ni_     ftgen i0 + 256, 0, 4096, -30, 1, 1, imaxh\ni0     =  i0 + 1\n       if (i0 &lt; 127.5) igoto loop1\n\n       instr 1\n\np3     =  p3 + 0.2\n\n/* note velocity */\niamp   =  0.0039 + p5 * p5 / 16192\n/* vibrato */\nkcps   oscili 1, 8, 3\nkenv   linseg 0, 0.05, 0, 0.1, 1, 1, 1\n/* frequency */\nkcps   =  (kcps * kenv * 0.01 + 1) * 440 * exp(log(2) * (p4 - 69) / 12)\n/* grain ftable */\nkfn    =  int(256 + 69 + 0.5 + 12 * log(kcps / 440) / log(2))\n/* grain duration */\nkgdur  port 100, 0.1, 20\nkgdur  =  kgdur / kcps\n\na1     grain2 kcps, kcps * 0.02, kgdur, 50, kfn, 2, -0.5, 22, 2\na1     butterlp a1, 3000\na2     grain2 kcps, kcps * 0.02, 4 / kcps, 50, kfn, 2, -0.5, 23, 2\na2     butterbp a2, 12000, 8000\na2     butterbp a2, 12000, 8000\naenv1  linseg 0, 0.01, 1, 1, 1\naenv2  linseg 3, 0.05, 1, 1, 1\naenv3  linseg 1, p3 - 0.2, 1, 0.07, 0, 1, 0\n\na1     =  aenv1 * aenv3 * (a1 + a2 * 0.7 * aenv2)\n\nga01   =  ga01 + a1 * 10000 * iamp\n\n       endin\n\n/* output instr */\n\n       instr 81\n\ni1     =  0.000001\naLl, aLh, aRl, aRh  spat3di ga01 + i1*i1*i1*i1, 3.0, 4.0, 0.0, 0.5, 7, 4\nga01   =  0\naLl    butterlp aLl, 800.0\naRl    butterlp aRl, 800.0\n\n       outs aLl + aLh, aRl + aRh\n\n       endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nt 0 60\n\ni 1 0.0 1.3 60 127\ni 1 2.0 1.3 67 127\ni 1 4.0 1.3 64 112\ni 1 4.0 1.3 72 112\n\ni 81 0 6.4\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/grain2/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/grain2/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.15</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/grain3/","title":"Grain3","text":""},{"location":"opcodes/grain3/#grain3","title":"grain3","text":"<p>Generate granular synthesis textures with more user control.</p> <p>grain2 is simpler to use but grain3 offers more control.</p>"},{"location":"opcodes/grain3/#syntax","title":"Syntax","text":"<pre><code>ares grain3 kcps, kphs, kfmd, kpmd, kgdur, kdens, imaxovr, kfn, iwfn, \\\n            kfrpow, kprpow [, iseed] [, imode]\n</code></pre>"},{"location":"opcodes/grain3/#initialization","title":"Initialization","text":"<p>imaxovr -- maximum number of overlapping grains. The number of overlaps can be calculated by (kdens * kgdur); however, it can be overestimated at no cost in rendering time, and a single overlap uses (depending on system) 16 to 32 bytes of memory.</p> <p>iwfn -- function table containing window waveform (Use Use GEN20 to calculate iwfn).</p> <p>iseed (optional, default=0) -- seed value for random number generator (positive integer in the range 1 to 2147483646 (2<sup>31</sup> - 2)). Zero or negative value seeds from current time (this is also the default).</p> <p>imode (optional, default=0) -- sum of the following values:</p> <ul> <li>64: synchronize start phase of grains to kcps.</li> <li>32: start all grains at integer sample location. This may be faster in some cases, however it also makes the timing of grain envelopes less accurate.</li> <li>16: do not render grains with start time less than zero. (see the image below; this option turns off grains marked with red on the image).</li> <li>8: interpolate window waveform (slower).</li> <li>4: do not interpolate grain waveform (fast, but lower quality).</li> <li>2: grain frequency is continuously modified by kcps and kfmd (by default, each grain keeps the frequency it was launched with). This may be slower at high control rates. It also controls phase modulation (kphs).</li> <li>1: skip initialization.</li> </ul> A diagram showing grains with a start time less than zero in red."},{"location":"opcodes/grain3/#performance","title":"Performance","text":"<p>ares -- output signal.</p> <p>kcps -- grain frequency in Hz.</p> <p>kphs -- grain phase. This is the location in the grain waveform table, expressed as a fraction (between 0 to 1) of the table length.</p> <p>kfmd -- random variation (bipolar) in grain frequency in Hz.</p> <p>kpmd -- random variation (bipolar) in start phase.</p> <p>kgdur -- grain duration in seconds. kgdur also controls the duration of already active grains (actually the speed at which the window function is read). This behavior does not depend on the imode flags.</p> <p>kdens -- number of grains per second.</p> <p>kfrpow -- this value controls the distribution of grain frequency variation. If kfrpow is positive, the random distribution (x is in the range -1 to 1) is:</p> <pre><code>abs(x) ^ ((1 / kfrpow) - 1)\n</code></pre> <p>for negative kfrpow values, it is:</p> <pre><code>(1 - abs(x)) ^ ((-1 / kfrpow) - 1)\n</code></pre> <p>Setting kfrpow to -1, 0, or 1 will result in uniform distribution (this is also faster to calculate). The image below shows some examples for kfrpow. The default value of kfrpow is 0.</p> A graph of distributions for different values of . <p>kprpow -- distribution of random phase variation (see kfrpow).  Setting kphs and kpmd to 0.5, and kprpow to 0 will emulate grain2.</p> <p>kfn -- function table containing grain waveform. Table number can be changed at k-rate (this is useful to select from a set of band-limited tables generated by Use GEN30, to avoid aliasing).</p> <p> Note</p> <p>grain3 internally uses the same random number generator as rnd31. So reading its documentation is also recommended.</p>"},{"location":"opcodes/grain3/#examples","title":"Examples","text":"<p>Here is an example of the grain3 opcode. It uses the file grain3.csd.</p> Example of the grain3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o grain3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =  48000\nkr      =  1000\nksmps   =  48\nnchnls  =  1\n\n/* Bartlett window */\nitmp    ftgen 1, 0, 16384, 20, 3, 1\n/* sawtooth wave */\nitmp    ftgen 2, 0, 16384, 7, 1, 16384, -1\n/* sine */\nitmp    ftgen 4, 0, 1024, 10, 1\n/* window for \"soft sync\" with 1/32 overlap */\nitmp    ftgen 5, 0, 16384, 7, 0, 256, 1, 7936, 1, 256, 0, 7936, 0\n/* generate bandlimited sawtooth waves */\nitmp    ftgen 3, 0, 4096, -30, 2, 1, 2048\nicnt    =  0\nloop01:\n; 100 tables for 8 octaves from 30 Hz\nifrq    =  30 * exp(log(2) * 8 * icnt / 100)\nitmp    ftgen icnt + 100, 0, 4096, -30, 3, 1, sr / (2 * ifrq)\nicnt    =  icnt + 1\n        if (icnt &lt; 99.5) igoto loop01\n/* convert frequency to table number */\n#define FRQ2FNUM(xout'xcps'xbsfn) #\n\n$xout   =  int(($xbsfn) + 0.5 + (100 / 8) * log(($xcps) / 30) / log(2))\n$xout   limit $xout, $xbsfn, $xbsfn + 99\n\n#\n\n/* instr 1: pulse width modulated grains */\n\n        instr 1\n\nkfrq    =  523.25               ; frequency\n$FRQ2FNUM(kfnum'kfrq'100)       ; table number\nkfmd    =  kfrq * 0.02          ; random variation in frequency\nkgdur   =  0.2                  ; grain duration\nkdens   =  200                  ; density\niseed   =  1                    ; random seed\n\nkphs    oscili 0.45, 1, 4       ; phase\n\na1      grain3  kfrq, 0, kfmd, 0.5, kgdur, kdens, 100,          \\\n                kfnum, 1, -0.5, 0, iseed, 2\na2      grain3  kfrq, 0.5 + kphs, kfmd, 0.5, kgdur, kdens, 100, \\\n                kfnum, 1, -0.5, 0, iseed, 2\n\n; de-click\naenv    linseg 0, 0.01, 1, p3 - 0.05, 1, 0.04, 0, 1, 0\n\n        out aenv * 2250 * (a1 - a2)\n\n        endin\n\n/* instr 2: phase variation */\n\n    instr 2\n\nkfrq    =  220                  ; frequency\n$FRQ2FNUM(kfnum'kfrq'100)       ; table number\nkgdur   =  0.2                  ; grain duration\nkdens   =  200                  ; density\niseed   =  2                    ; random seed\n\nkprdst  expon 0.5, p3, 0.02     ; distribution\n\na1      grain3  kfrq, 0.5, 0, 0.5, kgdur, kdens, 100,        \\\n                kfnum, 1, 0, -kprdst, iseed, 64\n\n; de-click\naenv    linseg 0, 0.01, 1, p3 - 0.05, 1, 0.04, 0, 1, 0\n\n        out aenv * 1500 * a1\n\n        endin\n\n/* instr 3: \"soft sync\" */\n\n        instr 3\n\nkdens   =  130.8                ; base frequency\nkgdur   =  2 / kdens            ; grain duration\n\nkfrq    expon 880, p3, 220      ; oscillator frequency\n$FRQ2FNUM(kfnum'kfrq'100)       ; table number\n\na1      grain3 kfrq, 0, 0, 0, kgdur, kdens, 3, kfnum, 5, 0, 0, 0, 2\na2      grain3 kfrq, 0.667, 0, 0, kgdur, kdens, 3, kfnum, 5, 0, 0, 0, 2\n\n; de-click\naenv    linseg 0, 0.01, 1, p3 - 0.05, 1, 0.04, 0, 1, 0\n\n        out aenv * 10000 * (a1 - a2)\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nt 0 60\ni 1 0 3\ni 2 4 3\ni 3 8 3\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/grain3/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/grain3/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.15</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/granule/","title":"Granule","text":""},{"location":"opcodes/granule/#granule","title":"granule","text":"<p>A more complex granular synthesis texture generator.</p> <p>The granule unit generator is more complex than grain, but does add new possibilities.</p> <p>granule is a Csound unit generator which employs a wavetable as input to produce granularly synthesized audio output. Wavetable data may be generated by any of the GEN subroutines such as GEN01 which reads an audio data file into a wavetable. This enable a sampled sound to be used as the source for the grains. Up to 128 voices are implemented internally. The maximum number of voices can be increased by redefining the variable MAXVOICE in the grain4.h file. granule has a build-in random number generator to handle all the random offset parameters. Thresholding is also implemented to scan the source function table at initialization stage. This facilitates features such as skipping silence passage between sentences.</p> <p>The characteristics of the synthesis are controlled by 22 parameters. xamp is the amplitude of the output and it can be either audio rate or control rate variable.</p>"},{"location":"opcodes/granule/#syntax","title":"Syntax","text":"<pre><code>ares granule xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, \\\n             igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec \\\n             [, iseed] [, ipitch1] [, ipitch2] [, ipitch3] [, ipitch4] [, ifnenv]\n</code></pre>"},{"location":"opcodes/granule/#initialization","title":"Initialization","text":"<p>ivoice -- number of voices.</p> <p>iratio -- ratio of the speed of the gskip pointer relative to output audio sample rate. eg. 0.5 will be half speed.</p> <p>imode -- +1 grain pointer move forward (same direction of the gskip pointer), -1 backward (oppose direction to the gskip pointer) or 0 for random.</p> <p>ithd -- threshold, if the sampled signal in the wavetable is smaller then ithd, it will be skipped.</p> <p>ifn -- function table number of sound source.</p> <p>ipshift -- pitch shift control. If ipshift is 0, pitch will be set randomly up and down an octave. If ipshift is 1, 2, 3 or 4, up to four different pitches can be set amount the number of voices defined in ivoice. The optional parameters ipitch1, ipitch2, ipitch3 and ipitch4 are used to quantify the pitch shifts.</p> <p>igskip -- initial skip from the beginning of the function table in sec.</p> <p>igskip_os -- gskip pointer random offset in sec, 0 will be no offset.</p> <p>ilength -- length of the table to be used starting from igskip in sec.</p> <p>igap_os -- gap random offset in % of the gap size, 0 gives no offset.</p> <p>igsize_os -- grain size random offset in % of grain size, 0 gives no offset.</p> <p>iatt -- attack of the grain envelope in % of grain size.</p> <p>idec -- decade of the grain envelope in % of grain size.</p> <p>iseed (optional, default=0.5) -- seed for the random number generator.</p> <p>ipitch1, ipitch2, ipitch3, ipitch4 (optional, default=1) -- pitch shift parameter, used when ipshift is set to 1, 2, 3 or 4. Time scaling technique is used in pitch shift with linear interpolation between data points. Default value is 1, the original pitch.</p> <p>ifnenv (optional, default=0) -- function table number to be used to generate the shape of the envelope.</p>"},{"location":"opcodes/granule/#performance","title":"Performance","text":"<p>xamp -- amplitude.</p> <p>kgap -- gap between grains in sec.</p> <p>kgsize -- grain size in sec.</p>"},{"location":"opcodes/granule/#examples","title":"Examples","text":"<p>Here is an example of the granule opcode. It uses the files granule.csd, marimba.aif and fox.wav</p> Example of the granule opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac    ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o granule.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkenv linseg 0,0.5,1,(p3-0.5),1      ; envelope with attack time of .5 seconds\n\niamp = p4\nivoice = p5\niratio = p6\nimode = p7\nithd = p8\nifn = p9\nipshift = p10\nigskip = p11\nigskipos = p12\nilenght = p13\nkgap = p14\nigapos = p15\nkgsize = p16\nigsize_os = p17\niatt = p18\nidec = p19\niseed = p20\nipitch1 = p21\nipitch2 = p22\nipitch3 = p23\nipitch4 = p24\n\na1  granule iamp*kenv, ivoice, iratio, imode, ithd, ifn, ipshift ,igskip ,igskipos , ilenght, kgap ,igapos, kgsize, igsize_os, iatt, idec, iseed,      ipitch1, ipitch2, ipitch3, ipitch4\na2  granule iamp*kenv, ivoice, iratio, imode, ithd, ifn, ipshift ,igskip ,igskipos , ilenght, kgap ,igapos, kgsize, igsize_os, iatt, idec, iseed+0.17, ipitch1, ipitch2, ipitch3, ipitch4\nouts a1,a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1      0 0 1 \"marimba.aif\" 0 0 0\nf2      0 0 1 \"fox.wav\" 0 0 0\n\n; both samples are played back 2 x slower\n\n;         p4 p5 p6 p7 p8 p9 p10 p11 p12  p13 p14  p15 p16   p17 p18 p19  [p20   p21 p22  p23  p24]\ni1 0  10 .25 64 1 0   0  1   4  0  0.005  1  0.01  0  0.02   50 25  25    0.39  1  1.42 0.29  2 ;part of marimba\ni1 11 20 .37 9  1 0   0  2   0  0  0.005  1  0.01  0  0.02   50 25  25    0.39  1  1.42 0.29  2 ;part of fox\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The above example reads a sound file called marimba.aif into wavetable number 1, a second reads fox.wav into wavetable number 2. The first note generates 10 seconds of stereo audio output using the wavetable. In the orchestra file, all parameters required to control the synthesis are passed from the score file. A linseg function generator is used to generate an envelope with 0.5 second of linear attack and decay. Stereo effect is generated by using different seeds for the two granule function calls. In the example, 0.17 is added to p20 (= iseed) before passing into the second granule call to ensure that all of the random offset events are different from the first one.</p> <p>The second note (wavetable number 2) has slightly different parameters.</p> <p>In the score file for the first note, the parameters are interpreted as:</p> Parameter Interpreted As p5 (ivoice) the number of voices is set to 64 p6 (iratio) set to 0.5, it scans the wavetable at half of the speed of the audio output rate p7 (imode) set to 0, the grain pointer only move forward p8 (ithd) set to 0, skipping the thresholding process p9 (ifn) set to 1, function table number 1 is used p10 (ipshift) set to 4, four different pitches are going to be generated p11 (igskip) set to 0 and p12 (igskip_os) is set to 0.005, no skipping into the wavetable and a 5 mSec random offset is used p13 (ilength) set to 1, 1 second of the wavetable is to be used p14 (kgap) set to 0.01 and p15 (igap_os) is set to 50, 10 mSec gap with 50% random offset is to be used p16 (kgsize) set to 0.02 and p17 (igsize_os) is set to 50, 20 mSec grain with 50% random offset is used p18 (iatt) and p19 (idec) set to 25, 25% of linear attack and decade is applied to the grain p20 (iseed) seed for the random number generator is set to 0.39 p21 - p24 pitches set to 1 which is the original pitch, 1.42 which is a 5th up, 0.29 which is a 7th down and finally 2 which is an octave up."},{"location":"opcodes/granule/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/granule/#credits","title":"Credits","text":"<p>Author: Allan Lee</p> <p>Belfast</p> <p>1996</p> <p>New in version 3.35</p>"},{"location":"opcodes/greaterequal/","title":"Greaterequal","text":""},{"location":"opcodes/greaterequal/#_1","title":"&gt;=","text":"<p>Determines if one value is greater than or equal to another.</p>"},{"location":"opcodes/greaterequal/#syntax","title":"Syntax","text":"<pre><code>(a &gt;= b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/greaterequal/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a greater than or equal to b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2.</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/greaterequal/#examples","title":"Examples","text":"<p>Here is an example of the &gt;= operator. It uses the file greaterequal.csd.</p> Example of the &gt;= operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o greaterequal.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the 4th p-field from the score.\n  k1 =  p4\n\n  ; Is it greater than or equal to 3? (1 = true, 0 = false)\n  k2 = (p4 &gt;= 3 ? 1 : 0)\n\n  ; Print the values of k1 and k2.\n  printks \"k1 = %f, k2 = %f\\\\n\", 1, k1, k2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Call Instrument #1 with a p4 = 2.\ni 1 0 0.5 2\n; Call Instrument #1 with a p4 = 3.\ni 1 1 0.5 3\n; Call Instrument #1 with a p4 = 4.\ni 1 2 0.5 4\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1 = 2.000000, k2 = 0.000000\nk1 = 3.000000, k2 = 1.000000\nk1 = 4.000000, k2 = 1.000000\n</code></pre>"},{"location":"opcodes/greaterequal/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/greaterequal/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/greaterthan/","title":"Greaterthan","text":""},{"location":"opcodes/greaterthan/#_1","title":"&gt;","text":"<p>Determines if one value is greater than another.</p>"},{"location":"opcodes/greaterthan/#syntax","title":"Syntax","text":"<pre><code>(a &gt;  b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/greaterthan/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a greater than b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2.</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/greaterthan/#examples","title":"Examples","text":"<p>Here is an example of the &gt; operator. It uses the file greaterthan.csd.</p> Example of the &gt; operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o greaterthan.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the 4th p-field from the score.\n  k1 =  p4\n\n  ; Is it greater than 3? (1 = true, 0 = false)\n  k2 = (p4 &gt; 3 ? 1 : 0)\n\n  ; Print the values of k1 and k2.\n  printks \"k1 = %f, k2 = %f\\\\n\", 1, k1, k2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Call Instrument #1 with a p4 = 2.\ni 1 0 0.5 2\n; Call Instrument #1 with a p4 = 3.\ni 1 1 0.5 3\n; Call Instrument #1 with a p4 = 4.\ni 1 2 0.5 4\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1 = 2.000000, k2 = 0.000000\nk1 = 3.000000, k2 = 0.000000\nk1 = 4.000000, k2 = 1.000000\n</code></pre>"},{"location":"opcodes/greaterthan/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/greaterthan/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/gtadsr/","title":"Gtadsr","text":""},{"location":"opcodes/gtadsr/#gtadsr","title":"gtadsr","text":"<p>A gated linear attack-decay-sustain with exponential release.</p> <p>This opcode can work either as a signal generator or as a signal processor. It is controlled by a gate k-rate signal (0 or  &gt; 0) which switches the envelope attack-decay-sustain phase on/off. With gate &gt; 0 (high), the envelope cycles through the attack and decay phases, and is sustained at the sustain level. Whenever gate is 0 (low), the envelope enters the release phase, decaying exponentially to 0. The attack and decay times are fixed with gate &gt; 0, but can be changed once the gate is zero.</p>"},{"location":"opcodes/gtadsr/#syntax","title":"Syntax","text":"<pre><code>ares gtadsr asig, katt, kdec, ksus, krel, kgate\nxres gtadsr kamp, katt, kdec, ksus, krel, kgate\n</code></pre>"},{"location":"opcodes/gtadsr/#performance","title":"Performance","text":"<p>x/ares -- output signal (k or a-rate)</p> <p>asig -- input signal (envelope as an amplitude processor)</p> <p>kamp -- maximum amplitude (envelope as a signal generator)</p> <p>katt -- duration of attack phase</p> <p>kdec -- duration of decay</p> <p>ksus -- level for sustain phase (in the range 0 - 1)</p> <p>krel -- duration of release phase</p> <p>kgate -- gate signal (0 = low, &gt; 0 high).</p> <p>The length of the sustain is calculated from the length of the note. This means gtadsr is not suitable for use with MIDI events.</p>"},{"location":"opcodes/gtadsr/#examples","title":"Examples","text":"<p>Here is an example of the gtadsr opcode. It uses the file gtadsr.csd.</p> Example of the gtadsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n0dbfs = 1\n\ninstr 1\n gkamp = p4\n gkfr = p5\n gkgate = 1\n gkatt = p6\n gkdec = p7\n gksus = p8\n gkrel = p9\nendin\n\ninstr 2\n a1 oscili gkamp,gkfr\n a2 gtadsr  a1,gkatt,gkdec,gksus,gkrel,gkgate\n out a2\n gkgate = 0;\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1 1 440 0.1 0.1 0.5 0.1\ni1 1.2 1 1 660 0.01 0.1 0.2 0.3\ni1 2.5 1 1 550 0.01 0.1 0.7 1\ni2 0 5\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gtadsr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/gtadsr/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini;</p> <p>New in version 6.17</p>"},{"location":"opcodes/gtf/","title":"Gtf","text":""},{"location":"opcodes/gtf/#gtf","title":"gtf","text":"<p>Apply a gammatone filter of various orders to an audio signal.</p>"},{"location":"opcodes/gtf/#syntax","title":"Syntax","text":"<pre><code>aout gtf ain, kfreq, idecay[, iorder, iphase]\n</code></pre>"},{"location":"opcodes/gtf/#initialization","title":"Initialization","text":"<p>idecay -- rate of decay</p> <p>iorder -- (optional) Order of filter in rangs 1 to 10 defaulting to 4.</p> <p>iphase -- (optional) Phase output, defaulting to zero.</p>"},{"location":"opcodes/gtf/#performance","title":"Performance","text":"<p>asig -- audio signal to be filtered.</p> <p>kfreq -- central frequency of filter in Hertz.</p> <p>The gammatone filter is commonly used in models of the auditory system. The algorithm is based on Martin Cooke's Ph.D work (Cooke, 1993) using the base-band impulse invariant transformation.   See http://staffwww.dcs.shef.ac.uk/people/N.Ma/resources/gammatone/</p>"},{"location":"opcodes/gtf/#examples","title":"Examples","text":"<p>Here is an example of the gtf opcode. It uses the file gtf.csd.</p> Example of the gtf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gtf.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1  \n\nkcps  init cpspch(p4) \nasig1 vco2 0.5, kcps ; SOUND\n\nkfreq1 linseg p5, p3, p6 ; frequency filter 1\nkfreq2 expseg p6, p3, p5 ; frequency filter 2\nidecay = p7 ; keep it very small\n\nafilter1 gtf asig1, kfreq1, idecay ; SOUND - filter 1\nafilter2 gtf asig1, kfreq2, idecay ; SOUND - filter 2\n\naref oscili 0.25, 440 ; AMPLITUDE reference\nafilter1 balance afilter1, aref ; compare filtered SOUND with reference\nafilter2 balance afilter2, aref ; ; compare filtered SOUND with reference\n\nouts afilter1, afilter2\n\nendin\n\n&lt;/CsInstruments&gt;\n\n\n&lt;CsScore&gt;\n\ni 1 0 5 6.00 200 12000 0.1\ni 1 5 5 6.00 200 12000 0.01             \n\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/gtf/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/gtf/#credits","title":"Credits","text":"<p>By: John ffitch 2019</p>"},{"location":"opcodes/guiro/","title":"Guiro","text":""},{"location":"opcodes/guiro/#guiro","title":"guiro","text":"<p>Semi-physical model of a guiro sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/guiro/#syntax","title":"Syntax","text":"<pre><code>ares guiro kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1]\n</code></pre>"},{"location":"opcodes/guiro/#initialization","title":"Initialization","text":"<p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 128.</p> <p>idamp (optional) -- the damping factor of the instrument. Not used.</p> <p>imaxshake (optional, default=0) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p> <p>ifreq (optional) -- the main resonant frequency. The default value is 2500 Hz.</p> <p>ifreq1 (optional) -- the first resonant frequency. Default value here is 4000 Hz</p>"},{"location":"opcodes/guiro/#performance","title":"Performance","text":"<p>kamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only an approximation.</p>"},{"location":"opcodes/guiro/#examples","title":"Examples","text":"<p>Here is an example of the guiro opcode. It uses the file guiro.csd.</p> Example of the guiro opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o guiro.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\na1  guiro .8, p4\n    outs a1, a1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1  1\ni1 + 1 .01\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/guiro/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/guiro/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/harmon/","title":"Harmon","text":""},{"location":"opcodes/harmon/#harmon","title":"harmon","text":"<p>Analyze an audio input and generate harmonizing voices in synchrony.</p>"},{"location":"opcodes/harmon/#syntax","title":"Syntax","text":"<pre><code>ares harmon asig, kestfrq, kmaxvar, kgenfreq1, kgenfreq2, imode, iminfrq, iprd\n</code></pre>"},{"location":"opcodes/harmon/#initialization","title":"Initialization","text":"<p>imode -- interpreting mode for the generating frequency inputs kgenfreq1, kgenfreq2. 0: input values are ratios with respect to the audio signal analyzed frequency. 1: input values are the actual requested frequencies in Hz.</p> <p>iminfrq -- the lowest expected frequency (in Hz) of the audio input. This parameter determines how much of the input is saved for the running analysis, and sets a lower bound on the internal pitch tracker.</p> <p>iprd -- period of analysis (in seconds). Since the internal pitch analysis can be time-consuming, the input is typically analyzed only each 20 to 50 milliseconds.</p>"},{"location":"opcodes/harmon/#performance","title":"Performance","text":"<p>kestfrq -- estimated frequency of the input.</p> <p>kmaxvar -- the maximum variance (expects a value betwee 0 and 1).</p> <p>kgenfreq1 -- the first generated frequency.</p> <p>kgenfreq2 -- the second generated frequency.</p> <p>This unit is a harmonizer, able to provide up to two additional voices with the same amplitude and spectrum as the input. The input analysis is assisted by two things: an input estimated frequency kestfrq (in Hz), and a fractional maximum variance kmaxvar about that estimate which serves to limit the size of the search. Once the real input frequency is determined, the most recent pulse shape is used to generate the other voices at their requested frequencies.</p> <p>The three frequency inputs can be derived in various ways from a score file or MIDI source. The first is the expected pitch, with a variance parameter allowing for inflections or inaccuracies; if the expected pitch is zero the harmonizer will be silent. The second and third pitches control the output frequencies; if either is zero the harmonizer will output only the non-zero request; if both are zero the harmonizer will be silent. When the requested frequency is higher than the input, the process requires additional computation due to overlapped output pulses. This is currently limited for efficiency reasons, with the result that only one voice can be higher than the input at any one time.</p> <p>This unit is useful for supplying a background chorus effect on demand, or for correcting the pitch of a faulty input vocal. There is essentially no delay between input and output. Output includes only the generated parts, and does not include the input.</p>"},{"location":"opcodes/harmon/#examples","title":"Examples","text":"<p>Here is an example of the harmon opcode. It uses the file harmon.csd.</p> Example of the harmon opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o harmon.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naout diskin2 \"sing.wav\", 1\n\nkestfrq = p4    ;different estimated frequency\nkmaxvar = 0.1\nimode   = 1\niminfrq = 100\niprd    = 0.02\n\nasig harmon aout, kestfrq, kmaxvar, kestfrq*.5, kestfrq*4, \\\n            imode, iminfrq, iprd\n     outs (asig + aout)*.6, (asig + aout)*.6    ;mix dry&amp;wet signal\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2.7 100\ni 1 + .   200\ni 1 + .   500\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/harmon/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/harmon/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe M.I.T., Cambridge, Mass 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/harmon234/","title":"Harmon234","text":""},{"location":"opcodes/harmon234/#harmon2","title":"harmon2","text":"<p>Analyze an audio input and generate harmonizing voices in synchrony with formants preserved.</p>"},{"location":"opcodes/harmon234/#syntax","title":"Syntax","text":"<pre><code>ares harmon2 asig, koct, kfrq1, kfrq2, icpsmode, ilowest[, ipolarity]\nares harmon3 asig, koct, kfrq1, kfrq2, kfrq3, icpsmode, ilowest[, ipolarity]\nares harmon4 asig, koct, kfrq1, kfrq2, kfrq3, kfrq4, icpsmode, ilowest \\\n             [, ipolarity]\n</code></pre>"},{"location":"opcodes/harmon234/#initialization","title":"Initialization","text":"<p>icpsmode -- interpreting mode for the generating frequency inputs kfrq1, kfrq2, kfrq3 and kfrq4: 0: input values are ratios w.r.t. the cps equivalent of koct.1: input values are the actual requested frequencies in cps.</p> <p>ilowest -- lowest value of the koct input for which harmonizing voices will be generated.</p> <p>ipolarity -- polarity of asig input, 1 = positive glottal pulses, 0 = negative. Default is 1.</p>"},{"location":"opcodes/harmon234/#performance","title":"Performance","text":"<p>Harmon2, harmon3 and harmon4 are high-performance harmonizers, able to provide up to four pitch-shifted copies of the input asig with spectral formants preserved. The pitch-shifting algorithm requires an accurate running estimate (koct, in decimal oct units) of the pitched content of asig, normally gained from an independent pitch tracker such as specptrk. The algorithm then isolates the most recent full pulse within asig, and uses this to generate the other voices at their required pulse rates.</p> <p>If the frequency (or ratio) presented to kfrq1, kfrq2, kfrq3 or kfrq4 is zero, then no signal is generated for that voice.  If any of them is non-zero, but the koct input is below the value ilowest, then that voice will output a direct copy of the input asig.  As a consequence, the data arriving at the k-rate inputs can variously cause the generated voices to be turned on or off, to pass a direct copy of a non-voiced fricative source, or to harmonize the source according to some constructed algorithm. The transition from one mode to another is cross-faded, giving seemless alternating between voiced (harmonized) and non-voiced fricatives during spoken or sung input.</p> <p>harmon2, harmon3, harmon4 are especially matched to the output of specptrk.  The latter generates pitch data in decimal octave format; it also emits its base value if no pitch is identified (as in fricative noise) and emits zero if the energy falls below a threshold, so that harmon2, harmon3, harmon4 can be set to pass the direct signal in both cases.  Of course, any other form of pitch estimation could also be used.  Since pitch trackers usually incur a slight delay for accurate estimation (for specptrk the delay is printed by the spectrum unit), it is normal to delay the audio signal by the same amount so that harmon2, harmon3, harmon4 can work from a fully concurrent estimate.</p>"},{"location":"opcodes/harmon234/#examples","title":"Examples","text":"<p>Here is an example of the harmon2 opcode. It uses the file harmon.csd.</p> Example of the harmon2 opcode.<pre><code>a1,a2      ins                                     ; get mic input\nw1         spectrum  a1, .02, 7, 24, 12, 1, 3      ; and examine it\nkoct,kamp  specptrk  w1, 1, 6.5, 9.5, 7.5, 10, 7, .7, 0, 3, 1\na3         delay     a1, .065                      ; allow for ptrk delay\na4         harmon2   a3, koct, 1.25, 0.75, 0, 6.9  ; output a fixed 6-4 harmony\n           outs      a3, a4                        ; as well as the original\n</code></pre> <p>Here is a complete example of the harmon3 opcode. It uses the file harmon3.csd.</p> Example of the harmon3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o harmon3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nilow = p4                                       ;lowest value to harmonize                      \naout diskin2 \"sing.wav\", 1, 0, 1\nkoct, kamp pitch aout, .01, 6, 10, 10           ;track pitch\nasig harmon3 aout, koct, .9, 1.5, 0.7, 0, ilow\n     outs (asig + aout)*.4, (asig + aout)*.4    ;mix dry&amp;wet signal\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2.2 8.8\ni1 3 2.2 8.2\ni1 6 2.2 7.0\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/harmon234/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/harmon234/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe M.I.T., Cambridge, Mass 2006</p> <p>New in version 5.04</p>"},{"location":"opcodes/hdf5read/","title":"Hdf5read","text":""},{"location":"opcodes/hdf5read/#hdf5read","title":"hdf5read","text":"<p>Read signals and arrays from an hdf5 file.</p> <p>Plugin opcode in hdf5ops. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/hdf5read/#syntax","title":"Syntax","text":"<pre><code>xout1[, xout2, xout3, ..., xoutN] hdf5read ifilename, ivariablename1[, \\\n    ivariablename2, ivariablename3, ..., ivariablenameN]\n</code></pre>"},{"location":"opcodes/hdf5read/#initialization","title":"Initialization","text":"<p>ifilename -- the hdf5 file's name (in double-quotes).</p> <p>ivariablename1[, ivariablename2, ivariablename3, ..., ivariablenameN] -- the names of the datasets (in double-quotes) to be read from the hdf5 file, if the dataset name is suffixed with an asterisk, e.g. \"mydataset*\", the entire dataset is copied to the array regardless of array type.</p>"},{"location":"opcodes/hdf5read/#performance","title":"Performance","text":"<p>xout1,... xoutN -- The specified types of variables that the hdf5 datasets are to be read  as. Datasets with a rank larger than 1 must be read as arrays, i-rate signals must also be read as i-rate signals. Other than these restrictions datasets may be read as any type of array or signal. When reading has reached the end of a dataset it no longer outputs any new values.</p>"},{"location":"opcodes/hdf5read/#examples","title":"Examples","text":"<p>Here is a simple example of the hdf5read opcode. It uses the file hdf5read.csd.</p> Example of the hdf5read opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\n0dbfs = 1\nksmps = 8\nsr = 44100\n\ninstr hdf5read\n\n    aArray[], aVar, kVar hdf5read \"example.h5\", \"aArray\", \"aVar\", \"kVar\" ; Open hdf5 file and read variables\n\n    aLeft = (aArray[0][0] + aArray[0][1] + aVar) / 3 ; Add audio signals together for stereo out\n    aRight = (aArray[1][0] + aArray[1][1] + aVar) / 3\n\n    outs aLeft * kVar, aRight * kVar ; Multiply audio signals by k-rate signal\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni \"hdf5read\" 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hdf5read/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/hdf5read/#credits","title":"Credits","text":"<p>Author: Edward Costello; NUIM, 2014</p>"},{"location":"opcodes/hdf5write/","title":"Hdf5write","text":""},{"location":"opcodes/hdf5write/#hdf5write","title":"hdf5write","text":"<p>Write signals and arrays to an hdf5 file.</p> <p>Plugin opcode in hdf5ops. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p>"},{"location":"opcodes/hdf5write/#syntax","title":"Syntax","text":"<pre><code>hdf5write ifilename, xout1[, xout2, xout3, ..., xoutN]\n</code></pre>"},{"location":"opcodes/hdf5write/#initialization","title":"Initialization","text":"<p>ifilename -- the hdf5 file's name (in double-quotes). If the file does not exist it will be created.</p>"},{"location":"opcodes/hdf5write/#performance","title":"Performance","text":"<p>xout1,... xoutN -- signals or arrays to be written to the hdf5 file. This opcode accepts i-rate, k-rate, a-rate signals or i-rate, k-rate, a-rate arrays of any dimension. These signals or arrays are written to a dataset within the hdf5 file using the same variable name as in Csound. For example, if the Csound variable is called 'ksignal', then the name of the hdf5 dataset is 'ksignal'. Any number and multiple types of datasets may be written at a time.</p>"},{"location":"opcodes/hdf5write/#examples","title":"Examples","text":"<p>Here is a simple example of the hdf5write opcode. It uses the file hdf5write.csd.</p> Example of the hdf5write opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\n0dbfs = 1\nksmps = 8\nsr = 44100\n\ninstr hdf5write\n\n    aArray[] init 2,2 ; Initialise a 2 X 2 a-rate array\n\n    aArray[0][0] vco2 0.2, 100 ; Fill array with vco2 signals\n    aArray[0][1] vco2 0.4, 200\n    aArray[1][0] vco2 0.8, 300\n    aArray[1][1] vco2 1, 400\n\n    aVar vco2 0.2, 100 ; Initialise an a-rate variable with a vco2 signal\n\n    kVar phasor 1 ; Initalise a k-rate variable with a phasor signal\n\n    hdf5write \"example.h5\", aArray, aVar, kVar ; Write variables to an hdf5 file\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni \"hdf5write\" 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hdf5write/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/hdf5write/#credits","title":"Credits","text":"<p>Author: Edward Costello; NUIM, 2014</p>"},{"location":"opcodes/hilbert/","title":"Hilbert","text":""},{"location":"opcodes/hilbert/#hilbert","title":"hilbert","text":"<p>A Hilbert transformer.</p>"},{"location":"opcodes/hilbert/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 hilbert asig\n</code></pre>"},{"location":"opcodes/hilbert/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>ar1 -- sine output of asig</p> <p>ar2 -- cosine output of asig</p> <p>hilbert is an IIR filter based implementation of a broad-band 90 degree phase difference network. The input to hilbert is an audio signal, with a frequency range from 15 Hz to 15 kHz. The outputs of hilbert have an identical frequency response to the input (i.e. they sound the same), but the two outputs have a constant phase difference of 90 degrees, plus or minus some small amount of error, throughout the entire frequency range. The outputs are in quadrature.</p> <p>hilbert is useful in the implementation of many digital signal processing techniques that require a signal in phase quadrature. ar1 corresponds to the cosine output of hilbert, while ar2 corresponds to the sine output. The two outputs have a constant phase difference throughout the audio range that corresponds to the phase relationship between cosine and sine waves.</p> <p>Internally, hilbert is based on two parallel 6th-order allpass filters. Each allpass filter implements a phase lag that increases with frequency; the difference between the phase lags of the parallel allpass filters at any given point is approximately 90 degrees.</p> <p>Unlike an FIR-based Hilbert transformer, the output of hilbert does not have a linear phase response. However, the IIR structure used in hilbert is far more efficient to compute, and the nonlinear phase response can be used in the creation of interesting audio effects, as in the second example below.</p>"},{"location":"opcodes/hilbert/#examples","title":"Examples","text":"<p>The first example implements frequency shifting, or single sideband amplitude modulation. Frequency shifting is similar to ring modulation, except the upper and lower sidebands are separated into individual outputs. By using only one of the outputs, the input signal can be \"detuned,\" where the harmonic components of the signal are shifted out of harmonic alignment with each other, e.g. a signal with harmonics at 100, 200, 300, 400 and 500 Hz, shifted up by 50 Hz, will have harmonics at 150, 250, 350, 450, and 550 Hz.</p> <p>Here is the first example of the hilbert opcode. It uses the file hilbert.csd, and drumsMlp.wav.</p> Example of the hilbert opcode implementing frequency shifting.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o hilbert.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n  idur = p3\n  ; Initial amount of frequency shift.\n  ; It can be positive or negative.\n  ibegshift = p4 \n  ; Final amount of frequency shift.\n  ; It can be positive or negative.\n  iendshift = p5 \n\n  ; A simple envelope for determining the \n  ; amount of frequency shift.\n  kfreq linseg ibegshift, idur, iendshift\n\n  ; Use the sound of your choice.\n  ain diskin2 \"drumsMlp.wav\", 1, 0, 1\n\n  ; Phase quadrature output derived from input signal.\n  areal, aimag hilbert ain\n\n  ; Quadrature oscillator.\n  asin oscili 1, kfreq, 1\n  acos oscili 1, kfreq, 1, .25\n\n  ; Use a trigonometric identity. \n  ; See the references for further details.\n  amod1 = areal * acos\n  amod2 = aimag * asin\n\n  ; Both sum and difference frequencies can be \n  ; output at once.\n  ; aupshift corresponds to the sum frequencies.\n  aupshift = (amod1 - amod2) * 0.7\n  ; adownshift corresponds to the difference frequencies. \n  adownshift = (amod1 + amod2) * 0.7\n\n  ; Notice that the adding of the two together is\n  ; identical to the output of ring modulation.\n\n  outs aupshift, aupshift\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Sine table for quadrature oscillator.\nf 1 0 16384 10 1\n\n; Starting with no shift, ending with all\n; frequencies shifted up by 2000 Hz.\ni 1 0 6 0 2000\n\n; Starting with no shift, ending with all\n; frequencies shifted down by 250 Hz.\ni 1 7 6 0 -250\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The second example is a variation of the first, but with the output being fed back into the input. With very small shift amounts (i.e. between 0 and +-6 Hz), the result is a sound that has been described as a \u201cbarberpole phaser\u201d or \u201cShepard tone phase shifter.\u201d Several notches appear in the spectrum, and are constantly swept in the direction opposite that of the shift, producing a filtering effect that is reminiscent of Risset's \u201cendless glissando\u201d.</p> <p>Here is the second example of the hilbert opcode. It uses the file hilbert_barberpole.csd.</p> Example of the hilbert opcode sounding like a \u201cbarberpole phaser\u201d.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o hilbert_barberpole.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\n; kr must equal sr for the barberpole effect to work.\nkr = 44100\nksmps = 1\nnchnls = 2\n\n; Instrument #1\ninstr 1\n  idur = p3\n  ibegshift = p4\n  iendshift = p5\n\n  ; sawtooth wave, not bandlimited\n  asaw   phasor 100\n  ; add offset to center phasor amplitude between -.5 and .5\n  asaw = asaw - .5\n  ; sawtooth wave, with amplitude of 10000\n  ain = asaw * 20000\n\n  ; The envelope of the frequency shift.\n  kfreq linseg ibegshift, idur, iendshift\n\n  ; Phase quadrature output derived from input signal.\n  areal, aimag hilbert ain\n\n  ; The quadrature oscillator.\n  asin oscili 1, kfreq, 1\n  acos oscili 1, kfreq, 1, .25\n\n  ; Based on trignometric identities.\n  amod1 = areal * acos\n  amod2 = aimag * asin\n\n  ; Calculate the up-shift and down-shift.\n  aupshift = (amod1 + amod2) * 0.7\n  adownshift = (amod1 - amod2) * 0.7\n\n  ; Mix in the original signal to achieve the barberpole effect.\n  amix1 = aupshift + ain\n  amix2 = aupshift + ain\n\n  ; Make sure the output doesn't get louder than the original signal.\n  aout1 balance amix1, ain\n  aout2 balance amix2, ain\n\n  outs aout1, aout2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table 1: A sine wave for the quadrature oscillator.\nf 1 0 16384 10 1\n\n; The score.\n; p4 = frequency shifter, starting frequency.\n; p5 = frequency shifter, ending frequency.\ni 1 0 6 -10 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hilbert/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/hilbert/#technical-history","title":"Technical History","text":"<p>The use of phase-difference networks in frequency shifters was pioneered by Harald Bode<sup>1</sup>. Bode and Bob Moog provide an excellent description of the implementation and use of a frequency shifter in the analog realm in <sup>2</sup>; this would be an excellent first source for those that wish to explore the possibilities of single sideband modulation. Bernie Hutchins provides more applications of the frequency shifter, as well as a detailed technical analysis<sup>3</sup>. A recent paper by Scott Wardle<sup>4</sup> describes a digital implementation of a frequency shifter, as well as some unique applications.</p>"},{"location":"opcodes/hilbert/#references","title":"References","text":"<ol> <li>H. Bode, \"Solid State Audio Frequency Spectrum Shifter.\" AES Preprint No. 395 (1965).</li> <li>H. Bode and R.A. Moog, \"A High-Accuracy Frequency Shfiter for Professional Audio Applications.\" Journal of the Audio Engineering Society, July/August 1972, vol. 20, no. 6, p. 453.</li> <li>B. Hutchins. Musical Engineer's Handbook (Ithaca, NY: Electronotes, 1975), ch. 6a.</li> <li>S. Wardle, \"A Hilbert-Transformer Frequency Shifter for Audio.\" Available online at http://www.iua.upf.es/dafx98/papers/.</li> </ol>"},{"location":"opcodes/hilbert/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>New in Csound version 3.55</p> <p>The examples were updated April 2002. Thanks go to Sean Costello for fixing the barberpole example.</p>"},{"location":"opcodes/hilbert2/","title":"Hilbert2","text":""},{"location":"opcodes/hilbert2/#hilbert2","title":"hilbert2","text":"<p>A DFT-based implementation of a Hilbert transformer.</p>"},{"location":"opcodes/hilbert2/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 hilbert2 asig, ifftsize, ihopsize\n</code></pre> <p>Initialisation</p> <p>ifftsize -- DFT analysis size</p> <p>ihopsize -- analysis hopsize</p>"},{"location":"opcodes/hilbert2/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>ar1 -- real output of asig</p> <p>ar2 -- imag output of asig</p> <p>hilbert2 is a DFT-based implementation of the Hilbert Transform producing two outputs in quadrature (90 degree phase difference across the spectrum). Unlike the IIR-based hilbert opcode, hilbert2 has a linear frequency response. Given that it employs a streaming algorithm, a delay of fftsize samples will be imposed between input and output.</p> <p>Example</p> <p>Here is an example of the hilbert2 opcode. It uses the file hilbert2.csd.</p> Example of the hilbert2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nnchnls = 2\n\ninstr 1\n\nasig  oscili   0dbfs*p4, p5\na1,a2 hilbert2 asig, 1024, 256\n      outs     a1, a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10 0.5 440\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hilbert2/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/hilbert2/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017</p>"},{"location":"opcodes/hrtfearly/","title":"Hrtfearly","text":""},{"location":"opcodes/hrtfearly/#hrtfearly","title":"hrtfearly","text":"<p>Generates 3D binaural audio with high-fidelity early reflections in a parametric room using a Phase Truncation algorithm.</p> <p>This opcode essentially nests the hrtfmove opcode in an image model for a user-definable shoebox-shaped room. A default room can be selected, or advanced room parameters can be used. Room surfaces can be controlled with high and low-frequency absorption coefficients and gain factors of a three-band equaliser.</p> <p>Although valid as a stand alone opcode, hrtfearly is designed to work with hrtfreverb to provide spatially accurate, dynamic binaural reverberation. A number of sources can be processed dynamically using a number of hrtfearly instances. All can then be processed with one instance of hrtfreverb.</p>"},{"location":"opcodes/hrtfearly/#syntax","title":"Syntax","text":"<pre><code>aleft, aright, irt60low, irt60high, imfp hrtfearly asrc, ksrcx, ksrcy, ksrcz, \\\n    klstnrx, klstnry, klstnrz, ifilel, ifiler, idefroom [,ifade, isr, iorder, \\\n    ithreed, kheadrot, iroomx, iroomy, iroomz, iwallhigh, iwalllow, \\\n    iwallgain1, iwallgain2, iwallgain3, ifloorhigh, ifloorlow, ifloorgain1, \\\n    ifloorgain2, ifloorgain3, iceilinghigh, iceilinglow, iceilinggain1, \\\n    iceilinggain2, iceilinggain3]\n</code></pre>"},{"location":"opcodes/hrtfearly/#initialization","title":"Initialization","text":"<p>ifilel - left HRTF spectral data file.</p> <p>ifiler - right HRTF spectral data file.</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) are available in 3 different sampling rates: 44.1, 48 and 96 kHz and are labelled accordingly. Input and processing sr should match datafile sr. Files should be in the current directory or the SADIR (see Environment Variables).</p> <p> Note</p> <p>HRTF Data files for use with hrtfmove, hrtfmove2, hrtfstat, hrtfearly, hrtfreverb were updated for Csound 5.15 and later (the code was updated and is more efficient). Old datafiles are now deprecated.</p> <p>idefroom - default room, medium (1: 10103), small (2: 343) or large (3: 20257). Wall details (high coef, low coef, gain1, gain2, gain3): .3, .1, .75, .95, .9. Floor: .6, .1, .95, .6, .35. Ceiling: .2, .1, 1, 1, 1. If 0 is entered, optional room parameters will be read.</p> <p>ifade - optional, number of processing buffers for phase change crossfade (default 8). Legal range is 1-24. See hrtfmove.</p> <p>isr - optional, default 44.1kHz, legal values: 44100, 48000 and 96000.</p> <p>iorder - optional, order of images processed: higher order: more reflections. Defaults to 1, legal range: 0-4.</p> <p>ithreed - optional, process image sources in three dimensions (1) or two (0: default).</p> <p>iroomx - optional, x room size in metres, will be read if no valid default room is entered (all below parameters behave similarly). Minimum room size is 2*2*2.</p> <p>iroomy - optional, y room size.</p> <p>iroomz - optional, z room size.</p> <p>iwallhigh - optional, high frequency wall absorption coefficient (all 4 walls are assumed identical). Absorption coefficients will affect reverb time output.</p> <p>iwalllow - optional, low frequency wall absorption coefficient.</p> <p>iwallgain1 - optional, gain on filter centred at 250 Hz (all filters have a Q implying 4 octaves).</p> <p>iwallgain2 - optional, as above, centred on 1000 Hz.</p> <p>iwallgain3 - optional, as above, centred on 4000 Hz.</p> <p>ifloorhigh, ifloorlow, ifloorgain1, ifloorgain2, ifloorgain3 - as above for floor.</p> <p>iceilinghigh, iceilinglow, iceilinggain1, iceilinggain2, iceilinggain3 - as above for ceiling.</p>"},{"location":"opcodes/hrtfearly/#performance","title":"Performance","text":"<p>ksrcx  source x location, must be 10 cm inside room. Also, near-field HRTFs are not processed, so source will not change spatially within a 45 cm radius of the listener. These restrictions also apply to location parameters below.</p> <p>ksrcy  source y location.</p> <p>ksrcz  source z location.</p> <p>klstnrx, klstnry, klstnrz  listener location, as above.</p> <p>kheadrot - optional, angular value for head rotation.</p> <p>asrc - Input/source signal.</p>"},{"location":"opcodes/hrtfearly/#output","title":"Output","text":"<p>irt60low - suggested low frequency reverb time for later binaural reverb.</p> <p>irt60high - as above, for high frequency.</p> <p>imfp - mean free path of room, to be used with later reverb.</p>"},{"location":"opcodes/hrtfearly/#examples","title":"Examples","text":"<p>Here is an example of the hrtfearly and hrtfreverb opcodes. It uses the file hrtfearly.csd.</p> Example of the htrfearly opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n; Select flags here\n; realtime audio out\n -o dac\n; file ouput \n; -o hrtf.wav\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nnchnls = 2\n\ngasrc init 0    ;global\n\ninstr 1         ;a plucked string, distorted and filtered\n\n  iamp = 15000\n  icps = cpspch(p4)\n\n  a1 pluck iamp, icps, icps, 0, 1\n  adist distort1 a1, 10, .5, 0, 0\n  afilt moogvcf2 adist, 8000, .5 \n  aout linen afilt, 0, p3, .01\n\n  gasrc = gasrc + aout\n\nendin\n\ninstr 10        ;uses output from instr1 as source\n\n  ;simple path for source\n  kx line 2, p3, 9\n\n  ;early reflections, room default 1\n  aearlyl,aearlyr, irt60low, irt60high, imfp hrtfearly gasrc, kx, 5, 1, 5, 1, 1, \"hrtf-44100-left.dat\", \"hrtf-44100-right.dat\", 1\n\n  ;later reverb, uses outputs from above\n  arevl, arevr, idel hrtfreverb gasrc, irt60low, irt60high, \"hrtf-44100-left.dat\", \"hrtf-44100-right.dat\", 44100, imfp\n\n  ;delayed and scaled\n  alatel delay arevl * .1, idel\n  alater delay arevr * .1, idel\n\n  outs  aearlyl + alatel, aearlyr + alater\n\n  gasrc = 0\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument 1: a simple arpeggio\ni1 0 .2 8.00 \ni1 + .2 8.04\ni1 + .2 8.07\ni1 + .2 8.11\ni1 + .2 9.02\ni1 + 1.5 8.11\ni1 + 1.5 8.07\ni1 + 1.5 8.04\ni1 + 1.5 8.00\ni1 + 1.5 7.09\ni1 + 4 8.00\n\n; Play Instrument 10 for 13 seconds.\ni10 0 13\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfearly/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p>"},{"location":"opcodes/hrtfearly/#credits","title":"Credits","text":"<p>Author: Brian Carty Maynooth 2011</p>"},{"location":"opcodes/hrtfer/","title":"Hrtfer","text":""},{"location":"opcodes/hrtfer/#hrtfer","title":"hrtfer","text":"<p>Creates 3D audio for two speakers. Output is binaural (headphone) 3D audio.</p> <p> Note</p> <p>This opcode is deprecated; use hrtfstat or similar opcode instead</p>"},{"location":"opcodes/hrtfer/#syntax","title":"Syntax","text":"<pre><code>aleft, aright hrtfer asig, kaz, kelev, &amp;#8220;HRTFcompact&amp;#8221;\n</code></pre>"},{"location":"opcodes/hrtfer/#initialization","title":"Initialization","text":"<p>kAz -- azimuth value in degrees. Positive values represent position on the right, negative values are positions on the left.</p> <p>kElev -- elevation value in degrees. Positive values represent position above horizontal, negative values are positions under horizontal.</p> <p>At present, the only file which can be used with hrtfer is HRTFcompact. It must be passed to the opcode as the last argument within quotes as shown above.</p> <p>HRTFcompact may also be obtained via anonymous ftp from: ftp://ftp.cs.bath.ac.uk/pub/dream/utilities/Analysis/HRTFcompact</p>"},{"location":"opcodes/hrtfer/#performance","title":"Performance","text":"<p>These unit generators place a mono input signal in a virtual 3D space around the listener by convolving the input with the appropriate HRTF data specified by the opcode's azimuth and elevation values. hrtfer allows these values to be k-values, allowing for dynamic spatialization. hrtfer can only place the input at the requested position because the HRTF is loaded in at i-time (remember that currently, CSound has a limit of 20 files it can hold in memory, otherwise it causes a segmentation fault). The output will need to be scaled either by using balance or by multiplying the output by some scaling constant.</p> <p> Note</p> <p>The sampling rate of the orchestra must be 44.1kHz. This is because 44.1kHz is the sampling rate at which the HRTFs were measured. In order to be used at a different rate, the HRTFs would need to be re-sampled at the desired rate.</p>"},{"location":"opcodes/hrtfer/#examples","title":"Examples","text":"<p>Here is an example of the hrtfer opcode. It uses the file hrtfer.csd,  HRTFcompact, and drumsMlp.wav.</p> Example of the hrtfer opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o hrtfer.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\ninstr 1\n  kaz          linseg 0, p3, -360  ; move the sound in circle\n  kel          linseg -40, p3, 45  ; around the listener, changing\n                                    ; elevation as its turning\n  asrc         soundin \"beats.wav\"\n  aleft,aright hrtfer asrc, kaz, kel, \"HRTFcompact\"\n  aleftscale   = aleft * 200\n  arightscale  = aright * 200\n\n  outs         aleftscale, arightscale\nendin        \n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfer/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p>"},{"location":"opcodes/hrtfer/#credits","title":"Credits","text":"<p>Authors: Eli Breder and David MacIntyre Montreal 1996</p> <p>Fixed the example thanks to a message from Istvan Varga.</p>"},{"location":"opcodes/hrtfmove/","title":"Hrtfmove","text":""},{"location":"opcodes/hrtfmove/#hrtfmove","title":"hrtfmove","text":"<p>Generates dynamic 3d binaural audio for headphones using magnitude interpolation and phase truncation.</p> <p>This opcode takes a source signal and spatialises it in the 3 dimensional space around a listener by convolving the source with stored head related transfer function (HRTF) based filters.</p>"},{"location":"opcodes/hrtfmove/#syntax","title":"Syntax","text":"<pre><code>aleft, aright hrtfmove asrc, kAz, kElev, ifilel, ifiler [, imode, ifade, isr]\n</code></pre>"},{"location":"opcodes/hrtfmove/#initialization","title":"Initialization","text":"<p>ifilel -- left HRTF spectral data file</p> <p>ifiler -- right HRTF spectral data file</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) are available in 3 different sampling rates: 44.1, 48 and 96 khz and are labelled accordingly. Input and processing sr should match datafile sr. Files should be in the current directory or the SADIR (see Environment Variables).</p> <p> Note</p> <p>HRTF Data files for use with hrtfmove, hrtfmove2, hrtfstat, hrtfearly, hrtfreverb were updated for Csound 5.15 and later (the code was updated and is more efficient). Old datafiles are now deprecated.</p> <p>imode -- optional, default 0 for phase truncation, 1 for minimum phase</p> <p>ifade -- optional, number of processing buffers for phase change crossfade (default 8). Legal range is 1-24. A low value is recommended for complex sources (4 or less: a higher value may make the crossfade audible), a higher value (8 or more: a lower value may make the inconsistency when the filter changes phase values audible) for narrowband sources. Does not effect minimum phase processing.</p> <p> Note</p> <p>Ocassionally fades may overlap (when unnaturally fast/complex trajectories are requested). In this case, a warning will be printed. Use a smaller crossfade or slightly change trajectory to avoid any possible inconsistencies that may arise.</p> <p>isr - optional, default 44.1kHz, legal values: 44100, 48000 and 96000.</p>"},{"location":"opcodes/hrtfmove/#performance","title":"Performance","text":"<p>kAz -- azimuth value in degrees. Positive values represent position on the right, negative values are positions on the left.</p> <p>kElev -- elevation value in degrees. Positive values represent position above horizontal, negative values are positions below horizontal (min -40).</p> <p>Artifact-free user-defined trajectories are made possible using an interpolation algorithm based on spectral magnitude interpolation and phase truncation. Crossfades are implemented to minimise/eliminate any inconsistencies caused by updating phase values. These crossfades are performed over a user definable number of convolution processing buffers. Complex sources may only need to crossfade over 1 buffer; narrow band sources may need several. The opcode also offers minimum phase based processing, a more traditional and complex method. In this mode, the hrtf filters used are reduced to minimum phase representations and the interpolation process then uses the relationship between minimum phase magnitude and phase spectra. Interaural time difference, which is inherent to the phase truncation process, is reintroduced in the minimum phase process using variable delay lines.</p>"},{"location":"opcodes/hrtfmove/#examples","title":"Examples","text":"<p>Here is an example of the hrtfmove opcode. It uses the file hrtfmove.csd.</p> Example of the htrfmove opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select flags here\n; realtime audio out \n -o dac \n; For Non-realtime ouput leave only the line below:\n ;-o hrtf.wav\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\ngasrc init 0\n\ninstr 1         ;a plucked string\n\n  kamp = p4\n  kcps = cpspch(p5)\n  icps = cpspch(p5)\n\n  a1 pluck kamp, kcps, icps, 0, 1\n\n  gasrc = a1\n\nendin\n\ninstr 10        ;uses output from instr1 as source\n\n kaz    linseg 0, p3, 720               ;2 full rotations\n\n aleft,aright hrtfmove gasrc, kaz,0, \"hrtf-44100-left.dat\",\"hrtf-44100-right.dat\"\n\n outs   aleft, aright\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument 1: a simple arpeggio\ni1 0 .2 15000 8.00 \ni1 + .2 15000 8.04\ni1 + .2 15000 8.07\ni1 + .2 15000 8.11\ni1 + .2 15000 9.02\ni1 + 1.5 15000 8.11\ni1 + 1.5 15000 8.07\ni1 + 1.5 15000 8.04\ni1 + 1.5 15000 8.00\ni1 + 1.5 15000 7.09\ni1 + 1.5 15000 8.00\n\n; Play Instrument 10 for 10 seconds.\ni10 0 10\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfmove/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p> <p>More information on this opcode: http://www.csoundjournal.com/issue9/newHRTFOpcodes.html, written by Brian Carty</p>"},{"location":"opcodes/hrtfmove/#credits","title":"Credits","text":"<p>Author: Brian Carty Maynooth 2008</p>"},{"location":"opcodes/hrtfmove2/","title":"Hrtfmove2","text":""},{"location":"opcodes/hrtfmove2/#hrtfmove2","title":"hrtfmove2","text":"<p>Generates dynamic 3d binaural audio for headphones using a Woodworth based spherical head model with improved low frequency phase accuracy.</p> <p>This opcode takes a source signal and spatialises it in the 3 dimensional space around a listener using head related transfer function (HRTF) based filters.</p>"},{"location":"opcodes/hrtfmove2/#syntax","title":"Syntax","text":"<pre><code>aleft, aright hrtfmove2 asrc, kAz, kElev, ifilel, ifiler [,ioverlap, iradius, isr]\n</code></pre>"},{"location":"opcodes/hrtfmove2/#initialization","title":"Initialization","text":"<p>ifilel -- left HRTF spectral data file</p> <p>ifiler -- right HRTF spectral data file</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) are available in 3 different sampling rates: 44.1, 48 and 96 khz and are labelled accordingly. Input and processing sr should match datafile sr. Files should be in the current directory or the SADIR (see Environment Variables).</p> <p> Note</p> <p>HRTF Data files for use with hrtfmove, hrtfmove2, hrtfstat, hrtfearly, hrtfreverb were updated for Csound 5.15 and later (the code was updated and is more efficient). Old datafiles are now deprecated.</p> <p>ioverlap -- optional, number of overlaps for STFT processing (default 4). See STFT section of manual.</p> <p>iradius --  optional, head radius used for phase spectra calculation in centimeters (default 9.0)</p> <p>isr - optional, default 44.1kHz, legal values: 44100, 48000 and 96000.</p>"},{"location":"opcodes/hrtfmove2/#performance","title":"Performance","text":"<p>asrc -- Input/source signal.</p> <p>kAz -- azimuth value in degrees. Positive values represent position on the right, negative values are positions on the left.</p> <p>kElev -- elevation value in degrees. Positive values represent position above horizontal, negative values are positions below horizontal (min -40).</p> <p>Artifact-free user-defined trajectories are made possible using an interpolation algorithm based on spectral magnitude interpolation and a derived phase spectrum based on the Woodworth spherical head model. Accuracy is increased for the data set provided by extracting and applying a frequency dependent scaling factor to the phase spectra, leading to a more precise low frequency interaural time difference. Users can control head radius for the phase derivation, allowing a crude level of individualisation. The dynamic source version of the opcode uses a Short Time Fourier Transform algorithm to avoid artefacts caused by derived phase spectra changes. STFT processing means this opcode is more computationally intensive than hrtfmove using phase truncation, but phase is constantly updated by hrtfmove2.</p>"},{"location":"opcodes/hrtfmove2/#examples","title":"Examples","text":"<p>Here is an example of the hrtfmove2 opcode. It uses the file hrtfmove2.csd.</p> Example of the htrfmove2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select flags here\n; realtime audio out \n -o dac \n; For Non-realtime ouput leave only the line below:\n; -o hrtf.wav\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\ngasrc init 0\n\ninstr 1         ;a plucked string\n\n  kamp = p4\n  kcps = cpspch(p5)\n  icps = cpspch(p5)\n\n  a1 pluck kamp, kcps, icps, 0, 1\n\n  gasrc = a1\n\nendin\n\ninstr 10        ;uses output from instr1 as source\n\n kaz    linseg 0, p3, 720               ;2 full rotations\n\n aleft,aright hrtfmove2 gasrc, kaz,0, \"hrtf-44100-left.dat\",\"hrtf-44100-right.dat\"\n\n outs   aleft, aright\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument 1: a simple arpeggio\ni1 0 .2 15000 8.00 \ni1 + .2 15000 8.04\ni1 + .2 15000 8.07\ni1 + .2 15000 8.11\ni1 + .2 15000 9.02\ni1 + 1.5 15000 8.11\ni1 + 1.5 15000 8.07\ni1 + 1.5 15000 8.04\ni1 + 1.5 15000 8.00\ni1 + 1.5 15000 7.09\ni1 + 1.5 15000 8.00\n\n; Play Instrument 10 for 10 seconds.\ni10 0 10\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfmove2/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p> <p>More information on this opcode: http://www.csoundjournal.com/issue9/newHRTFOpcodes.html, written by Brian Carty</p>"},{"location":"opcodes/hrtfmove2/#credits","title":"Credits","text":"<p>Author: Brian Carty Maynooth 2008</p>"},{"location":"opcodes/hrtfreverb/","title":"Hrtfreverb","text":""},{"location":"opcodes/hrtfreverb/#hrtfreverb","title":"hrtfreverb","text":"<p>A binaural, dynamic FDN based diffuse-field reverberator. The opcode works independently as an efficient, flexible reverberator.</p> <p>A frequency-dependent, efficient reverberant field is created based on low and high frequency desired reverb times. The opcode is designed to work with hrtfearly, ideally using its outputs as inputs. However, hrtfreverb can be used as a standalone tool. Stability is enforced.</p> <p>It is, however, designed for use with hrtfearly to provide spatially accurate reverberation with user definable source trajectories. Accurate interaural coherence is also provided.</p>"},{"location":"opcodes/hrtfreverb/#syntax","title":"Syntax","text":"<pre><code>aleft, aright, idel hrtfreverb asrc, ilowrt60, ihighrt60, ifilel, ifiler \\\n                               [,isr, imfp, iorder]\n</code></pre>"},{"location":"opcodes/hrtfreverb/#initialization","title":"Initialization","text":"<p>ilowrt60 - low frequency reverb time.</p> <p>ihighrt60 - high frequency reverb time.</p> <p>ifilel - left HRTF spectral data file.</p> <p>ifiler - right HRTF spectral data file.</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) are available in 3 different sampling rates: 44.1, 48 and 96 kHz and are labelled accordingly. Input and processing sr should match datafile sr. Files should be in the current directory or the SADIR (see Environment Variables).</p> <p> Note</p> <p>HRTF Data files for use with hrtfmove, hrtfmove2, hrtfstat, hrtfreverb were updated for Csound 5.15 and later (the code was updated and is more efficient). Old datafiles are now deprecated.</p> <p>isr - optional, default 44.1kHz, legal values: 44100, 48000 and 96000.</p> <p>imfp - optional, mean free path, defaults to that of a medium room. If used with hrtfearly, the mean free path of the room can be used to calculate the appropriate delay for the later reverb. Legal range: the mean free path of the smallest room allowed by hrtfearly (0.003876)  1.</p> <p>iorder - optional, order of early reflection processing. If used with hrtfearly, the order of early reflections can be used to calculate the appropriate delay on the later reverb.</p>"},{"location":"opcodes/hrtfreverb/#performance","title":"Performance","text":"<p>asrc - Input/source signal.</p>"},{"location":"opcodes/hrtfreverb/#output","title":"Output","text":"<p>idel - if used with hrtfearly, the appropriate delay for the later reverb, based on the room and order of processing.</p>"},{"location":"opcodes/hrtfreverb/#examples","title":"Examples","text":"<p>Here is an example of the hrtfearly and hrtfreverb opcodes. It uses the file hrtfearly.csd.</p> Example of the htrfearly opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n; Select flags here\n; realtime audio out\n -o dac\n; file ouput \n; -o hrtf.wav\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nnchnls = 2\n\ngasrc init 0    ;global\n\ninstr 1         ;a plucked string, distorted and filtered\n\n  iamp = 15000\n  icps = cpspch(p4)\n\n  a1 pluck iamp, icps, icps, 0, 1\n  adist distort1 a1, 10, .5, 0, 0\n  afilt moogvcf2 adist, 8000, .5 \n  aout linen afilt, 0, p3, .01\n\n  gasrc = gasrc + aout\n\nendin\n\ninstr 10        ;uses output from instr1 as source\n\n  ;simple path for source\n  kx line 2, p3, 9\n\n  ;early reflections, room default 1\n  aearlyl,aearlyr, irt60low, irt60high, imfp hrtfearly gasrc, kx, 5, 1, 5, 1, 1, \"hrtf-44100-left.dat\", \"hrtf-44100-right.dat\", 1\n\n  ;later reverb, uses outputs from above\n  arevl, arevr, idel hrtfreverb gasrc, irt60low, irt60high, \"hrtf-44100-left.dat\", \"hrtf-44100-right.dat\", 44100, imfp\n\n  ;delayed and scaled\n  alatel delay arevl * .1, idel\n  alater delay arevr * .1, idel\n\n  outs  aearlyl + alatel, aearlyr + alater\n\n  gasrc = 0\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument 1: a simple arpeggio\ni1 0 .2 8.00 \ni1 + .2 8.04\ni1 + .2 8.07\ni1 + .2 8.11\ni1 + .2 9.02\ni1 + 1.5 8.11\ni1 + 1.5 8.07\ni1 + 1.5 8.04\ni1 + 1.5 8.00\ni1 + 1.5 7.09\ni1 + 4 8.00\n\n; Play Instrument 10 for 13 seconds.\ni10 0 13\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfreverb/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p>"},{"location":"opcodes/hrtfreverb/#credits","title":"Credits","text":"<p>Author: Brian Carty Maynooth 2011</p>"},{"location":"opcodes/hrtfstat/","title":"Hrtfstat","text":""},{"location":"opcodes/hrtfstat/#hrtfstat","title":"hrtfstat","text":"<p>Generates static 3d binaural audio for headphones using a Woodworth based spherical head model with improved low frequency phase accuracy.</p> <p>This opcode takes a source signal and spatialises it in the 3 dimensional space around a listener using head related transfer function (HRTF) based filters. It produces a static output (azimuth and elevation parameters are i-rate), because a static source allows much more efficient processing than hrtfmove and hrtfmove2,.</p>"},{"location":"opcodes/hrtfstat/#syntax","title":"Syntax","text":"<pre><code>aleft, aright hrtfstat asrc, iAz, iElev, ifilel, ifiler [,iradius, isr]\n</code></pre>"},{"location":"opcodes/hrtfstat/#initialization","title":"Initialization","text":"<p>iAz -- azimuth value in degrees. Positive values represent position on the right, negative values are positions on the left.</p> <p>iElev -- elevation value in degrees. Positive values represent position above horizontal, negative values are positions below horizontal (min -40).</p> <p>_ifilel _ -- left HRTF spectral data file</p> <p>_ifiler _ -- right HRTF spectral data file</p> <p> Note</p> <p>Spectral datafiles (based on the MIT HRTF database) are available in 3 different sampling rates: 44.1, 48 and 96 khz and are labelled accordingly. Input and processing sr should match datafile sr. Files should be in the current directory or the SADIR (see Environment Variables). </p> <p> Note</p> <p>HRTF Data files for use with hrtfmove, hrtfmove2, hrtfstat, hrtfearly, hrtfreverb were updated for Csound 5.15 and later (the code was updated and is more efficient). Old datafiles are now deprecated.</p> <p>iradius --  optional, head radius used for phase spectra calculation in centimeters (default 9.0)</p> <p>isr - optional (default 44.1kHz). Legal values are 44100, 48000 and 96000.</p>"},{"location":"opcodes/hrtfstat/#performance","title":"Performance","text":"<p>Artifact-free user-defined static spatialisation is made possible using an interpolation algorithm based on spectral magnitude interpolation and a derived phase based on the Woodworth spherical head model. Accuracy is increased for the data set provided by extracting and applying a frequency dependent scaling factor to the phase spectra, leading to a more precise low frequency interaural time difference. Users can control head radius for the phase derivation, allowing a crude level of individualisation. The static source version of the opcode uses overlap add convolution (it does not need STFT processing, see hrtfmove2), and is thus considerably more efficient than hrtfmove2 or hrtfmove, but cannot generate moving sources.</p>"},{"location":"opcodes/hrtfstat/#examples","title":"Examples","text":"<p>Here is an example of the hrtfstat opcode. It uses the file hrtfstat.csd.</p> Example of the hrtfstat opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o hrtfstat.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngasrc init 0\n\ninstr 1 ;a plucked string\n\nkamp = p4\nkcps = cpspch(p5)\nicps = cpspch(p5)\na1 pluck kamp, kcps, icps, 0, 1\n\ngasrc = a1\n\nendin\n\ninstr 10;uses output from instr1 as source\n\naleft,aright hrtfstat gasrc, 90,0, \"hrtf-44100-left.dat\",\"hrtf-44100-right.dat\"\n             outs     aleft, aright\n\nclear gasrc\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2 .7 8.00  ; Play Instrument 1: a plucked string\ni1 .5 2 .7 8.00\ni1 1 2 .7 8.00\ni1 2 2 .7 7.00\n\ni10 0 12        ; Play Instrument 10 for 2 seconds.\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the hrtfstat opcode. It uses the file htrfstat-2.csd, and Church.wav, which is a looped sample.</p> Example two of the hrtfstat opcode<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o hrtfstat-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niAz   = p4\niElev = p5\n\nitim = ftlptim(1)\n;    transeg a   dur   ty  b  dur    ty  c    dur   ty  d\nkamp transeg 0, p3*.1, 0, .9, p3*.3, -3, .5,  p3*.3, -2, 0\nain  loscil3 kamp, 50, 1\naleft,aright hrtfstat ain, iAz, iElev, \"hrtf-44100-left.dat\",\"hrtf-44100-right.dat\"\n     outs aleft, aright\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"Church.wav\" 0 0 0 ;Csound computes tablesize\n\n;      Azim Elev\ni1 0 7  90   0  ;to the right\ni1 3 7 -90  -40 ;to the left and below\ni1 6 7 180   90 ;behind and up\ne \n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hrtfstat/#see-also","title":"See also","text":"<p>Panning and Spatialization: Binaural spatialization</p> <p>More information on this opcode: http://www.csoundjournal.com/issue9/newHRTFOpcodes.html, written by Brian Carty</p>"},{"location":"opcodes/hrtfstat/#credits","title":"Credits","text":"<p>Author: Brian Carty Maynooth 2008</p>"},{"location":"opcodes/hsboscil/","title":"Hsboscil","text":""},{"location":"opcodes/hsboscil/#hsboscil","title":"hsboscil","text":"<p>An oscillator which takes tonality and brightness as arguments, relative to a base frequency.</p>"},{"location":"opcodes/hsboscil/#syntax","title":"Syntax","text":"<pre><code>ares hsboscil kamp, ktone, kbrite, ibasfreq, iwfn, ioctfn \\\n              [, ioctcnt] [, iphs]\n</code></pre>"},{"location":"opcodes/hsboscil/#initialization","title":"Initialization","text":"<p>ibasfreq -- base frequency to which tonality and brighness are relative</p> <p>iwfn -- function table of the waveform, usually a sine</p> <p>ioctfn -- function table used for weighting the octaves, usually something like:</p> <p><code>f1 0  1024  -19  1  0.5  270  0.5</code></p> <p>ioctcnt (optional) -- number of octaves used for brightness blending. Must be in the range 2 to 10. Default is 3.</p> <p>iphs (optional, default=0) -- initial phase of the oscillator. If iphs = -1, initialization is skipped.</p>"},{"location":"opcodes/hsboscil/#performance","title":"Performance","text":"<p>kamp -- amplitude of note</p> <p>ktone -- cyclic tonality parameter relative to ibasfreq in logarithmic octave, range 0 to 1, values &gt;&gt; 1 can be used, and are internally reduced to frac(ktone).</p> <p>kbrite -- brightness parameter relative to ibasfreq, achieved by weighting ioctcnt octaves. It is scaled in such a way, that a value of 0 corresponds to the orignal value of ibasfreq, 1 corresponds to one octave above ibasfreq, -2 corresponds to two octaves below ibasfreq, etc. kbrite may be fractional.</p> <p>hsboscil takes tonality and brightness as arguments, relative to a base frequency (ibasfreq). Tonality is a cyclic parameter in the logarithmic octave, brightness is realized by mixing multiple weighted octaves. It is useful when tone space is understood in a concept of polar coordinates.</p> <p>Making ktone a line, and kbrite a constant, produces Risset's glissando.</p> <p>Oscillator table iwfn is always read interpolated. Performance time requires about ioctcnt * oscili.</p>"},{"location":"opcodes/hsboscil/#examples","title":"Examples","text":"<p>Here is an example of the hsboscil opcode. It uses the file hsboscil.csd.</p> Example of the hsboscil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o hsboscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; synth waveform\ngiwave  ftgen 1, 0, 1024, 10, 1, 1, 1, 1\n; blending window\ngiblend ftgen 2, 0, 1024, -19, 1, 0.5, 270, 0.5\n\ninstr 1 ; produces Risset's glissando.\n\n  kamp = .4\n  kbrite = 0.3\n  ibasfreq = 200\n  ioctcnt = 5\n\n  ; Change ktone linearly from 0 to 1, \n  ; over the period defined by p3.\n  ktone line 0, p3, 1\n\nasig hsboscil kamp, ktone, kbrite, ibasfreq, giwave, giblend, ioctcnt\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the hsboscil opcode in a MIDI instrument. It uses the file hsboscil_midi.csd.</p> Example of the hsboscil opcode in a MIDI instrument.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out  \n-odac   -M0 ;;;realtime audio out and realtime MIDI in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; -o hsboscil_midi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; synth waveform\ngiwave  ftgen 1, 0, 1024, 10, 1, 1, 1, 1\n; blending window\ngiblend ftgen 2, 0, 1024, -19, 1, 0.5, 270, 0.5\n\ninstr 1\n\nibase = cpsoct(6)\nioctcnt = 5\n\n; all octaves sound alike.\n  itona octmidi\n  ; velocity is mapped to brightness\n  ibrite ampmidi 4\n\n; Map an exponential envelope for the amplitude.\nkenv expon .8, 1, .01\nasig hsboscil kenv, itona, ibrite, ibase, giwave, giblend, ioctcnt\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 30 ; play for 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hsboscil/#see-also","title":"See also","text":"<p>Additive Synthesis/Resynthesis</p>"},{"location":"opcodes/hsboscil/#credits","title":"Credits","text":"<p>Author: Peter Neub\u00e4cker Munich, Germany August, 1999</p> <p>New in Csound version 3.58</p>"},{"location":"opcodes/hvs1/","title":"Hvs1","text":""},{"location":"opcodes/hvs1/#hvs1","title":"hvs1","text":"<p>Allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.</p>"},{"location":"opcodes/hvs1/#syntax","title":"Syntax","text":"<pre><code>hvs1 kx, inumParms, inumPointsX, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]\n</code></pre>"},{"location":"opcodes/hvs1/#initialization","title":"Initialization","text":"<p>inumParms - number of parameters controlled by the HVS. Each HVS snapshot is made up of inumParms elements.</p> <p>inumPointsX - number of points that each dimension of the HVS cube (or square in case of two-dimensional HVS; or line in case of one-dimensional HVS) is made up.</p> <p>iOutTab - number of the table receiving the set of output-parameter instant values of the HVS. The total amount of parameters is defined by the inumParms argument.</p> <p>iPositionsTab \u2013 a table filled with the individual positions of snapshots in the HVS matrix (see below for more information).</p> <p>iSnapTab \u2013 a table filled with all the snapshots. Each snapshot is made up of a set of parameter values. The amount of elements contained in each snapshots is specified by the inumParms argument. The set of elements of each snapshot follows (and is adjacent) to the previous one in this table. So the total size of this table should be &gt;= to inumParms multiplied the number of snapshots you intend to store for the HVS.</p> <p>iConfigTab \u2013 (optional) a table containing the behavior of the HVS for each parameter. If the value of iConfigTab is zero (default), this argument is ignored, meaning that each parameter is treated with linear interpolation by the HVS. If iConfigTab is different than zero, then it must refer to an existing table whose contents are in its turn referring to a particolar kind of interpolation. In this table, a value of -1 indicates that corresponding parameter is leaved unchanged (ignored) by the HVS; a value of zero indicates that corresponding parameter is treated with linear-interpolation; each other values must be integer numbers indicating an existing table filled with a shape which will determine the kind of special interpolation to be used (table-based interpolation).</p>"},{"location":"opcodes/hvs1/#performance","title":"Performance","text":"<p>kx -  these are externally-modified variables which controls the motion of the pointer in the HVS matrix cube (or square or line in case of HVS matrices made up of less than 3 dimensions). The range of these input arguments must be 0 to 1.</p> <p>Hyper Vectorial Synthesis is a technique that allows control of a huge set of parameters by using a simple and global approach. The key concepts of the HVS are:</p> <p>The set of HVS parameters, whose amount is fixed and defined by the inumParms argument. During the HVS performance, all these parameters are variant and can be applied to any sound synthesis technique, as well as to any global control for algorithmic composition and any other kind of level. The user must previously define several sets of fixed values for each HVS parameter, each set corresponding to a determinate synthesis configuration. Each set of values is called snapshot, and can be considered as the coordinates of a bound of a multi-dimensional space. The HVS consists on moving a point in this multi-dimensional space (by using a special motion pointer, see below), according and inside the bounds defined by the snapshots. You can fix any amount of HVS parameters (each parameter being a dimension of the multi-dimensional space), even a huge number, the limit only depends on the processing power (and the memory) of your computer and on the complexity of the sound-synthesis you will use.</p> <p>The HVS cube (or square or line). This is the matrix (of 3, 2 or 1 dimensions, according to the hvs opcode you intend to use) of \u201cmainstays\u201d (or pivot) points of HVS. The total amount of pivot-points depends on the value of the inumPointsX, inumPointsY and inumPointsZ arguments. In the case of a 3-dimensional HVS matrix you can define, for instance, 3 points for the X dimension, 5 for the Y dimension and 2 for the Z dimension. In this case, the total number of pivot-points is 3 * 5 * 2 = 30. With this set of pivot points, the cube Is divided into smaller cubed zones each one bounded by eight nearby points. Each point is numbered. The numeral order of these points is enstabilished in the following way: number zero is the first point, number 1 the second and so on. Assuming you are using a 3-dimensional HVS cube having the number of points above mentioned (i.e. 3, 5 and 2 respectively for the X, Y and Z axis), the first point (point zero) is the upper-left-front vertex of the cube, by facing the XY plane of the cube. The second point is the middle point of the upper front edge of the cube and so on. You can refer to the figure below in order to understand how the numeral order of the pivot-points proceeds:</p> <p>For the 2-dimensional HVS, it is the same, by only omitting the rear cube face, so each zone is bounded by 4 pivot-points instead of 8. For the 1-dimensional HVS, the whole thing is even simpler because it is a line with the pivot-points proceeding from left to right. Each point is coupled with a snapshot.</p> <p>Snapshot order, as stored into the iSnapTab, can or cannot follow the order of the pivot-points numbers. In fact it is possible to alter this order by means the iPositionsTab, a table that remaps the position of each snapshot in relation to the pivot points. The iPositionsTab is made up of the positions of the snapshots (contained in the iSnapTab) in the two-dimensional grid. Each subsequent element is actually a pointer representing the position in the iSnapTab. For example, in a 2-dimensional HVS matrix such as the following (in this case having inumPointsX = 3 and inumPointsY = 5:</p> 5 7 1 3 4 9 6 2 0 4 1 3 8 2 7 <p>These numbers (to be stored in the iSnapTab table by using, for instance, the GEN02 function generator) represents the snapshot position within the grid (in this case a 3x5 matrix). So, the first element 5, has index zero and represents the 6th (element zero is the first) snapshot contained in the iSnapTab, the second element 7 represents the 8th element of iSnapTab and so on. Summing up, the vertices of each zone (a cubed zone is delimited by 8 vertices; a squared zone by 4 vertices and a linear zone by 2 points) are coupled with a determinate snapshot, whose number is remapped by the iSnapTab.</p> <p>Output values of the HVS are influenced by the motion pointer, a point whose position, in the HVS cube (or square or segment) is determined by the kx, ky and kz arguments. The values of these arguments, which must be in the 0 to 1 range, are externally set by the user. The output values, whose amount is equal to the inumParms argument, are stored in the iOutTab, a table that must be already allocated by the user, and must be at least inumParms size. In what way the motion pointer influences the output? Well, when the motion pointer falls in a determinate cubed zone, delimited, for instance, by 8 vertices (or pivot points), we assume that each vertex has associated a different snapshot (i.e. a set of inumParms values), well, the output will be the weighted average value of the 8 vertices, calculated according on the distance of the motion pointer from each of the 8 vertices. In the case of a default behavior, when the iConfigTab argument is not set, the exact output is calculated by using linear interpolation which is applied to each different parameter of the HVS. Anyway, it is possible to influence this behavior by setting the iConfigTab argument to a number of a table whose contents can affect one or more HVS parameters. The iConfigTab table elements are associated to each HVS parameter and their values affect the HVS output in the following way:</p> <ul> <li>If iConfigTab is equal to -1, corresponding output is skipped, i.e. the element is not calculated, leaving corresponding element value in the iOutTab unchanged;</li> <li>If iConfigTab is equal to zero, then the normal HVS output is calculated (by using weighted average of the nearest vertex of current zone where it falls the motion pointer);</li> <li>If iConfigTab element is equal to an integer number &gt; zero, then the contents of a table having that number is used as a shape of a table-based interpolation.</li> </ul>"},{"location":"opcodes/hvs1/#examples","title":"Examples","text":"<p>Here is an example of the hvs1 opcode. It uses the file hvs1.csd.</p> Example of the hvs1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac     ;      -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o hvs1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\nnchnls=2\n0dbfs = 1\n\n; after the original FLTK example by Gabriel Maldonado and Andres Cabrera\n; by Stefano Cucchi and Menno Knevel\n\ninstr 1\ninumLinesX init 16\ninumParms  init 3\niOutTab  ftgen   5,0,8, -2,   0\niPosTab  ftgen   6,0,32, -2,  3,2,1,0,4,5,6,7,8,9,10, 11, 15, 14, 13, 12\niSnapTab ftgen   8,0,64, -2,  1,1,1,   2,0,0,  3,2,0,  2,2,2,  5,2,1,  2,3,4,  6,1,7,  0,0,0, \\\n                              1,3,5,   3,4,4,  1,5,8,  1,1,5,  4,3,2,  3,4,5,  7,6,5,  7,8,9\nk1 linseg 0, p3, 1\nprintk 0.2, k1\n;           kx,   inumParms,  inumPointsX,  iOutTab,  iPosTab,  iSnapTab  [, iConfigTab]\n    hvs1    k1,  inumParms, inumLinesX, iOutTab, iPosTab, iSnapTab  ;, iConfigTab\n\nk0  tab     0, 5\nk1  tab     1, 5\nk2  tab     2, 5\n\nprintk2 k0\nprintk2 k1, 10\nprintk2 k2, 20\n\naosc1 oscil k0/20, k1*100 + 200, 1\naosc2 oscil k1/20, k2*100 + 200, 1\naosc3 oscil k2/20, k0*100 + 200, 1\naosc4 oscil k1/20, k0*100 + 200, 1\naosc5 oscil k2/20, k1*100 + 200, 1\naosc6 oscil k0/20, k2*100 + 200, 1\nouts (aosc1 + aosc2 + aosc3)*0.7, (aosc4 + aosc5 + aosc6)*0.7\n\n    endin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 1024 10 1\ni1 0 10\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hvs1/#see-also","title":"See also","text":"<p>Hyper Vectorial Synthesis</p>"},{"location":"opcodes/hvs1/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/hvs2/","title":"Hvs2","text":""},{"location":"opcodes/hvs2/#hvs2","title":"hvs2","text":"<p>Allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.</p>"},{"location":"opcodes/hvs2/#syntax","title":"Syntax","text":"<pre><code>hvs2 kx, ky, inumParms, inumPointsX, inumPointsY, iOutTab, iPositionsTab, \\\n     iSnapTab [, iConfigTab]\n</code></pre>"},{"location":"opcodes/hvs2/#initialization","title":"Initialization","text":"<p>inumParms - number of parameters controlled by the HVS. Each HVS snapshot is made up of inumParms elements.</p> <p>inumPointsX, inumPointsY - number of points that each dimension of the HVS cube (or square in case of two-dimensional HVS; or line in case of one-dimensional HVS) is made up.</p> <p>iOutTab - number of the table receiving the set of output-parameter instant values of the HVS. The total amount of parameters is defined by the inumParms argument.</p> <p>iPositionsTab \u2013 a table filled with the individual positions of snapshots in the HVS matrix (see below for more information).</p> <p>iSnapTab \u2013 a table filled with all the snapshots. Each snapshot is made up of a set of parameter values. The amount of elements contained in each snapshots is specified by the inumParms argument. The set of elements of each snapshot follows (and is adjacent) to the previous one in this table. So the total size of this table should be &gt;= to inumParms multiplied the number of snapshots you intend to store for the HVS.</p> <p>iConfigTab \u2013 (optional) a table containing the behavior of the HVS for each parameter. If the value of iConfigTab is zero (default), this argument is ignored, meaning that each parameter is treated with linear interpolation by the HVS. If iConfigTab is different than zero, then it must refer to an existing table whose contents are in its turn referring to a particolar kind of interpolation. In this table, a value of -1 indicates that corresponding parameter is leaved unchanged (ignored) by the HVS; a value of zero indicates that corresponding parameter is treated with linear-interpolation; each other values must be integer numbers indicating an existing table filled with a shape which will determine the kind of special interpolation to be used (table-based interpolation).</p>"},{"location":"opcodes/hvs2/#performance","title":"Performance","text":"<p>kx, ky -  these are externally-modified variables which controls the motion of the pointer in the HVS matrix cube (or square or line in case of HVS matrices made up of less than 3 dimensions). The range of these input arguments must be 0 to 1.</p> <p>Hyper Vectorial Synthesis is a technique that allows control of a huge set of parameters by using a simple and global approach. The key concepts of the HVS are:</p> <p>The set of HVS parameters, whose amount is fixed and defined by the inumParms argument. During the HVS performance, all these parameters are variant and can be applied to any sound synthesis technique, as well as to any global control for algorithmic composition and any other kind of level. The user must previously define several sets of fixed values for each HVS parameter, each set corresponding to a determinate synthesis configuration. Each set of values is called snapshot, and can be considered as the coordinates of a bound of a multi-dimensional space. The HVS consists on moving a point in this multi-dimensional space (by using a special motion pointer, see below), according and inside the bounds defined by the snapshots. You can fix any amount of HVS parameters (each parameter being a dimension of the multi-dimensional space), even a huge number, the limit only depends on the processing power (and the memory) of your computer and on the complexity of the sound-synthesis you will use.</p> <p>The HVS cube (or square or line). This is the matrix (of 3, 2 or 1 dimensions, according to the hvs opcode you intend to use) of \u201cmainstays\u201d (or pivot) points of HVS. The total amount of pivot-points depends on the value of the inumPointsX, inumPointsY and inumPointsZ arguments. In the case of a 3-dimensional HVS matrix you can define, for instance, 3 points for the X dimension, 5 for the Y dimension and 2 for the Z dimension. In this case, the total number of pivot-points is 3 * 5 * 2 = 30. With this set of pivot points, the cube Is divided into smaller cubed zones each one bounded by eight nearby points. Each point is numbered. The numeral order of these points is enstabilished in the following way: number zero is the first point, number 1 the second and so on. Assuming you are using a 3-dimensional HVS cube having the number of points above mentioned (i.e. 3, 5 and 2 respectively for the X, Y and Z axis), the first point (point zero) is the upper-left-front vertex of the cube, by facing the XY plane of the cube. The second point is the middle point of the upper front edge of the cube and so on. You can refer to the figure below in order to understand how the numeral order of the pivot-points proceeds:</p> <p>For the 2-dimensional HVS, it is the same, by only omitting the rear cube face, so each zone is bounded by 4 pivot-points instead of 8. For the 1-dimensional HVS, the whole thing is even simpler because it is a line with the pivot-points proceeding from left to right. Each point is coupled with a snapshot.</p> <p>Snapshot order, as stored into the iSnapTab, can or cannot follow the order of the pivot-points numbers. In fact it is possible to alter this order by means the iPositionsTab, a table that remaps the position of each snapshot in relation to the pivot points. The iPositionsTab is made up of the positions of the snapshots (contained in the iSnapTab) in the two-dimensional grid. Each subsequent element is actually a pointer representing the position in the iSnapTab. For example, in a 2-dimensional HVS matrix such as the following (in this case having inumPointsX = 3 and inumPointsY = 5:</p> 5 7 1 3 4 9 6 2 0 4 1 3 8 2 7 <p>These numbers (to be stored in the iSnapTab table by using, for instance, the GEN02 function generator) represents the snapshot position within the grid (in this case a 3x5 matrix). So, the first element 5, has index zero and represents the 6th (element zero is the first) snapshot contained in the iSnapTab, the second element 7 represents the 8th element of iSnapTab and so on. Summing up, the vertices of each zone (a cubed zone is delimited by 8 vertices; a squared zone by 4 vertices and a linear zone by 2 points) are coupled with a determinate snapshot, whose number is remapped by the iSnapTab.</p> <p>Output values of the HVS are influenced by the motion pointer, a point whose position, in the HVS cube (or square or segment) is determined by the kx, ky and kz arguments. The values of these arguments, which must be in the 0 to 1 range, are externally set by the user. The output values, whose amount is equal to the inumParms argument, are stored in the iOutTab, a table that must be already allocated by the user, and must be at least inumParms size. In what way the motion pointer influences the output? Well, when the motion pointer falls in a determinate cubed zone, delimited, for instance, by 8 vertices (or pivot points), we assume that each vertex has associated a different snapshot (i.e. a set of inumParms values), well, the output will be the weighted average value of the 8 vertices, calculated according on the distance of the motion pointer from each of the 8 vertices. In the case of a default behavior, when the iConfigTab argument is not set, the exact output is calculated by using linear interpolation which is applied to each different parameter of the HVS. Anyway, it is possible to influence this behavior by setting the iConfigTab argument to a number of a table whose contents can affect one or more HVS parameters. The iConfigTab table elements are associated to each HVS parameter and their values affect the HVS output in the following way:</p> <ul> <li>If iConfigTab is equal to -1, corresponding output is skipped, i.e. the element is not calculated, leaving corresponding element value in the iOutTab unchanged;</li> <li>If iConfigTab is equal to zero, then the normal HVS output is calculated (by using weighted average of the nearest vertex of current zone where it falls the motion pointer);</li> <li>If iConfigTab element is equal to an integer number &gt; zero, then the contents of a table having that number is used as a shape of a table-based interpolation.</li> </ul>"},{"location":"opcodes/hvs2/#examples","title":"Examples","text":"<p>Here is an example of the hvs2 opcode. It uses the file hvs2.csd.</p> Example of the hvs2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac     ;      -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o hvs2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; updated example by Stefano Cucchi and Menno Knevel (original creators unknown)\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr   1\n\ninumLinesX init 4 ; number of LINES - matrix -  16 POINTS\ninumLinesY init 4 ; numeber of COLOUMNS\ninumParms  init 3 ; 3 PARAMETERS  every ponint of the matrix - take a look at iSnapTab\niOutTab  ftgen   5,0,8, -2,      0 ; \niPosTab  ftgen   6,0,32, -2,     3,2,1,0,4,5,6,7,8,9,10, 11, 15, 14, 13, 12\niSnapTab ftgen   8,0,64, -2,     1,1,1,  2,0,0, 3,2,0, 2,2,2, 5,2,1, 2,3,4, 6,1,7,  0,0,0, \\\n                                 1,3,5,  1,4,4, 1,5,8, 1,1,5, 4,3,2, 3,4,5, 7,6,5,  7,8,9\n\nkx linseg 0, p3*0.3, 1, p3*0.3, 0, p3*0.4, 1\nky linseg 1, p3, 0\n\n\n;     kx,  ky, inumParms,  inumlinesX,  inumlinesY,  iOutTab,  iPosTab,  iSnapTab \nhvs2  kx,  ky, inumParms,  inumLinesX,  inumLinesY,  iOutTab,  iPosTab,  iSnapTab  \n\nk0  tab    0, 5 ; init first value of 3 of iSnapTab\nk1  tab    1, 5 ; init  second value of 3 of iSnapTab\nk2  tab    2, 5 ; init third value of 3 of iSnapTab\n\nprintk2 k0, 10\nprintk2 k1, 10\nprintk2 k2, 10\n\n; Make parameters of synthesis depend on the table values produced by hvs\n; k0 = first value of group of three in iSnapTab\n; k1 = second value of group of three in iSnapTab\n; k2 = first value of group of three in iSnapTab\n\nares1 fof 0.2, k0*100 + 50, k1*100 + 200, 0, k2 * 10 + 50, 0.003, 0.02, 0.007, 20, \\\n      1, 2, p3\nares2 fof 0.2, k1*100 + 50, k2*100 + 200, 0, k0 * 10 + 50, 0.003, 0.02, 0.007, 20, \\\n      1, 2, p3\nkdeclik linseg 0, 0.3, 1, p3-0.6, 1, 0.3, 0\nouts ares1*kdeclik, ares2*kdeclik\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 1024 10 1  ;Sine wave\nf 2 0 1024 19 0.5 0.5 270 0.5  ;Grain envelope table\n\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is second example of the hvs2 opcode. It uses the file hvs2-2.csd.</p> Second example of the hvs2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o hvs2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=48000\nksmps=100\nnchnls=2\n\n; Example by James Hearon 2008\n; Edited by Andres Cabrera\n\nginumPointsX init       16\nginumPointsY init       16\nginumParms  init        3\n\n;Generate 9 tables with arbitrary points\ngitmp ftgen 100, 0, 16, -2, 70, 260, 390, 180, 200, 300, 980, 126, \\\n                330, 860, 580, 467, 220, 399, 1026, 1500\ngitmp ftgen 200, 0, 16, -2, 100, 200, 300, 140, 600, 700, 880, 126, \\\n                330, 560, 780, 167, 220, 999, 1026, 1500\ngitmp ftgen 300, 0, 16, -2, 400, 200, 300, 540, 600, 700, 880, 126, \\\n                330, 160, 780, 167, 820, 999, 1026, 1500\ngitmp ftgen 400, 0, 16, -2, 100, 200, 800, 640, 600, 300, 880, 126, \\\n                330, 660, 780, 167, 220, 999, 1026, 1500\ngitmp ftgen 500, 0, 16, -2, 200, 200, 360, 440, 600, 700, 880, 126, \\\n                330, 560, 380, 167, 220, 499, 1026, 1500\ngitmp ftgen 600, 0, 16, -2, 100, 600, 300, 840, 600, 700, 880, 126, \\\n                330, 260, 980, 367, 120, 399, 1026, 1500\ngitmp ftgen 700, 0, 16, -2, 100, 200, 300, 340, 200, 500, 380, 126, \\\n                330, 860, 780, 867, 120, 999, 1026, 1500\ngitmp ftgen 800, 0, 16, -2, 100, 600, 300, 240, 200, 700, 880, 126, \\\n                130, 560, 980, 167, 220, 499, 1026, 1500\ngitmp ftgen 900, 0, 16, -2, 100, 800, 200, 140, 600, 700, 680, 126, \\\n                330, 560, 780, 167, 120, 299, 1026, 1500\n\ngiOutTab ftgen   5,0,8, -2,      0\ngiPosTab ftgen   6,0,32, -2, 0,1,2,3,4,5,6,7,8,9,10, 11, 15, 14, 13, 12\ngiSnapTab ftgen   8,0,64, -2,  1,1,1,   2,0,0,  3,2,0,  2,2,2,  \\\n        5,2,1,  2,3,4,  6,1,7,  0,0,0,  1,3,5,  3,4,4,  1,5,8,  1,1,5,  \\\n        4,3,2,  3,4,5,  7,6,5,  7,8,9\n\ntb0_init        giOutTab\n\n        FLpanel \"hsv2\",440,100,10,10,0\ngk1,ih1 FLslider \"X\", 0,1, 0, 5, -1, 400,20, 20,10\ngk2, ih2 FLslider \"Y\", 0, 1, 0, 5, -1, 400, 20, 20, 50\n        FLpanel_end\n\n        FLpanel \"hvsBox\",280,280,500,1000,0\n;ihandle FLhvsBox inumlinesX, inumlinesY, iwidth, iheight, ix, iy [, image]\ngih1  FLhvsBox  16, 16, 250, 250, 10, 1\n        FLpanel_end\n        FLrun\n\n\n        instr   1\nFLhvsBoxSetValue gk1, gk2, gih1\n\nhvs2    gk1,gk2,  ginumParms, ginumPointsX, ginumPointsY, giOutTab, giPosTab, giSnapTab  ;, iConfigTab\n\nk0      init    0\nk1      init    1\nk2      init    2\nkspeed  init    0\n\nkspeed = int((tb0(k2)) + 1)*.10\n\nkenv  oscil   25000, kspeed*16, 10 \n\nk1    phasor kspeed ;slow phasor: 200 sec.\nkpch  tableikt k1 * 16, int((tb0(k1)) +1)*100 ;scale phasor * length\na1    oscilikt kenv, kpch, int(tb0(k0)) +1000;scale pitch slightly\nahp butterlp a1, 2500\nouts ahp, ahp\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 10  0  1024 20  5 ;use of windowing function\nf1000 0 1024 10 .33 .25 .5\nf1001 0 1024 10 1\nf1002 0 1024 10 .5  .25  .05\nf1003 0 1024 10 .05  .10  .3  .5  1\nf1004 0 1024 10 1 .5  .25  .125  .625\nf1005 0 1024 10 .33  .44  .55  .66\nf1006 0 1024 10 1 1 1 1 1\nf1007 0 1024 10 .05 .25 .05 .25 .05 1\n\nf0 3600\ni1 0 3600\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hvs2/#see-also","title":"See also","text":"<p>Hyper Vectorial Synthesis</p>"},{"location":"opcodes/hvs2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/hvs3/","title":"Hvs3","text":""},{"location":"opcodes/hvs3/#hvs3","title":"hvs3","text":"<p>Allows three-dimensional Hyper Vectorial Synthesis (HVS) controlled by externally-updated k-variables.</p>"},{"location":"opcodes/hvs3/#syntax","title":"Syntax","text":"<pre><code>hvs3 kx, ky, kz, inumParms, inumPointsX, inumPointsY, inumPointsZ, iOutTab, \\\n     iPositionsTab, iSnapTab [, iConfigTab]\n</code></pre>"},{"location":"opcodes/hvs3/#initialization","title":"Initialization","text":"<p>inumParms - number of parameters controlled by the HVS. Each HVS snapshot is made up of inumParms elements.</p> <p>inumPointsX, inumPointsY, inumPointsZ - number of points that each dimension of the HVS cube (or square in case of two-dimensional HVS; or line in case of one-dimensional HVS) is made up.</p> <p>iOutTab - number of the table receiving the set of output-parameter instant values of the HVS. The total amount of parameters is defined by the inumParms argument.</p> <p>iPositionsTab \u2013 a table filled with the individual positions of snapshots in the HVS matrix (see below for more information).</p> <p>iSnapTab \u2013 a table filled with all the snapshots. Each snapshot is made up of a set of parameter values. The amount of elements contained in each snapshots is specified by the inumParms argument. The set of elements of each snapshot follows (and is adjacent) to the previous one in this table. So the total size of this table should be &gt;= to inumParms multiplied the number of snapshots you intend to store for the HVS.</p> <p>iConfigTab \u2013 (optional) a table containing the behavior of the HVS for each parameter. If the value of iConfigTab is zero (default), this argument is ignored, meaning that each parameter is treated with linear interpolation by the HVS. If iConfigTab is different than zero, then it must refer to an existing table whose contents are in its turn referring to a particolar kind of interpolation. In this table, a value of -1 indicates that corresponding parameter is leaved unchanged (ignored) by the HVS; a value of zero indicates that corresponding parameter is treated with linear-interpolation; each other values must be integer numbers indicating an existing table filled with a shape which will determine the kind of special interpolation to be used (table-based interpolation).</p>"},{"location":"opcodes/hvs3/#performance","title":"Performance","text":"<p>kx, ky, kz -  these are externally-modified variables which controls the motion of the pointer in the HVS matrix cube (or square or line in case of HVS matrices made up of less than 3 dimensions). The range of these input arguments must be 0 to 1.</p> <p>Hyper Vectorial Synthesis is a technique that allows control of a huge set of parameters by using a simple and global approach. The key concepts of the HVS are:</p> <p>The set of HVS parameters, whose amount is fixed and defined by the inumParms argument. During the HVS performance, all these parameters are variant and can be applied to any sound synthesis technique, as well as to any global control for algorithmic composition and any other kind of level. The user must previously define several sets of fixed values for each HVS parameter, each set corresponding to a determinate synthesis configuration. Each set of values is called snapshot, and can be considered as the coordinates of a bound of a multi-dimensional space. The HVS consists on moving a point in this multi-dimensional space (by using a special motion pointer, see below), according and inside the bounds defined by the snapshots. You can fix any amount of HVS parameters (each parameter being a dimension of the multi-dimensional space), even a huge number, the limit only depends on the processing power (and the memory) of your computer and on the complexity of the sound-synthesis you will use.</p> <p>The HVS cube (or square or line). This is the matrix (of 3, 2 or 1 dimensions, according to the hvs opcode you intend to use) of \u201cmainstays\u201d (or pivot) points of HVS. The total amount of pivot-points depends on the value of the inumPointsX, inumPointsY and inumPointsZ arguments. In the case of a 3-dimensional HVS matrix you can define, for instance, 3 points for the X dimension, 5 for the Y dimension and 2 for the Z dimension. In this case, the total number of pivot-points is 3 * 5 * 2 = 30. With this set of pivot points, the cube Is divided into smaller cubed zones each one bounded by eight nearby points. Each point is numbered. The numeral order of these points is enstabilished in the following way: number zero is the first point, number 1 the second and so on. Assuming you are using a 3-dimensional HVS cube having the number of points above mentioned (i.e. 3, 5 and 2 respectively for the X, Y and Z axis), the first point (point zero) is the upper-left-front vertex of the cube, by facing the XY plane of the cube. The second point is the middle point of the upper front edge of the cube and so on. You can refer to the figure below in order to understand how the numeral order of the pivot-points proceeds:</p> <p>For the 2-dimensional HVS, it is the same, by only omitting the rear cube face, so each zone is bounded by 4 pivot-points instead of 8. For the 1-dimensional HVS, the whole thing is even simpler because it is a line with the pivot-points proceeding from left to right. Each point is coupled with a snapshot.</p> <p>Snapshot order, as stored into the iSnapTab, can or cannot follow the order of the pivot-points numbers. In fact it is possible to alter this order by means the iPositionsTab, a table that remaps the position of each snapshot in relation to the pivot points. The iPositionsTab is made up of the positions of the snapshots (contained in the iSnapTab) in the two-dimensional grid. Each subsequent element is actually a pointer representing the position in the iSnapTab. For example, in a 2-dimensional HVS matrix such as the following (in this case having inumPointsX = 3 and inumPointsY = 5:</p> 5 7 1 3 4 9 6 2 0 4 1 3 8 2 7 <p>These numbers (to be stored in the iSnapTab table by using, for instance, the GEN02 function generator) represents the snapshot position within the grid (in this case a 3x5 matrix). So, the first element 5, has index zero and represents the 6th (element zero is the first) snapshot contained in the iSnapTab, the second element 7 represents the 8th element of iSnapTab and so on. Summing up, the vertices of each zone (a cubed zone is delimited by 8 vertices; a squared zone by 4 vertices and a linear zone by 2 points) are coupled with a determinate snapshot, whose number is remapped by the iSnapTab.</p> <p>Output values of the HVS are influenced by the motion pointer, a point whose position, in the HVS cube (or square or segment) is determined by the kx, ky and kz arguments. The values of these arguments, which must be in the 0 to 1 range, are externally set by the user. The output values, whose amount is equal to the inumParms argument, are stored in the iOutTab, a table that must be already allocated by the user, and must be at least inumParms size. In what way the motion pointer influences the output? Well, when the motion pointer falls in a determinate cubed zone, delimited, for instance, by 8 vertices (or pivot points), we assume that each vertex has associated a different snapshot (i.e. a set of inumParms values), well, the output will be the weighted average value of the 8 vertices, calculated according on the distance of the motion pointer from each of the 8 vertices. In the case of a default behavior, when the iConfigTab argument is not set, the exact output is calculated by using linear interpolation which is applied to each different parameter of the HVS. Anyway, it is possible to influence this behavior by setting the iConfigTab argument to a number of a table whose contents can affect one or more HVS parameters. The iConfigTab table elements are associated to each HVS parameter and their values affect the HVS output in the following way:</p> <ul> <li>If iConfigTab is equal to -1, corresponding output is skipped, i.e. the element is not calculated, leaving corresponding element value in the iOutTab unchanged;</li> <li>If iConfigTab is equal to zero, then the normal HVS output is calculated (by using weighted average of the nearest vertex of current zone where it falls the motion pointer);</li> <li>If iConfigTab element is equal to an integer number &gt; zero, then the contents of a table having that number is used as a shape of a table-based interpolation.</li> </ul>"},{"location":"opcodes/hvs3/#see-also","title":"See also","text":"<p>Hyper Vectorial Synthesis</p>"},{"location":"opcodes/hvs3/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/hypot/","title":"Hypot","text":""},{"location":"opcodes/hypot/#hypot","title":"hypot","text":"<p>Euclidean distance function.</p>"},{"location":"opcodes/hypot/#syntax","title":"Syntax","text":"<pre><code>ires[] hypot iarg1[], iarg2[]\nkres[] hypot karg1[], karg2[]\n</code></pre>"},{"location":"opcodes/hypot/#initialization","title":"Initialization","text":"<p>iarg[]1/2 -- the operands.</p>"},{"location":"opcodes/hypot/#performance","title":"Performance","text":"<p>karg[]1/2 -- the operands</p>"},{"location":"opcodes/hypot/#examples","title":"Examples","text":"<p>Here is an example of the hypot opcode. It uses the file hypot.csd.</p> Example of the hypot opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg1[] fillarray 1,2,3\niArg2[] fillarray 4,5,6\niRes[] hypot iArg1,iArg2\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/hypot/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/hypot/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017 </p>"},{"location":"opcodes/if/","title":"If","text":""},{"location":"opcodes/if/#if","title":"if","text":"<p>Branches conditionally at initialization or during performance time.</p> <p>if...igoto -- conditional branch at initialization time, depending on the truth value of the logical expression ia R ib. The branch is taken only if the result is true.</p> <p>if...kgoto -- conditional branch during performance time, depending on the truth value of the logical expression ka R kb. The branch is taken only if the result is true.</p> <p>if...goto -- combination of the above. Condition tested on every pass.</p> <p>if...then -- allows the ability to specify conditional if/else/endif blocks.  All if...then blocks must end with an endif statement. elseif and else statements are optional. Any number of elseif statements are allowed. Only one else statement may occur and it must be the last conditional statement before the endif statement. Nested if...then blocks are allowed.</p> <p> Note</p> <p>Note that if the condition uses a k-rate variable (for instance, \u201cif kval &gt; 0\u201d), the if...goto or if...then statement will be ignored during the i-time pass. This allows for opcode initialization, even if the k-rate variable has already been assigned an appropriate value by an earlier init statement.</p>"},{"location":"opcodes/if/#syntax","title":"Syntax","text":"<pre><code>if ia R ib igoto label\nif ka R kb kgoto label\nif xa R xb goto label\nif xa R xb then\n</code></pre> <p>where label is in the same instrument block and is not an expression, and where R is one of the Relational operators (&lt;, =, &lt;=, ==, !=) (and = for convenience, see also under Conditional Values).</p> <p>If goto or then is used instead of kgoto or igoto, the behavior is determined by the type being compared. If the comparison used k-type variables, kgoto is used and viceversa.</p> <p> Note</p> <p>If/then/goto statements cannot do audio-type comparisons. You cannot put a-type variables in the comparison expressions for these opcodes. The reason for this is that audio variables are actually vectors, which cannot be compared in the same way as scalars. If you need to compare individua audio samples, use  kr = 1 or Comparators</p>"},{"location":"opcodes/if/#examples","title":"Examples","text":"<p>Here is an example of the if...igoto combination. It uses the file igoto.csd.</p> Example of the if...igoto combination.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o igoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the value of the 4th p-field from the score.\n  iparam = p4\n\n  ; If iparam is 1 then play the high note.\n  ; If not then play the low note.\n  if (iparam == 1) igoto highnote\n    igoto lownote\n\nhighnote:\n  ifreq = 880\n  goto playit\n\nlownote:\n  ifreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of iparam and ifreq.\n  print iparam\n  print ifreq\n\n  a1 oscil 10000, ifreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; p4: 1 = high note, anything else = low note\n; Play Instrument #1 for one second, a low note.\ni 1 0 1 0\n; Play a Instrument #1 for one second, a high note.\ni 1 1 1 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  iparam = 0.000\ninstr 1:  ifreq = 440.000\ninstr 1:  iparam = 1.000\ninstr 1:  ifreq = 880.000\n</code></pre> <p>Here is an example of the if...kgoto combination. It uses the file kgoto.csd.</p> Example of the if...kgoto combination.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o kgoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change kval linearly from 0 to 2 over\n  ; the period set by the third p-field.\n  kval line 0, p3, 2\n\n  ; If kval is greater than or equal to 1 then play the high note.\n  ; If not then play the low note.\n  if (kval &gt;= 1) kgoto highnote\n    kgoto lownote\n\nhighnote:\n  kfreq = 880\n  goto playit\n\nlownote:\n  kfreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of kval and kfreq.\n  printks \"kval = %f, kfreq = %f\\\\n\", 1, kval, kfreq\n\n  a1 oscil 10000, kfreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>kval = 0.000000, kfreq = 440.000000\nkval = 0.999732, kfreq = 440.000000\nkval = 1.999639, kfreq = 880.000000\n</code></pre> <p>Here is an example of the if...then combo. It uses the file ifthen.csd.</p> Example of the if...then combo.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ifthen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the note value from the fourth p-field.\n  knote = p4\n\n  ; Does the user want a low note?\n  if (knote == 0) then\n    kcps = 220\n  ; Does the user want a middle note?\n  elseif (knote == 1) then\n    kcps = 440\n  ; Does the user want a high note?\n  elseif (knote == 2) then\n    kcps = 880\n  endif\n\n  ; Create the note.\n  kamp init 25000\n  ifn = 1\n  a1 oscili kamp, kcps, ifn\n\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; p4: 0=low note, 1=middle note, 2=high note.\n; Play Instrument #1 for one second, low note.\ni 1 0 1 0\n; Play Instrument #1 for one second, middle note.\ni 1 1 1 1\n; Play Instrument #1 for one second, high note.\ni 1 2 1 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/if/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/if/#credits","title":"Credits","text":"<p>Examples written by Kevin Conder.</p> <p>Added a note by Jim Aikin.</p> <p>February 2004. Added a note by Matt Ingalls.</p>"},{"location":"opcodes/igoto/","title":"Igoto","text":""},{"location":"opcodes/igoto/#igoto","title":"igoto","text":"<p>During the i-time pass only, unconditionally transfer control to the statement labeled by label.</p>"},{"location":"opcodes/igoto/#syntax","title":"Syntax","text":"<pre><code>igoto label\n</code></pre> <p>where label is in the same instrument block and is not an expression.</p>"},{"location":"opcodes/igoto/#examples","title":"Examples","text":"<p>Here is an example of the igoto opcode. It uses the file igoto.csd.</p> Example of the igoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o igoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Get the value of the 4th p-field from the score.\n  iparam = p4\n\n  ; If iparam is 1 then play the high note.\n  ; If not then play the low note.\n  if (iparam == 1) igoto highnote\n    igoto lownote\n\nhighnote:\n  ifreq = 880\n  goto playit\n\nlownote:\n  ifreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of iparam and ifreq.\n  print iparam\n  print ifreq\n\n  a1 oscil 10000, ifreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; p4: 1 = high note, anything else = low note\n; Play Instrument #1 for one second, a low note.\ni 1 0 1 0\n; Play a Instrument #1 for one second, a high note.\ni 1 1 1 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  iparam = 0.000\ninstr 1:  ifreq = 440.000\ninstr 1:  iparam = 1.000\ninstr 1:  ifreq = 880.000\n</code></pre>"},{"location":"opcodes/igoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/igoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/ihold/","title":"Ihold","text":""},{"location":"opcodes/ihold/#ihold","title":"ihold","text":"<p>Causes a finite-duration note to become a \u201cheld\u201d note</p>"},{"location":"opcodes/ihold/#syntax","title":"Syntax","text":"<pre><code>ihold\n</code></pre>"},{"location":"opcodes/ihold/#performance","title":"Performance","text":"<p>ihold -- this i-time statement causes a finite-duration note to become a \u201cheld\u201d note. It thus has the same effect as a negative p3 ( see score i Statement), except that p3 here remains positive and the instrument reclassifies itself to being held indefinitely. The note can be turned off explicitly with turnoff, or its space taken over by another note of the same instrument number (i.e. it is tied into that note). Effective at i-time only; no-op during a reinit pass.</p>"},{"location":"opcodes/ihold/#examples","title":"Examples","text":"<p>Here is an example of the ihold opcode. It uses the file ihold.csd.</p> Example of the ihold opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ihold.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; A simple oscillator with its note held indefinitely.\n  a1 oscil 10000, 440, 1\n  ihold\n\n  ; If p4 equals 0, turn the note off.\n  if (p4 == 0) kgoto offnow\n    kgoto playit\n\noffnow:\n  ; Turn the note off now.\n  turnoff\n\nplayit:\n  ; Play the note.\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: an ordinary sine wave.\nf 1 0 32768 10 1\n\n; p4 = turn the note off (if it is equal to 0).\n; Start playing Instrument #1.\ni 1 0 1 1\n; Turn Instrument #1 off after 3 seconds.\ni 1 3 1 0\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ihold/#see-also","title":"See also","text":"<p>Duration Control Statements</p>"},{"location":"opcodes/ihold/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/in/","title":"In","text":""},{"location":"opcodes/in/#in","title":"in","text":"<p>Reads mono audio data from an external device or stream.</p> <p> Warning</p> <p>There are two versions of this opcode.  The first is designed to be used only with orchestras that have inchnls=1. Doing so with orchestras with inchnls &gt; 1 will cause incorrect audio input.</p> <p>The second form will read multiple channels into an array.</p>"},{"location":"opcodes/in/#syntax","title":"Syntax","text":"<pre><code>ar1 in\naarray in\n</code></pre>"},{"location":"opcodes/in/#performance","title":"Performance","text":"<p>Form 1 reads mono audio data from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer. Any number of these opcodes can read freely from this buffer.</p> <p>The second format will read upto ichnls of audio into an audio array, which must be initialised.</p>"},{"location":"opcodes/in/#examples","title":"Examples","text":"<p>Here is an example of the in opcode. It uses the file in.csd.</p> Example of the in opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -iadc   ;;;realtime audio I/O\n; For Non-realtime ouput leave only the line below:\n; in.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;1 channel in, two channels out\n\nain1 in ;grab your mic and sing\nadel linseg 0, p3*.5, 0.02, p3*.5, 0    ;max delay time = 20ms\naout flanger ain1, adel, .7\n     fout \"in_1.wav\", 14, aout, aout    ;write to stereo file,\n     outs aout, aout                    ;16 bits with header\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/in/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/in/#credits","title":"Credits","text":"<p>Authors: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997 Authors: John ffitch NUIM, 2013</p> <p>Already in version 3.30</p> <p>Array version in versio 6.01</p>"},{"location":"opcodes/in32/","title":"In32","text":""},{"location":"opcodes/in32/#in32","title":"in32","text":"<p>Reads a 32-channel audio signal from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls_i=32. Doing so with orchestras with nchnls_i &gt; 32 will cause incorrect audio input.</p>"},{"location":"opcodes/in32/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \\\nar15, ar16, ar17, ar18, ar19, ar20, ar21, ar22, ar23, ar24, ar25, ar26, \\\nar27, ar28, ar29, ar30, ar31, ar32 in32\n</code></pre>"},{"location":"opcodes/in32/#performance","title":"Performance","text":"<p>in32 reads a 32-channel audio signal from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer.</p>"},{"location":"opcodes/in32/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/in32/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/inch/","title":"Inch","text":""},{"location":"opcodes/inch/#inch","title":"inch","text":"<p>Reads from numbered channels in an external audio signal or stream.</p>"},{"location":"opcodes/inch/#syntax","title":"Syntax","text":"<pre><code>ain1[, ...] inch kchan1[,...]\n</code></pre>"},{"location":"opcodes/inch/#performance","title":"Performance","text":"<p>ain1, ... - input audio signals</p> <p>kchan1,... - channel numbers</p> <p>inch reads from numbered channels determined by the corresponding kchan into the associated ain. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile). inch can also be used to receive audio in realtime from the audio interface using -iadc.</p> <p> Note</p> <p>The highest number for kchan available for use with inch depends on nchnls_i. If kchan is greater than nchnls_i, ain will be silent. Note that inch will give a warning but not an error in this case.</p>"},{"location":"opcodes/inch/#examples","title":"Examples","text":"<p>Here is an example of the inch opcode. It uses the file inch.csd.</p> Example of the inch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -iadc   ;;;realtime audio I/O\n; For Non-realtime ouput leave only the line below:\n; inch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;nchnls channels in, two channels out\n\nain1, ainr inch 1, 2                    ;grab your mic and sing\nadel  linseg 0, p3*.5, 0.02, p3*.5, 0   ;max delay time = 20ms\naoutl flanger ain1, adel, .7\naoutr flanger ain1, adel*2, .8\n      fout \"in_ch.wav\", 14, aoutl, aoutr ;write to stereo file,\n      outs aoutl, aoutr                 ;16 bits with header\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/inch/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inch/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p> <p>Multiple arguments from version 5.13</p>"},{"location":"opcodes/inh/","title":"Inh","text":""},{"location":"opcodes/inh/#inh","title":"inh","text":"<p>Reads six-channel audio data from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls_i=6. Doing so with orchestras with nchnls_i &gt; 6 will cause incorrect audio input.</p>"},{"location":"opcodes/inh/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4, ar5, ar6 inh\n</code></pre>"},{"location":"opcodes/inh/#performance","title":"Performance","text":"<p>Reads six-channel audio data from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer. Any number of these opcodes can read freely from this buffer.</p>"},{"location":"opcodes/inh/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inh/#credits","title":"Credits","text":"<p>Author: John ffitch</p>"},{"location":"opcodes/init/","title":"Init","text":""},{"location":"opcodes/init/#init","title":"init","text":"<p>Puts the value of the i-time expression into a k-, a-rate or t- variable.</p>"},{"location":"opcodes/init/#syntax","title":"Syntax","text":"<pre><code>ares init iarg\nires init iarg\nkres init iarg\nares, ... init iarg, ...\nires, ... init iarg, ...\nkres, ... init iarg, ...\ntab init isize[, ival]\n</code></pre>"},{"location":"opcodes/init/#initialization","title":"Initialization","text":"<p>Puts the value of the i-time expression iarg into a k-, a-rate or t- variable, i.e., initialize the result. Note that init provides the only case of an init-time statement being permitted to write into a perf-time (k- or a-rate) result cell; the statement has no effect at perf-time.</p> <p>Since version 5.13 it is possible to initialise upto 24 variables of the same class in one statement.  If there are more output variables than input expressions then the last one is repeated.  It is an error to have more inputs than outputs.</p> <p>The t-variable form was introduced in 5.14 and allocated space for a vector or the given size, initialised to the given value (default value is zero).</p>"},{"location":"opcodes/init/#examples","title":"Examples","text":"<p>Here is an example of the init opcode. It uses the file init.csd.</p> Example of the init opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n  ;no sound output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt; \n\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;shows what init does\n        kinit init 0 \n        kinit = kinit + 1 \n        printk .1, kinit \nendin \n\ninstr 2 ;shows what an assignment does\n        knoinit = 0 \n        knoinit = knoinit + 1 \n        printk .1, knoinit \nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n;play one second each\ni1 0 1 \ni2 2 1 \ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00073:     1.00000\ni   1 time     0.10014:   138.00000\ni   1 time     0.20027:   276.00000\ni   1 time     0.30041:   414.00000\ni   1 time     0.40054:   552.00000\ni   1 time     0.50068:   690.00000\ni   1 time     0.60009:   827.00000\ni   1 time     0.70023:   965.00000\ni   1 time     0.80036:  1103.00000\ni   1 time     0.90050:  1241.00000\n\ni   2 time     2.00054:     1.00000\ni   2 time     2.09995:     1.00000\ni   2 time     2.20009:     1.00000\ni   2 time     2.30023:     1.00000\ni   2 time     2.40036:     1.00000\ni   2 time     2.50050:     1.00000\ni   2 time     2.59991:     1.00000\ni   2 time     2.70005:     1.00000\ni   2 time     2.80018:     1.00000\ni   2 time     2.90032:     1.00000\n</code></pre>"},{"location":"opcodes/init/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p> <p>Array opcodes</p>"},{"location":"opcodes/init/#credits","title":"Credits","text":"<p>Init first appeared in the original Csound, but the extension to multiple values is by</p> <p>Author: John ffitch University of Bath, and Codemist Ltd. Bath, UK February 2010</p> <p>Multiple form new in version 5.13; t-variable form new in 5.14.</p>"},{"location":"opcodes/initc14/","title":"Initc14","text":""},{"location":"opcodes/initc14/#initc14","title":"initc14","text":"<p>Initializes the controllers used to create a 14-bit MIDI value.</p>"},{"location":"opcodes/initc14/#syntax","title":"Syntax","text":"<pre><code>initc14 ichan, ictlno1, ictlno2, ivalue\n</code></pre>"},{"location":"opcodes/initc14/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlno1 -- most significant byte controller number (0-127)</p> <p>ictlno2 -- least significant byte controller number (0-127)</p> <p>ivalue -- floating point value (must be within 0 to 1)</p>"},{"location":"opcodes/initc14/#performance","title":"Performance","text":"<p>initc14 can be used together with both midic14 and ctrl14 opcodes for initializing the first controller's value. ivalue argument must be set with a number within 0 to 1. An error occurs if it is not. Use the following formula to set ivalue according with midic14 and ctrl14 min and max range:</p> <pre><code>ivalue = (initial_value - min) / (max - min)\n</code></pre>"},{"location":"opcodes/initc14/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/initc14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/initc21/","title":"Initc21","text":""},{"location":"opcodes/initc21/#initc21","title":"initc21","text":"<p>Initializes the controllers used to create a 21-bit MIDI value.</p>"},{"location":"opcodes/initc21/#syntax","title":"Syntax","text":"<pre><code>initc21 ichan, ictlno1, ictlno2, ictlno3, ivalue\n</code></pre>"},{"location":"opcodes/initc21/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlno1 -- most significant byte controller number (0-127)</p> <p>ictlno2 -- medium significant byte controller number (0-127)</p> <p>ictlno3 -- least significant byte controller number (0-127)</p> <p>ivalue -- floating point value (must be within 0 to 1)</p>"},{"location":"opcodes/initc21/#performance","title":"Performance","text":"<p>initc21 can be used together with both midic21 and ctrl21 opcodes for initializing the first controller's value. ivalue argument must be set with a number within 0 to 1. An error occurs if it is not. Use the following formula to set ivalue according with midic21 and ctrl21 min and max range:</p> <pre><code>ivalue = (initial_value - min) / (max - min)\n</code></pre>"},{"location":"opcodes/initc21/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/initc21/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/initc7/","title":"Initc7","text":""},{"location":"opcodes/initc7/#initc7","title":"initc7","text":"<p>Initializes the controller used to create a 7-bit MIDI value.</p>"},{"location":"opcodes/initc7/#syntax","title":"Syntax","text":"<pre><code>initc7 ichan, ictlno, ivalue\n</code></pre>"},{"location":"opcodes/initc7/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlno -- controller number (0-127)</p> <p>ivalue -- floating point value (must be within 0 to 1)</p>"},{"location":"opcodes/initc7/#performance","title":"Performance","text":"<p>initc7 can be used together with both midic7 and  ctrl7 opcodes for initializing the first controller's value. ivalue argument must be set with a number within 0 to 1. An error occurs if it is not. Use the following formula to set ivalue according with midic7 and ctrl7 min and max range:</p> <pre><code>ivalue = (initial_value - min) / (max - min)\n</code></pre>"},{"location":"opcodes/initc7/#examples","title":"Examples","text":"<p>Here is an example of the initc7 opcode. It uses the file initc7.csd.</p> Example of the initc7 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -M0  ;;;realtime audio I/O with MIDI in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; expects MIDI controller input on channel 1\n; run and move your midi controller to see result\n\nimax = 1\nimin = 0\nichan = 1 \nictlno = 7\n\n        initc7  1, 7, 1                 ; start at max. volume\nkamp    ctrl7   ichan, ictlno, imin, imax       ; controller 7\n        printk2 kamp\nasig    oscil   kamp, 220, 1\n        outs    asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/initc7/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/initc7/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/ino/","title":"Ino","text":""},{"location":"opcodes/ino/#ino","title":"ino","text":"<p>Reads eight-channel audio data from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls_i=8. Doing so with orchestras with nchnls_i &gt; 8 will cause incorrect audio input.</p>"},{"location":"opcodes/ino/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8 ino\n</code></pre>"},{"location":"opcodes/ino/#performance","title":"Performance","text":"<p>Reads eight-channel audio data from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer. Any number of these opcodes can read freely from this buffer.</p>"},{"location":"opcodes/ino/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/ino/#credits","title":"Credits","text":"<p>Author: John ffitch</p>"},{"location":"opcodes/inq/","title":"Inq","text":""},{"location":"opcodes/inq/#inq","title":"inq","text":"<p>Reads quad audio data from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls_i=4. Doing so with orchestras with nchnls_i &gt; 4 will cause incorrect audio input.</p>"},{"location":"opcodes/inq/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2,  ar3, a4 inq\n</code></pre>"},{"location":"opcodes/inq/#performance","title":"Performance","text":"<p>Reads quad audio data from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer. Any number of these opcodes can read freely from this buffer.</p>"},{"location":"opcodes/inq/#examples","title":"Examples","text":"<p>Here is an example of the inq opcode. It uses the file inq.csd.</p> Example of the inq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -iadc ;;;realtime audio I/O\n; For Non-realtime ouput leave only the line below:\n; inq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr   = 44100\nksmps   = 32\nnchnls   = 2    ;2 channels out\n0dbfs    = 1\nnchnls_i = 4    ;4 channels in\n\ninstr 1 ;4 channels in, two channels out\n\nain1, ain2, ain3, ain4 inq              ;grab your mics and sing\n\nadel   linseg 0, p3*.5, 0.02, p3*.5, 0    ;max delay time = 20ms\nadel2  linseg 0.02, p3*.5, 0, p3*.5, 0.02 ;max delay time = 20ms        \naoutl  flanger ain1, adel, .7\naoutr  flanger ain2, adel*2, .8\naoutla flanger ain3, adel2, .9\naoutra flanger ain4, adel2*2, .5\n;write to quad file, 16 bits with header\n       fout \"in_4.wav\", 14, aoutl, aoutr, aoutla, aoutra        \n       outs (aoutl+aoutla)*.5, (aoutr+aoutra)*.5 ;stereo out\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/inq/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inq/#credits","title":"Credits","text":"<p>Authors: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/inrg/","title":"Inrg","text":""},{"location":"opcodes/inrg/#inrg","title":"inrg","text":"<p>Reads audio from a range of adjacent audio channels from the audio input device.</p>"},{"location":"opcodes/inrg/#syntax","title":"Syntax","text":"<pre><code>inrg kstart, ain1 [,ain2, ain3, ..., ainN]\n</code></pre>"},{"location":"opcodes/inrg/#performance","title":"Performance","text":"<p>kstart - the number of the first channel of the input device to be accessed (channel numbers starts with 1, which is the first channel)</p> <p>ain1, ain2, ... ainN - the output arguments filled with the incoming audio coming from corresponding channels.</p> <p>inrg allows input from a range of adjacent channels from the input device. kstart indicates the first channel to be accessed (channel 1 is the first channel). The user must be sure that the number obtained by summing kstart plus the number of accessed channels -1 is &lt;= nchnls_i.</p> <p> Note</p> <p>Note that this opcode is exceptional in that it produces its \u201coutput\u201d on the parameters to the right.</p>"},{"location":"opcodes/inrg/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inrg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/ins/","title":"Ins","text":""},{"location":"opcodes/ins/#ins","title":"ins","text":"<p>Reads stereo audio data from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls_i=2. Doing so with orchestras with nchnls_i &gt; 2 will cause incorrect audio input.</p>"},{"location":"opcodes/ins/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 ins\n</code></pre>"},{"location":"opcodes/ins/#performance","title":"Performance","text":"<p>Reads stereo audio data from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer. Any number of these opcodes can read freely from this buffer.</p>"},{"location":"opcodes/ins/#examples","title":"Examples","text":"<p>Here is an example of the ins opcode. It uses the file ins.csd.</p> Example of the ins opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -iadc   ;;;realtime audio I/O\n; For Non-realtime ouput leave only the line below:\n; ins.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2                              ;two channels out\n0dbfs  = 1\n\ninstr 1 \n\nain1, ainr ins                          ;grab your mic and sing\nadel  linseg 0, p3*.5, 0.02, p3*.5, 0   ;max delay time = 20ms\naoutl flanger ain1, adel, .7\naoutr flanger ain1, adel*2, .8\n      fout \"in_s.wav\", 14, aoutl, aoutr ;write to stereo file,\n      outs aoutl, aoutr                 ;16 bits with header\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ins/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/ins/#credits","title":"Credits","text":"<p>Authors: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/int/","title":"Int","text":""},{"location":"opcodes/int/#int","title":"int","text":"<p>Extracts an integer from a decimal number.</p>"},{"location":"opcodes/int/#syntax","title":"Syntax","text":"<pre><code>int(x)  (init-rate or control-rate; also works at audio rate in Csound5)\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/int/#examples","title":"Examples","text":"<p>Here is an example of the int opcode. It uses the file int.csd.</p> Example of the int opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o int.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nicount init 0\nloop:\n  inum = icount / 3\n  inm  = int(inum)\n  prints \"integer (%f/3) = %f\\\\n\", icount, inm\nloop_lt icount, 1, 10, loop\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>integer (0.000000/3) = 0.000000\ninteger (1.000000/3) = 0.000000\ninteger (2.000000/3) = 0.000000\ninteger (3.000000/3) = 1.000000\ninteger (4.000000/3) = 1.000000\ninteger (5.000000/3) = 1.000000\ninteger (6.000000/3) = 2.000000\ninteger (7.000000/3) = 2.000000\ninteger (8.000000/3) = 2.000000\ninteger (9.000000/3) = 3.000000\n</code></pre> <p>Here is an example for the rounding-group, comparing the different rounding opcodes. It uses the file rounding-group.csd.</p> Example of the rounding group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac       ;   \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n\n; by tgrey 2020\ninstr 1\n\niLoopStart = p4\niLoopEnd   = p5\niOffset    = p6\n\niCount init iLoopStart\n\n\nif(iLoopStart&lt;iLoopEnd) then            ; loop going up\n        while iCount &lt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount + 1             \n        od\n\nelseif(iLoopEnd&lt;iLoopStart) then        ; loop going down\n        while iCount &gt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount - 1             \n        od\nendif\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 .1 0 10 .5\ni1 .2 .1 0 -10 .5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/int/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/integ/","title":"Integ","text":""},{"location":"opcodes/integ/#integ","title":"integ","text":"<p>Modify a signal by integration.</p>"},{"location":"opcodes/integ/#syntax","title":"Syntax","text":"<pre><code>ares integ asig [, iskip]\nkres integ ksig [, iskip]\n</code></pre>"},{"location":"opcodes/integ/#initialization","title":"Initialization","text":"<p>iskip (optional) -- initial disposition of internal save space (see reson). The default value is 0.</p>"},{"location":"opcodes/integ/#performance","title":"Performance","text":"<p>integ and diff perform integration and differentiation on an input control signal or audio signal. Each is the converse of the other, and applying both will reconstruct the original signal. Since these units are special cases of low-pass and high-pass filters, they produce a scaled (and phase shifted) output that is frequency-dependent. Thus diff of a sine produces a cosine, with amplitude 2 * pi * Hz / sr that of the original (for each component partial); integ will inversely affect the magnitudes of its component inputs. With this understanding, these units can provide useful signal modification.</p>"},{"location":"opcodes/integ/#examples","title":"Examples","text":"<p>Here is an example of the integ opcode. It uses the file integ.csd.</p> Example of the integ opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o integ.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\nasig diskin2 \"fox.wav\", 1\n     outs asig, asig\n\nendin\n\ninstr 2 ; with diff\n\nasig diskin2 \"fox.wav\", 1\nares diff asig\n     outs ares, ares\n\nendin\n\ninstr 3 ; with integ\n\nasig diskin2 \"fox.wav\", 1\naint integ asig\naint = aint*.05                 ;way too loud\n     outs aint, aint\n\nendin\n\ninstr 4 ; with diff and integ\n\nasig diskin2 \"fox.wav\", 1\nares diff asig\naint integ ares\n     outs aint, aint\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 2 1 1\ni 3 2 1\ni 4 3 1\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/integ/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/interleave/","title":"Interleave","text":""},{"location":"opcodes/interleave/#interleave","title":"interleave","text":"<p>Interleaves arrays into a a single one by placing the input data in alternate positions.</p>"},{"location":"opcodes/interleave/#syntax","title":"Syntax","text":"<pre><code>kout[] interleave kin1[], kin2[]\n</code></pre>"},{"location":"opcodes/interleave/#performance","title":"Performance","text":"<p>kout[] -- output array containing the interleaved output. It will be created if it does not exist.</p> <p>kin1[], kin2[] -- input arrays containing the values to be interleaved.</p>"},{"location":"opcodes/interleave/#examples","title":"Examples","text":"<p>Here is an example of the interleave opcode. It uses the file interleave.csd.</p> Example of the interleave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\nkin1[] fillarray 1,2,3,4\nkin2[] fillarray 5,6,7,8\n\nkInt[] interleave kin1, kin2\n\nprintf \"inputs: \\n%d %d %d %d \\n%d %d %d %d\\n\", 1,\n         kin1[0], kin1[1], kin1[2], kin1[3],\n         kin2[0], kin2[1], kin2[2], kin2[3]\n\nprintf \"interleaved:\\n%d %d %d %d %d %d %d %d\\n\", 1,\n         kInt[0], kInt[1], kInt[2], kInt[3],\n         kInt[4], kInt[5], kInt[6], kInt[7]\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1  \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/interleave/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/interleave/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2018</p> <p>New in version 6.12</p>"},{"location":"opcodes/interp/","title":"Interp","text":""},{"location":"opcodes/interp/#interp","title":"interp","text":"<p>Converts a control signal to an audio signal using linear interpolation.</p>"},{"location":"opcodes/interp/#syntax","title":"Syntax","text":"<pre><code>ares interp ksig [, iskip] [, imode] [, ivalue]\n</code></pre>"},{"location":"opcodes/interp/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non zero skips initialisation of internal save space (see reson).</p> <p>imode (optional, default=0) -- sets the initial output value to the first k-rate input instead of zero.  The following graphs show the output of interp with a constant input value, in the original, when skipping init, and in the new mode:</p> <p>iskip=0, imode=0</p> <pre><code>|    ________\n|   /\n|  /\n| /\n|/\n-+------------\n|\n</code></pre> <p>iskip=1, imode=0</p> <pre><code>(prev)\n|  __________\n| /\n|/\n|\n|\n-+------------\n|\n</code></pre> <p>iskip=0, imode=1</p> <pre><code>|____________\n|\n|\n|\n|\n-+------------\n|\n</code></pre> <p>ivalue (optional, default=0) -- initial value if both imode and iskip are zero.</p>"},{"location":"opcodes/interp/#performance","title":"Performance","text":"<p>ksig -- input k-rate signal.</p> <p>interp converts a control signal to an audio signal. It uses linear interpolation between successive kvals.</p>"},{"location":"opcodes/interp/#examples","title":"Examples","text":"<p>Here is an example of the interp opcode. It uses the file interp.csd.</p> Example of the interp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o interp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     = 44100\nksmps  = 1024    ; very high, for demonstration purpose\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp linseg 0, p3/2, .5, p3/2, 0        ; Create an amplitude envelope.\na1   oscil kamp, 440                    ; The amplitude envelope will sound rough because it\nouts a1, a1                             ; jumps every ksmps period (1024)\nendin\n\n\ninstr 2     ; a smoother sounding instrument.\n\nkamp linseg 0, p3/2, .5, p3/2, 0        ; Create an amplitude envelope\naamp interp kamp                        ; The amplitude envelope will sound smoother due to\na1 oscil aamp, 440                      ; linear interpolation at the higher a-rate\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 2     ; sounds raw\n\ni 2 3 2     ; sounds smooth\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/interp/#see-also","title":"See also","text":"<p>Sample Level Operators</p> <p>More information on this opcode: Csound Journal, issue10 - An Overview of Csound Variable Types, written by Andr\u00e9s Cabrera</p>"},{"location":"opcodes/interp/#credits","title":"Credits","text":"<p>Updated November 2002, thanks to a note from both Rasmus Ekman and Istvan Varga.</p>"},{"location":"opcodes/invalue/","title":"Invalue","text":""},{"location":"opcodes/invalue/#invalue","title":"invalue","text":"<p>Reads a k-rate or i-rate signal or string from a user-defined channel.</p>"},{"location":"opcodes/invalue/#syntax","title":"Syntax","text":"<pre><code>ivalue invalue \"channel name\"\nkvalue invalue \"channel name\"\nSname invalue \"channel name\"\n</code></pre>"},{"location":"opcodes/invalue/#performance","title":"Performance","text":"<p>ivalue, kvalue -- The value that is read from the channel.</p> <p>_ Sname_ -- The string variable that is read from the channel.</p> <p>\"channel name\" -- An integer, string (in double-quotes), or string variable identifying the channel.</p>"},{"location":"opcodes/invalue/#examples","title":"Examples","text":"<p>Here is an example of the invalue opcode. It uses the file invalue.csd.</p> Example of the invalue opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;run this example in CsoundQt, a Csound editor that provides widgets\n;make the Widgets-panel visible, by clicking the Widgets symbol in the menu or pressing (Alt+1).\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n; written by Andres Cabrera\ninstr 1\n\nkfreq invalue \"freq\" ; Quotes are needed here\nasig  oscil 0.1, kfreq, 1\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 10 1 ;sine\ni 1 0 300       ;play for 300 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/invalue/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/invalue/#credits","title":"Credits","text":"<p>Author: Matt Ingalls</p> <p>i-rate version new in Csound 6.04</p>"},{"location":"opcodes/inx/","title":"Inx","text":""},{"location":"opcodes/inx/#inx","title":"inx","text":"<p>Reads a 16-channel audio signal from an external device or stream.</p> <p> Warning</p> <p>This opcode is designed to be used only with orchestras that have nchnls=16. Doing so with orchestras with nchnls &gt; 16 will cause incorrect audio input.</p>"},{"location":"opcodes/inx/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, \\\nar13, ar14, ar15, ar16 inx\n</code></pre>"},{"location":"opcodes/inx/#performance","title":"Performance","text":"<p>inx reads a 16-channel audio signal from an external device or stream. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer.</p>"},{"location":"opcodes/inx/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inx/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/inz/","title":"Inz","text":""},{"location":"opcodes/inz/#inz","title":"inz","text":"<p>Reads multi-channel audio samples into a ZAK array from an external device or stream.</p>"},{"location":"opcodes/inz/#syntax","title":"Syntax","text":"<pre><code>inz ksig1\n</code></pre>"},{"location":"opcodes/inz/#performance","title":"Performance","text":"<p>inz reads audio samples in nchnls into a ZAK array starting at ksig1. If the command-line -i flag is set, sound is read continuously from the audio input stream (e.g. stdin or a soundfile) into an internal buffer.</p>"},{"location":"opcodes/inz/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/inz/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/jitter/","title":"Jitter","text":""},{"location":"opcodes/jitter/#jitter","title":"jitter","text":"<p>Generates a segmented line whose segments are randomly generated.</p>"},{"location":"opcodes/jitter/#syntax","title":"Syntax","text":"<pre><code>kout jitter kamp, kcpsMin, kcpsMax\n</code></pre>"},{"location":"opcodes/jitter/#performance","title":"Performance","text":"<p>kamp -- Amplitude of jitter deviation</p> <p>kcpsMin -- Minimum speed of random frequency variations (expressed in cps)</p> <p>kcpsMax -- Maximum speed of random frequency variations (expressed in cps)</p> <p>jitter generates a segmented line whose segments are randomly generated inside the +kamp and -kamp interval. Duration of each segment is a random value generated according to kcpsmin and kcpsmax values.</p> <p>jitter can be used to make more natural and \u201canalog-sounding\u201d some static, dull sound. For best results, it is suggested to keep its amplitude moderate.</p>"},{"location":"opcodes/jitter/#examples","title":"Examples","text":"<p>Here is an example of the jitter opcode. It uses the file jitter.csd.</p> Example of the jitter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o jitter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp    init p4\nkcpsmin init 4\nkcpsmax init 8\n\nkj2  jitter kamp, kcpsmin, kcpsmax\naout pluck 1, 200+kj2, 1000, 0, 1\naout dcblock aout       ;remove DC\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 15 2      ;a bit jitter\ni 1 8 15 10     ;some more\ni 1 16 15 20    ;lots more\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/jitter/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/jitter/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.15</p>"},{"location":"opcodes/jitter2/","title":"Jitter2","text":""},{"location":"opcodes/jitter2/#jitter2","title":"jitter2","text":"<p>Generates a segmented line with user-controllable random segments.</p>"},{"location":"opcodes/jitter2/#syntax","title":"Syntax","text":"<pre><code>kout jitter2 ktotamp, kamp1, kcps1, kamp2, kcps2, kamp3, kcps3[ , iopt]\n</code></pre> <p>Initialisation</p> <p>iopt -- Optional, controls time of onset of effects.  If zero (default) the output is zero until the end of the shortest kcps value.  If not zero the effect starts immediately</p>"},{"location":"opcodes/jitter2/#performance","title":"Performance","text":"<p>ktotamp -- Resulting amplitude of jitter2</p> <p>kamp1 -- Amplitude of the first jitter component</p> <p>kcps1 -- Speed of random variation of the first jitter component (expressed in cps)</p> <p>kamp2 -- Amplitude of the second jitter component</p> <p>kcps2 -- Speed of random variation of the second jitter component (expressed in cps)</p> <p>kamp3 -- Amplitude of the third jitter component</p> <p>kcps3 -- Speed of random variation of the third jitter component (expressed in cps)</p> <p>jitter2 also generates a segmented line such as jitter, but in this case the result is similar to the sum of three randi opcodes, each one with a different amplitude and frequency value (see randi for more details), that can be varied at k-rate. Different effects can be obtained by varying the input arguments.</p> <p>jitter2 can be used to make more natural and \u201canalog-sounding\u201d some static, dull sound. For best results, it is suggested to keep its amplitude moderate.</p>"},{"location":"opcodes/jitter2/#examples","title":"Examples","text":"<p>Here is an example of the jitter2 opcode. It uses the file jitter2.csd.</p> Example of the jitter2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o jitter2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nktotamp init p4\nkamp1   init .5\nkcps1   init 10\nkamp2   init .5\nkcps2   init 2\nkamp3   init .5\nkcps3   init 3\n\nkj2  jitter2 ktotamp, kamp1, kcps1, kamp2, kcps2, kamp3, kcps3\naout pluck 1, 200+kj2, 1000, 0, 1\naout dcblock aout\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 15 2      ;a bit jitter\ni 1 8 15 10     ;some more\ni 1 16 15 20    ;lots more\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/jitter2/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/jitter2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado, John ffitch</p> <p>New in Version 4.15</p> <p>iopt new in version 6.08</p>"},{"location":"opcodes/joystick/","title":"Joystick","text":""},{"location":"opcodes/joystick/#joystick","title":"joystick","text":"<p>Reads data from a Linux joystick controller</p> <p>Plugin opcode in joystick.</p>"},{"location":"opcodes/joystick/#syntax","title":"Syntax","text":"<pre><code>kres joystick kdevice, ktab\n</code></pre>"},{"location":"opcodes/joystick/#performance","title":"Performance","text":"<p> Note</p> <p>Please note that this opcode is currently only supported on GNU/Linux.</p> <p>kdevice -- the index of the joystick device, either /dev/js_N_ or /dev/input/js_N_.</p> <p>ktab -- A table to hold input results, should be at least enough elements to store one value for each stick axis and one for each button + 2.  The first two elements of the table are initialized with the number of axes and the number of buttons, respectively, when a joystick is opened. If a joystick is unplugged during performance, the opcode will repeatedly attempt to reopen the device with a delay between attempts.</p>"},{"location":"opcodes/joystick/#examples","title":"Examples","text":"<p>Here is an example of the joystick opcode. It uses the file joystick.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o joystick.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n;0dbfs  = 1\n\ninstr 1 ; gives information about your joystick in real time\n\nkmask    joystick   0, 1\nkidx     =  2\nkaxes    tab 0, 1 ; number of axes has been stored in position 0\nkbuttons tab 1, 1 ; number of buttons has been stored in position 1\n         printf \"this joystick has %d axes, %d buttons\\n\", kidx, kaxes, kbuttons\nkuniq    init 0\n\nreportaxis: ; first we see if we have any x/y input\n        kcheck    =  kmask &amp; (1&lt;&lt;kidx)\n        if kcheck == 0 kgoto nexta\n        kres      tab       kidx, 1\n        kuniq     =  kuniq + 1 ; to be sure to make the printf print\n                  printf    \"axis %d, value %6d\\n\", kuniq, kidx-2, kres\nnexta:\n        kidx      =  kidx+1\n        if kidx &lt; (kaxes+2) kgoto reportaxis\n\nreportbutton: ; now we check for any buttons pressed\n        kcheck    =  kmask &amp; 1&lt;&lt;kidx\n        if kcheck == 0 kgoto nextb\n        kres      tab       kidx, 1 ; a button has been pressed, get from table\n                  printf    \"button %d, pushed\\n\", kidx*kres, (kidx-(kaxes+2))\n                  printf    \"button %d, released\\n\", kidx*(1-kres), (kidx-(kaxes+2))\n\nnextb:\n        kidx      =  kidx+1\n        if kidx &lt; (kaxes+kbuttons+2) kgoto reportbutton\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1  0 32    7     0     7     0         ; will hold the joystick data\n\ni1  0  60000\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the joystick opcode. It uses the file joystick-2.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o joystick-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n;0dbfs  = 1\n\ninstr 1\n\nkmask   joystick   0, 1\nkaxes    init 0\nkbuttons init 0\nkx0      init 0 ; first two entries are # of axes and # of buttons, \nky0      init 0 ; then axes, then buttons                           \n         vtabk 0, 1, kaxes, kbuttons, kx0, ky0\nkidx     =  2+kaxes \n\nbuttons:\n  kcheck =  kmask &amp; 1&lt;&lt;kidx   ; if the button was just now pressed and...\n  kres   tab       kidx, 1    ; if button value is one, start a note\n         schedkwhen  kres*kcheck, 1, 20, 2, 0, 60000, kidx, kx0, ky0\n  kidx   =  kidx+1\nif kidx &lt; (kaxes+kbuttons+2) kgoto buttons\n\nendin\n\ninstr 2 ; play a tone until the button is released\n\nkstop   tab  p4, 1 ; when this button is released, we fade out\nihz     init cpsoct(((p5+32767)/9362)+5) ; ~ 30 hz to 4khz\nprint ihz\nito     init ampdb(((p6+32767)/2184)+60) ; ~ 60 - 90 db\nkenv    init 0\nkdelta  init ito/(kr*10)\nif kstop == 1 kgoto output\nif kdelta &lt; 0 kgoto output\nkdelta    =  kdelta*-1\n\noutput:\n  kenv =  kenv+kdelta\n  kenv limit kenv, 0, ito\n  aout oscils 1, ihz, 0\n  aout =  kenv*aout\n       outs aout, aout\nif kenv != 0 kgoto noexit\nif kdelta &gt; 0 kgoto noexit\nturnoff\nnoexit:\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1  0 32    7     0     7     0         ; will hold the joystick data\n\ni1  0  60000\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/joystick/#see-also","title":"See also","text":"<p>Sensing and Control: Keyboard and mouse sensing</p> <p>non-MIDI devices</p>"},{"location":"opcodes/joystick/#credits","title":"Credits","text":"<p>Author: Justin Glenn Smith 2010</p> <p>New in version 5.17.12</p>"},{"location":"opcodes/jspline/","title":"Jspline","text":""},{"location":"opcodes/jspline/#jspline","title":"jspline","text":"<p>A jitter-spline generator.</p>"},{"location":"opcodes/jspline/#syntax","title":"Syntax","text":"<pre><code>ares jspline xamp, kcpsMin, kcpsMax\nkres jspline kamp, kcpsMin, kcpsMax\n</code></pre>"},{"location":"opcodes/jspline/#performance","title":"Performance","text":"<p>kres, ares -- Output signal</p> <p>xamp -- Amplitude factor</p> <p>kcpsMin, kcpsMax -- Range of point-generation rate. Min and max limits are expressed in cps.</p> <p>jspline (jitter-spline generator) generates a smooth curve based on random points generated at [cpsMin, cpsMax] rate.  This opcode is similar to randomi or randi or jitter, but segments are not straight lines, but cubic spline curves. Output value range is approximately &gt; -xamp and &lt; xamp. Actually, real range could be a bit greater, because of interpolating curves beetween each pair of random-points.</p> <p>At present time generated curves are quite smooth when cpsMin is not too different from cpsMax. When cpsMin-cpsMax interval is big, some little discontinuity could occurr, but it should not be a problem, in most cases. Maybe the algorithm will be improved in next versions.</p> <p>These opcodes are often better than jitter when user wants to \u201cnaturalize\u201d or \u201canalogize\u201d digital sounds. They could be used also in algorithmic composition, to generate smooth random melodic lines when used together with samphold opcode.</p> <p>Note that the result is quite different from the one obtained by filtering white noise, and they allow the user to obtain a much more precise control.</p>"},{"location":"opcodes/jspline/#examples","title":"Examples","text":"<p>Here is an example of the jspline opcode. It uses the file jspline.csd.</p> Example of the jspline opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o jspline.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp    init p4\nkcpsmin init 2\nkcpsmax init 20\n\nksp  jspline kamp, kcpsmin, kcpsmax\naout pluck 1, 200+ksp, 1000, 0, 1\naout dcblock aout       ;remove DC\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10 2      ;a bit jitter\ni 1 8 10 10     ;some more\ni 1 16 10 20    ;lots more\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/jspline/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/jspline/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.15</p>"},{"location":"opcodes/k35_hpf/","title":"K35 hpf","text":""},{"location":"opcodes/k35_hpf/#k35_hpf","title":"K35_hpf","text":"<p>Zero-delay feedback implementation of Korg35 resonant high-pass filter.</p> <p>This filter design is found in the Korg MS10 early MS20.</p>"},{"location":"opcodes/k35_hpf/#syntax","title":"Syntax","text":"<pre><code>asig K35_hpf ain, xcf, xQ [, inlp, isaturation, istor]\n</code></pre>"},{"location":"opcodes/k35_hpf/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/k35_hpf/#performance","title":"Performance","text":"<p>asig -- output signal.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>xQ -- filter Q value (i-, k-, or a-rate). Range 1.0-10.0 (clamped by opcode). Self-oscillation occurs at 10.0.</p> <p>knlp (optional, default=0) -- Non-linear processing method. 0 = no processing, 1 = non-linear processing. Method 1 uses tanh(ksaturation * input). Enabling NLP may increase the overall output of filter above unity and should be compensated for outside of the filter.</p> <p>ksaturation (optional, default=1) -- saturation amount to use for non-linear processing. Values &gt; 1 increase the steepness of the NLP curve.</p>"},{"location":"opcodes/k35_hpf/#examples","title":"Examples","text":"<p>Here is an example of the K35_hpf opcode. It uses the file k35.csd.</p> Example of the K35_hpf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n; ==============================================\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\n;; test instruments to demo filter cutoff sweep with high resonance\n\ninstr 1 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_lpf(asig, expseg:a(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n\ninstr 2 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_lpf(asig, expseg:k(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\ninstr 3 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_hpf(asig, expseg:a(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n\ninstr 4 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_hpf(asig, expseg:k(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n;; beat instruments\n\ninstr ms20_drum\n\n  ipch = cps2pch(p4, 12)\n  iamp = ampdbfs(p5)\n  aenv = expseg:a(10000, 0.05, ipch, p3 - .05, ipch)\n\n  asig = rand:a(-1.0, 1.0)\n  asig = K35_hpf(asig, 60, 7, 1, 1)\n  asig = K35_lpf(asig, aenv, 9.8, 1, 1)\n\n  asig = tanh(asig * 16)\n\n  asig *= expon(iamp, p3, 0.0001)\n\n  outc(asig, asig)\n\nendin\n\ninstr ms20_bass \n  ipch = cps2pch(p4, 12)\n  iamp = ampdbfs(p5)\n  aenv = expseg(1000, 0.1, ipch * 2, p3 - .05, ipch * 2)\n\n  asig = vco2(1.0, ipch)\n  asig = K35_hpf(asig, ipch, 5, 0, 1)\n  asig = K35_lpf(asig, aenv, 8, 0, 1)\n\n  asig *= expon:a(iamp, p3, 0.0001) * 0.8\n\n  outc(asig, asig)\nendin\n\n;; perf code\n\ngktempo init 122\n\nopcode beat_dur,i,0\n  xout 60 / i(gktempo) \nendop\n\ninstr bass_player\n  idur = beat_dur() / int(random(1,3)) \n  ipch = 6.00 + int(random(1,3)) + int(random(1,3)) / 100\n\n  schedule(\"ms20_bass\", 0, idur, ipch, -11) \n\n  if(p2 &lt; 37.5) then\n    schedule(\"bass_player\", idur, 0.1)\n  endif\n  turnoff\nendin\n\ninstr beat_player \n  istep_total = p4 \n  istep = istep_total % 16\n\n  if(istep % 4 == 0) then\n    ipch = ((istep_total % 128) &lt; 112) ? 4.00 : 8.00\n    iamp = (istep == 0)  ? -9 : -12\n    schedule(\"ms20_drum\", 0, 0.5, ipch, iamp)\n  endif\n\n  schedule(\"ms20_drum\", 0, 0.125, 14.00, \n           (istep % 4 == 0) ? -12 : -18)\n\n  if(p2 &lt; 37.5) then\n    schedule(\"beat_player\", beat_dur() / 4, 0.1, istep_total + 1)\n  endif\n  turnoff\nendin\n\n;; start play of beats\n\ninstr start_beats\n  schedule(\"beat_player\", 0, 0.1, 0)\n  schedule(\"bass_player\", 0, 0.1)\nendin\n\n\n&lt;/CsInstruments&gt;\n; ==============================================\n&lt;CsScore&gt;\ni1 0 5.0\ni2 5 5.0\ni3 10 5.0\ni4 15 5.0\n\ni \"start_beats\" 22 0.5 0\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/k35_hpf/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-7A:\u00a0Virtual Analog (VA) Korg35 Highpass Filter v2.0 Simplified. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/k35_hpf/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/k35_hpf/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/k35_lpf/","title":"K35 lpf","text":""},{"location":"opcodes/k35_lpf/#k35_lpf","title":"K35_lpf","text":"<p>Zero-delay feedback implementation of Korg35 resonant low-pass filter.</p> <p>This filter design is found in the Korg MS10, early MS20, and Monotron series.</p>"},{"location":"opcodes/k35_lpf/#syntax","title":"Syntax","text":"<pre><code>asig K35_lpf ain, xcf, xQ [, inlp, isaturation, istor]\n</code></pre>"},{"location":"opcodes/k35_lpf/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/k35_lpf/#performance","title":"Performance","text":"<p>asig -- output signal.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>xQ -- filter Q value (i-, k-, or a-rate). Range 1.0-10.0 (clamped by opcode). Self-oscillation occurs at 10.0.</p> <p>knlp (optional, default=0) -- Non-linear processing method. 0 = no processing, 1 = non-linear processing. Method 1 uses tanh(ksaturation * input). Enabling NLP may increase the overall output of filter above unity and should be compensated for outside of the filter.</p> <p>ksaturation (optional, default=1) -- saturation amount to use for non-linear processing. Values &gt; 1 increase the steepness of the NLP curve.</p>"},{"location":"opcodes/k35_lpf/#examples","title":"Examples","text":"<p>Here is an example of the K35_lpf opcode. It uses the file k35.csd.</p> Example of the K35_lpf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n; ==============================================\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\n;; test instruments to demo filter cutoff sweep with high resonance\n\ninstr 1 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_lpf(asig, expseg:a(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n\ninstr 2 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_lpf(asig, expseg:k(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\ninstr 3 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_hpf(asig, expseg:a(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n\ninstr 4 \n\nasig = vco2(0.5, cps2pch(6.00, 12))\nasig = K35_hpf(asig, expseg:k(10000, p3, 30), 9.9, 0, 1)\nasig *= 0.25\nasig  = limit(asig, -1.0, 1.0)\n\noutc(asig, asig)\n\nendin\n\n;; beat instruments\n\ninstr ms20_drum\n\n  ipch = cps2pch(p4, 12)\n  iamp = ampdbfs(p5)\n  aenv = expseg:a(10000, 0.05, ipch, p3 - .05, ipch)\n\n  asig = rand:a(-1.0, 1.0)\n  asig = K35_hpf(asig, 60, 7, 1, 1)\n  asig = K35_lpf(asig, aenv, 9.8, 1, 1)\n\n  asig = tanh(asig * 16)\n\n  asig *= expon(iamp, p3, 0.0001)\n\n  outc(asig, asig)\n\nendin\n\ninstr ms20_bass \n  ipch = cps2pch(p4, 12)\n  iamp = ampdbfs(p5)\n  aenv = expseg(1000, 0.1, ipch * 2, p3 - .05, ipch * 2)\n\n  asig = vco2(1.0, ipch)\n  asig = K35_hpf(asig, ipch, 5, 0, 1)\n  asig = K35_lpf(asig, aenv, 8, 0, 1)\n\n  asig *= expon:a(iamp, p3, 0.0001) * 0.8\n\n  outc(asig, asig)\nendin\n\n;; perf code\n\ngktempo init 122\n\nopcode beat_dur,i,0\n  xout 60 / i(gktempo) \nendop\n\ninstr bass_player\n  idur = beat_dur() / int(random(1,3)) \n  ipch = 6.00 + int(random(1,3)) + int(random(1,3)) / 100\n\n  schedule(\"ms20_bass\", 0, idur, ipch, -11) \n\n  if(p2 &lt; 37.5) then\n    schedule(\"bass_player\", idur, 0.1)\n  endif\n  turnoff\nendin\n\ninstr beat_player \n  istep_total = p4 \n  istep = istep_total % 16\n\n  if(istep % 4 == 0) then\n    ipch = ((istep_total % 128) &lt; 112) ? 4.00 : 8.00\n    iamp = (istep == 0)  ? -9 : -12\n    schedule(\"ms20_drum\", 0, 0.5, ipch, iamp)\n  endif\n\n  schedule(\"ms20_drum\", 0, 0.125, 14.00, \n           (istep % 4 == 0) ? -12 : -18)\n\n  if(p2 &lt; 37.5) then\n    schedule(\"beat_player\", beat_dur() / 4, 0.1, istep_total + 1)\n  endif\n  turnoff\nendin\n\n;; start play of beats\n\ninstr start_beats\n  schedule(\"beat_player\", 0, 0.1, 0)\n  schedule(\"bass_player\", 0, 0.1)\nendin\n\n\n&lt;/CsInstruments&gt;\n; ==============================================\n&lt;CsScore&gt;\ni1 0 5.0\ni2 5 5.0\ni3 10 5.0\ni4 15 5.0\n\ni \"start_beats\" 22 0.5 0\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/k35_lpf/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-5:\u00a0Virtual Analog (VA) Korg35 Lowpass Filter v3.5. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/k35_lpf/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/k35_lpf/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/kgoto/","title":"Kgoto","text":""},{"location":"opcodes/kgoto/#kgoto","title":"kgoto","text":"<p>During the p-time passes only, unconditionally transfer control to the statement labeled by label.</p>"},{"location":"opcodes/kgoto/#syntax","title":"Syntax","text":"<pre><code>kgoto label\n</code></pre> <p>where label is in the same instrument block and is not an expression.</p>"},{"location":"opcodes/kgoto/#examples","title":"Examples","text":"<p>Here is an example of the kgoto opcode. It uses the file kgoto.csd.</p> Example of the kgoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o kgoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change kval linearly from 0 to 2 over\n  ; the period set by the third p-field.\n  kval line 0, p3, 2\n\n  ; If kval is greater than or equal to 1 then play the high note.\n  ; If not then play the low note.\n  if (kval &gt;= 1) kgoto highnote\n    kgoto lownote\n\nhighnote:\n  kfreq = 880\n  goto playit\n\nlownote:\n  kfreq = 440\n  goto playit\n\nplayit:\n  ; Print the values of kval and kfreq.\n  printks \"kval = %f, kfreq = %f\\\\n\", 1, kval, kfreq\n\n  a1 oscil 10000, kfreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: a simple sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>kval = 0.000000, kfreq = 440.000000\nkval = 0.999732, kfreq = 440.000000\nkval = 1.999639, kfreq = 880.000000\n</code></pre>"},{"location":"opcodes/kgoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/kgoto/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/lag/","title":"Lag","text":""},{"location":"opcodes/lag/#lag","title":"lag","text":"<p>Exponential Lag</p> <p>Plugin opcode in scugens.</p> <p>Exponential lag with 60dB lag time. Port of Supercollider's Lag. This is essentially a one pole filter except that instead of supplying the coefficient directly, it is calculated from a 60 dB lag time. This is the time required for the filter to converge to within 0.01% of a value. This is useful for smoothing out control signals.</p>"},{"location":"opcodes/lag/#syntax","title":"Syntax","text":"<pre><code>aout lag ain, klagtime [, initialvalue]\nkout lag kin, klagtime [, initialvalue]\n</code></pre>"},{"location":"opcodes/lag/#initialization","title":"Initialization","text":"<p>initialvalue If given, sets the internal state. It defaults to the first value passed</p>"},{"location":"opcodes/lag/#performance","title":"Performance","text":"<p>ain -- input signal</p> <p>klagtime -- 60 dB lag time in seconds.</p> <p>kladown -- 60 dB lag time in seconds for the downgoing signal.</p>"},{"location":"opcodes/lag/#examples","title":"Examples","text":"<p>Here is an example of the lag opcode. It uses the file lag.csd.</p> Example of the lag opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\ninstr 1\n  ; smooth a krate signal  \n  kx = floor(line(0, p3, 10))\n  kx2 = lag(kx, 0.1)\n  printk2 kx2\nendin\n\ninstr 2\n  ; smooth an audio signal\n  kmidi = floor(line(60, p3, 72)/2)*2\n  afreq = upsamp(mtof(kmidi))\n  afreqsmooth = lag(afreq, 1)\n  a1 = oscili(1, afreq)\n  a2 = oscili(1, afreqsmooth)\n  outch 1, a1\n  outch 2, a2 \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 0 10\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lag/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/lag/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/lagud/","title":"Lagud","text":""},{"location":"opcodes/lagud/#lagud","title":"lagud","text":"<p>Exponential Lag</p> <p>Plugin opcode in scugens.</p> <p>Exponential lag with different smoothing time for up- and downgoing signals. Port of Supercollider's LagUD.</p> <p>This is essentially the same as the opcode lag except that you can supply a different 60 dB time for ascending and descending signals. This is useful for smoothing out control signals, where \"fade in\" should be different from \"fade out\", or to model the attack/release of a gate, etc.</p>"},{"location":"opcodes/lagud/#syntax","title":"Syntax","text":"<pre><code>aout lagud ain, klagup, klagdown [, initialvalue]\nkout lagud kin, klagup, klagdown [, initialvalue]\n</code></pre>"},{"location":"opcodes/lagud/#initialization","title":"Initialization","text":"<p>initialvalue If given, sets the internal state. Defaults to the first value passed</p>"},{"location":"opcodes/lagud/#performance","title":"Performance","text":"<p>ain -- input signal</p> <p>klagup -- 60 dB lag time in seconds for the upgoing signal.</p> <p>klagdown -- 60 dB lag time in seconds for the downgoing signal.</p>"},{"location":"opcodes/lagud/#examples","title":"Examples","text":"<p>Here is an example of the lagud opcode. It uses the file lagud.csd.</p> Example of the lagud opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\ninstr 1\n  kx = randh(2, 1)\n  kx2 = lagud(kx, 1.0, 0.1, 1)\n  printks \"x %f  x2 %f\\n\", 0.1, kx, kx2\nendin\n\ninstr 2\n  kmidis[] fillarray 60, 65, 60, 65, 60\n  ilen = lenarray(kmidis)\n  kidx = int(linseg(0, ilen*2, ilen-0.00000001))\n  kmidi = mtof(kmidis[kidx])\n  afreq = lagud(a(kmidi), 1, 0.1)\n  a0 = oscili(0.7, afreq)\n  kfreq = lagud(kmidi, 1, 0.1)\n  a1 = oscili(0.7, kfreq)\n  outch 1, a0\n  outch 2, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; i 1 0 10\ni 2 0 12\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lagud/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/lagud/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/lastcycle/","title":"Lastcycle","text":""},{"location":"opcodes/lastcycle/#lastcycle","title":"lastcycle","text":"<p>Indicates whether an event is in its last performance cycle.</p> <p>Whether an event has a finite duration (p3 &gt; 0) or a note is extended via a time extending opcode (like linsegr or xtratim), this opcode returns 1 if the event is currently at its last k-cycle. The only sitatuation where lastcycle does not detect that the event will not run for another cycle is when the note is turned off by another event (using turnoff2) and is not given the possibility of running through its release stage (using turnoff2 instrnum, imode, 0)</p>"},{"location":"opcodes/lastcycle/#syntax","title":"Syntax","text":"<pre><code>kflag lastcycle\n</code></pre>"},{"location":"opcodes/lastcycle/#performance","title":"Performance","text":"<p>kflag -- indicates whether the note is in its last cycle. (1 if this the last cycle, otherwise 0)</p> <p>This opcode is useful for performing cleanup actions, signaling to other events that this event is finishing, etc. It works only at performance time.</p>"},{"location":"opcodes/lastcycle/#examples","title":"Examples","text":"<p>Here is an example of the lastcycle opcode. It uses the file lastcycle.csd.</p> Example of the lastcycle opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent  MIDI in\n-odac\n-d\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 64\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n  aenv linsegr 0, 0.1, 1, 0.1, 0\n  asig =  oscili(0.1, 1000)\n  asig += oscili(0.1, 1012)\n  asig *= aenv\n  if lastcycle() == 1 then\n    schedulek p1, 0, p3\n  endif\n  outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni 1 0 0.5\nf 0 3600 \n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lastcycle/#see-also","title":"See also","text":"<p>Event Extenders</p>"},{"location":"opcodes/lastcycle/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2020</p> <p>New in Csound version 6.14 (2020)</p>"},{"location":"opcodes/lenarray/","title":"Lenarray","text":""},{"location":"opcodes/lenarray/#lenarray","title":"lenarray","text":"<p>Evaluates the size or number of dimensions of an array.</p>"},{"location":"opcodes/lenarray/#syntax","title":"Syntax","text":"<pre><code>ir lenarray karray[, iwhich]\nkr lenarray karray[, iwhich]\n</code></pre> <p>Initialisation</p> <p>karray -- The array that is being questioned.  It can be of any dimension.</p> <p>iwhich -- selects which dimension to evaluate the size.  If zero or negative it selects the number of dimensions.  It defaults to 1, as used in a vector.</p>"},{"location":"opcodes/lenarray/#performance","title":"Performance","text":"<p>kr -- length of vector.</p> <p>karray -- array to query.</p> <p>If the dimension requested is larger than the actual array, or the array is not initialised the value -1 is returned.</p>"},{"location":"opcodes/lenarray/#examples","title":"Examples","text":"<p>Here is an example of the lenarray opcode. It uses the file lenarray.csd.</p> Example of the lenarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n -m128 ;no sound output, reduced messages\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example by joachim heintz\nsr = 44100\nksmps = 32\nnchnls = 1\n0dbfs = 1\n\n  instr 1 ;simple example\nkArr[]  fillarray 1, 2, 3, 4 ;fill array manually\n        printks \"Length of kArr = %d\\n\\n\", 0, lenarray(kArr) ;print out its length\n        turnoff ;only do this in the first k-cycle\n  endin\n\n  instr 2 ;random array length\niNumEls random  1, 11 ;create random number between 1 and 10\nkArr[]  init    int(iNumEls) ;create array of this length\n        printks \"Random length of kArr = %d\\n\", 0, lenarray(kArr) ;print out\n        turnoff\n  endin\n\n  instr 3 ;fill random array length with random elements\niNumEls random  1, 11 ;create random number between 1 and 10\nkArr[]  init    int(iNumEls) ;create array of this length\n        printks \"Random length of kArr = %d\\n\", 0, lenarray(kArr) ;print out\n\n;fill\nkIndx   =       0 ;initialize index\n  until kIndx == lenarray(kArr) do\nkArr[kIndx] rnd31 10, 0 ;set element to random value -10...10\nkIndx   +=      1 ;increase index\n  od\n\n;print\nkIndx   =       0 ;initialize index\n  until kIndx == lenarray(kArr) do\nprintf(\"kArr[%d] = %f\\n\", kIndx+1, kIndx, kArr[kIndx])\nkIndx   +=      1 ;increase index\n  od\n\n        turnoff\n  endin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .1\ni 2 0 .1 \ni 2 0 .1\ni 3 0 .1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lenarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/lenarray/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2013</p> <p>New in version 6.00</p> <p>Extended to multi-dimensions in 6.04</p>"},{"location":"opcodes/lessequal/","title":"Lessequal","text":""},{"location":"opcodes/lessequal/#_1","title":"&lt;=","text":"<p>Determines if one value is less than or equal to another.</p>"},{"location":"opcodes/lessequal/#syntax","title":"Syntax","text":"<pre><code>(a &lt;= b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/lessequal/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a less than or equal to b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2.</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/lessequal/#examples","title":"Examples","text":"<p>Here is an example of the &lt;= operator. It uses the file lessequal.csd.</p> Example of the &lt;= operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o &lt;=.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkval    randomh 0, 1.2, 20              ;choose between 0 and 1.2\n\nif kval &gt;0 &amp;&amp; kval&lt;=.5 then             ;3 possible outcomes\n        kvl = 1                 \nelseif kval &gt;.5 &amp;&amp; kval&lt;=1 then\n        kvl =2\nelseif kval &gt;1 then\n        kvl =3\nendif\n\nprintks \"random number = %f, result = %f\\n\", .1, kval, kvl\nasig    poscil .7, 440*kvl, 1\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>random number = 1.035781, result = 3.000000\nrandom number = 0.134037, result = 1.000000\nrandom number = 0.130742, result = 1.000000\nrandom number = 1.002550, result = 3.000000\nrandom number = 0.370565, result = 1.000000\nrandom number = 0.655759, result = 2.000000\nrandom number = 0.676154, result = 2.000000\n......\n</code></pre>"},{"location":"opcodes/lessequal/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/lessthan/","title":"Lessthan","text":""},{"location":"opcodes/lessthan/#_1","title":"&lt;","text":"<p>Determines if one value is less than another.</p>"},{"location":"opcodes/lessthan/#syntax","title":"Syntax","text":"<pre><code>(a &lt;  b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/lessthan/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a less than b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2.</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/lessthan/#examples","title":"Examples","text":"<p>Here is an example of the &lt; operator. It uses the file lessthan.csd.</p> Example of the &lt; operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o &lt;.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nipch = p4\nipitch  = (ipch &lt; 15 ? cpspch(ipch) : ipch)     ;if p4 is lower then 15, it assumes p4 to be pitch-class\nprint ipitch                                    ;and not meant to be a frequency in Hertz\nasig  poscil .5,  ipitch , 1\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1  ;sine wave\n\ni1 0  3 8.00    ;pitch class\ni1 4  3 800     ;frequency\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>ipitch = 261.626\nipitch = 800.00\n</code></pre>"},{"location":"opcodes/lessthan/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/lfo/","title":"Lfo","text":""},{"location":"opcodes/lfo/#lfo","title":"lfo","text":"<p>A low frequency oscillator of various shapes.</p>"},{"location":"opcodes/lfo/#syntax","title":"Syntax","text":"<pre><code>kres lfo kamp, kcps [, itype]\nares lfo kamp, kcps [, itype]\n</code></pre>"},{"location":"opcodes/lfo/#initialization","title":"Initialization","text":"<p>itype (optional, default=0) -- determine the waveform of the oscillator. Default is 0.</p> <ul> <li>itype = 0 - sine</li> <li>itype = 1 - triangles</li> <li>itype = 2 - square (bipolar)</li> <li>itype = 3 - square (unipolar)</li> <li>itype = 4 - saw-tooth (unipolar - up)</li> <li>itype = 5 - saw-tooth (unipolar - down)</li> </ul> <p>The sine wave is implemented as a 4096 table and linear interpolation. The others are calculated.</p>"},{"location":"opcodes/lfo/#performance","title":"Performance","text":"<p>kamp -- amplitude of output</p> <p>kcps -- frequency of oscillator</p>"},{"location":"opcodes/lfo/#examples","title":"Examples","text":"<p>Here is an example of the lfo opcode. It uses the file lfo.csd.</p> Example of the lfo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lfo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 5\nitype = p4      ;lfo type\n\nklfo line 0, p3, 20\nal   lfo klfo, kcps, itype\nasig poscil .5, 220+al, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 32768 10 1\n\ni 1 0 3 0       ;lfo = sine\ni 1 + 3 2       ;lfo = square\ni 1 + 3 5       ;lfo = saw-tooth down\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the lfo opcode. It uses the file lfo-advanced.csd.</p> Advanced example of the lfo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lfo_advanced.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\ninstr 1\n\n; LFO 1\nkAmpLFO1 linseg p6, p3, p7\nkFreqLFO1 linseg p8, p3, p9\nkLFO1 lfo kAmpLFO1, kFreqLFO1, p10\n\n; LFO 2\nkAmpLFO2 linseg p7, p3, p6\nkFreqLFO2 linseg p9, p3, p8\nkLFO2 lfo kAmpLFO2, kFreqLFO1, p11\n\n; AUDIO SIGNAL\nasig1 oscili p4+kLFO1, p5+kLFO2,1\n\n; LFO DELAY\nkAmpDELAY1 lfo, 100, 1.35, 1\nkAmpDELAY1 = kAmpDELAY1 + 50\n\n; DELAY SIGNAL\nadel1 vdelay asig1, kAmpDELAY1, 500\n\nkdeclick linseg 0, 1.5, p12, p3-3, p12, 1.5, 0\noutch 1, (asig1  + (adel1 *0.3)) * kdeclick\noutch 2, (asig1  + (adel1 *0.3)) * kdeclick\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\nf 1 0 4096 10 1 0.3 0.2 0.1 0.03 0 0.3\n\ni1 0 8 0.3 250 0.22 0.65 3 6 0 3 0.8\ni1 8 8 0.3 123 0.12 10.85 70 6 1 5 0.09\n\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lfo/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/lfo/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK November 1998</p> <p>New in Csound version 3.491</p>"},{"location":"opcodes/lfsr/","title":"Lfsr","text":""},{"location":"opcodes/lfsr/#lfsr","title":"lfsr","text":"<p>Linear Feedback Shift Register (LFSR).</p> <p>Output is a series of pseudo-random positive integers. This is the technique used in so-called \"Turing machine\" synth modules and is usually used to generate melodic sequences. This implementation is adapted from the firmware for the Ornament &amp; Crime module, as used in the Quantermain and Meta-Q apps.</p>"},{"location":"opcodes/lfsr/#syntax","title":"Syntax","text":"<pre><code>knum lfsr ilen, iprob [, iseed]\n</code></pre>"},{"location":"opcodes/lfsr/#initialization","title":"Initialization","text":"<p>ilen -- length of shift register, valid values are 1-31 (inclusive). The larger the length, the larger the resulting integers in the output. You can use this to constrain the output to a suitable range.</p> <p>iprob -- probability, valid values 1-255 (inclusive). Controls the spread of the output; larger values result in a wider spread of values.</p> <p>iseed (optional, default -1) -- initial state of the shift register, as a pattern of bits. The value is treated as an unsigned integer, so the default of -1 is effectivly all bits on (0b11111111...).</p>"},{"location":"opcodes/lfsr/#performance","title":"Performance","text":"<p>knum -- integer output</p>"},{"location":"opcodes/lfsr/#examples","title":"Examples","text":"<p>Here is an example of the lfsr opcode. It uses the file lfsr.csd.</p> Example of the lfsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-W -o lfsr.wav\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 1\nnchnls = 2\n0dbfs = 1.0\n\n; triangle wave\ngitabsz init 2^13\ngiTri ftgen 1, 0, gitabsz, 7, 0, gitabsz/4, 1, gitabsz/2, -1, gitabsz/4, 0\n\n; Grady Centaur scale\ngiCent = ftgen(100, 0, 128, -51,\n               12, 2, 297.989, 60,\n               1.0, 21/20, 9/8, 7/6, 5/4, 4/3, 7/5, 3/2, 14/9, 5/3, 7/4, 15/8, 2.0)\n\n; just print the values\ninstr 1\n    kn = lfsr(5, 128)\n    printk2(kn)\nendin\n\n; play a melodic sequence\ninstr 2\n    idur = p3\n    iamp = p4\n    iwav = p5\n    itun = p6\n\n    ; keep range small and transpose up 2 octaves to ensure audibility\n    ; we're interpreting these number like MIDI notes numbers for easy table lookups\n    kidx = lfsr(5, 128) + 24\n\n    ktrig = metro(1)\n    schedkwhen(ktrig, 0, 1, 3, 0, 1, iamp, iwav, itun, kidx)\nendin\n\ninstr 3\n    idur = p3\n    iamp = ampdb(p4)\n    iwav = p5\n    itun = p6\n    inote = p7\n\n        kenv = linen(iamp, 0.1, idur, 0.1)\n        aout = poscil3(kenv, tablekt(inote, itun), iwav)\n        outs(aout, aout)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.25\ni 2 0 10 -6 1 100\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lfsr/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/lfsr/#credits","title":"Credits","text":"<p>By: Dave Seidel 2020</p> <p>Based on code by Patrick Dowling in the Ornament &amp; Crime firmware.</p> <p>New in version 6.16</p>"},{"location":"opcodes/limit/","title":"Limit","text":""},{"location":"opcodes/limit/#limit","title":"limit","text":"<p>Sets the lower and upper limits of the value it processes.</p>"},{"location":"opcodes/limit/#syntax","title":"Syntax","text":"<pre><code>ares limit asig, klow, khigh\nires limit isig, ilow, ihigh\nkres limit ksig, klow, khigh\nires[] limit isig[], ilow, ihigh\nkres[] limit ksig[], klow, khigh\n</code></pre>"},{"location":"opcodes/limit/#initialization","title":"Initialization","text":"<p>isig -- input signal</p> <p>ilow -- low threshold</p> <p>ihigh -- high threshold</p>"},{"location":"opcodes/limit/#performance","title":"Performance","text":"<p>xsig -- input signal</p> <p>klow -- low threshold</p> <p>khigh -- high threshold</p> <p>limit sets the lower and upper limits on the xsig value it processes. If xhigh is lower than xlow, then the output will be the average of  the two - it will not be affected by xsig.</p> <p>This opcode is useful in several situations, such as table indexing or for clipping and modeling a-rate, i-rate or k-rate signals.</p>"},{"location":"opcodes/limit/#examples","title":"Examples","text":"<p>Here is an example of the limit opcode. It uses the file limit.csd.</p> Example of the limit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o limit.wav -W  ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr    1 ; Limit / Mirror / Wrap\n\nigain    = p4                           ;gain\nilevl1   = p5                           ; + level\nilevl2   = p6                           ; - level\nimode    = p7                           ;1 = limit, 2 = mirror, 3 = wrap\n\nain   soundin  \"fox.wav\"\nain   = ain*igain\n\nif    imode = 1 goto limit\nif    imode = 2 goto mirror\n\nasig  wrap  ain, ilevl2, ilevl1\ngoto  outsignal\n\nlimit:\nasig  limit  ain, ilevl2, ilevl1\ngoto  outsignal\n\nmirror:\nasig  mirror  ain, ilevl2, ilevl1\noutsignal:\n\nouts  asig*.5, asig*.5                  ;mind your speakers\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;           Gain  +Levl -Levl Mode\ni1  0  3    4.00  .25  -1.00   1        ;limit\ni1  4  3    4.00  .25  -1.00   2        ;mirror\ni1  8  3    4.00  .25  -1.00   3        ;wrap\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/limit/#see-also","title":"See also","text":"<p>Signal Limiters</p> <p>Array opcodes</p>"},{"location":"opcodes/limit/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia</p> <p>New in Csound version 3.46</p>"},{"location":"opcodes/limit1/","title":"Limit1","text":""},{"location":"opcodes/limit1/#limit1","title":"limit1","text":"<p>Limits the value of an argument to the range [0,1].</p>"},{"location":"opcodes/limit1/#syntax","title":"Syntax","text":"<pre><code>ires[] limit1 iarg\nkres[] limit1 karg\n</code></pre>"},{"location":"opcodes/limit1/#initialization","title":"Initialization","text":"<p>iarg[] -- the argument.</p>"},{"location":"opcodes/limit1/#performance","title":"Performance","text":"<p>karg[] -- the argument.</p>"},{"location":"opcodes/limit1/#examples","title":"Examples","text":"<p>Here is an example of the limit1 opcode. It uses the file limit1.csd.</p> Example of the limit1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\ninstr 1\n\niArg1[] fillarray 1,2,3\niRes[] limit1 iArg1/2.5\nik init 0\n\nwhile ik &lt; lenarray(iRes) do\n print iRes[ik]\n ik += 1\nod\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/limit1/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/limit1/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2017 </p>"},{"location":"opcodes/lincos/","title":"Lincos","text":""},{"location":"opcodes/lincos/#lincos","title":"lincos","text":"<p>Linear to cosine interpolation</p> <p>Plugin opcode in emugens.</p> <p>Maps a linear range of values to a cosine (easy-in/easy-out) range of values. At present it supports only scalars, at i- and k-time (no arrays)</p>"},{"location":"opcodes/lincos/#syntax","title":"Syntax","text":"<pre><code>ky lincos kx, ky0, ky1 [, kx0, kx1 ]\niy lincos ix, iy0, iy1 [, ix0, ix1 ]\n</code></pre>"},{"location":"opcodes/lincos/#performance","title":"Performance","text":"<p>kx -- Input signal</p> <p>ky0 -- Lower limit of output range</p> <p>ky1 -- Higher limit of output range</p> <p>kx0 -- Lower limit of input range (default = 0)</p> <p>kx1 -- Higher limit of input range (default = 1)</p> <pre><code>dx = ((x-x0) / (x1-x0)) * PI + PI\ny  = y0 + ((y1 - y0) * (1 + cos(dx)) / 2.0);\n</code></pre>"},{"location":"opcodes/lincos/#examples","title":"Examples","text":"<p>Here is an example of the lincos opcode. It uses the file lincos.csd.</p> Example of the lincos opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\n; Example file for lincos.csd\n\n/*\n  lincos\n\n  similar to cosseg, but with an explicit input for time\n  lincos can be used ease-in / out any linear ramp\n\n  ky  lincos kx, ky0, ky1, kx0=0, kx1=1\n  iy  lincos ix, iy0, iy1, ix0=0, ix1=1\n\n*/\n\n\nseed 0\n\ninstr 1\n  ; Map a value within the range 1-3 to the range 0-10.\n  iy lincos 1.5, 0, 10, 1, 3\n  print iy\n  kx line 1, p3, 3\n  ky lincos kx, 0, 10, 1, 3\n  printks \"kx: %f   ky: %f \\n\", 1/kr, kx, ky\nendin\n\ninstr 2\n  ; lincos can be used to create amplitude or pitch envelopes\n  ktrig init 0\n  krnd dust 1, 1\n  ktrig = lineto(tirghold(krnd &amp; ~ktrig, 0.5), 1)\n  kpitch = lincos:k(ktrig, 60, 61)\n  a0 oscili 0.7, mtof(kpitch)\n\n  kfade  lincos linsegr(0, 1.5, 1, 1.5, 0), 0, 1\n  kcresc lincos ktrig, 0.25, 1\n  outch 1, a0 * interp(kfade * kcresc)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0.2\ni 2 0 20\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lincos/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/lincos/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/line/","title":"Line","text":""},{"location":"opcodes/line/#line","title":"line","text":"<p>Trace a straight line between specified points.</p>"},{"location":"opcodes/line/#syntax","title":"Syntax","text":"<pre><code>ares line ia, idur, ib\nkres line ia, idur, ib\n</code></pre>"},{"location":"opcodes/line/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib -- value after idur seconds.</p> <p>idur -- duration in seconds of segment. A zero or negative value will cause all initialization to be skipped.</p>"},{"location":"opcodes/line/#performance","title":"Performance","text":"<p>line generates control or audio signals whose values move linearly from an initial value to a final one.</p> <p> Note</p> <p>A common error with this opcode is to assume that the value of ib is held after the time idur1. line does not automatically end or stop at the end of the duration given. If your note length is longer than idur seconds, kres (or ares) will not come to rest at ib, but will instead continue to rise or fall with the same rate. If a rise (or fall) and then hold is required that the linseg opcode should be considered instead.</p>"},{"location":"opcodes/line/#examples","title":"Examples","text":"<p>Here is an example of the line opcode. It uses the file line.csd.</p> Example of the line opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o line.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nkp = p6\n;choose between expon or line\nif (kp == 0) then       \n  kpitch expon p4, p3, p5 \nelseif (kp == 1) then\n  kpitch line p4, p3, p5 \nendif\n\nasig   vco2 .6, kpitch \n       outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0  2 300  600  0    ;if p6=0 then expon is used\ni 1 3  2 300  600  1    ;if p6=1 then line is used\ni 1 6  2 600  1200 0\ni 1 9  2 600  1200 1\ni 1 12 2 1200 2400 0\ni 1 15 2 1200 2400 1\ni 1 18 2 2400 30   0\ni 1 21 2 2400 30   1\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/line/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/linen/","title":"Linen","text":""},{"location":"opcodes/linen/#linen","title":"linen","text":"<p>Applies a straight line rise and decay pattern to an input amp signal.</p>"},{"location":"opcodes/linen/#syntax","title":"Syntax","text":"<pre><code>ares linen xamp, irise, idur, idec\nkres linen kamp, irise, idur, idec\n</code></pre>"},{"location":"opcodes/linen/#initialization","title":"Initialization","text":"<p>irise -- rise time in seconds. A zero or negative value signifies no rise modification.</p> <p>idur -- overall duration in seconds. A zero or negative value will cause initialization to be skipped.</p> <p>idec -- decay time in seconds. Zero means no decay. An idec &gt; idur will cause a truncated decay.</p>"},{"location":"opcodes/linen/#performance","title":"Performance","text":"<p>kamp, xamp -- input amplitude signal.</p> <p>Rise modifications are applied for the first irise seconds, and decay from time idur - idec. If these periods are separated in time there will be a steady state during which amp will be unmodified. If linen rise and decay periods overlap then both modifications will be in effect for that time. If the overall duration idur is exceeded in performance, the final decay will continue on in the same direction, going negative.</p> Envelope generated by the _linen_ opcode <p> Note</p> <p>A common error with this opcode is to assume that the value of 0 is the held after the envelope has finished at idur. linen does not automatically end or stop at the end of the duration given. If your note length is longer than idur seconds, kres (or ares) will not come to rest at 0, but will instead continue to fall with the same rate. If a decay and then hold is required then the linseg opcode should be considered instead.</p>"},{"location":"opcodes/linen/#examples","title":"Examples","text":"<p>Here is an example of the linen opcode. It uses the file linen.csd.</p> Example of the linen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o linen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n; p4=amp\n; p5=freq\n; p6=attack time\n; p7=release time\nares linen  p4, p6, p3, p7 \nasig poscil ares, p5, 1    \n     outs   asig, asig     \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1   0    4096 10 1      ; sine wave\n\n;ins strt dur amp  freq attack release\ni1   0    1   .5   440   0.5    0.7\ni1   1.5  1   .2   440   0.9    0.1\ni1   3    1   .2   880   0.02   0.99\ni1   4.5  1   .2   880   0.7    0.01\ni1   6    3   .7   220   0.5    0.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linen/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/linenr/","title":"Linenr","text":""},{"location":"opcodes/linenr/#linenr","title":"linenr","text":"<p>The linen opcode extended with a final release segment.</p> <p>linenr -- same as linen except that the final segment is entered only on sensing a MIDI note release. The note is then extended by the decay time.</p>"},{"location":"opcodes/linenr/#syntax","title":"Syntax","text":"<pre><code>ares linenr xamp, irise, idec, iatdec\nkres linenr kamp, irise, idec, iatdec\n</code></pre>"},{"location":"opcodes/linenr/#initialization","title":"Initialization","text":"<p>irise -- rise time in seconds. A zero or negative value signifies no rise modification.</p> <p>idec -- decay time in seconds. Zero means no decay.</p> <p>iatdec -- attenuation factor by which the closing steady state value is reduced exponentially over the decay period. This value must be positive and is normally of the order of .01. A large or excessively small value is apt to produce a cutoff which is audible. A zero or negative value is illegal.</p>"},{"location":"opcodes/linenr/#performance","title":"Performance","text":"<p>kamp, xamp -- input amplitude signal.</p> <p>linenr is unique within Csound in containing a note-off sensor and release time extender. When it senses either a score event termination or a MIDI noteoff, it will immediately extend the performance time of the current instrument by idec seconds, then execute an exponential decay towards the factor iatdec. For two or more units in an instrument, extension is by the greatest idec.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linsegr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you don't need to use xtratim if you are using linenr, since the time is extended automatically.</p> <p>These \u201cr\u201d units can also be modified by MIDI noteoff velocities (see veloffs).</p>"},{"location":"opcodes/linenr/#examples","title":"Examples","text":"<p>Here is an example of the linenr opcode. It uses the file linenr.csd.</p> Example of the linenr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc       -M0 ;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example by Jonathan Murphy and Charles Gran 2007\n  sr        =  44100\n  ksmps     =  10\n  nchnls    =  2\n\n        ; new, and important. Make sure that midi note events are only\n        ; received by instruments that actually need them.\n\n        ; turn default midi routing off\n        massign         0, 0\n        ; route note events on channel 1 to instr 1\n        massign         1, 1\n\n; Define your midi controllers\n#define C1 #21#\n#define C2 #22#\n#define C3 #23#\n\n; Initialize MIDI controllers\n            initc7    1, 21, 0.5                  ;delay send\n            initc7    1, 22, 0.5                  ;delay: time to zero\n            initc7    1, 23, 0.5                  ;delay: rate \n\n  gaosc     init      0\n\n; Define an opcode to \"smooth\" the MIDI controller signal\n    opcode smooth, k, k\n  kin       xin\n  kport     linseg    0, 0.0001, 0.01, 1, 0.01\n  kin       portk     kin, kport\n            xout      kin\n    endop\n\ninstr   1  \n ; Generate a sine wave at the frequency of the MIDI note that triggered the intrument\n  ifqc      cpsmidi\n  iamp      ampmidi   10000\n  aenv      linenr    iamp, .01, .1, .01          ;envelope\n  a1        oscil     aenv, ifqc, 1\n; All sound goes to the global variable gaosc\n  gaosc     =  gaosc + a1\n    endin\n\n    instr     198 ; ECHO\n  kcmbsnd   ctrl7     1, 21, 0, 1                 ;delay send\n  ktime     ctrl7     1, 22, 0.01, 6              ;time loop fades out\n  kloop     ctrl7     1, 23, 0.01, 1              ;loop speed\n; Receive MIDI controller values and then smooth them\n  kcmbsnd   smooth    kcmbsnd\n  ktime     smooth    ktime\n  kloop     smooth    kloop\n\n  imaxlpt   =  1                                  ;max loop time\n; Create a variable reverberation (delay) of the gaosc signal\n  acomb     vcomb     gaosc, ktime, kloop, imaxlpt, 1\n  aout      =  (acomb * kcmbsnd) + gaosc * (1 - kcmbsnd)\n            outs      aout, aout\n  gaosc     =  0\n    endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 16384 10 1\ni198 0 10000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linenr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/lineto/","title":"Lineto","text":""},{"location":"opcodes/lineto/#lineto","title":"lineto","text":"<p>Generate glissandos starting from a control signal.</p>"},{"location":"opcodes/lineto/#syntax","title":"Syntax","text":"<pre><code>kres lineto ksig, ktime\n</code></pre>"},{"location":"opcodes/lineto/#performance","title":"Performance","text":"<p>kres -- Output signal.</p> <p>ksig -- Input signal.</p> <p>ktime -- Time length of glissando in seconds.</p> <p>lineto adds glissando (i.e. straight lines) to a stepped input signal (for example, produced by randh or lpshold).  It generates a straight line starting from previous step value, reaching the new step value in ktime seconds. When the new step value is reached, such value is held until a new step occurs. Be sure that ktime argument value is smaller than the time elapsed between two consecutive steps of the original signal, otherwise discontinuities will occur in output signal.</p> <p>When used together with the output of lpshold it emulates the glissando effect of old analog sequencers.</p> <p> Note</p> <p>No new value for ksig or ktime will have effect until the previous ktime has elapsed.</p>"},{"location":"opcodes/lineto/#examples","title":"Examples","text":"<p>Here is an example of the lineto opcode. It uses the file lineto.csd.</p> Example of the lineto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lineto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkfreq     randh     1000, 20, 2, 1, 2000 ;generates ten random number between 100 and 300 per second\nkpan      randh     .5, 1, 2, 1, .5   ;panning between 0 and 1\nkp        lineto    kpan, .5          ;smoothing pan transition\naout      poscil    .4, kfreq, giSine\naL, aR    pan2      aout, kp\n          outs      aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lineto/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/lineto/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.13</p>"},{"location":"opcodes/linlin/","title":"Linlin","text":""},{"location":"opcodes/linlin/#linlin","title":"linlin","text":"<p>Linear to linear interpolation</p> <p>Plugin opcode in emugens.</p> <p>Maps a linear range of values to another linear range of values. Supports both scalars and arrays, at i- and k-time</p>"},{"location":"opcodes/linlin/#syntax","title":"Syntax","text":"<pre><code>ky linlin kx, ky0, ky1 [, kx0, kx1 ]\niy linlin ix, iy0, iy1 [, ix0, ix1 ]\nkys[] linlin kxs[], ky0, ky1 [, kx0, kx1 ]\niys[] linlin ixs[], ky0, ky1, [ kx0, kx1 ]\nkC[] linlin kx, kA[], kB[] [, kx0, kx1 ]\n</code></pre>"},{"location":"opcodes/linlin/#performance","title":"Performance","text":"<p>kx -- Input signal</p> <p>kx0 -- Lower limit of input range. Defaults to 0</p> <p>kx1 -- Higher limit of input range. Defaults to 1</p> <p>ky0 -- Lower limit of output range</p> <p>ky1 -- Higher limit of output range</p> <pre><code>y = (x - x0) / (x1 - x0) * (y1 - y0) + y0\n</code></pre>"},{"location":"opcodes/linlin/#examples","title":"Examples","text":"<p>Here is an example of the linlin opcode. It uses the file linlin.csd.</p> Example of the linlin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\n; Example file for linlin.csd\n\n/*\n\nlinlin\n\nlinear to linear interpolation between two ranges\n\nky    linlin kx, ky0, ky1, kx0=0, kx1=1\nkys[] linlin kxs[], ky0, ky1, kx0=0, kx1=1\niys[] linlin ixs[], iy0, iy1, ix0=0, ix1=1\n\nlinlin can be also used to blend between two arrays:\n\nkC[]  linlin kx, kA[], kB[], kx0=0, kx1=1\n\nif kx==0.5, kC[] will hold the avg of kA[] and kB[] for each value\n(assumes that kA[] and kB[] are arrays of the same size)\n\n*/\n\n; Map a value within the range 1-3 to the range 0-10.\ninstr 1\n  kx line 1, p3, 3\n  ky linlin kx, 0, 10, 1, 3\n  printks \"kx: %f   ky: %f \\n\", 1/kr, kx, ky\nendin\n\n; Map an array of values\ninstr 2\n  kX[] fillarray 0, 0.5, 1, 1.5, 2\n  trim kX, 4\n  kY[] linlin kX, 0, 10, 0, 2\n  printarray kY\n  turnoff\nendin\n\n; Blend between two arrays\ninstr 3\n  kA[] fillarray 0, 1, 2, 3, 4, 5\n  kB[] fillarray 0, 2, 4, 6, 8, 10\n  kx line 0, p3, 1\n  kC[] linlin kx, kA, kB\n  printarray kC, -1, \"\", \"blend\"\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; i 1 0   0.2\ni 2 0.5 0.2\n; i 3 1 0.5\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linlin/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/linlin/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p> <p>New plugin in version 6.11</p>"},{"location":"opcodes/linrand/","title":"Linrand","text":""},{"location":"opcodes/linrand/#linrand","title":"linrand","text":"<p>Linear distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/linrand/#syntax","title":"Syntax","text":"<pre><code>ares linrand krange\nires linrand krange\nkres linrand krange\n</code></pre>"},{"location":"opcodes/linrand/#performance","title":"Performance","text":"<p>krange -- the range of the random numbers (0 - krange). Outputs only positive numbers.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/linrand/#examples","title":"Examples","text":"<p>Here is an example of the linrand opcode. It uses the file linrand.csd.</p> Example of the linrand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o linrand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; every run time same values\n\nklin    linrand 100\n        printk .2, klin                 ; look \naout    oscili 0.8, 440+klin, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nklin    linrand 100\n        printk .2, klin                 ; look \naout    oscili 0.8, 440+klin, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>i   1 time     0.00033:    13.54770\ni   1 time     0.20033:    32.38746\ni   1 time     0.40033:    47.69304\ni   1 time     0.60033:    19.82218\ni   1 time     0.80033:    42.98293\ni   1 time     1.00000:    81.13174\ni   1 time     1.20033:    47.39585\ni   1 time     1.40033:    12.53248\ni   1 time     1.60033:    35.70722\ni   1 time     1.80000:    65.25774\ni   1 time     2.00000:    23.24811\nSeeding from current time 392575384\ni   2 time     3.00033:    23.05609\ni   2 time     3.20033:    76.15114\ni   2 time     3.40033:    22.78861\ni   2 time     3.60000:     0.79064\ni   2 time     3.80033:    43.49438\ni   2 time     4.00000:    34.10963\ni   2 time     4.20000:    31.88702\ni   2 time     4.40033:    59.78054\ni   2 time     4.60033:     4.96821\ni   2 time     4.80033:    24.69674\ni   2 time     5.00000:    21.88815\n</code></pre>"},{"location":"opcodes/linrand/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/linrand/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/linseg/","title":"Linseg","text":""},{"location":"opcodes/linseg/#linseg","title":"linseg","text":"<p>Trace a series of line segments between specified points.</p>"},{"location":"opcodes/linseg/#syntax","title":"Syntax","text":"<pre><code>ares linseg ia, idur1, ib [, idur2] [, ic] [...]\nkres linseg ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/linseg/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p>"},{"location":"opcodes/linseg/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note.</p>"},{"location":"opcodes/linseg/#examples","title":"Examples","text":"<p>Here is an example of the linseg opcode. It uses the file linseg.csd.</p> Example of the linseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o linseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkcps = cpspch(p4)\nkenv linseg 0, 0.25, 1, 0.75, 0 ; together = 1 sec\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 2 ; scaling to duration\n\nkcps = cpspch(p4)\nkenv linseg 0, p3*0.25, 1, p3*0.75, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 3 ; with negative value\n\nkcps = cpspch(p4)\naenv linseg 0, 0.1, 1, 0.5, -0.9, 0.4, 0\nasig poscil aenv, kcps, giSine\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1   7.00  ; = 1 sec, p3 fits exactly\ni 1 2 2   7.00  ; = 2 sec, p3 truncated at 1 sec\n\ni 2 4 1   7.00  ; scales to duration\ni 2 6 2   7.00  ; of p3\n\ni 3 9 2   7.00\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/linseg/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe</p>"},{"location":"opcodes/linsegb/","title":"Linsegb","text":""},{"location":"opcodes/linsegb/#linsegb","title":"linsegb","text":"<p>Trace a series of line segments between specified absolute points.</p>"},{"location":"opcodes/linsegb/#syntax","title":"Syntax","text":"<pre><code>ares linsegb ia, itim1, ib [, itim2] [, ic] [...]\nkres linsegb ia, itim1, ib [, itim2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/linsegb/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value at tim1 seconds, etc.</p> <p>itim1 -- time in seconds of end of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>itim2, itim3, etc. -- time in seconds at the end of subsequent segments.</p>"},{"location":"opcodes/linsegb/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The last tim value may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last value to be repeated until the end of the note.</p>"},{"location":"opcodes/linsegb/#examples","title":"Examples","text":"<p>Here is an example of the linsegb opcode. It uses the file linsegb.csd.</p> Example of the linsegb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o linseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkcps = cpspch(p4)\nkenv linsegb 0, 0.25, 1, 1, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\ninstr 2 ; scaling to duration\n\nkcps = cpspch(p4)\nkenv linseg 0, p3*0.25, 1, p3, 0\nasig poscil kenv, kcps, giSine\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1   7.00  ; = 1 sec, p3 fits exactly\ni 1 2 2   7.00  ; = 2 sec, p3 truncated at 1 sec\n\ni 2 4 1   7.00  ; scales to duration\ni 2 6 2   7.00  ; of p3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linsegb/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/linsegb/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini June 2011 </p> <p>New in version 5.14</p>"},{"location":"opcodes/linsegr/","title":"Linsegr","text":""},{"location":"opcodes/linsegr/#linsegr","title":"linsegr","text":"<p>Trace a series of line segments between specified points including a release segment.</p>"},{"location":"opcodes/linsegr/#syntax","title":"Syntax","text":"<pre><code>ares linsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\nkres linsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz\n</code></pre>"},{"location":"opcodes/linsegr/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc.</p> <p>idur1 -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments. A zero or negative value will terminate the initialization process with the preceding point, permitting the last-defined line or curve to be continued indefinitely in performance. The default is zero.</p> <p>irel, iz -- duration in seconds and final value of a note releasing segment.</p> <p>For Csound versions prior to 5.00, the release time cannot be longer than 32767/kr seconds. This limit has been extended to (2<sup>31</sup>-1)/kr.</p>"},{"location":"opcodes/linsegr/#performance","title":"Performance","text":"<p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern, while a longer one will cause the last-defined segment to continue on in the same direction.</p> <p>linsegr is amongst the Csound \u201cr\u201d units that contain a note-off sensor and release time extender. When each senses an event termination or MIDI noteoff, it immediately extends the performance time of the current instrument by irel _seconds, and sets out to reach the value _iz by the end of that period (no matter which segment the unit is in). \u201cr\u201d units can also be modified by MIDI noteoff velocities. For two or more extenders in an instrument, extension is by the greatest period.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linenr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using linsegr, since the time is extended automatically.</p>"},{"location":"opcodes/linsegr/#examples","title":"Examples","text":"<p>Here is an example of the linsegr opcode. It uses the file linsegr.csd.</p> Example of the linsegr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0   ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o linsegr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n\nicps    cpsmidi          \niamp    ampmidi .3       \n\nkenv    linsegr 1, .05, 0.5, 1, 0\nasig    pluck   kenv, icps, 200, 1, 1    \n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ;sine wave\n\nf0 30   ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/linsegr/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/linsegr/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe</p> <p>December 2002, December 2006. Thanks to Istvan Varga, added documentation about the maximum release time.</p> <p>New in Csound 3.47</p>"},{"location":"opcodes/liveconv/","title":"Liveconv","text":""},{"location":"opcodes/liveconv/#liveconv","title":"liveconv","text":"<p>Partitioned convolution with dynamically reloadable impulse response</p> <p>Plugin opcode in liveconv.</p> <p>Computationally efficient, partitioned convolution, using a function table as impulse response (IR) source, similar to the ftconv opcode. The liveconv opcode allows dynamic reload of IR data at any time while the convolution is running, controlled by the kupdate parameter. Due to the manner in which the IR is updated, the operation can be done without audio artifacts in the convolution output.</p> <p>The IR table is read partition by partition after signalling an update. The first ksmps samples must be available when the update flag is set. The rest of the table can be continuously filled in consecutive passes. There may be a new update for every partition, allowing as many as ftlen/iplen simultaneous updates (ftlen is the length of the IR table).</p> <p>The low-latency, dynamic behavior of liveconv makes it ideal for convolution with live sampled impulse responses, and/or real-time impulse response transformations and modifications.</p>"},{"location":"opcodes/liveconv/#syntax","title":"Syntax","text":"<pre><code>ares liveconv ain, ift, iplen, kupdate, kclear\n</code></pre>"},{"location":"opcodes/liveconv/#initialization","title":"Initialization","text":"<p>ift -- table number for storing the impulse response (IR) for convolution. The table may be filled with new data at any time while the convolution is running.</p> <p>iplen -- length of impulse response partition in samples; must be an integer power of two. Lower settings allow for shorter output delay, but will increase CPU usage.</p>"},{"location":"opcodes/liveconv/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>ares -- output signal.</p> <p>kupdate -- flag indicating whether the IR table should be updated. If kupdate=1 the IR table ift is loaded partition by partition, starting with the next partition. If kupdate=-1 the IR table ift is unloaded (cleared to zero) partition by partition, starting with the next partition. Other values have no effect.</p> <p>kclear -- flag for clearing all internal buffers. If kclear has any value != zero, the internal buffers are cleared immediately. This operation is not free of artifacts.</p>"},{"location":"opcodes/liveconv/#example","title":"Example","text":"<p>Here is an example of the liveconv opcode. It uses the file liveconv.csd.</p> Example of the liveconv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac  ;realtime audio out\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n        sr      = 44100\n        nchnls  = 2\n        0dbfs   = 1\n\n; empty IR table\ngiIR_record     ftgen   0, 0, 131072, 2, 0\n\n; Record impulse response\ninstr 13\n\np3              =       ftlen(giIR_record)/sr\niskip   =       p4\nirlen   =       p5\na1              diskin2 \"fox.wav\", 1, iskip\n\n; Fill IR table with segment from audio file\namp     linseg  0, 0.1, 1, irlen, 1, 0.1, 0, 1, 0\nandx_IR line    0, 1, 1/(ftlen(giIR_record)/sr)\n                tablew  a1*amp, andx_IR, giIR_record, 1\n                outch   1, a1*amp       ; output the IR\nktrig   init    1\nif ktrig &gt; -1 then\n        chnset  ktrig, \"conv_update\"\n        ktrig -= 1\nendif\n\nendin\n\n; The convolver\ninstr 14\n\nain     diskin2 \"drumsMlp.wav\", 1, 0, 1\nkupdate chnget  \"conv_update\"\naconv   liveconv ain, giIR_record, 2048, kupdate, 0\n                outch   2, aconv*0.009  ; output the convolution response\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; record impulse response\n;          skip  IR_dur\ni13     0       1       0.0     0.5\ni13     2       1       0.5     0.5\ni13     4       1       1.0     0.5\ni13     6       1       1.5     0.5\ni13     8       1       2.0     0.75\ni13     10      1       2.38 0.25\n\n; convolve\ni14     0.0     11.65   \n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/liveconv/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/liveconv/#credits","title":"Credits","text":"<p>Author: Sigurd Saue, Oeyvind Brandtsegg 2017</p>"},{"location":"opcodes/locsend/","title":"Locsend","text":""},{"location":"opcodes/locsend/#locsend","title":"locsend","text":"<p>Distributes the audio signals of a previous locsig opcode.</p> <p>The number of output signals must match the number in the previous locsig. The output signals from locsend are derived from the values given for distance and reverb in the locsig and are ready to be sent to local or global reverb units (see example below). The reverb amount and the balance between the 2 or 4 channels are calculated in the same way as described in the Dodge book (an essential text!).</p>"},{"location":"opcodes/locsend/#syntax","title":"Syntax","text":"<pre><code>a1, a2 locsend\na1, a2,  a3, a4 locsend\n</code></pre>"},{"location":"opcodes/locsend/#examples","title":"Examples","text":"<pre><code>  asig some audio signal\n  kdegree            line    0, p3, 360\n  kdistance          line    1, p3, 10\n  a1, a2, a3, a4     locsig  asig, kdegree, kdistance, .1\n  ar1, ar2, ar3, ar4 locsend\n  ga1 = ga1+ar1\n  ga2 = ga2+ar2\n  ga3 = ga3+ar3\n  ga4 = ga4+ar4\n                     outq    a1, a2, a3, a4\nendin\n\ninstr 99 ; reverb instrument\n  a1                 reverb2 ga1, 2.5, .5\n  a2                 reverb2 ga2, 2.5, .5\n  a3                 reverb2 ga3, 2.5, .5\n  a4                 reverb2 ga4, 2.5, .5\n                     outq    a1, a2, a3, a4\n  ga1=0\n  ga2=0\n  ga3=0\n  ga4=0\n</code></pre> <p>In the above example, the signal, asig, is sent around a complete circle once during the duration of a note while at the same time it becomes more and more \u201cdistant\u201d from the listeners' location. locsig sends the appropriate amount of the signal internally to locsend. The outputs of the locsend are added to global accumulators in a common Csound style and the global signals are used as inputs to the reverb units in a separate instrument. For an example, see locsig.</p> <p>locsig is useful for quad and stereo panning as well as fixed placed of sounds anywhere between two loudspeakers. Below is an example of the fixed placement of sounds in a stereo field. It uses the file locsend_stereo.csd.</p> Example of the locsend opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o locsend_stereo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nga1 init 0\nga2 init 0\n\ninstr 1\n\nkrevsend  = p4\naout      diskin2 \"drumsMlp.wav\", 1, 0, 1\nkdegree   line 0, p3, 180 ;left to right\nkdistance line 1, p3, 30\na1, a2    locsig aout, kdegree, kdistance, p4\nar1, ar2  locsend\nga1 = ga1+ar1\nga2 = ga2+ar2\n          outs a1, a2\n\nendin\n\ninstr 99 ; reverb instrument\na1      reverb2 ga1, 2.5, .5\na2      reverb2 ga2, 2.5, .5\n        outs    a1, a2\nga1 = 0\nga2 = 0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 16384 10 1\n\ni 1 0 4 .1      ;with reverb\ni 1 + 4 0       ;no reverb\ni99 0 7\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A few notes:</p> <pre><code>;place the sound in the left speaker and near:\ni1 0 1 0 1\n\n;place the sound in the right speaker and far:\ni1 1 1 90 25\n\n;place the sound equally between left and right and in the middle ground distance:\ni1 2 1 45 12\ne\n</code></pre> <p>The next example shows a simple intuitive use of the distance value to simulate Doppler shift. The same value is used to scale the frequency as is used as the distance input to locsig.</p> <pre><code>kdistance          line    1, p3, 10\nkfreq = (ifreq * 340) / (340 + kdistance)\nasig               oscili  iamp, kfreq, 1\nkdegree            line    0, p3, 360\na1, a2, a3, a4     locsig  asig, kdegree, kdistance, .1\nar1, ar2, ar3, ar4 locsend\n</code></pre>"},{"location":"opcodes/locsend/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/locsend/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1998</p> <p>New in Csound version 3.48</p>"},{"location":"opcodes/locsig/","title":"Locsig","text":""},{"location":"opcodes/locsig/#locsig","title":"locsig","text":"<p>Takes an input signal and distributes between 2 or 4 channels.</p> <p>It uses values in degrees to calculate the balance between adjacent channels. It also takes arguments for distance (used to attenuate signals that are to sound as if they are some distance further than the loudspeaker itself), and for the amount the signal that will be sent to reverberators. This unit is based upon the example in the Charles Dodge/Thomas Jerse book, Computer Music, page 320.</p>"},{"location":"opcodes/locsig/#syntax","title":"Syntax","text":"<pre><code>a1, a2 locsig asig, kdegree, kdistance, kreverbsend\na1, a2,  a3, a4 locsig asig, kdegree, kdistance, kreverbsend\n</code></pre>"},{"location":"opcodes/locsig/#performance","title":"Performance","text":"<p>kdegree -- value between 0 and 360 for placement of the signal in a 2 or 4 channel space configured as: a1=0, a2=90, a3=180, a4=270 (kdegree=45 would balanced the signal equally between a1 and a2). locsig maps kdegree to sin and cos functions to derive the signal balances (e.g.: asig=1, kdegree=45, a1=a2=.707).</p> <p>kdistance -- value &gt;= 1 used to attenuate the signal and to calculate reverb level to simulate distance cues.  As kdistance gets larger the sound should get softer and somewhat more reverberant (assuming the use of locsend in this case).</p> <p>kreverbsend -- the percentage of the direct signal that will be factored along with the distance and degree values to derive signal amounts that can be sent to a reverb unit such as reverb, or reverb2.</p>"},{"location":"opcodes/locsig/#examples","title":"Examples","text":"<p>Here is an example of the locsig opcode. It uses the file locsig_quad.csd.</p> Example of the locsig opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o locsig_quad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\nga1 init 0\nga2 init 0\nga3 init 0\nga4 init 0\n\ninstr 1\n\nkrevsend  = p4\naout      diskin2 \"drumsMlp.wav\", 1, 0, 1\nkdegree   line 0, p3, 360 ;full circle\nkdistance line 1, p3 , 1\na1, a2, a3, a4     locsig aout, kdegree, kdistance, krevsend\nar1, ar2, ar3, ar4 locsend\n\nga1 = ga1+ar1\nga2 = ga2+ar2\nga3 = ga3+ar3\nga4 = ga4+ar4\n    outq a1, a2, a3, a4\n\nendin\n\ninstr 99 ; reverb instrument\na1 reverb2 ga1, 3.5, .5\na2 reverb2 ga2, 3.5, .5\na3 reverb2 ga3, 3.5, .5\na4 reverb2 ga4, 3.5, .5\n   outq a1, a2, a3, a4\n\nga1 = 0\nga2 = 0\nga3 = 0\nga4 = 0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 16384 10 1\n\ni 1 0  14  .1   ;with reverb\ni 1 14 14  0    ;no reverb\ni99 0 36\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>In the above example, the signal, aout, is sent around a complete circle once during the duration of a note while at the same time it becomes more and more \"distant\" from the listeners' location. locsig sends the appropriate amount of the signal internally to locsend. The outputs of the locsend are added to global accumulators in a common Csound style and the global signals are used as inputs to the reverb units in a separate instrument.</p> <p>locsig is useful for quad and stereo panning as well as fixed placed of sounds anywhere between two loudspeakers. Below is an example of the fixed placement of sounds in a stereo field.</p> <pre><code>instr 1\n  a1, a2             locsig  asig, p4, p5, .1\n  ar1, ar2           locsend\n  ga1 = ga1+ar1\n  ga2 = ga2+ar2\n                     outs a1, a\nendin\ninstr 99 \n  ; reverb....\nendin\n</code></pre> <p>A few notes:</p> <pre><code>;place the sound in the left speaker and near:\ni1 0 1 0 1\n\n;place the sound in the right speaker and far:\ni1 1 1 90 25\n\n;place the sound equally between left and right and in the middle ground distance:\ni1 2 1 45 12\ne\n</code></pre> <p>The next example shows a simple intuitive use of the distance value to simulate Doppler shift. The same value is used to scale the frequency as is used as the distance input to locsig.</p> <pre><code>kdistance          line    1, p3, 10\nkfreq = (ifreq * 340) / (340 + kdistance)\nasig               oscili  iamp, kfreq, 1\nkdegree            line    0, p3, 360\na1, a2, a3, a4     locsig  asig, kdegree, kdistance, .1\nar1, ar2, ar3, ar4 locsend\n</code></pre>"},{"location":"opcodes/locsig/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/locsig/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1998</p> <p>New in Csound version 3.48</p>"},{"location":"opcodes/log/","title":"Log","text":""},{"location":"opcodes/log/#log","title":"log","text":"<p>Returns the natural log of x (x positive only).</p> <p>In the case of an array input, the operation can have an optional arbitrary base.</p> <p>The argument value is restricted for log, log10, and sqrt.</p>"},{"location":"opcodes/log/#syntax","title":"Syntax","text":"<pre><code>log(x) (no rate restriction)\nlog(k/i[]) (k- or i-arrays )\nkout[] log kin[], ibas\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression. In the case of an array input, ibas is the optional arbitrary base, which defaults to e (natural log base).</p>"},{"location":"opcodes/log/#examples","title":"Examples","text":"<p>Here is an example of the log opcode. It uses the file log.csd.</p> Example of the log opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o log.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = log(8)\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 2.079\n</code></pre>"},{"location":"opcodes/log/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/log/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in version 3.47</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/log10/","title":"Log10","text":""},{"location":"opcodes/log10/#log10","title":"log10","text":"<p>Returns the base 10 log of x (x positive only).</p> <p>The argument value is restricted for log, log10, and sqrt.</p>"},{"location":"opcodes/log10/#syntax","title":"Syntax","text":"<pre><code>log10(x) (no rate restriction)\nlog10(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/log10/#examples","title":"Examples","text":"<p>Here is an example of the log10 opcode. It uses the file log10.csd.</p> Example of the log10 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o log10.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = log10(8)\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 0.903\n</code></pre>"},{"location":"opcodes/log10/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/log10/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in version 3.47</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/log2/","title":"Log2","text":""},{"location":"opcodes/log2/#log2","title":"log2","text":"<p>Returns the base 2 log of x (x positive only).</p> <p>The argument value is restricted for log, log2, and sqrt.</p>"},{"location":"opcodes/log2/#syntax","title":"Syntax","text":"<pre><code>log2(x) (no rate restriction)\nlog2(k/i[]) (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/log2/#examples","title":"Examples","text":"<p>Here is an example of the log2 opcode. It uses the file log2.csd.</p> Example of the log2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o log10.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = log2(8)\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 3.000\n</code></pre>"},{"location":"opcodes/log2/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/log2/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in version 5.17.12</p>"},{"location":"opcodes/logbtwo/","title":"Logbtwo","text":""},{"location":"opcodes/logbtwo/#logbtwo","title":"logbtwo","text":"<p>Performs a logarithmic base two calculation.</p>"},{"location":"opcodes/logbtwo/#syntax","title":"Syntax","text":"<pre><code>logbtwo(x)  (init-rate or control-rate args only)\n</code></pre>"},{"location":"opcodes/logbtwo/#performance","title":"Performance","text":"<p>logbtwo() returns the logarithm base two of x. The range of values admitted as argument is .25 to 4 (i.e. from -2 octave to +2 octave response). This function is the inverse of powoftwo().</p> <p>These functions are fast, because they read values stored in tables. Also they are very useful when working with tuning ratios. They work at i- and k-rate.</p>"},{"location":"opcodes/logbtwo/#examples","title":"Examples","text":"<p>Here is an example of the logbtwo opcode. It uses the file logbtwo.csd.</p> Example of the logbtwo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o logbtwo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  i1 = logbtwo(3)\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 1.585\n</code></pre>"},{"location":"opcodes/logbtwo/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/logbtwo/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy June 1998</p> <p>Author: John ffitch University of Bath, Codemist, Ltd. Bath, UK July 1999</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/logcurve/","title":"Logcurve","text":""},{"location":"opcodes/logcurve/#logcurve","title":"logcurve","text":"<p>This opcode implements a formula for generating a normalised logarithmic curve in range 0 - 1. It is based on the Max / MSP work of Eric Singer (c) 1994.</p> <p>Generates a logarithmic curve in range 0 to 1 of arbitrary steepness. Steepness index less than 1.0 would result in Not-a-Number errors and cause unstable behavior, so it is treated as if it were 1.</p> <p>The formula used to calculate the curve is:</p> <pre><code>log(x * (y-1)+1) / log(y)\n</code></pre> <p>where x is equal to kindex and y is equal to ksteepness.</p>"},{"location":"opcodes/logcurve/#syntax","title":"Syntax","text":"<pre><code>kout logcurve kindex, ksteepness\n</code></pre>"},{"location":"opcodes/logcurve/#performance","title":"Performance","text":"<p>kindex -- Index value. Expected range 0 to 1.</p> <p>ksteepness -- Steepness of the generated curve. Values closer to 1.0 result in a straighter line while larger values steepen the curve.</p> <p>kout -- Scaled output.</p>"},{"location":"opcodes/logcurve/#examples","title":"Examples","text":"<p>Here is an example of the logcurve opcode. It uses the file logcurve.csd.</p> Example of the logcurve opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent\n-odac           -iadc     -d    ;;;realtime output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       100\nnchnls  =       2\n\n                instr   1       ; logcurve test\nkmod    phasor  1/p3\nkout    logcurve kmod, p4\n        printks \"kmod = %f  kout = %f\\\\n\", 0.1, kmod, kout\n                endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1      0       10 2\ni1      10      10 30\ni1      20      10 0.5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/logcurve/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/logcurve/#credits","title":"Credits","text":"<p>Author: David Akbari October 2006 Range check introduced in 6.16 by John ffitch</p>"},{"location":"opcodes/loop_ge/","title":"Loop ge","text":""},{"location":"opcodes/loop_ge/#loop_ge","title":"loop_ge","text":"<p>Construction of looping operations.</p>"},{"location":"opcodes/loop_ge/#syntax","title":"Syntax","text":"<pre><code>loop_ge  indx, idecr, imin, label\nloop_ge  kndx, kdecr, kmin, label\n</code></pre>"},{"location":"opcodes/loop_ge/#initialization","title":"Initialization","text":"<p>indx -- i-rate variable to count loop.</p> <p>idecr -- value to decrement the loop.</p> <p>imin -- minimum value of loop index.</p>"},{"location":"opcodes/loop_ge/#performance","title":"Performance","text":"<p>kndx -- k-rate variable to count loop.</p> <p>kdecr -- value to decrement the loop.</p> <p>kmin -- minimum value of loop index.</p> <p>The actions of loop_ge are equivalent to the code</p> <pre><code>indx  =  indx - idecr\nif (indx &gt;= imin) igoto label\n</code></pre> <p>or</p> <pre><code>kndx  =  kndx - kdecr\nif (kndx &gt;= kmin) kgoto label\n</code></pre> <p> Note</p> <p>Adviced is to use the 'modern' while or until opcodes for looping constructions.</p>"},{"location":"opcodes/loop_ge/#examples","title":"Examples","text":"<p>Here is a group example for all loop_xx opcodes, comparing the different loop_ opcodes. It uses the file loop_-group.csd.</p> Group example of the loop_xx opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example by joachim heintz\nsr     = 44100\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\n  instr 1 ;loop_lt: counts from 1 upwards and checks if &lt; 10\nicount    =         1\nloop:\n          print     icount\n          loop_lt   icount, 1, 10, loop\n          prints    \"Instr 1 terminated!%n\"\n  endin\n\n  instr 2 ;loop_le: counts from 1 upwards and checks if &lt;= 10\nicount    =         1\nloop:\n          print     icount\n          loop_le   icount, 1, 10, loop\n          prints    \"Instr 2 terminated!%n\"\n  endin\n\n  instr 3 ;loop_gt: counts from 10 downwards and checks if &gt; 0\nicount    =         10\nloop:\n          print     icount\n          loop_gt   icount, 1, 0, loop\n          prints    \"Instr 3 terminated!%n\"\n  endin\n\n  instr 4 ;loop_ge: counts from 10 downwards and checks if &gt;= 0\nicount    =         10\nloop:\n          print     icount\n          loop_ge   icount, 1, 0, loop\n          prints    \"Instr 4 terminated!%n\"\n  endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0\ni 2 0 0\ni 3 0 0\ni 4 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loop_ge/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p> <p>More information on this opcode: http://www.csoundjournal.com/2006summer/controlFlow_part2.html written by Steven Yi, and in the Floss Manuals:  https://flossmanual.csound.com/csound-language/control-structures</p>"},{"location":"opcodes/loop_ge/#credits","title":"Credits","text":"<p>Istvan Varga. 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/loop_gt/","title":"Loop gt","text":""},{"location":"opcodes/loop_gt/#loop_gt","title":"loop_gt","text":"<p>Construction of looping operations.</p>"},{"location":"opcodes/loop_gt/#syntax","title":"Syntax","text":"<pre><code>loop_gt  indx, idecr, imin, label\nloop_gt  kndx, kdecr, kmin, label\n</code></pre>"},{"location":"opcodes/loop_gt/#initialization","title":"Initialization","text":"<p>indx -- i-rate variable to count loop.</p> <p>idecr -- value to decrement the loop.</p> <p>imin -- minimum value of loop index.</p>"},{"location":"opcodes/loop_gt/#performance","title":"Performance","text":"<p>kndx -- k-rate variable to count loop.</p> <p>kdecr -- value to decrement the loop.</p> <p>kmin -- minimum value of loop index.</p> <p>The actions of loop_gt are equivalent to the code</p> <pre><code>indx  =  indx - idecr\nif (indx &gt; imin) igoto label\n</code></pre> <p>or</p> <pre><code>kndx  =  kndx - kdecr\nif (kndx &gt; kmin) kgoto label\n</code></pre> <p> Note</p> <p>Adviced is to use the 'modern' while or until opcodes for looping constructions.</p>"},{"location":"opcodes/loop_gt/#examples","title":"Examples","text":"<p>Here is an example of the loop_gt opcode. It uses the file loop_gt.csd.</p> Example of the loop_gt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loop_gt.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi - 2021\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisaw  ftgen 3, 0, 16384, 10, 0, .2, 0, .4, 0, .6, 0, .8, 0, 1, 0, .8, 0, .6, 0, .4, 0,.2 \n\ninstr 1 ;master instrument\n\nindxFreq = p5\n\nloop:\n\nifreq = p4 + indxFreq\nprint ifreq\niamp = 0.5/((p5-p7)/p6)\nevent_i \"i\", 10, 0, p3, iamp, ifreq\nloop_gt indxFreq, p6, p7, loop\n\nendin\n\n\ninstr 10\n\nasig  oscili p4, p5, gisaw\nasig butterhp asig, 50\nkdeclick linseg 0, 0.1, 1, p3-0.2, 1, 0.1, 0\nouts asig * kdeclick, asig * kdeclick\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\ni1 0 2 200 10 3 1\n\ni1 2 2 200 4 0.3 1\n\ni1 4 2 200 55 7 1\n\ni1 6 2 200 3 0.2 1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loop_gt/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p> <p>More information on this opcode: http://www.csoundjournal.com/2006summer/controlFlow_part2.html written by Steven Yi, and in the Floss Manuals:  https://flossmanual.csound.com/csound-language/control-structures</p>"},{"location":"opcodes/loop_gt/#credits","title":"Credits","text":"<p>Istvan Varga.</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/loop_le/","title":"Loop le","text":""},{"location":"opcodes/loop_le/#loop_le","title":"loop_le","text":"<p>Construction of looping operations.</p>"},{"location":"opcodes/loop_le/#syntax","title":"Syntax","text":"<pre><code>loop_le  indx, incr, imax, label\nloop_le  kndx, kncr, kmax, label\n</code></pre>"},{"location":"opcodes/loop_le/#initialization","title":"Initialization","text":"<p>indx -- i-rate variable to count loop.</p> <p>incr -- value to increment the loop.</p> <p>imax -- maximum value of loop index.</p>"},{"location":"opcodes/loop_le/#performance","title":"Performance","text":"<p>kndx -- k-rate variable to count loop.</p> <p>kncr -- value to increment the loop.</p> <p>kmax -- maximum value of loop index.</p> <p>The actions of loop_le are equivalent to the code</p> <pre><code>indx  =  indx + incr\nif (indx &lt;= imax) igoto label\n</code></pre> <p>or</p> <pre><code>kndx  =  kndx + kncr\nif (kndx &lt;= kmax) kgoto label\n</code></pre> <p> Note</p> <p>Adviced is to use the 'modern' while or until opcodes for looping constructions.</p>"},{"location":"opcodes/loop_le/#examples","title":"Examples","text":"<p>Here is an example of the loop_le opcode. It uses the file loop_le.csd.</p> Example of the loop_le opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loop_le.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;master instrument\n\nininstr = 5 ;number of called instances\nindx = 0\nloop:\n      prints \"play instance %d\\\\n\", indx\nipan  random 0, 1\nifreq random 100, 1000\niamp  = 1/ininstr\nevent_i \"i\", 10, 0, p3, iamp, ifreq, ipan\nloop_le indx, 1, ininstr, loop\n\nendin\n\ninstr 10\n\nipeak random 0, 1 ;where is the envelope peak\nasig  poscil3 p4, p5, gisine\naenv  transeg 0, p3*ipeak, 6, 1, p3-p3*ipeak, -6, 0\naL,aR pan2 asig*aenv, p6\n      outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>play instance 0\nplay instance 1\nplay instance 2\nplay instance 3\nplay instance 4\nplay instance 5\n</code></pre>"},{"location":"opcodes/loop_le/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p> <p>More information on this opcode: http://www.csoundjournal.com/2006summer/controlFlow_part2.html written by Steven Yi, and in the Floss Manuals:  https://flossmanual.csound.com/csound-language/control-structures</p>"},{"location":"opcodes/loop_le/#credits","title":"Credits","text":"<p>Istvan Varga.</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/loop_lt/","title":"Loop lt","text":""},{"location":"opcodes/loop_lt/#loop_lt","title":"loop_lt","text":"<p>Construction of looping operations.</p>"},{"location":"opcodes/loop_lt/#syntax","title":"Syntax","text":"<pre><code>loop_lt  indx, incr, imax, label\nloop_lt  kndx, kncr, kmax, label\n</code></pre>"},{"location":"opcodes/loop_lt/#initialization","title":"Initialization","text":"<p>indx -- i-rate variable to count loop.</p> <p>incr -- value to increment the loop.</p> <p>imax -- maximum value of loop index.</p>"},{"location":"opcodes/loop_lt/#performance","title":"Performance","text":"<p>kndx -- k-rate variable to count loop.</p> <p>kncr -- value to increment the loop.</p> <p>kmax -- maximum value of loop index.</p> <p>The actions of loop_lt are equivalent to the code</p> <pre><code>indx  =  indx + incr\nif (indx &lt; imax) igoto label\n</code></pre> <p>or</p> <pre><code>kndx  =  kndx + kncr\nif (kndx &lt; kmax) kgoto label\n</code></pre> <p> Note</p> <p>Adviced is to use the 'modern' while or until opcodes for looping constructions.</p>"},{"location":"opcodes/loop_lt/#examples","title":"Examples","text":"<p>Here is an example of the loop_lt opcode. It uses the file loop_lt.csd.</p> Example of the loop_lt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loop_lt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;master instrument\n\nininstr = 5 ;number of called instances\nindx = 0\nloop:\n      prints \"play instance %d\\\\n\", indx\nipan  random 0, 1\nifreq random 100, 1000\niamp  = 1/ininstr\nevent_i \"i\", 10, 0, p3, iamp, ifreq, ipan\nloop_lt indx, 1, ininstr, loop\n\nendin\n\ninstr 10\n\nipeak random 0, 1 ;where is the envelope peak\nasig  poscil3 p4, p5, gisine\naenv  transeg 0, p3*ipeak, 6, 1, p3-p3*ipeak, -6, 0\naL,aR pan2 asig*aenv, p6\n      outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>play instance 0\nplay instance 1\nplay instance 2\nplay instance 3\nplay instance 4\n</code></pre>"},{"location":"opcodes/loop_lt/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p> <p>More information on this opcode: http://www.csoundjournal.com/2006summer/controlFlow_part2.html written by Steven Yi, and in the Floss Manuals:  https://flossmanual.csound.com/csound-language/control-structures</p>"},{"location":"opcodes/loop_lt/#credits","title":"Credits","text":"<p>Istvan Varga.</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/loopseg/","title":"Loopseg","text":""},{"location":"opcodes/loopseg/#loopseg","title":"loopseg","text":"<p>Generate control signal consisting of linear segments delimited by two or more specified points.</p> <p>The entire envelope is looped at kfreq rate. Each parameter can be varied at k-rate.</p>"},{"location":"opcodes/loopseg/#syntax","title":"Syntax","text":"<pre><code>ksig loopseg kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] \\\n             [, kvalue2] [, ktime2][...]\n</code></pre>"},{"location":"opcodes/loopseg/#initialization","title":"Initialization","text":"<p>iphase -- A value between 0 and 1 to say where to start the loop.  Zero, the commonest value, indicates the beginning.</p>"},{"location":"opcodes/loopseg/#performance","title":"Performance","text":"<p>ksig -- Output signal.</p> <p>kfreq -- Repeat rate in Hz or fraction of Hz.</p> <p>ktrig -- If non-zero, retriggers the envelope from start (see trigger opcode), before the envelope cycle is completed.</p> <p>kvalue0...kvalueN -- Values of points</p> <p>ktime0...ktimeN -- Times between points; expressed in fractions of a cycle (see below). The final time designates a ramp between the final value and the first value.</p> <p>loopseg opcode is similar to linseg, but the entire envelope is looped at kfreq rate. Notice that times are not expressed in seconds but in fraction of a cycle. Actually each duration represent is proportional to the other, and the entire cycle duration is proportional to the sum of all duration values.</p> <p>The sum of all duration is then rescaled according to kfreq argument. For example, considering an envelope made up of 3 segments, each segment having 100 as duration value, their sum will be 300. This value represents the total duration of the envelope, and is actually divided into 3 equal parts, a part for each segment.</p> <p>Actually, the real envelope duration in seconds is determined by kfreq. Again, if the envelope is made up of 3 segments, but this time the first and last segments have a duration of 50, whereas the central segment has a duration of 100 again, their sum will be 200. This time 200 represent the total duration of the 3 segments, so the central segment will be twice as long as the other segments.</p> <p>All parameters can be varied at k-rate.  Negative frequency values are allowed, reading the envelope backward.  ktime0 should always be set to 0, except if the user wants some special effect.</p>"},{"location":"opcodes/loopseg/#examples","title":"Examples","text":"<p>Here is an example of the loopseg opcode. It uses the file loopseg.csd.</p> Example of the loopseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loopseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkfreq  init     p4  ; frequency of loop repetition\nifrac  =        p5  ; frequency ratio of restart triggers\nktrig  metro    kfreq * ifrac  ; triggers to restart loop\niphase =        0   ; initial phase\n; loop of note values (some glissandi)\n;                                    val dur val dur etc...\nknote loopseg  kfreq, ktrig, iphase, 40, 1,  40, 0,  43,1,43,0, 49,2,48,0, \\\n 47,1,47,0, 46,1,46,0, 46,1,47,0, 49,1,49,0, 43,1,43,0, 46,1,46,0, 40,1,39,0    \n; loop of filter cutoff values (oct format). This loop, half speed of note loop.\nkcfoct loopseg  kfreq*0.5, ktrig, iphase, 11,2,4,0, 12,1,4,0, 13,1,4,0, \\\n 11.5,3,4,0, 12.5,1,4,0, 13,2,4,0, 12.5,1,4,0\nkenv  linseg   0,0.01,1,p3-5.01,1,5,0\nioct  =        int((rnd(0.999)*4)-2) ; random value either -1, 0 or 1\nasig  vco2     0.2*kenv,cpsmidinn(knote)*octave(ioct),0 ; sawtooth\nasig  moogladder  asig,cpsoct(kcfoct),rnd(0.6)          ; filter sawtooth\naL,aR pan2     asig,rnd(1)  ; random static pan location\n      outs     aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; 4 layers, each with a different frequency of loop repetition (p4),\n;  frequency ratio of restart triggers (p5) and pan position (p6).\ni 1  0 30 0.5   [11/19]\ni 1  6 30 0.25  [11/13]\ni 1 12 30 0.125 [11/16]\ni 1 18 30 1     [11/12]\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loopseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/loopseg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.13</p>"},{"location":"opcodes/loopsegp/","title":"Loopsegp","text":""},{"location":"opcodes/loopsegp/#loopsegp","title":"loopsegp","text":"<p>Control signals based on linear segments.</p> <p>Generate control signal consisiting of linear segments delimited by two or more specified points. The entire envelope can be looped at time-variant rate. Each segment coordinate can also be varied at k-rate.</p>"},{"location":"opcodes/loopsegp/#syntax","title":"Syntax","text":"<pre><code>ksig loopsegp  kphase, kvalue0, kdur0, kvalue1 \\\n               [, kdur1, ... , kdurN-1, kvalueN]\n</code></pre>"},{"location":"opcodes/loopsegp/#performance","title":"Performance","text":"<p>ksig - output signal</p> <p>kphase - point of the sequence read, expressed as a fraction of a cycle (0 to 1)</p> <p>kvalue0 ...kvalueN  - values of points</p> <p>kdur0 ...kdurN-1  -  duration of points expessed in fraction of a cycle</p> <p>loopsegp opcode is similar to loopseg; the only difference is that, instead of frequency,  a time-variant phase is required. If you use phasor to get the phase value, you will have a behaviour identical to loopseg, but interesting results can be achieved when using phases having non-linear motions, making loopsegp more  powerful and general than loopseg.</p>"},{"location":"opcodes/loopsegp/#examples","title":"Examples","text":"<p>Here is an example of the loopsegp opcode. It uses the file loopsegp.csd.</p> Example of the loopsegp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loopsegp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nktrig metro 22/8 ; triggers used to generate new direction values\nkdir  trandom ktrig,-2.99,2.99\nkdir  =       0.5*int(kdir) ; kdir will either -1, -0.5, 0, 0.5 or 1\n; kphase - looping pointer\nkphase phasor kdir\n; a loop sequence of midi note numbers and durations\nknote loopsegp  kphase, 40,1,40,0, 43,1,43,0, 49,2,48,0, \\\n 47,1,47,0, 46,1,46,0, 46,1,47,0, 49,1,49,0, 43,1,43,0, 46,1,46,0, 40,1,39,0    \nkmul  rspline 0.1,0.8,0.5,5                         ; modulation of buzz tone\nasig  gbuzz   0.2, cpsmidinn(knote), 30, 3, kmul, 1 ; buzz tone\n      outs    asig, asig\n\n      schedkwhen ktrig,0,0,2,0,0.1 ; play metronome\nendin\n\ninstr 2 ; metronome\nacps  expon   180+rnd(40),p3,50\naamp  expon   0.05+rnd(0.05),p3,0.001\nasig  poscil  aamp-0.001,acps,2\n      outs    asig,asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; cosine wave.\nf 1 0 16384 11 1\n; sine wave.\nf 2 0 16384 10 1\n\ni 1 0 360 0.25\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loopsegp/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/loopsegp/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5. (Previously available only on CsoundAV)</p>"},{"location":"opcodes/looptseg/","title":"Looptseg","text":""},{"location":"opcodes/looptseg/#looptseg","title":"looptseg","text":"<p>Generate control signal consisting of exponential or linear segments delimited by two or more specified points.</p> <p>The entire envelope is looped at kfreq rate. Each parameter can be varied at k-rate.</p>"},{"location":"opcodes/looptseg/#syntax","title":"Syntax","text":"<pre><code>ksig looptseg kfreq, ktrig, iphase, kvalue0, ktype0, ktime0, [, kvalue1] \\\n              [,ktype1] [, ktime1] [, kvalue2] [,ktype2] [, ktime2] [...] \\\n              [, kvalueN] [,ktypeN] [, ktimeN]\n</code></pre>"},{"location":"opcodes/looptseg/#initialization","title":"Initialization","text":"<p>iphase -- A value between 0 and 1 to say where to start the loop.  Zero, the commonest value, indicates the beginning.</p>"},{"location":"opcodes/looptseg/#performance","title":"Performance","text":"<p>ksig -- Output signal.</p> <p>kfreq -- Repeat rate in Hz or fraction of Hz.</p> <p>ktrig -- If non-zero, retriggers the envelope from start (see trigger opcode), before the envelope cycle is completed.</p> <p>kvalue0...kvalueN -- Values of points</p> <p>ktime0...ktimeN -- Times between points; expressed in fractions of a cycle (see below). The final time designates a ramp between the final value and the first value.</p> <p>ktype0...ktypeN -- shape of the envelope.  If the value is 0 then the shap eis linear; otherwise it is an concave exponential (positive type) or a convex exponential (negative type).</p> <p>looptseg opcode is similar to transeg, but the entire envelope is looped at kfreq rate. Notice that times are not expressed in seconds but in fraction of a cycle. Actually each duration represent is proportional to the other, and the entire cycle duration is proportional to the sum of all duration values.</p> <p>The sum of all duration is then rescaled according to kfreq argument. For example, considering an envelope made up of 3 segments, each segment having 100 as duration value, their sum will be 300. This value represents the total duration of the envelope, and is actually divided into 3 equal parts, a part for each segment.</p> <p>Actually, the real envelope duration in seconds is determined by kfreq. Again, if the envelope is made up of 3 segments, but this time the first and last segments have a duration of 50, whereas the central segment has a duration of 100 again, their sum will be 200. This time 200 represent the total duration of the 3 segments, so the central segment will be twice as long as the other segments.</p> <p>All parameters can be varied at k-rate.  Negative frequency values are allowed, reading the envelope backward.  ktime0 should always be set to 0, except if the user wants some special effect.</p>"},{"location":"opcodes/looptseg/#examples","title":"Examples","text":"<p>Here is an example of the looptseg opcode. It uses the file looptseg.csd.</p> Example of the looptseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o looptseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkfreq   =        1         ; frequency of loop repetition\nktrig   init     0         ; loop restart trigger (not used)\niphase  =        0         ; initial phase\nktyp    line     6,p3,-6   ; explore the useful range of curve types\n; loop of filter cutoff values (oct format)\n;                                     value curve dur.\nkcfoct looptseg  kfreq, ktrig, iphase,13,   ktyp, 1, \\\n                                      4,    ktyp, 0, \\\n                                      11,   ktyp, 1, \\\n                                      4\nasig  vco2     0.2,cpsmidinn(48),0             ; a sawtooth\nasig  moogladder  asig,cpsoct(kcfoct),rnd(0.6) ; filter sawtooth\n      outs     asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 12\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/looptseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/looptseg/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in Version 5.12</p>"},{"location":"opcodes/loopxseg/","title":"Loopxseg","text":""},{"location":"opcodes/loopxseg/#loopxseg","title":"loopxseg","text":"<p>Generate control signal consisting of exponential segments delimited by two or more specified points.</p> <p>The entire envelope is looped at kfreq rate. Each parameter can be varied at k-rate.</p>"},{"location":"opcodes/loopxseg/#syntax","title":"Syntax","text":"<pre><code>ksig loopxseg kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\\n              [, kvalue2] [, ktime2] [...]\n</code></pre>"},{"location":"opcodes/loopxseg/#performance","title":"Performance","text":"<p>ksig -- Output signal.</p> <p>kfreq -- Repeat rate in Hz or fraction of Hz.</p> <p>ktrig -- If non-zero, retriggers the envelope from start (see trigger opcode), before the envelope cycle is completed.</p> <p>iphase -- A value between 0 and 1 to say where to start the loop.  Zero, the commonest value, indicates the beginning.</p> <p>ktime0...ktimeN -- Times of points; expressed in fraction of a cycle.</p> <p>kvalue0...kvalueN -- Values of points</p> <p>loopxseg opcode is similar to expseg, but the entire envelope is looped at kfreq rate. Notice that times are not expressed in seconds but in fraction of a cycle. Actually each duration represent is proportional to the other, and the entire cycle duration is proportional to the sum of all duration values.</p> <p>The sum of all duration is then rescaled according to kfreq argument. For example, considering an envelope made up of 3 segments, each segment having 100 as duration value, their sum will be 300. This value represents the total duration of the envelope, and is actually divided into 3 equal parts, a part for each segment.</p> <p>Actually, the real envelope duration in seconds is determined by kfreq. Again, if the envelope is made up of 3 segments, but this time the first and last segments have a duration of 50, whereas the central segment has a duration of 100 again, their sum will be 200. This time 200 represent the total duration of the 3 segments, so the central segment will be twice as long as the other segments.</p> <p>All parameters can be varied at k-rate.  Negative frequency values are allowed, reading the envelope backward.  ktime0 should always be set to 0, except if the user wants some special effect.</p>"},{"location":"opcodes/loopxseg/#examples","title":"Examples","text":"<p>Here is an example of the loopxseg opcode. It uses the file loopxseg.csd.</p> Example of the loopxseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loopxseg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkfreq  rspline  0.01,20,0.2,1   ; freq. of loop repetition created by random spline\nktrig  init     0   ; loop restart trigger (not used)\niphase =        0   ; initial phase\n; loop of filter cutoff values (oct format). Rescaled further down.\nkcfoct loopxseg  kfreq, ktrig, iphase, 1,1,0,0\nkenv   linseg   0,0.01,1,p3-5.01,1,5,0\nasig   vco2     0.2*kenv,cpsmidinn(48),0\nkdep   rspline  5,8,0.2,1  ; filter depth created by a random spline\nkcf    port     cpsoct((kcfoct*kdep)+4), 0.001  ; smooth filter changes\nasig   moogladder  asig,kcf,rnd(0.6)\naL,aR  pan2     asig,rnd(1)\n       outs     aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1  0 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loopxseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/loopxseg/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in Version 5.12</p>"},{"location":"opcodes/lorenz/","title":"Lorenz","text":""},{"location":"opcodes/lorenz/#lorenz","title":"lorenz","text":"<p>Implements the Lorenz system of equations.</p> <p>Implements the Lorenz system of equations.  The Lorenz system is a chaotic-dynamic system which was originally used to simulate the motion of a particle in convection currents and simplified weather systems. Small differences in initial conditions rapidly lead to diverging values. This is sometimes expressed as the butterfly effect. If a butterfly flaps its wings in Australia, it will have an effect on the weather in Alaska. This system is one of the milestones in the development of chaos theory. It is useful as a chaotic audio source or as a low frequency modulation source.</p>"},{"location":"opcodes/lorenz/#syntax","title":"Syntax","text":"<pre><code>ax, ay, az lorenz ksv, krv, kbv, kh, ix, iy, iz, iskip [, iskipinit]\n</code></pre>"},{"location":"opcodes/lorenz/#initialization","title":"Initialization","text":"<p>ix, iy, iz -- the initial coordinates of the particle.</p> <p>iskip -- used to skip generated values. If iskip is set to 5, only every fifth value generated is output. This is useful in generating higher pitched tones.</p> <p>iskipinit (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/lorenz/#performance","title":"Performance","text":"<p>ksv -- the Prandtl number or sigma</p> <p>krv -- the Rayleigh number</p> <p>kbv -- the ratio of the length and width of the box in which the convection currents are generated</p> <p>kh -- the step size used in approximating the differential equation. This can be used to control the pitch of the systems. Values of .1-.001 are typical.</p> <p>The equations are approximated as follows:</p> <pre><code>x = x + h*(s*(y - x))\ny = y + h*(-x*z + r*x - y)\nz = z + h*(x*y - b*z)\n</code></pre> <p>The historical values of these parameters are:</p> <pre><code>ks = 10\nkr = 28\nkb = 8/3\n</code></pre> <p> Note</p> <p>This algorithm uses internal non linear feedback loops which causes audio result to depend on the orchestra sampling rate. For example, if you develop a project with sr=48000Hz and if you want to produce an audio CD from it, you should record a file with sr=48000Hz and then downsample the file to 44100Hz using the src_conv utility.</p>"},{"location":"opcodes/lorenz/#examples","title":"Examples","text":"<p>Here is an example of the lorenz opcode. It uses the file lorenz.csd.</p> Example of the lorenz opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o lorenz.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 2\n\n; Instrument #1 - a lorenz system in 3D space.\ninstr 1\n  ; Create a basic tone.\n  kamp init 25000\n  kcps init 1000\n  ifn = 1\n  asnd oscil kamp, kcps, ifn\n\n  ; Figure out its X, Y, Z coordinates.\n  ksv init 10\n  krv init 28\n  kbv init 2.667\n  kh init 0.0003\n  ix = 0.6\n  iy = 0.6\n  iz = 0.6\n  iskip = 1\n  ax1, ay1, az1 lorenz ksv, krv, kbv, kh, ix, iy, iz, iskip\n\n  ; Place the basic tone within 3D space.\n  kx downsamp ax1\n  ky downsamp ay1\n  kz downsamp az1\n  idist = 1\n  ift = 0\n  imode = 1\n  imdel = 1.018853416\n  iovr = 2\n  aw2, ax2, ay2, az2 spat3d asnd, kx, ky, kz, idist, \\\n                            ift, imode, imdel, iovr\n\n  ; Convert the 3D sound to stereo.\n  aleft = aw2 + ay2\n  aright = aw2 - ay2\n\n  outs aleft, aright\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1 a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for 5 seconds.\ni 1 0 5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lorenz/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/lorenz/#credits","title":"Credits","text":"<p>Author: Hans Mikelson February 1999</p> <p>New in Csound version 3.53</p> <p>Note added by Fran\u00e7ois Pinot, August 2009</p>"},{"location":"opcodes/loscil/","title":"Loscil","text":""},{"location":"opcodes/loscil/#loscil","title":"loscil","text":"<p>Read sampled sound (mono or stereo) from a table.</p> <p>Reading with optional sustain and release looping. A version that outputs the exact table position (phase) corresponding to the output sample is provided as an alternative opcode.</p>"},{"location":"opcodes/loscil/#syntax","title":"Syntax","text":"<pre><code>ar1 [,ar2] loscil xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n                  [, imod2] [, ibeg2] [, iend2]\naph, ar1 [,ar2] loscilphs xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] \\\n                          [, iend1] [, imod2] [, ibeg2] [, iend2]\n</code></pre>"},{"location":"opcodes/loscil/#initialization","title":"Initialization","text":"<p>ifn -- function table number, typically denoting an sampled sound segment with prescribed looping points loaded using GEN01. The source file may be mono or stereo.</p> <p>ibas (optional) -- base frequency in Hz of the recorded sound. This optionally overrides the frequency given in the audio file, but is required if the file did not contain one. The default value is 261.626 Hz, i.e. middle C. (New in Csound 4.03). If this value is not known or not present, use 1 here and in kcps.</p> <p>imod1, imod2 (optional, default=-1) -- play modes for the sustain and release loops. A value of 1 denotes normal looping, 2 denotes forward &amp; backward looping, 0 denotes no looping. The default value (-1) will defer to the mode and the looping points given in the source file. Make sure you select an appropriate mode if the file does not contain this information.</p> <p>ibeg1, iend1, ibeg2, iend2 (optional, dependent on mod1, mod2) -- begin and end points of the sustain and release loops. These are measured in sample frames from the beginning of the file, so will look the same whether the sound segment is monaural or stereo. If no loop points are specified, and a looping mode (imod1, imod2) is given, the file will be looped for the whole length.</p>"},{"location":"opcodes/loscil/#performance","title":"Performance","text":"<p>aph -- the normalised table position corresponding to the output sample (loscilphs only).</p> <p>ar1, ar2 -- the output at audio-rate. There is just ar1 for mono output. However, there is both ar1 and ar2 for stereo output.</p> <p>xamp -- the amplitude of the output signal.</p> <p>kcps -- the frequency of the output signal in cycles per second.</p> <p>loscil samples the ftable audio at a rate determined by kcps, then multiplies the result by xamp. The sampling increment for kcps is dependent on the table's base-note frequency ibas, and is automatically adjusted if the orchestra sr value differs from that at which the source was recorded. In this unit, ftable is always sampled with interpolation.</p> <p>If sampling reaches the sustain loop endpoint and looping is in effect, the point of sampling will be modified and loscil will continue reading from within that loop segment. Once the instrument has received a turnoff signal (from the score or from a MIDI noteoff event), the next sustain endpoint encountered will be ignored and sampling will continue towards the release loop end-point, or towards the last sample (henceforth to zeros).</p> <p>loscil is the basic unit for building a sampling synthesizer. Given a sufficient set of recorded piano tones, for example, this unit can resample them to simulate the missing tones. Locating the sound source nearest a desired pitch can be done via table lookup. Once a sampling instrument has begun, its turnoff point may be unpredictable and require an external release envelope; this is often done by gating the sampled audio with linenr, which will extend the duration of a turned-off instrument by a specific period while it implements a decay.</p> <p>If you want to loop the whole file, specify a looping mode in imod1 and do not enter any values for ibeg and iend.</p> <p> Note to Windows users</p> <p>Windows users typically use back-slashes, \u201c\\\u201d, when specifying the paths of their files. As an example, a Windows user might use the path \u201cc:\\music\\samples\\loop001.wav\u201d. This is problematic because back-slashes are normally used to specify special characters.</p> <p>To correctly specify this path in Csound, one may alternately:</p> <ul> <li>Use forward slashes: c:/music/samples/loop001.wav</li> <li>Use back-slash special characters, \u201c\\\\\u201d: c:\\\\music\\\\samples\\\\loop001.wav</li> </ul> <p> Note</p> <p>This is mono loscil: <pre><code>a1 loscil_ 10000, 1, 1, 1 ,1\n</code></pre> ...and this is stereo loscil: <pre><code>a1, a2 loscil_ 10000, 1, 1, 1 ,1\n</code></pre></p>"},{"location":"opcodes/loscil/#examples","title":"Examples","text":"<p>Here is an example of the loscil opcode. It uses the files loscil.csd, drumsMlp.wav and drumsSlp.wav.</p> Example of the loscil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 20222\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; loscil makes use of embedded loop points in wav\n\nichnls = ftchnls(p4)\nprints  \"\\nnumber of channels = %d\\n\\n\", ichnls\n\nif (ichnls == 1) then                   ; sample is played 2 x faster\n   asigL loscil .8, 1.5, p4, 1          ; sample loops between 1 and end loop point at 2 secs. in sample\n   asigR =      asigL\nelseif (ichnls == 2) then               ; sample is played at half speed\n   asigL, asigR loscil .8, .5, p4, 1    ; sample loops between 2 and end loop point at 3 secs. in sample\nelse                                    ; safety precaution if not mono or stereo\n   asigL = 0\n   asigR = 0\nendif\n        outs asigL, asigR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\nf 2 0 0 1 \"drumsSlp.wav\" 0 0 0\n\ni 1 0 7 1   ;mono file\ni 1 7 12 2  ;stereo file\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loscil/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/loscil/#credits","title":"Credits","text":"<p>Note about the mono/stereo difference was contributed by Rasmus Ekman.</p>"},{"location":"opcodes/loscil3/","title":"Loscil3","text":""},{"location":"opcodes/loscil3/#loscil3","title":"loscil3","text":"<p>Read sampled sound from a table using cubic interpolation.</p> <p>Reading with optional sustain and release looping, using cubic interpolation. A version that outputs the exact table position (phase) corresponding to the output sample is provided as an alternative opcode.</p>"},{"location":"opcodes/loscil3/#syntax","title":"Syntax","text":"<pre><code>ar1 [,ar2] loscil3 xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \\\n                   [, imod2] [, ibeg2] [, iend2]\naph, ar1 [,ar2] loscil3phs xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] \\\n                           [, iend1] [, imod2] [, ibeg2] [, iend2]\n</code></pre>"},{"location":"opcodes/loscil3/#initialization","title":"Initialization","text":"<p>ifn -- function table number, typically denoting an sampled sound segment with prescribed looping points loaded using GEN01. The source file may be mono or stereo.</p> <p>ibas (optional) -- base frequency in Hz of the recorded sound. This optionally overrides the frequency given in the audio file, but is required if the file did not contain one. The default value is 261.626 Hz, i.e. middle C. (New in Csound 4.03). If this value is not known or not present, use 1 here and in kcps.</p> <p>imod1, imod2 (optional, default=-1) -- play modes for the sustain and release loops. A value of 1 denotes normal looping, 2 denotes forward &amp; backward looping, 0 denotes no looping. The default value (-1) will defer to the mode and the looping points given in the source file. Make sure you select an appropriate mode if the file does not contain this information.</p> <p>ibeg1, iend1, ibeg2, iend2 (optional, dependent on mod1, mod2) -- begin and end points of the sustain and release loops. These are measured in sample frames (a set of samples with the same timestamp, one for each channel. Mono: 1 frame = 1 sample. Stereo: 1 frame = 2 samples etc.) from the beginning of the file, so will look the same whether the sound segment is monaural or stereo.  If no loop points are specified, and a looping mode (imod1, imod2) is given, the file will be looped for the whole length.</p>"},{"location":"opcodes/loscil3/#performance","title":"Performance","text":"<p>aph -- the normalised table position corresponding to the output sample (loscil3phs only).</p> <p>ar1, ar2 -- the output at audio-rate. There is just ar1 for mono output. However, there is both ar1 and ar2 for stereo output.</p> <p>xamp -- the amplitude of the output signal.</p> <p>kcps -- the frequency of the output signal in cycles per second.</p> <p>loscil3 is identical to loscil except that it uses cubic interpolation. New in Csound version 3.50.</p> <p> Note to Windows users</p> <p>Windows users typically use back-slashes, \u201c\\\u201d, when specifying the paths of their files. As an example, a Windows user might use the path \u201cc:\\music\\samples\\loop001.wav\u201d. This is problematic because back-slashes are normally used to specify special characters.</p> <p>To correctly specify this path in Csound, one may alternately:</p> <ul> <li>Use forward slashes: c:/music/samples/loop001.wav</li> <li>Use back-slash special characters, \u201c\\\\\u201d: c:\\\\music\\\\samples\\\\loop001.wav</li> </ul> <p> Note</p> <p>This is mono loscil3: <pre><code>a1 loscil3_ 10000, 1, 1, 1, 1\n</code></pre> ...and this is stereo loscil3: <pre><code>a1, a2 loscil3_ 10000, 1, 1, 1, 1\n</code></pre></p>"},{"location":"opcodes/loscil3/#examples","title":"Examples","text":"<p>Here is an example of the loscil3 opcode. It uses the file loscil3.csd, drumsMlp.wav and drumsSlp.wav.</p> Example of the loscil3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loscil3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; loscil makes use of embedded loop points in wav\n\nichnls = ftchnls(p4)\nprints  \"\\nnumber of channels = %d\\n\\n\", ichnls\n\nif (ichnls == 1) then\n   asigL loscil3 .8, 1, p4, 1           ; sample loops between 1 and end loop point at 2 secs.\n   asigR =      asigL\nelseif (ichnls == 2) then\n   asigL, asigR loscil3 .8, 1, p4, 1    ; sample loops between 2 and end loop point at 3 secs.\nelse                                    ; safety precaution if not mono or stereo\n   asigL = 0\n   asigR = 0\nendif\n        outs asigL, asigR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\nf 2 0 0 1 \"drumsSlp.wav\" 0 0 0\n\ni 1 0 7 1   ;mono file\ni 1 7 12 2  ;stereo file\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loscil3/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/loscil3/#credits","title":"Credits","text":"<p>Note about the mono/stereo difference was contributed by Rasmus Ekman.</p>"},{"location":"opcodes/loscilx/","title":"Loscilx","text":""},{"location":"opcodes/loscilx/#loscilx","title":"loscilx","text":"<p>Read sampled sound (up to 16 channels) from a table, with optional sustain and release looping.</p>"},{"location":"opcodes/loscilx/#syntax","title":"Syntax","text":"<pre><code>ar1 [, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \\\nar15, ar16] loscilx xamp, kcps, ifn \\\n                    [, iwsize, ibas, istrt, imod, ibeg, iend]\nar[] loscilx xamp, kcps, ifn \\\n             [, iwsize, ibas, istrt, imod, ibeg, iend]\n</code></pre>"},{"location":"opcodes/loscilx/#initialization","title":"Initialization","text":"<p>ifn -- function table number, typically denoting an sampled sound segment with prescribed looping points loaded using GEN01. The source file may have up to 16 channels.</p> <p>iwsize (optional) -- window size used in interpolation. iwsize (optional, defaults to zero) -- interpolation window size, in samples. Can be one of the following:</p> <ul> <li>1: round to nearest sample (no interpolation, for kpitch=1)</li> <li>2: linear interpolation</li> <li>4: cubic interpolation</li> <li>&gt;= 8: iwsize point sinc interpolation with anti-aliasing (slow)</li> </ul> <p>Zero or negative values select the default, which is cubic interpolation.</p> <p>ibas (optional) -- base frequency in Hz of the recorded sound. This optionally overrides the frequency given in the audio file, but is required if the file did not contain one. The default value is 261.626 Hz, i.e. middle C. (New in Csound 4.03). If this value is not known or not present, use 1 here and in kcps.</p> <p>istrt (optional, default 0) -- Frame to start reading the data.  If this is not an integer the the data is interpolated (see iwsize).</p> <p>imod (optional, default -1) --  play mode for the sustain and release loops. A value of 1 denotes normal looping, 2 denotes forward &amp; backward looping, 0 denotes no looping. The default value (-1) will defer to the mode and the looping points given in the source file. Make sure you select an appropriate mode if the file does not contain this information.</p> <p>ibeg, iend (optional, depending on imod) -- begin and end points of the sustain and release loops. These are measured in sample frames from the beginning of the file. If no loop points are specified, and a looping mode (imod is given), the file will be looped for the whole length.</p>"},{"location":"opcodes/loscilx/#performance","title":"Performance","text":"<p>ar1, ar2, ... ar[] -- the output at audio-rate. The number of outputs must match the number of channels in the sample file.</p> <p>xamp -- the amplitude of the output signal.</p> <p>kcps -- the factor to read the file.  For example, a value of 1 has no pitch change, 1.5 is up a fifth and 2 an octave.</p> <p>loscilx samples the ftable audio at a rate determined by kcps, then multiplies the result by xamp. The sampling increment for kcps is dependent on the table's base-note frequency ibas, and is automatically adjusted if the orchestra sr value differs from that at which the source was recorded. In this unit, ftable is always sampled with interpolation.</p> <p>If sampling reaches the sustain loop endpoint and looping is in effect, the point of sampling will be modified and loscil will continue reading from within that loop segment. Once the instrument has received a turnoff signal (from the score or from a MIDI noteoff event), the next sustain endpoint encountered will be ignored and sampling will continue towards the release loop end-point, or towards the last sample (henceforth to zeros).</p> <p>If you want to loop the whole file, specify a looping mode in imod and do not enter any values for ibeg and iend.</p>"},{"location":"opcodes/loscilx/#examples","title":"Examples","text":"<p>Here is an example of the loscilx opcode. It uses the files loscilx.csd and drumsSlp.wav.</p> Example of the loscilx opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o loscilx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n;  by Istvan Varga 2006 and Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngS_loop = \"drumsSlp.wav\"\ngisr filesr gS_loop\ngilength filelen gS_loop\ngibeats = 16 \ngi_sampleleft ftgen 1, 0, 0, 1, gS_loop, 0, 4, 0\n\ninstr 1\n    idur = p3\n    iamp = p4\n    ibeat = p5\n    itune = p6\n    ipos = ibeat / gibeats * gilength * gisr\n\n    aenv linseg iamp, idur - 0.01, iamp, 0.01, 0\n    a1, a2 loscilx aenv, itune, 1, 0, 1, ipos, 0    ; in this case stereo file\n    outs a1, a2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nt 0 170\n\n; Measure 1\ni 1 0.0 0.5 0.707 2 1\ni 1 1.0 0.5 0.707 1 1\ni 1 2.5 0.5 0.707 0 1\ni 1 3.0 0.5 0.707 1 .8\n\n; Measure 2\ni 1 4.0 0.5 0.707 0 1\ni 1 5.0 0.5 0.707 1 1\ni 1 6.5 0.5 0.707 0 1\ni 1 7.0 0.5 0.707 1 1\n\n; Measure 3\ni 1 8.0  0.5 0.707 0 1\ni 1 9.0  0.5 0.707 1 1\ni 1 10.5 0.5 0.707 0 1\ni 1 11.0 0.5 0.707 1 1\n\n; Measure 4\ni 1 12.0 0.5 0.707 0 1\ni 1 13.0 0.5 0.707 1 1\ni 1 14.5 0.5 0.707 0 1\ni 1 15.0 0.5 0.707 2 .8\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/loscilx/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/loscilx/#credits","title":"Credits","text":"<p>Written by Istvan Varga.</p> <p>2006</p> <p>New in Csound 5.03</p> <p>Array version new in Csound 6.13 (February 2019)</p>"},{"location":"opcodes/lowpass2/","title":"Lowpass2","text":""},{"location":"opcodes/lowpass2/#lowpass2","title":"lowpass2","text":"<p>A resonant second-order lowpass filter.</p>"},{"location":"opcodes/lowpass2/#syntax","title":"Syntax","text":"<pre><code>ares lowpass2 asig, kcf, kq [, iskip]\n</code></pre>"},{"location":"opcodes/lowpass2/#initialization","title":"Initialization","text":"<p>iskip -- initial disposition of internal data space. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/lowpass2/#performance","title":"Performance","text":"<p>asig -- input signal to be filtered</p> <p>kcf -- cutoff or resonant frequency of the filter, measured in Hz</p> <p>kq -- Q of the filter, defined, for bandpass filters, as bandwidth/cutoff. kq should be between 1 and 500</p> <p>lowpass2 is a second order IIR lowpass filter, with k-rate controls for cutoff frequency (kcf) and Q (kq). As kq is increased, a resonant peak forms around the cutoff frequency, transforming the lowpass filter response into a response that is similar to a bandpass filter, but with more low frequency energy. This corresponds to an increase in the magnitude and \"sharpness\" of the resonant peak. For high values of kq, a scaling function such as balance may be required. In practice, this allows for the simulation of the voltage-controlled filters of analog synthesizers, or for the creation of a pitch of constant amplitude while filtering white noise.</p>"},{"location":"opcodes/lowpass2/#examples","title":"Examples","text":"<p>Here is an example of the lowpass2 opcode. It uses the file lowpass2.csd.</p> Example of the lowpass2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n;-o lpf18.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Sean Costello\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidur    = p3\nifreq   = p4\niamp    = p5 \niharms  = (sr*.4) / ifreq\nasig    gbuzz .3, ifreq, iharms, 1, .9, 1           ; Sawtooth-like waveform\nkfreq   linseg 1, idur * 0.5, 5000, idur * 0.5, 1   ; Envelope to control filter cutoff\nafilt   lowpass2 asig,kfreq, 30\nkenv    linseg 0, .1, iamp, idur -.2, iamp, .1, 0   ; Simple amplitude envelope\nouts    afilt * kenv, afilt * kenv\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 9 1 1 .25\n;       frq     amp\ni1 0 5  100     .15\ni1 5 5  200     .12\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lowpass2/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/lowpass2/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington August 1999</p> <p>New in Csound version 4.0</p>"},{"location":"opcodes/lowres/","title":"Lowres","text":""},{"location":"opcodes/lowres/#lowres","title":"lowres","text":"<p>Another resonant lowpass filter.</p>"},{"location":"opcodes/lowres/#syntax","title":"Syntax","text":"<pre><code>ares lowres asig, xcutoff, xresonance [, iskip]\n</code></pre>"},{"location":"opcodes/lowres/#initialization","title":"Initialization","text":"<p>iskip -- initial disposition of internal data space. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/lowres/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xcutoff -- filter cutoff frequency point</p> <p>xresonance -- resonance amount</p> <p>lowres is a resonant lowpass filter derived from a Hans Mikelson orchestra. This implementation is much faster than implementing it in Csound language, and it allows kr lower than sr. xcutoff is not in Hz and xresonance is not in dB, so experiment for the finding best results.</p>"},{"location":"opcodes/lowres/#examples","title":"Examples","text":"<p>Here is an example of the lowres opcode. It uses the file lowres.csd.</p> Example of the lowres opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lowres.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkres = p4\nasig vco .2, 220, 1             ;sawtooth\n\nkcut line 1000, p3, 10          ;note: kcut is not in Hz\nas   lowres asig, kcut, kres    ;note: kres is not in dB\naout balance as, asig           ;avoid very loud sounds\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; a sine\nf 1 0 16384 10 1\n\ni 1 0 4 3\ni 1 + 4 30\ni 1 + 4 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lowres/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/lowres/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado (adapted by John ffitch) Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/lowresx/","title":"Lowresx","text":""},{"location":"opcodes/lowresx/#lowresx","title":"lowresx","text":"<p>Simulates layers of serially connected resonant lowpass filters.</p>"},{"location":"opcodes/lowresx/#syntax","title":"Syntax","text":"<pre><code>ares lowresx asig, xcutoff, xresonance [, inumlayer] [, iskip]\n</code></pre>"},{"location":"opcodes/lowresx/#initialization","title":"Initialization","text":"<p>inumlayer -- number of elements in a lowresx stack. Default value is 4. There is no maximum.</p> <p>iskip -- initial disposition of internal data space. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/lowresx/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xcutoff -- filter cutoff frequency point</p> <p>xresonance -- resonance amount</p> <p>lowresx is equivalent to more layer of lowres with the same arguments serially connected. Using a stack of a larger number of filters allows a sharper cutoff. This is faster than using a larger number of instances of lowres in a Csound orchestra because only one initialization and k cycle are needed at time and the audio loop falls entirely inside the cache memory of processor. Based on an orchestra by Hans Mikelson</p>"},{"location":"opcodes/lowresx/#examples","title":"Examples","text":"<p>Here is an example of the lowresx opcode. It uses the file lowresx.csd.</p> Example of the lowresx opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lowresx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkres = p4\ninumlayer = 4\n\nkenv linseg 0, p3*.1, 1, p3*.8, 1, p3*.1, 0     ;envelope\nasig vco .3 * kenv, 220, 1                      ;sawtooth\nkcut line 30, p3, 1000                          ;note: kcut is not in Hz\nalx  lowresx asig, kcut, kres, inumlayer        ;note: kres is not in dB\naout balance alx, asig                          ;avoid very loud sounds\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;sine wave\nf 1 0 16384 10 1\n\ni 1 0 5 1\ni 1 + 5 3\ni 1 + 5 20\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lowresx/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/lowresx/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado (adapted by John ffitch) Italy</p> <p>New in Csound version 3.49</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/lpf18/","title":"Lpf18","text":""},{"location":"opcodes/lpf18/#lpf18","title":"lpf18","text":"<p>A 3-pole sweepable resonant lowpass filter.</p>"},{"location":"opcodes/lpf18/#syntax","title":"Syntax","text":"<pre><code>ares lpf18 asig, xfco, xres, xdist [, iskip]\n</code></pre>"},{"location":"opcodes/lpf18/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/lpf18/#performance","title":"Performance","text":"<p>xfco -- the filter cutoff frequency in Hz. Should be in the range 0 to sr/2.</p> <p>xres -- the amount of resonance. Self-oscillation occurs when xres is approximately 1. Should usually be in the range 0 to 1, however, values slightly greater than 1 are possible for more sustained oscillation and an \u201coverdrive\u201d effect.</p> <p>xdist -- amount of distortion. kdist = 0 gives a clean output. xdist &gt; 0 adds tanh() distortion controlled by the filter parameters, in such a way that both low cutoff and high resonance increase the distortion amount. Some experimentation is encouraged.</p> <p>lpf18 is a digital emulation of a 3 pole (18 dB/oct.) lowpass filter capable of self-oscillation with a built-in distortion unit. It is really a 3-pole version of moogvcf, retuned, recalibrated and with some performance improvements. The tuning and feedback tables use no more than 6 adds and 6 multiplies per control rate. The distortion unit, itself, is based on a modified tanh function driven by the filter controls.</p> <p> Note</p> <p>Before version 6.04 this filter requires that the input signal be normalized to one.</p>"},{"location":"opcodes/lpf18/#examples","title":"Examples","text":"<p>Here is an example of the lpf18 opcode. It uses the file lpf18.csd.</p> Example of the lpf18 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n;-o lpf18.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder with help from Iain Duncan\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp init 1                         ; Note that its amplitude (kamp) ranges from 0 to 1.\nkcps init 440\nknh init 3\nifn = 1\nasine buzz kamp, kcps, knh, ifn     ; Generate a sine waveform.\nkfco line 300, p3, 3000             ; Filter the sine waveform.\nkres init 0.8                       ; Vary the cutoff frequency (kfco) from 300 to 3,000 Hz.\nkdist = p4\nivol = p5\naout lpf18 asine, kfco, kres, kdist\nouts aout * ivol, aout * ivol\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1    ; sine wave.\n\n; different distortion and volumes to compensate\ni 1 0 4     0.2         .8\ni 1 4.5 4   0.9         .7\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lpf18/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/lpf18/#credits","title":"Credits","text":"<p>Author: Josep M Comajuncosas Spain December 2000</p> <p>New in Csound version 4.10</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/lphasor/","title":"Lphasor","text":""},{"location":"opcodes/lphasor/#lphasor","title":"lphasor","text":"<p>Generates a table index for sample playback (e.g. with tablexkt).</p>"},{"location":"opcodes/lphasor/#syntax","title":"Syntax","text":"<pre><code>ares lphasor xtrns [, ilps] [, ilpe] [, imode] [, istrt] [, istor]\n</code></pre>"},{"location":"opcodes/lphasor/#initialization","title":"Initialization","text":"<p>ilps -- loop start.</p> <p>ilpe -- loop end (must be greater than ilps to enable looping).  The default value of ilps and ilpe is zero.</p> <p>imode (optional: default = 0) -- loop mode. Allowed values are:</p> <ul> <li>0: no loop</li> <li>1: forward loop</li> <li>2: backward loop</li> <li>3: forward-backward loop</li> </ul> <p>istrt (optional: default = 0) -- The initial output value (phase). It must be less than ilpe if looping is enabled, but is allowed to be greater than ilps (i.e. you can start playback in the middle of the loop).</p> <p>istor (optional: default = 0) -- skip initialization if set to any non-zero value.</p>"},{"location":"opcodes/lphasor/#performance","title":"Performance","text":"<p>ares -- a raw table index in samples (same unit for loop points). Can be used as index with the table opcodes.</p> <p>xtrns -- transpose factor, expressed as a playback ratio. ares is incremented by this value, and wraps around loop points. For example, 1.5 means a fifth above, 0.75 means fourth below. It is not allowed to be negative.</p>"},{"location":"opcodes/lphasor/#examples","title":"Examples","text":"<p>Here is an example of the lphasor opcode. It uses the file lphasor.csd.</p> Example of the lphasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o lphashor.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n; Example by Jonathan Murphy Dec 2006\n\n  sr        =  44100\n  ksmps     =  10\n  nchnls    =  1\n\n    instr 1\n\n  ifn       =  1   ; table number\n  ilen      =  nsamp(ifn)    ; return actual number of samples in table\n  itrns     =  1   ; no transposition\n  ilps      =  0   ; loop starts at index 0\n  ilpe      =  ilen ; ends at value returned by nsamp above\n  imode     =  3    ; loop forwards &amp; backwards\n  istrt     =  10000  ; commence playback at index 10000 samples\n  ; lphasor provides index into f1 \n  alphs     lphasor   itrns, ilps, ilpe, imode, istrt\n  atab      tablei    alphs, ifn\n            ; amplify signal\n  atab      =  atab * 10000\n\n            out       atab\n\n    endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf 1 0 262144 1 \"drumsMlp.wav\" 0 4 1\ni1 0 60\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lphasor/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lphasor/#credits","title":"Credits","text":"<p>Author: Istvan Varga January 2002 Example by: Jonathan Murphy</p> <p>New in version 4.18</p> <p>Updated April 2002 and November 2002 by Istvan Varga</p>"},{"location":"opcodes/lposcil/","title":"Lposcil","text":""},{"location":"opcodes/lposcil/#lposcil","title":"lposcil","text":"<p>Read sampled sound (mono or stereo) from a table, with looping, and high precision.</p>"},{"location":"opcodes/lposcil/#syntax","title":"Syntax","text":"<pre><code>ares lposcil kamp, kfreqratio, kloop, kend, ifn [, iphs]\n</code></pre>"},{"location":"opcodes/lposcil/#initialization","title":"Initialization","text":"<p>ifn -- function table number</p>"},{"location":"opcodes/lposcil/#performance","title":"Performance","text":"<p>kamp -- amplitude</p> <p>kfreqratio -- multiply factor of table frequency (for example: 1 = original frequency, 1.5 = a fifth up , .5 = an octave down)</p> <p>kloop -- start loop point (in samples)</p> <p>kend -- end loop point (in samples)</p> <p>lposcil (looping precise oscillator) allows varying at k-rate, the starting and ending point of a sample contained in a table (GEN01). This can be useful when reading a sampled loop of a wavetable, where repeat speed can be varied during the performance.</p>"},{"location":"opcodes/lposcil/#examples","title":"Examples","text":"<p>Here is an example of the lposcil opcode. It uses the file lposcil.csd.</p> Example of the lposcil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lposcil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 1.5     ; a fifth up\nkloop = 0       ; loop start time in samples\nkend  = 45000   ; loop end time in samples\n\nasig lposcil 1, kcps, kloop, kend, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Its table size is deferred,\n; and format taken from the soundfile header.\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\n\n; Play Instrument #1 for 6 seconds.\n; This will loop the drum pattern several times.\ni 1 0 6\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lposcil/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lposcil/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.52</p>"},{"location":"opcodes/lposcil3/","title":"Lposcil3","text":""},{"location":"opcodes/lposcil3/#lposcil3","title":"lposcil3","text":"<p>Read sampled sound (mono or stereo) from a table, with looping, and high precision.</p> <p>lposcil3 uses cubic interpolation.</p>"},{"location":"opcodes/lposcil3/#syntax","title":"Syntax","text":"<pre><code>ares lposcil3 kamp, kfreqratio, kloop, kend, ifn [, iphs]\n</code></pre>"},{"location":"opcodes/lposcil3/#initialization","title":"Initialization","text":"<p>ifn -- function table number</p>"},{"location":"opcodes/lposcil3/#performance","title":"Performance","text":"<p>kamp -- amplitude</p> <p>kfreqratio -- multiply factor of table frequency (for example: 1 = original frequency, 1.5 = a fifth up , .5 = an octave down)</p> <p>kloop -- start loop point (in samples)</p> <p>kend -- end loop point (in samples)</p> <p>lposcil3 (looping precise oscillator) allows varying at k-rate, the starting and ending point of a sample contained in a table (GEN01). This can be useful when reading a sampled loop of a wavetable, where repeat speed can be varied during the performance.</p>"},{"location":"opcodes/lposcil3/#examples","title":"Examples","text":"<p>Here is an example of the lposcil3 opcode. It uses the file lposcil3.csd.</p> Example of the lposcil3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lposcil3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 1.5                     ; a fifth up\nkloop = 0                       ; loop start time (in samples)\nkend line 45000, p3, 10000      ; vary loop end time (in samples)\n\nasig lposcil3 1, kcps, kloop, kend, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Its table size is deferred,\n; and format taken from the soundfile header.\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\n\n; Play Instrument #1 for 6 seconds.\n; This will loop the drum pattern several times.\ni 1 0 6\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lposcil3/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lposcil3/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.52</p>"},{"location":"opcodes/lposcila/","title":"Lposcila","text":""},{"location":"opcodes/lposcila/#lposcila","title":"lposcila","text":"<p>Read sampled sound from a table with looping and high precision.</p>"},{"location":"opcodes/lposcila/#syntax","title":"Syntax","text":"<pre><code>ar lposcila aamp, kfreqratio, kloop, kend, ift [,iphs]\n</code></pre>"},{"location":"opcodes/lposcila/#initialization","title":"Initialization","text":"<p>ift -- function table number</p> <p>iphs -- initial phase (in samples)</p>"},{"location":"opcodes/lposcila/#performance","title":"Performance","text":"<p>ar -- output signal</p> <p>aamp -- amplitude</p> <p>kfreqratio -- multiply factor of table frequency (for example: 1 = original frequency, 1.5 = a fifth up , .5 = an octave down)</p> <p>kloop -- start loop point (in samples)</p> <p>kend -- end loop point (in samples)</p> <p>lposcila is the same as lposcil, but has an audio-rate amplitude argument (instead of k-rate) to allow fast envelope transients.</p>"},{"location":"opcodes/lposcila/#examples","title":"Examples","text":"<p>Here is an example of the lposcila opcode. It uses the file lposcila.csd.</p> Example of the lposcila opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lposcila.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 1.3                                     ;a 3d up\nkloop = 0                                       ;loop start time in samples\nkend  = 10000                                   ;loop end time in samples\n\naenv expsega 0.01, 0.1, 1, 0.1, 0.5, 0.5, 0.01  ;envelope with fast and short segment\nasig lposcila aenv, kcps, kloop, kend, 1        ;use it for amplitude\n     outs asig*2, asig*2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Its table size is deferred,\n; and format taken from the soundfile header.\nf 1 0 0 1 \"drumsMlp.wav\" 0 0 0\n\n; Play Instrument #1 for 6 seconds.\n; This will loop the drum pattern several times.\ni 1 0 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lposcila/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lposcila/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/lposcilsa/","title":"Lposcilsa","text":""},{"location":"opcodes/lposcilsa/#lposcilsa","title":"lposcilsa","text":"<p>Read stereo sampled sound from a table with looping and high precision.</p>"},{"location":"opcodes/lposcilsa/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 lposcilsa aamp, kfreqratio, kloop, kend, ift [,iphs]\n</code></pre>"},{"location":"opcodes/lposcilsa/#initialization","title":"Initialization","text":"<p>ift -- function table number</p> <p>iphs -- initial phase (in samples)</p>"},{"location":"opcodes/lposcilsa/#performance","title":"Performance","text":"<p>ar1, ar2 -- output signal</p> <p>aamp -- amplitude</p> <p>kfreqratio -- multiply factor of table frequency (for example: 1 = original frequency, 1.5 = a fifth up , .5 = an octave down)</p> <p>kloop -- start loop point (in samples)</p> <p>kend -- end loop point (in samples)</p> <p>lposcilsa is the same as lposcila, but works with stereo files loaded with GEN01.</p>"},{"location":"opcodes/lposcilsa/#examples","title":"Examples","text":"<p>Here is an example of the lposcilsa opcode. It uses the file lposcilsa.csd.</p> Example of the lposcilsa opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lposcilsa.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 1.3                                     ;a 3th up\nkloop = 0                                       ;loop start time in samples\nkend  = p4                                      ;loop end time in samples\n\naenv expsega 0.01, 0.1, .8, 1, .3, 1.1, .42     ;envelope with fast and short segment\naL, aR lposcilsa aenv, kcps, kloop, kend, 1     ;use it for amplitude\n     outs aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; table size of stereo file is deferred,\n; and format taken from the soundfile header.\nf 1 0 0 1 \"drumsSlp.wav\" 0 0 0\n\ni 1 0 5 45000\ni 1 6 3 15000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lposcilsa/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lposcilsa/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/lposcilsa2/","title":"Lposcilsa2","text":""},{"location":"opcodes/lposcilsa2/#lposcilsa2","title":"lposcilsa2","text":"<p>Read stereo sampled sound from a table with looping and high precision.</p>"},{"location":"opcodes/lposcilsa2/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 lposcilsa2 aamp, kfreqratio, kloop, kend, ift [,iphs]\n</code></pre>"},{"location":"opcodes/lposcilsa2/#initialization","title":"Initialization","text":"<p>ift -- function table number.</p> <p>iphs -- initial phase (in samples).</p>"},{"location":"opcodes/lposcilsa2/#performance","title":"Performance","text":"<p>ar1, ar2 -- output signal.</p> <p>aamp -- amplitude.</p> <p>kfreqratio -- multiply factor of table frequency (for example: 1 = original frequency, 2 = an octave up). Only integers are allowed.</p> <p>kloop -- start loop point (in samples).</p> <p>kend -- end loop point (in samples).</p> <p>lposcilsa2 is the same as lposcilsa, but no interpolation is implemented and only works with integer kfreqratio values. Much faster than lposcilsa, it is mainly intended to be used with kfreqratio = 1, being in this case a fast substitute of soundin, since the soundfile must be entirely loaded in memory.</p>"},{"location":"opcodes/lposcilsa2/#examples","title":"Examples","text":"<p>Here is an example of the lposcilsa2 opcode. It uses the file lposcilsa2.csd.</p> Example of the lposcilsa2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lposcilsa2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps  = 1                                       ;only integers are allowed\nkloop = 0                                       ;loop start time in samples\nkend  = 45000                                   ;loop end time in samples\n\naenv expsega 0.01, 0.2*p3, .9, 0.1*p3, 0.2, 0.5*p3, 0.7 ;envelope\naL, aR lposcilsa2 aenv, kcps, kloop, kend, 1    ;use it for amplitude\n     outs aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Its table size is deferred,\n; and format taken from the soundfile header.\nf 1 0 0 1 \"drumsSlp.wav\" 0 0 0\n\n; This will loop the drum pattern several times.\ni 1 0 10.4\ni 1 11 5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lposcilsa2/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/lposcilsa2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/lpshold/","title":"Lpshold","text":""},{"location":"opcodes/lpshold/#lpshold","title":"lpshold","text":"<p>Generate control signal consisting of held segments.</p> <p>The segments are delimited by two or more specified points. The entire envelope is looped at kfreq rate. Each parameter can be varied at k-rate.</p>"},{"location":"opcodes/lpshold/#syntax","title":"Syntax","text":"<pre><code>ksig lpshold kfreq, ktrig, iphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\\n             [, kvalue2] [, ktime2] [...]\n</code></pre>"},{"location":"opcodes/lpshold/#performance","title":"Performance","text":"<p>ksig -- Output signal</p> <p>kfreq -- Repeat rate in Hz or fraction of Hz</p> <p>ktrig -- If non-zero, retriggers the envelope from start (see trigger opcode), before the envelope cycle is completed.</p> <p>iphase -- A vaue between 0 and 1 to say where to start the loop.  Zero, the commonest value, indicates the beginning.</p> <p>kvalue0...kvalueN -- Values of points</p> <p>ktime0...ktimeN -- Times between points; expressed in fractions of a cycle (see below). The final time designates a ramp between the final value and the first value.</p> <p>lpshold is similar to loopseg, but can generate only horizontal segments, i.e. holds values for each time interval placed between ktimeN and ktimeN+1. It can be useful, among other things, for melodic control, like old analog sequencers.</p>"},{"location":"opcodes/lpshold/#examples","title":"Examples","text":"<p>Here is an example of the lpshold opcode. It uses the file lpshold.csd.</p> Example of the lpshold opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o lpshold.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkfrq  init    p4  ; frequency of the loop \nifrac =       p5  ; fraction of frequency at which to force retrigger\nipan  =       p6  ; pan position\nktrig metro   kfrq * ifrac  ; trigger to force restart the loop\niphs  =       0   ; initial phase of the loop\n; a loop of midi note numbers:   note duration etc...\nknote lpshold kfrq, ktrig, iphs, 61,  0.0625,  60, 0.9375,   61, 1, 58, 1, \\\n63, 2, 65, 3\naenv  linseg 0,0.01,1,p3-0.11,1,0.1,0   ; amplitude envelope\nkrnd  rspline -0.05,0.05,0.5,1 ; random detune\nasig  gbuzz   0.2*aenv, cpsmidinn(knote+krnd), 30, 1, 0.5, 1 \n      outs    asig*ipan, asig*(1-ipan)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; cosine wave.\nf 1 0 16384 11 1\n\n; 3 layers of the loop are played, each at a different speed, \n; - with different retriggering rate, and pan location.\ni 1 0 60 0.5   [8/10] 0.5\ni 1 0 60 0.375 [8/11] 0.1\ni 1 0 60 0.25  [8/13] 0.9\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lpshold/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/lpshold/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.13</p>"},{"location":"opcodes/lpsholdp/","title":"Lpsholdp","text":""},{"location":"opcodes/lpsholdp/#lpsholdp","title":"lpsholdp","text":"<p>Control signals based on held segments.</p> <p>The segments are delimited by two or more specified points. The entire envelope can be looped at time-variant rate. Each segment coordinate can also be varied at k-rate.</p>"},{"location":"opcodes/lpsholdp/#syntax","title":"Syntax","text":"<pre><code>ksig lpsholdp  kphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \\\n               [, kvalue2] [, ktime2] [...]\n</code></pre>"},{"location":"opcodes/lpsholdp/#performance","title":"Performance","text":"<p>ksig - output signal</p> <p>kphase -- point of the sequence read, expressed as a fraction of a cycle (0 to 1)</p> <p>kvalue0...kvalueN -- Values of points</p> <p>ktime0...ktimeN -- Times between points; expressed in fractions of a cycle (see below). The final time designates a ramp between the final value and the first value.</p> <p>lpsholdp opcode is similar to lpshold; the only difference is that, instead of frequency,  a time-variant phase is required. If you use a phasor to get the phase value, you will have a behaviour identical to lpshold, but interesting results can be achieved when using phases having non-linear motions, making lpsholdp more powerful and general than lpshold.</p>"},{"location":"opcodes/lpsholdp/#examples","title":"Examples","text":"<p>Here is an example of the lpsholdp opcode. It uses the file lpsholdp.csd.</p> Example of the lpsholdp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o lpsholdp.wav -W ;;; for file output any platform\n\n; by Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n\ninstr 1\n\nkphase1 phasor 3\n\nkmodulation oscil 0.5, 0.01, 2\nkphase2 phasor 3+kmodulation\n\nkamp    linseg 0, 0.2, 1, p3-0.4, 1, 0.2, 0\nkfreq1  lpsholdp kphase1, cpspch(p4), 6, cpspch(p5), 10, cpspch(p6), 12\nkfreq2  lpsholdp kphase2, cpspch(p4), 6, cpspch(p5), 10, cpspch(p6), 12\n\na1 = poscil(kamp, kfreq1, 1)\na2 = poscil(kamp, kfreq2, 1)\n\noutch 1, a1\noutch 2, a2\nendin\n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\n\nf1 0 8192 10 1 0 1 0 1 0 1 0 1 0 1\nf2 0 4096 10 1 0 1 1 1\n\ni1 0 10 6.09 6.02 7.03\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lpsholdp/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/lpsholdp/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/lufs/","title":"Lufs","text":""},{"location":"opcodes/lufs/#lufs","title":"lufs","text":"<p>Momentary, Integrated and Short-Term Loudness meter in LUFS</p> <p>The opcodes performs an analysis of input audio according to ITU-R BS.1770-4 recommendation.</p>"},{"location":"opcodes/lufs/#syntax","title":"Syntax","text":"<pre><code>kmom, kint, kshort lufs kreset, ain1 [, ain2]\n</code></pre>"},{"location":"opcodes/lufs/#performance","title":"Performance","text":"<p>kreset -- reset input. It resets the value of the integrated loudness if kreset is not 0.</p> <p>ain1, ain2 -- input audio signal(s). Only mono and stereo are supported (see below)</p> <p>kmom -- momentary loudness in LUFS</p> <p>kint -- integrated loudness in LUFS</p> <p>kshort -- short-term loudness in LUFS</p> <p>The Momentary Loudness is calculated over 400 ms period and Short-Term Loudness is for 3 s period. Integrated Loudness is obtained by averaging the whole programm. The calculation algorithm is based on formulae from Matlab integratedLoudness code.</p> <p>ITU-R BS.1770-4 gives K-weigthing filters coefficients only for 48000 Hz, thus other sampling frequencies coefficients are calculated according to Brecht De Man code Only mono and stereo formats are supported due to rare usage of 5.1 format in the field of computer music. ITU-R BS.1770-4 standardizes only 1, 2 and 5.1 channels.</p> <p> Warning!</p> <p>ksmps should not be set to values higher than sr/10, i.e. 4410 @ sr = 44100 and higher.</p>"},{"location":"opcodes/lufs/#examples","title":"Examples","text":"<p>Here is an example of the lufs opcode. It uses the file lufs.csd.</p> Example of the lufs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=48000\nksmps=64\n0dbfs=1.0\nnchnls=2\n\ninstr 1\nktrig init 0\niamp = ampdbfs(-18.0)\na1 poscil iamp,1000,1\nkM,kI,kS lufs ktrig,a1,a1\nprintks \"M: %f, I: %f, S: %f LUFS\\n\", 0.3, k1, k2, k3\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\ni1 0 20\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/lufs/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/lufs/#credits","title":"Credits","text":"<p>By: Gleb Rogozinsky, Summer 2020</p> <p>New in version 6.15</p>"},{"location":"opcodes/mac/","title":"Mac","text":""},{"location":"opcodes/mac/#mac","title":"mac","text":"<p>Multiplies and accumulates a- and k-rate signals.</p>"},{"location":"opcodes/mac/#syntax","title":"Syntax","text":"<pre><code>ares mac ksig1, asig1 [, ksig2] [, asig2] [, ksig3] [, asig3] [...]\n</code></pre>"},{"location":"opcodes/mac/#performance","title":"Performance","text":"<p>ksig1, etc. -- k-rate input signals</p> <p>asig1, etc. -- a-rate input signals</p> <p>mac multiplies and accumulates a- and k-rate signals. It is equivalent to:</p> <pre><code>ares = asig1*ksig1 + asig2*ksig2 + asig3*ksig3 + ...\n</code></pre>"},{"location":"opcodes/mac/#examples","title":"Examples","text":"<p>Here is an example of the mac opcode. It uses the file mac.csd. It is written for *NIX systems, and will generate errors on Windows.</p> Example of the mac opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mac.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;4 band equalizer\n\nklow =  p4      ;low gain1\nklmid = p5      ;low gain2      \nkmidh = p6      ;high gain1\nkhigh = p7      ;high gain2\nifn  =  p8      ;table\n\nilc1 table 0, ifn       ;low freqency range\nilc2 table 1, ifn       ;low-mid\nihc1 table 2, ifn       ;mid-high\nihc2 table 3, ifn       ;high\n\nasig    diskin2  \"fox.wav\", 1\nalow1   butterlp asig, ilc1             ;lowpass 1\nalmid   butterlp asig, ilc2             ;lowpass 2\namidh   butterhp asig, ihc1             ;highpass 1\nahigh   butterhp asig, ihc2             ;highpass 2\naout    mac      klow, alow1, klmid, almid, kmidh, amidh, khigh, ahigh\n        outs     aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0  4 -2 150 300 600  5000\nf2 0  4 -2 75  500 1000 10000\nf3 0  4 -2 200 700 1500 3000\n\n;          low lowmid midhigh high table                \ni 1 0  2.8  2    1      1      1     1  \ni 1 3  2.8  2    3      1      1     2 \ni 1 6  2.8  2    1      2      3     3 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mac/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/mac/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist, Ltd. Bath, UK May 1999</p> <p>New in Csound version 3.54</p>"},{"location":"opcodes/maca/","title":"Maca","text":""},{"location":"opcodes/maca/#maca","title":"maca","text":"<p>Multiply and accumulate a-rate signals only.</p>"},{"location":"opcodes/maca/#syntax","title":"Syntax","text":"<pre><code>ares maca asig1 , asig2 [, asig3] [, asig4] [, asig5] [...]\n</code></pre>"},{"location":"opcodes/maca/#performance","title":"Performance","text":"<p>asig1, asig2, ... -- a-rate input signals</p> <p>maca multiplies and accumulates a-rate signals only. It is equivalent to:</p> <pre><code>ares = asig1*asig2 + asig3*asig4 + asig5*asig6 + ...\n</code></pre>"},{"location":"opcodes/maca/#examples","title":"Examples","text":"<p>Here is an example of the maca opcode. It uses the file maca.csd. It is written for *NIX systems, and will generate errors on Windows.</p> Example of the maca opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mac.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;4 band equalizer\n\nklow =  p4      ;low gain1\naenv1   oscil   0.2, 1, 4\naenv1 = aenv1 + klow\nklmid = p5      ;low gain2      \naenv2   oscil   0.21, 1.1, 4\naenv2 = aenv2 + klmid\nkmidh = p6      ;high gain1\naenv3   oscil   0.19, 1.2, 4\naenv3 = aenv3 + kmidh\nkhigh = p7      ;high gain2\naenv4   oscil   0.18, 1.3, 4\naenv4 = aenv4 + khigh\n\nifn  =  p8      ;table\n\nilc1 table 0, ifn       ;low freqency range\nilc2 table 1, ifn       ;low-mid\nihc1 table 2, ifn       ;mid-high\nihc2 table 3, ifn       ;high\n\nasig    diskin2  \"fox.wav\", 1\nalow1   butterlp asig, ilc1             ;lowpass 1\nalmid   butterlp asig, ilc2             ;lowpass 2\namidh   butterhp asig, ihc1             ;highpass 1\nahigh   butterhp asig, ihc2             ;highpass 2\naout    maca     aenv1, alow1, aenv2, almid, aenv3, amidh, aenv4, ahigh\n        outs     aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0  4 -2 150 300 600  5000\nf2 0  4 -2 75  500 1000 10000\nf3 0  4 -2 200 700 1500 3000\nf4 0  4096 10 1\n\n;          low lowmid midhigh high table                \ni 1 0  2.8  2    1      1      1     1  \ni 1 3  2.8  2    3      1      1     2 \ni 1 6  2.8  2    1      2      3     3 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maca/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/maca/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist, Ltd. Bath, UK May 1999</p> <p>New in Csound version 3.54</p>"},{"location":"opcodes/madsr/","title":"Madsr","text":""},{"location":"opcodes/madsr/#madsr","title":"madsr","text":"<p>Calculates the classical ADSR envelope using the linsegr mechanism.</p>"},{"location":"opcodes/madsr/#syntax","title":"Syntax","text":"<pre><code>ares madsr iatt, idec, islev, irel [, idel] [, ireltim]\nkres madsr iatt, idec, islev, irel [, idel] [, ireltim]\n</code></pre>"},{"location":"opcodes/madsr/#initialization","title":"Initialization","text":"<p>iatt -- duration of attack phase</p> <p>idec -- duration of decay</p> <p>islev -- level for sustain phase</p> <p>irel -- duration of release phase.</p> <p>idel -- period of zero before the envelope starts</p> <p>ireltim (optional, default=-1) -- Control release time after receiving a MIDI noteoff event. If less than zero, the longest release time given in the current instrument is used. If zero or more, the given value will be used for release time. Its default value is -1. (New in Csound 3.59 - not yet properly tested)</p> <p>Please note that the release time was restricted to 32767/kr seconds in versions prior to 5.00; since then it has been (2<sup>31</sup>-1)/kr.</p>"},{"location":"opcodes/madsr/#performance","title":"Performance","text":"<p>The envelope is in the range 0 to 1 and may need to be scaled further. The envelope may be described as:</p> Picture of an ADSR envelope. <p>The length of the sustain is calculated from the length of the note. This means adsr is not suitable for use with MIDI events. The opcode madsr uses the linsegr mechanism, and so can be used in MIDI applications.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linsegr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using madsr, since the time is extended automatically.</p> <p> Note</p> <p>Times for iatt, idec and irel cannot be 0. If 0 is used, no envelope is generated. Use a very small value like 0.0001 if you need an instantaneous attack, decay or release.</p>"},{"location":"opcodes/madsr/#examples","title":"Examples","text":"<p>Here is an example of the madsr opcode. It uses the file madsr.csd.</p> Example of the madsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o madsr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Iain McCurdy */\n; Initialize the global variables.\nsr = 44100\nkr = 441\nksmps = 100\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Attack time.\n  iattack = 0.5\n  ; Decay time.\n  idecay = 0\n  ; Sustain level.\n  isustain = 1\n  ; Release time.\n  irelease = 0.5\n  aenv madsr iattack, idecay, isustain, irelease\n\n  a1 oscili 10000, 440, 1\n  out a1*aenv\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Iain McCurdy */\n; Table #1, a sine wave.\nf 1 0 1024 10 1\n\n; Leave the score running for 6 seconds.\nf 0 6\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the madsr opcode, using midi input. It uses the file madsr-2.csd.</p> second example of the madsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -m0  --midi-key=4 --midi-velocity-amp=5 ; treat p4 and p5 as midi data\n; For Non-realtime ouput leave only the line below:\n; -o madsr-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel - 2021\n\ninstr 1                               ; use score and treat p4 and p5 as midi data\nicps    = cpsmidinn(p4)               ; take midi note (p4) from score\niveloc  ampmidid p5, 92               ; take velocity (p5) from score\n;               att, dec, lvl, release\nkenv    madsr  .001, .2,   1,    p6 \nprints  \"duration of note (%ds) + release (%2.1fs)\\\\n\", p3, p6                ; \nasig    vco2    iveloc, icps\nasig    butlp   asig, 2000 \n        outs    asig*kenv, asig*kenv\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;      note vel release \ns\ni 1 0 1 62  60  0\ni 1 2 1 62  80  0       \ni 1 4 1 62  100 0       \ni 1 6 1 58  50  0\ns\ni 1 1 1 62  60  0\ni 1 3 1 62  80  .5      \ni 1 5 1 62  100 1.5     \ni 1 7 1 58  50  3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the adsr-group, comparing the different adsr opcodes. It uses the file adsr-group.csd.</p> Example of the adsr group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsr-group.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel - 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; both amplitude and filter use same ADSR curves \ninstr 1                  \nkenv    adsr    .01, .5, .5, p4         ; linear envelope \nasig    vco2    kenv, 110                       ; A+D+S+R = p3  \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig       \nendin\n\ninstr 2 ; midi behavior                  \nkenv    madsr   .01, .5, .5, p4         ; linear envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage                \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled  \n                outs    asig, asig                      \nendin\n\ninstr 3                  \nkenv    xadsr   .01, .5 , .5, p4    ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S+R = p3   \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig\nendin\n\ninstr 4 ; midi behavior          \nkenv    mxadsr  .01, .5 , .5, p4        ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage         \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig                      \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 1 2 .01      ; same notes for everyone!\ni1 5 . .5\ni1 9 . 1.5\ns\ni2 1 2 .01\ni2 5 . .5\ni2 9 . 1.5\ns\ni3 1 2 .01\ni3 5 . .5\ni3 9 . 1.5\ns\ni4 1 2 .01\ni4 5 . .5\ni4 9 . 1.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/madsr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/madsr/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>November 2002. Thanks to Rasmus Ekman, added documentation for the ireltim parameter.</p> <p>December 2002. Thanks to Iain McCurdy, added an example.</p> <p>December 2002. Thanks to Istvan Varga, added documentation about the maximum release time.</p> <p>New in Csound version 3.49.</p>"},{"location":"opcodes/mandel/","title":"Mandel","text":""},{"location":"opcodes/mandel/#mandel","title":"mandel","text":"<p>Mandelbrot set</p> <p>Returns the number of iterations corresponding to a given point of complex plane by applying the Mandelbrot set formula.</p>"},{"location":"opcodes/mandel/#syntax","title":"Syntax","text":"<pre><code>kiter, koutrig mandel  ktrig, kx, ky, kmaxIter\n</code></pre>"},{"location":"opcodes/mandel/#performance","title":"Performance","text":"<p>kiter - number of iterations</p> <p>koutrig - output trigger signal</p> <p>ktrig - input trigger signal</p> <p>kx, ky - coordinates of a given point belonging to the complex plane</p> <p>kmaxIter - maximum iterations allowed</p> <p>mandel is an opcode that allows the use of the Mandelbrot set formula to generate an output that can be applied to any musical (or non-musical) parameter. It has two output arguments: kiter, that contains the iteration number of a given point, and koutrig, that generates a trigger 'bang' each time kiter changes. A new number of iterations is evaluated only when ktrig is set to a non-zero value. The coordinates of the complex plane are set in kx and ky, while kmaxIter contains the maximum number of iterations. Output values, which are integer numbers, can be mapped in any sorts of ways by the composer.</p>"},{"location":"opcodes/mandel/#examples","title":"Examples","text":"<p>Here is an example of the mandel opcode. It uses the file mandel.csd.</p> Example of the mandel opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mandel.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; FM instrument\n\nksig oscil 1, 4                                 ; create a trigger signal\nktrig trigger ksig, 0, 2\n\nkx linseg p8, p3, p9                            ; in the range -1 1\nky linseg p6, p3, p7                            ; in the range -1 1\nkmaxIter linseg p4, p3*0.5, p5, p3*0.5, p4\n\nkiter, koutrig mandel  ktrig, kx, ky, kmaxIter\nprintks2 \"maximum iterations =  %d\\n\", kiter    ; show them\n\nasig foscili 0.3, 1, 440, kiter, 10, 1          ; use number of iterations to modulate\nouts asig, asig\n\nendin\n\ninstr 2     ; grain instrument\n\nksig oscil 1, 100                               ; create a trigger signal\nktrig trigger ksig, 0, 2\n\nkx linseg p8, p3, p9                            ; in the range -1 1\nky linseg p6, p3, p7                            ; in the range -1 1\nkmaxIter linseg p4, p3*0.5, p5, p3*0.5, p4\n\nkiter, koutrig mandel  ktrig, kx, ky, kmaxIter\nprintks2 \"maximum iterations =  %d\\n\", kiter    ; show them\n\ninsnd   = 1 \nibasfrq = 44100 / ftlen(insnd)                  ; use original sample rate of insnd file \n\nkamp   = .8\nkpitch = 1\nkdens  = kiter\nkaoff  line 0, p3, .1\nkpoff  = 0\nkgdur  =.002\nimaxgdur =  .5 \n\nasig  grain kamp, kpitch, kdens, kaoff, kpoff, kgdur, insnd, 1, imaxgdur, 0.0 \nouts asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 1 0 1   ; sinoid wave (instr 1)\nf5  0 512  20 2         ; Hanning window (instr 2)\n\n;           start   end     X1  X2  Y1  Y2 \ni 1 0 10    110     2000    -1  1   -1  1\n\n;           start   end     X1  X2  Y1  Y2    \ni 2 11 10   120      1       0  1   -1  0     \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Two musical examples featuring the mandel opcode: Mandel_Daughtrey.csd by Scott Daughtrey, and Mandel_Gogins.csd by Michael Gogins.</p>"},{"location":"opcodes/mandel/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/mandel/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/mandol/","title":"Mandol","text":""},{"location":"opcodes/mandol/#mandol","title":"mandol","text":"<p>An emulation of a mandolin.</p>"},{"location":"opcodes/mandol/#syntax","title":"Syntax","text":"<pre><code>ares mandol kamp, kfreq, kpluck, kdetune, kgain, ksize \\\n            [, ifn] [, iminfreq]\n</code></pre>"},{"location":"opcodes/mandol/#initialization","title":"Initialization","text":"<p>ifn -- table number containing the pluck wave form. The file mandpluk.aiff is suitable for this. It is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p> <p>iminfreq (optional, default=0) -- Lowest frequency to be played on the note. If it is omitted it is taken to be the same as the initial kfreq.</p>"},{"location":"opcodes/mandol/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kpluck -- The pluck position, in range 0 to 1. Suggest 0.4.</p> <p>_kdetune _ -- The proportional detuning between the two strings. Suggested range 0.9 to 1.</p> <p>kgain -- the loop gain of the model, in the range 0.97 to 1.</p> <p>ksize -- The size of the body of the mandolin. Range 0 to 2.</p>"},{"location":"opcodes/mandol/#examples","title":"Examples","text":"<p>Here is an example of the mandol opcode. It uses the file mandol.csd, and mandpluk.aiff.</p> Example of the mandol opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mandol.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp    = p4\nksize   = p5\nkdetune = p6\nasig mandol kamp, 880, .4, kdetune, 0.99, ksize, 1, 220\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; \"mandpluk.aiff\" audio file\nf 1 0 8192 1 \"mandpluk.aiff\" 0 0 0\n\ni 1 .5 1  1  2 .99\ni 1 +  1 .5  1 .99      ;lower volume to compensate\ni 1 +  3 .3 .3 .99      ;lower volume to compensate\n\ni 1 4  1  1  2 .39      ;change detune value\ni 1 +  1 .5  1 .39\ni 1 +  3 .3 .3 .39\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mandol/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/mandol/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/maparray/","title":"Maparray","text":""},{"location":"opcodes/maparray/#maparray","title":"maparray","text":"<p>Apply a function of one argument to every element of a vector (one-dimensional k-rate array).</p>"},{"location":"opcodes/maparray/#syntax","title":"Syntax","text":"<pre><code>karray maparray kinarray, String\nkarray maparray_i kinarray, String\n</code></pre>"},{"location":"opcodes/maparray/#initialization","title":"Initialization","text":"<p>String -- a string that names an opcode function, at i-rate for maparray_i or k-rate for maparray.</p>"},{"location":"opcodes/maparray/#performance","title":"Performance","text":"<p>karray --  array for answers.</p> <p>kinarray --  array for arguments to the function.</p>"},{"location":"opcodes/maparray/#examples","title":"Examples","text":"<p>Here is an example of the maparray opcode. It uses the file maparray.csd.</p> Example of the maparray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n;create an array and fill with numbers\nkArrSrc[] fillarray 1.01, 2.02, 3.03, 4.05, 5.08, 6.13, 7.21\n\n;print source array\n        printf  \"%s\", 1, \"\\nSource array:\\n\"\nkndx    =       0\n  until kndx == lenarray(kArrSrc) do\n        printf  \"kArrSrc[%d] = %f\\n\", kndx+1, kndx, kArrSrc[kndx]\nkndx    +=      1\n  od\n\n;create an empty array for the results\nkArrRes[] init  7\n\n;apply the sqrt() function to each element\nkArrRes maparray kArrSrc, \"sqrt\"\n\n;print the result\n        printf  \"%s\", 1, \"\\nResult after applying sqrt() to source array\\n\"\nkndx    =       0\n  until kndx == lenarray(kArrRes) do\n        printf  \"kArrRes[%d] = %f\\n\", kndx+1, kndx, kArrRes[kndx]\nkndx    +=      1\n  od\n\n;apply the log() function to each element\nkArrRes maparray kArrSrc, \"log\"\n\n;print the result\n        printf  \"%s\", 1, \"\\nResult after applying log() to source array\\n\"\nkndx    =       0\n  until kndx == lenarray(kArrRes) do\n        printf  \"kArrRes[%d] = %f\\n\", kndx+1, kndx, kArrRes[kndx]\nkndx    +=      1\n  od\n\n;apply the int() function to each element\nkArrRes maparray kArrSrc, \"int\"\n\n;print the result\n        printf  \"%s\", 1, \"\\nResult after applying int() to source array\\n\"\nkndx    =       0\n  until kndx == lenarray(kArrRes) do\n        printf  \"kArrRes[%d] = %f\\n\", kndx+1, kndx, kArrRes[kndx]\nkndx     +=     1\n  od\n\n;apply the frac() function to each element\nkArrRes maparray kArrSrc, \"frac\"\n\n;print the result\n        printf  \"%s\", 1, \"\\nResult after applying frac() to source array\\n\"\nkndx    =       0\n  until kndx == lenarray(kArrRes) do\n        printf  \"kArrRes[%d] = %f\\n\", kndx+1, kndx, kArrRes[kndx]\nkndx += 1\n  od\n\n;turn instrument instance off\n        turnoff\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maparray/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/maparray/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2013</p> <p>New in version 6.00</p>"},{"location":"opcodes/marimba/","title":"Marimba","text":""},{"location":"opcodes/marimba/#marimba","title":"marimba","text":"<p>Physical model related to the striking of a wooden block as found in a marimba.</p> <p>The method is a physical model developed from Perry Cook but re-coded for Csound.</p>"},{"location":"opcodes/marimba/#syntax","title":"Syntax","text":"<pre><code>ares marimba kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec \\\n             [, idoubles] [, itriples]\n</code></pre>"},{"location":"opcodes/marimba/#initialization","title":"Initialization","text":"<p>ihrd -- the hardness of the stick used in the strike. A range of 0 to 1 is used. 0.5 is a suitable value.</p> <p>ipos -- where the block is hit, in the range 0 to 1.</p> <p>imp -- a table of the strike impulses. The file marmstk1.wav is a suitable function from measurements and can be loaded with a GEN01 table. It is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p> <p>ivfn -- shape of vibrato, usually a sine table, created by a function</p> <p>idec --  time before end of note when damping is introduced</p> <p>idoubles (optional) -- percentage of double strikes. Default is 40%.</p> <p>itriples (optional) -- percentage of triple strikes. Default is 20%.</p>"},{"location":"opcodes/marimba/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/marimba/#examples","title":"Examples","text":"<p>Here is an example of the marimba opcode. It uses the file marimba.csd, and marmstk1.wav.</p> Example of the marimba opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o marimba.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 128\nnchnls = 2\n\n; Instrument #1.\ninstr 1\n  ifreq = cpspch(p4)\n  ihrd = 0.1\n  ipos = 0.561\n  imp = 1\n  kvibf = 6.0\n  kvamp = 0.05\n  ivibfn = 2\n  idec = 0.6\n\n  a1 marimba 20000, ifreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec, 20, 10\n\n  outs a1, a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, the \"marmstk1.wav\" audio file.\nf 1 0 256 1 \"marmstk1.wav\" 0 0 0\n; Table #2, a sine wave for the vibrato.\nf 2 0 128 10 1\n\n; Play Instrument #1 for one second.\ni 1 0 1 8.09\ni 1 + 0.5 8.00\ni 1 + 0.5 7.00\ni 1 + 0.25 8.02\ni 1 + 0.25 8.01\ni 1 + 0.25 7.09\ni 1 + 0.25 8.02\ni 1 + 0.25 8.01\ni 1 + 0.25 7.09\ni 1 + 0.3333 8.09\ni 1 + 0.3333 8.02\ni 1 + 0.3334 8.01\ni 1 + 0.25 8.00\ni 1 + 0.3333 8.09\ni 1 + 0.3333 8.02\ni 1 + 0.25 8.01\ni 1 + 0.3333 7.00\ni 1 + 0.3334 6.00\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/marimba/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/marimba/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/massign/","title":"Massign","text":""},{"location":"opcodes/massign/#massign","title":"massign","text":"<p>Assigns a MIDI channel number to a Csound instrument.</p>"},{"location":"opcodes/massign/#syntax","title":"Syntax","text":"<pre><code>massign ichnl, insnum[, ireset]\nmassign ichnl, \"insname\"[, ireset]\n</code></pre>"},{"location":"opcodes/massign/#initialization","title":"Initialization","text":"<p>ichnl -- MIDI channel number (1-16).</p> <p>insnum -- Csound orchestra instrument number. If zero or negative, the channel is muted (i.e. it does not trigger a csound instrument, though information will still be received by opcodes like midiin).</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>ireset -- If non-zero resets the controllers; default is to reset.</p>"},{"location":"opcodes/massign/#performance","title":"Performance","text":"<p>Assigns a MIDI channel number to a Csound instrument. Also useful to make sure a certain instrument (if its number is from 1 to 16) will not be triggered by midi noteon messages (if using something midiin to interpret midi information). In this case set insnum to 0 or a negative number.</p> <p>If ichan is set to 0, the value of insnum is used for all channels. This way you can route all MIDI channels to a single Csound instrument. You can also disable triggering of instruments from MIDI note events from all channels with the following line:</p> <pre><code>massign 0,0\n</code></pre> <p>This can be useful if you are doing all MIDI evaluation within Csound with an always on instrument(e.g. using midiin and turnon) to avoid doubling the instrument when a note is played.</p>"},{"location":"opcodes/massign/#examples","title":"Examples","text":"<p>Here is an example of the massign opcode. It uses the file massign.csd.</p> Example of the massign opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0    ;;;realtime audio out and realtime midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o massign.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiengine fluidEngine\n; soundfont path to manual/examples\nisfnum   fluidLoad \"19Trumpet.sf2\", giengine, 1\n         fluidProgramSelect giengine, 1, isfnum, 0, 56\n\nmassign 0,0     ;disable triggering of all instruments on all channels, but\nmassign 12,10   ;assign instr. 10 to midi channel 12\nmassign 3,30    ;assign instr. 30 to midi channel 3\n\ninstr 10 ; soundfont only on midi channel 12\n\n      mididefault   60, p3\n      midinoteonkey p4, p5      ; in midi notes\nikey  init p4\nivel  init p5\n      fluidNote giengine, 1, ikey, ivel\nendin\n\ninstr 30 ; FM-oscilator only on midi channel 3\n\n      mididefault   60, p3\n      midinoteoncps p4, p5      ; in Hertz\nicps  init p4\niamp  init p5\niamp  = iamp/127\nkenv  madsr  0.5, 0, 1, 0.5\nasig  foscil iamp*kenv, icps, 1, 1.414, 2, 1\n      outs asig, asig \nendin \n\ninstr 99 ; output sound from fluidengine\n\nimvol init 7\naL, aR fluidOut giengine\n      outs aL*imvol, aR*imvol\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine\nf 1 0 16384 10 1\n\ni 10 0 2 60 100  ;one note on the trumpet in midi and...\ni 30 2 2 220 80  ;one FM note in Hz\ni 99 0 60        ;stay active for 60 sec.\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/massign/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/massign/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT, Cambridge, Mass.</p> <p>New in Csound version 3.47</p> <p>ireset parameter new in Csound5</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel range.</p>"},{"location":"opcodes/max/","title":"Max","text":""},{"location":"opcodes/max/#max","title":"max","text":"<p>Produces a signal that is the maximum of any number of input signals.</p> <p>The max opcode takes any number of a-rate, k-rate or i-rate signals as input (all of the same rate), and outputs a signal at the same rate that is the maximum of all of the inputs.  For a-rate signals, the inputs are compared one sample at a time (i.e. max does not scan an entire ksmps period of a signal for its local maximum as the max_k opcode does).</p>"},{"location":"opcodes/max/#syntax","title":"Syntax","text":"<pre><code>amax max ain1, ain2 [, ain3] [, ain4] [...]\nkmax max kin1, kin2 [, kin3] [, kin4] [...]\nimax max iin1, iin2 [, iin3] [, iin4] [...]\n</code></pre>"},{"location":"opcodes/max/#performance","title":"Performance","text":"<p>ain1, ain2, ... --  a-rate signals to be compared.</p> <p>kin1, kin2, ... --  k-rate signals to be compared.</p> <p>iin1, iin2, ... --  i-rate signals to be compared.</p>"},{"location":"opcodes/max/#examples","title":"Examples","text":"<p>Here is an example of the max opcode. It uses the file max.csd.</p> Example of the max opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o max.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   oscili 1, 10.0, 1                  ;combine 3 sinusses\nk2   oscili 1, 1.0, 1                   ;at different rates\nk3   oscili 1, 3.0, 1\nkmax max   k1, k2, k3\nkmax = kmax*250                         ;scale kmax\nprintk2 kmax                            ;check the values\n\naout vco2 .5, 220, 6                    ;sawtooth\nasig moogvcf2 aout, 600+kmax, .5        ;change filter around 600 Hz            \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32768 10 1\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/max/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/max/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01; i-rate version new in 6.04</p>"},{"location":"opcodes/max_k/","title":"Max k","text":""},{"location":"opcodes/max_k/#max_k","title":"max_k","text":"<p>Local maximum (or minimum) value of an incoming asig signal, checked in the time interval between ktrig has become true twice.</p>"},{"location":"opcodes/max_k/#syntax","title":"Syntax","text":"<pre><code>knumkout max_k asig, ktrig, itype\n</code></pre>"},{"location":"opcodes/max_k/#initialization","title":"Initialization","text":"<p>itype - itype determinates the behaviour of max_k (see below)</p>"},{"location":"opcodes/max_k/#performance","title":"Performance","text":"<p>asig - incoming (input) signal</p> <p>ktrig - trigger signal</p> <p>max_k outputs the local maximum (or minimum) value of  the incoming asig signal, checked in the time interval between ktrig has become true twice. itype determinates the behaviour of max_k:</p> <p>1 - absolute maximum (sign of negative values is changed to positive before evaluation).</p> <p>2 - actual maximum.</p> <p>3 - actual minimum.</p> <p>4 - calculate average value of asig in the time interval since the last trigger.</p> <p>This opcode can be useful in several situations, for example to implement a vu-meter.</p>"},{"location":"opcodes/max_k/#examples","title":"Examples","text":"<p>Here is an example of the max_k opcode. It uses the file max_k.csd.</p> Example of the max_k opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;-Ma   ;;;realtime audio out and midi in (on all inputs)\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o max_k.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Stefano Cucchi 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1\n\nanoise noise 0.1, 0.1 ; generate some noise\narandom randomi 400, 12000, 4 ; generate random numbers from 400 to 1200 \n\nktrig metro 3 ; trigger signal\n\nkmin max_k arandom, ktrig, 3 ; minumum value \nkmax max_k arandom, ktrig, 2 ; maximum value \n\nprintk 0.2, kmin\nprintk 0.2, kmax\n\nanoisehp butterhp anoise, kmin ; hipass filter at kmin frequency\nanoiselp butterlp anoise, kmax*0.5 ; lopass filter at kmin/2 frequency\n\nacomp oscil 0.1, 440 ; comparator signal for consistent amplitude\n\nanoisehp balance anoisehp, acomp ; adjusting the volume\nanoiselp balance anoiselp, acomp ; adjusting the volume\n\nouts anoisehp, anoiselp\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/max_k/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/max_k/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p> <p>Fixed to agree with documentation in 5.15</p>"},{"location":"opcodes/maxabs/","title":"Maxabs","text":""},{"location":"opcodes/maxabs/#maxabs","title":"maxabs","text":"<p>Produces a signal that is the maximum of the absolute values of any number of input signals.</p> <p>The maxabs opcode takes any number of a-rate or k-rate signals as input (all of the same rate), and outputs a signal at the same rate that is the maximum of all of the inputs.  It is identical to the max opcode except that it takes the absolute value of each input before comparing them.  Therefore, the output is always non-negative.  For a-rate signals, the inputs are compared one sample at a time (i.e. maxabs does not scan an entire ksmps period of a signal for its local maximum as the max_k opcode does).</p>"},{"location":"opcodes/maxabs/#syntax","title":"Syntax","text":"<pre><code>amax maxabs ain1, ain2 [, ain3] [, ain4] [...]\nkmax maxabs kin1, kin2 [, kin3] [, kin4] [...]\n</code></pre>"},{"location":"opcodes/maxabs/#performance","title":"Performance","text":"<p>ain1, ain2, ... --  a-rate signals to be compared.</p> <p>kin1, kin2, ... --  k-rate signals to be compared.</p>"},{"location":"opcodes/maxabs/#examples","title":"Examples","text":"<p>Here is an example of the maxabs opcode. It uses the file maxabs.csd.</p> Example of the maxabs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o maxabs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   oscili 1, 10.0, 1                  ;combine 3 sinusses\nk2   oscili 1, 1.0, 1                   ;at different rates\nk3   oscili 1, 3.0, 1\nkmax maxabs   k1, k2, k3\nkmax = kmax*250                         ;scale kmax\nprintk2 kmax                            ;check the values\n\naout vco2 .5, 220, 6                    ;sawtooth\nasig moogvcf2 aout, 600+kmax, .5        ;change filter above 600 Hz             \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32768 10 1\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maxabs/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/maxabs/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/maxabsaccum/","title":"Maxabsaccum","text":""},{"location":"opcodes/maxabsaccum/#maxabsaccum","title":"maxabsaccum","text":"<p>Accumulates the maximum of the absolute values of audio signals.</p> <p>maxabsaccum compares two audio-rate variables and stores the maximum of their absolute values into the first.</p>"},{"location":"opcodes/maxabsaccum/#syntax","title":"Syntax","text":"<pre><code>maxabsaccum aAccumulator, aInput\n</code></pre>"},{"location":"opcodes/maxabsaccum/#performance","title":"Performance","text":"<p>aAccumulator -- audio variable to store the maximum value</p> <p>aInput -- signal that aAccumulator is compared to</p> <p>The maxabsaccum opcode is designed to accumulate the maximum value from among many audio signals that may be in different note instances, different channels, or otherwise cannot all be compared at once using the maxabs opcode.  maxabsaccum is identical to maxaccum except that it takes the absolute value of aInput before the comparison.  Its semantics are similar to vincr since aAccumulator is used as both an input and an output variable, except that maxabsaccum keeps the maximum absolute value instead of adding the signals together.  maxabsaccum performs the following operation on each pair of samples:</p> <pre><code>if  (abs(aInput) &gt; aAccumulator)  aAccumulator = abs(aInput)\n</code></pre> <p>aAccumulator will usually be a global audio variable.  At the end of any given computation cycle (k-period), after its value is read and used in some way, the accumulator variable should usually be reset to zero  (perhaps by using the clear opcode).  Clearing to zero is sufficient for maxabsaccum, unlike the maxaccum opcode.</p>"},{"location":"opcodes/maxabsaccum/#examples","title":"Examples","text":"<p>Here is an example of the maxabsaccum opcode. It uses the file maxabsaccum.csd.</p> Example of the maxabsaccum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o maxabsaccum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;saw\n\nasig  vco2 .2, p4               \n      outs  asig, asig                          \ngasaw = asig\nendin\n\ninstr 2 ;sine\n\naout  poscil .3, p4, 1          \n      outs  aout, aout                          \ngasin = aout\nendin\n\ninstr 10        \n\naccum init 0    \n      maxabsaccum  accum, gasaw + gasin         ;saw and sine accumulated       \naccum dcblock2 accum                            ;get rid of DC\n      outs accum, accum \n\nclear accum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ;sine wave      \n\ni 1 0 7 330\ni 2 3 3 440\n\ni 1 10 7 330    ;same notes but without maxabsaccum, for comparison\ni 2 13 3 440\n\ni 10 0 6        ;accumulation note stops after 6 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maxabsaccum/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/maxabsaccum/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/maxaccum/","title":"Maxaccum","text":""},{"location":"opcodes/maxaccum/#maxaccum","title":"maxaccum","text":"<p>Accumulates the maximum value of audio signals.</p> <p>maxaccum compares two audio-rate variables and stores the maximum value between them into the first.</p>"},{"location":"opcodes/maxaccum/#syntax","title":"Syntax","text":"<pre><code>maxaccum aAccumulator, aInput\n</code></pre>"},{"location":"opcodes/maxaccum/#performance","title":"Performance","text":"<p>aAccumulator -- audio variable to store the maximum value</p> <p>aInput -- signal that aAccumulator is compared to</p> <p>The maxaccum opcode is designed to accumulate the maximum value from among many audio signals that may be in different note instances, different channels, or otherwise cannot all be compared at once using the max opcode.  Its semantics are similar to vincr since aAccumulator is used as both an input and an output variable, except that maxaccum keeps the maximum value instead of adding the signals together.  maxaccum performs the following operation on each pair of samples:</p> <pre><code>if  (aInput &gt; aAccumulator)  aAccumulator = aInput\n</code></pre> <p>aAccumulator will usually be a global audio variable.  At the end of any given computation cycle (k-period), after its value is read and used in some way, the accumulator variable should usually be reset to zero  (perhaps by using the clear opcode).  Care must be taken however if aInput is negative at any point, in which case the accumulator should be initialized and reset to some large enough negative value that will always be less than the input signals to which it is compared.</p>"},{"location":"opcodes/maxaccum/#examples","title":"Examples","text":"<p>Here is an example of the maxaccum opcode. It uses the file maxaccum.csd.</p> Example of the maxabs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o maxaccum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;saw\n\nasig  vco2 .2, p4               \n      outs  asig, asig                          \ngasaw = asig\nendin\n\ninstr 2 ;sine\n\naout  poscil .3, p4, 1          \n      outs  aout, aout                          \ngasin = aout\nendin\n\ninstr 10        \n\naccum init 0    \n      maxaccum accum, gasaw + gasin     ;saw and sine accumulated\n      outs  accum, accum                \n\nclear accum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 \n\ni 1 0 7 330\ni 2 3 3 440\n\ni 1 10 7 330    ;same notes but without maxaccum, for comparison\ni 2 13 3 440\n\ni 10 0 6        ;accumulation note stops after 6 seconds\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maxaccum/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/maxaccum/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/maxalloc/","title":"Maxalloc","text":""},{"location":"opcodes/maxalloc/#maxalloc","title":"maxalloc","text":"<p>Limits the number of allocations of an instrument.</p>"},{"location":"opcodes/maxalloc/#syntax","title":"Syntax","text":"<pre><code>maxalloc insnum, icount\nmaxalloc Sinsname, icount\n</code></pre>"},{"location":"opcodes/maxalloc/#initialization","title":"Initialization","text":"<p>insnum -- instrument number</p> <p>Sinsname -- instrument name</p> <p>icount -- number of instrument allocations</p>"},{"location":"opcodes/maxalloc/#performance","title":"Performance","text":"<p>maxalloc limits the number of simultaneous instances (notes) of an instrument. Any score events after the maximum has been reached, are ignored.</p> <p>All instances of maxalloc must be defined in the header section, not in the instrument body.</p>"},{"location":"opcodes/maxalloc/#examples","title":"Examples","text":"<p>Here is an example of the maxalloc opcode. It uses the file maxalloc.csd.</p> Example of the maxalloc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o maxalloc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nmaxalloc 1, 3   ; Limit to three instances.\n\ninstr 1\n\nasig oscil .3, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine\nf 1 0 32768 10 1\n\ni 1 0 5 220     ;1\ni 1 1 4 440     ;2\ni 1 2 3 880     ;3, limit is reached\ni 1 3 2 1320    ;is not played\ni 1 4 1 1760    ;is not played\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should contain messages like these:</p> <pre><code>WARNING: cannot allocate last note because it exceeds instr maxalloc\n</code></pre>"},{"location":"opcodes/maxalloc/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/maxalloc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/maxarray/","title":"Maxarray","text":""},{"location":"opcodes/maxarray/#maxarray","title":"maxarray","text":"<p>Returns the maximum value in a k-rate array, and optional its index.</p>"},{"location":"opcodes/maxarray/#syntax","title":"Syntax","text":"<pre><code>kmax [,kindx] maxarray karray\n</code></pre>"},{"location":"opcodes/maxarray/#performance","title":"Performance","text":"<p>kmax --  variable for result.</p> <p>kindx --  position (index) of result in array.</p> <p>karray --  array for reading.</p>"},{"location":"opcodes/maxarray/#examples","title":"Examples","text":"<p>Here is an example of the maxarray opcode. It uses the file maxarray.csd.</p> Example of the maxarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nksmps = 32\n;example by joachim heintz\n\n           seed       0\n\ninstr 1\n;create an array with 10 elements\nkArr[]     init       10\n;fill in random numbers and print them out\nkIndx      =          0\n  until kIndx == 10 do\nkNum       random     -100, 100\nkArr[kIndx] =         kNum\n           printf     \"kArr[%d] = %10f\\n\", kIndx+1, kIndx, kNum\nkIndx      +=         1\n  od\n;investigate maximum number and print it out\nkMax, kMaxIndx maxarray kArr\n           printf     \"Maximum of kArr = %f at index %d\\n\", kIndx+1, kMax, kMaxIndx\n           turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/maxarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/maxarray/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.14</p> <p>Revised in Csound version 6.00 to work on multidimensional arrays</p>"},{"location":"opcodes/mclock/","title":"Mclock","text":""},{"location":"opcodes/mclock/#mclock","title":"mclock","text":"<p>Sends a MIDI CLOCK message.</p>"},{"location":"opcodes/mclock/#syntax","title":"Syntax","text":"<pre><code>mclock ifreq\n</code></pre>"},{"location":"opcodes/mclock/#initialization","title":"Initialization","text":"<p>ifreq -- clock message frequency rate in Hz</p>"},{"location":"opcodes/mclock/#performance","title":"Performance","text":"<p>Sends a MIDI CLOCK message (0xF8) every 1/ifreq seconds. So ifreq is the frequency rate of CLOCK message in Hz.</p>"},{"location":"opcodes/mclock/#examples","title":"Examples","text":"<p>Here is an example of the mclock opcode. It uses the file mclock.csd.</p> Example of the mclock opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-Q0   ;;;midi out\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;let csound synchronize a sequencer\n\nmclock 24\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mclock/#see-also","title":"See Also","text":"<p>mrtmsg</p> <p>System Realtime Messages</p>"},{"location":"opcodes/mclock/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/mdelay/","title":"Mdelay","text":""},{"location":"opcodes/mdelay/#mdelay","title":"mdelay","text":"<p>A MIDI delay opcode.</p>"},{"location":"opcodes/mdelay/#syntax","title":"Syntax","text":"<pre><code>mdelay kstatus, kchan, kd1, kd2, kdelay\n</code></pre>"},{"location":"opcodes/mdelay/#performance","title":"Performance","text":"<p>kstatus -- status byte of MIDI message to be delayed</p> <p>kchan -- MIDI channel (1-16)</p> <p>kd1 -- first MIDI data byte</p> <p>kd2 -- second MIDI data byte</p> <p>kdelay -- delay time in seconds</p> <p>Each time that kstatus is other than zero, mdelay outputs a MIDI message to the MIDI out port after kdelay seconds. This opcode is useful in implementing MIDI delays. Several instances of mdelay can be present in the same instrument with different argument values, so complex and colorful MIDI echoes can be implemented. Further, the delay time can be changed at k-rate.</p>"},{"location":"opcodes/mdelay/#examples","title":"Examples","text":"<p>Here is an example of the mdelay opcode. It uses the file mdelay.csd.</p> Example of the mdelay opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q0 \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\ninstr 1  ;Triggered by MIDI notes on channel 1\n\n  kstatus init 0\n  ifund   notnum         \n  ivel  veloc \n\n  noteondur  1, ifund, ivel, 1\n\n  kstatus = kstatus + 1 \n\n  idel1 = .2\n  idel2 = .4\n  idel3 = .6\n  idel4 = .8\n\n  ;make four delay lines\n\n  mdelay        kstatus,1,ifund+2, ivel,idel1\n  mdelay        kstatus,1,ifund+4, ivel,idel2\n  mdelay        kstatus,1,ifund+6, ivel,idel3\n  mdelay        kstatus,1,ifund+8, ivel,idel4\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Dummy ftable\nf 0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mdelay/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/mdelay/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy November 1998</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/median/","title":"Median","text":""},{"location":"opcodes/median/#median","title":"median","text":"<p>A median filter, a variant FIR lowpass filter.</p>"},{"location":"opcodes/median/#syntax","title":"Syntax","text":"<pre><code>ares median asig, ksize, imaxsize [, iskip]\n</code></pre>"},{"location":"opcodes/median/#initialization","title":"Initialization","text":"<p>imaxsize -- the maximun  size of the window used to select the data.</p> <p>iskip -- initial disposition of internal data space. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/median/#performance","title":"Performance","text":"<p>asig -- input signal to be filtered</p> <p>ksize -- size of the window over which the input is to be filtered.  It must not exceed the maximum window size; if it does it is truncated.</p> <p>median is a simple filter that retuns the median value of the last ksize values.  It has a lowpass action.  The efficiency decreases as the window size increases.</p>"},{"location":"opcodes/median/#examples","title":"Examples","text":"<p>Here is an example of the median opcode. It uses the file median.csd.</p> Example of the median opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsInstruments&gt;\nsr = 44100\nkr = 441\nksmps = 100\nnchnls = 1\n\ninstr 1\n  a1  oscil  30000, 10, 1\n  a2  median a1, 5, 8\n  out a2\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 4096 10 1\ni 1 0 0.1 \ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/median/#see-also","title":"See also","text":"<p>Standard filters: Variant FIR lowpass filter</p>"},{"location":"opcodes/median/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath May 2010</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/mediank/","title":"Mediank","text":""},{"location":"opcodes/mediank/#mediank","title":"mediank","text":"<p>A median filter, a variant FIR lowpass filter.</p>"},{"location":"opcodes/mediank/#syntax","title":"Syntax","text":"<pre><code>kres mediank kin, ksize, imaxsize [, iskip]\n</code></pre>"},{"location":"opcodes/mediank/#initialization","title":"Initialization","text":"<p>imaxsize -- the maximun  size of the window used to select the data.</p> <p>iskip -- initial disposition of internal data space. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mediank/#performance","title":"Performance","text":"<p>kin -- krate value to be filtered</p> <p>ksize -- size of the window over which the input is to be filtered.  It must not exceed the maximum window size; if it does it is truncated.</p> <p>mediank is a simple filter that retuns the median value of the last ksize values.  It has a lowpass action.  The efficiency decreases as the window size increases.</p>"},{"location":"opcodes/mediank/#examples","title":"Examples","text":"<p>Here is an example of the mediank opcode. It uses the file mediank.csd.</p> Example of the mediank opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nkr = 147\nksmps = 300\nnchnls = 1\n\ninstr 1\n  k1  oscil  100, 10, 1\n  k2  mediank k1, 5, 8\n  printk 0, k2\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 4096 10 1\ni 1 0 1 \ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mediank/#see-also","title":"See also","text":"<p>Standard filters: Variant FIR lowpass filter</p>"},{"location":"opcodes/mediank/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath May 2010</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/metro/","title":"Metro","text":""},{"location":"opcodes/metro/#metro","title":"metro","text":"<p>Trigger Metronome</p> <p>Generate a metronomic signal to be used in any circumstance an isochronous trigger is needed.</p>"},{"location":"opcodes/metro/#syntax","title":"Syntax","text":"<pre><code>ktrig  metro  kfreq [, initphase]\n</code></pre>"},{"location":"opcodes/metro/#initialization","title":"Initialization","text":"<p>initphase  - initial phase value (in the 0 to 1 range)</p>"},{"location":"opcodes/metro/#performance","title":"Performance","text":"<p>ktrig - output trigger signal</p> <p>kfreq - frequency of trigger bangs in cps</p> <p>metro is a simple opcode that outputs a sequence of isochronous bangs (that is 1 values) each 1/kfreq seconds. Trigger signals can be used in any circumstance, mainly to temporize realtime algorithmic compositional structures.</p> <p> Note</p> <p>metro will produce a trigger signal of 1 when its phase is exactly 0 or 1. If you want to skip the initial trigger, use a very small value like 0.00000001.</p>"},{"location":"opcodes/metro/#examples","title":"Examples","text":"<p>Here is an example of the metro opcode. It uses the file metro.csd</p> Example of the metro opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -B441 -b441\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =        44100\nkr     =        100\nksmps  =        441\nnchnls =        2\n\n       instr    1\nktrig metro 0.2\nprintk2 ktrig\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the metro opcode. It uses the file metro-2.csd</p> Another example of the metro opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o metro-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkpch    random   1,20           ;produce values at k-rate\nktrig   metro    10             ;trigger 10 times per second\nkval    samphold kpch, ktrig    ;change value whenever ktrig = 1 \nasig    buzz     1, 220, kval, 1;harmonics\n        outs     asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ; sine\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/metro/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p> <p>More information on this opcode in the Floss Manuals: https://flossmanual.csound.com/csound-language/control-structures</p>"},{"location":"opcodes/metro/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>First Example written by Andr\u00e9s Cabrera.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/metro2/","title":"Metro2","text":""},{"location":"opcodes/metro2/#metro2","title":"metro2","text":"<p>Trigger Metronome with Swing and Accents</p>"},{"location":"opcodes/metro2/#syntax","title":"Syntax","text":"<pre><code>ktrig  metro2  kfreq, kswing [, iamp, initphase]\n</code></pre>"},{"location":"opcodes/metro2/#initialization","title":"Initialization","text":"<p>iamp  -  off-beat click amplitude</p> <p>initphase  - initial phase value (in the 0 to 1 range)</p>"},{"location":"opcodes/metro2/#performance","title":"Performance","text":"<p>ktrig - output trigger signal</p> <p>kfreq - frequency of trigger bangs in cps</p> <p>kswing - value (in the 0 to 1 range)</p> <p>metro2 is a modification of 'classic' metro opcode with additional swinging. The swinging clicks can be modulated at k-rate. Also, swinging clicks can have their own amplitude value set by iamp.</p> <p> Note</p> <p>metro2 as well as metro will produce a trigger signal of 1 when its phase is exactly 0 or 1. If you want to skip the initial trigger, use a very small value like 0.00000001.</p>"},{"location":"opcodes/metro2/#examples","title":"Examples","text":"<p>Here is an example of the metro2 opcode. It uses the file metro2.csd</p> Example of the metro2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac ; for RT audio\n&lt;/CsOptions&gt;\n        &lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 16\nnchnls = 2\n0dbfs = 1.0\n\nga1 init 0   ; delay aux\n\ninstr 1 ; main triggering instrument\nkndx init 0\nkndx2 init -1\n; the clicks are 1/16th notes @ 137 BPM\nkT metro2 (4*137/60), p4, -1\nif (kT == 0) goto Halt\n        k1 table kndx, 1, 0, 0, 1\n        kndx += 1\n        if (k1 == 0) goto Next\n                event \"i\", 2, 0, 0.35, k1\nNext: \n; positive amplitude values of down-beat clicks \n; are used to trigger kick (instr 3)\nif (kT &lt; 1) goto Halt\n        kndx2 += 1\n        kndx2 wrap kndx2, 0, 2 \n        if kndx2 != 0 goto Halt\n        event \"i\", 3, 0, 0.2\nHalt:\nendin\n\ninstr 2  ; simple subtractive bass\nkAE linsegr 0, 0.005, 1, p3/2, .7, .04, 0, .04, 0\nkFE linsegr 1, 0.005, 2, p3/2, .7, .04, .1, .04, .1\nifr = cpspch(p4)\na1 vco2 1, ifr\na2 vco2 1, ifr * 1.005\na3 vco2 1, ifr * 0.993\naM = (a1+a2+a3)/3\naM moogvcf aM*kAE, 1000 * kFE, 0.5\nouts aM, aM\nga1 += aM * 0.25\nendin\n\ninstr 3 ; simple techno kick\nk1 linseg 200, p3, 10\nk2 linseg 0,0.001,1,0.25,0\na1 oscil 0.3*k2, k1\nouts a1,a1\nendin\n\ninstr 99 ; feedback delay for bass\na1 delayr 0.5\nab deltap 0.33\n   delayw ga1 + ab*0.3\nouts ab,ab\nga1 = 0\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nt 0 137 \n; ftable1 is the bass sequence to played with various swings\nf1 0 16 -2 6.00 0 0 7.00 0 0 6.00 0 6.00 0 0 7.00 0 7.01 6.00 0\n; 4 measure pattern of different swinging \ni1 0 16 0.5\ni1 + .  0.65\ni1 + .  0.4\ni99 0 46\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/metro2/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/metro2/#credits","title":"Credits","text":"<p>Author: Gleb Rogozinsky; St.Petersburg, October 2019</p> <p>New in Csound version 6.14</p>"},{"location":"opcodes/metrobpm/","title":"Metrobpm","text":""},{"location":"opcodes/metrobpm/#metrobpm","title":"metrobpm","text":"<p>Trigger Metronome with optional gate</p> <p>Generate a metronomic signal to be used in any circumstance an isochronous trigger is needed.</p>"},{"location":"opcodes/metrobpm/#syntax","title":"Syntax","text":"<pre><code>ktrig  metrobpm  kfreq [, initphase] [, kgate]\n</code></pre>"},{"location":"opcodes/metrobpm/#initialization","title":"Initialization","text":"<p>initphase  - initial phase value (in the 0 to 1 range)</p>"},{"location":"opcodes/metrobpm/#performance","title":"Performance","text":"<p>ktrig - output trigger signal</p> <p>kfreq - frequency of trigger bangs in beats per minute</p> <p>kgate - proportion of the cycle that the trigger held at one</p> <p>metrobpm is a simple opcode that outputs a sequence of isochronous bangs with optional holdin (that is 1 values,) each 60/kfreq seconds.</p> <p> Note</p> <p>metrobpm will produce a trigger signal of 1 when its phase is exactly 0 or 1. If you want to skip the initial trigger, use a very small value like 0.00000001.</p>"},{"location":"opcodes/metrobpm/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/metrobpm/#credits","title":"Credits","text":"<p>Written by John ffitch</p> <p>New in Csound 6.17</p>"},{"location":"opcodes/midiarp/","title":"Midiarp","text":""},{"location":"opcodes/midiarp/#midiarp","title":"midiarp","text":"<p>Generates arpeggios based on currently held MIDI notes.</p> <p>The opcode will output notes in the form of MIDI note numbers, and a metronomic signal that can be used to sequence the notes. Users can choose the rate at which the notes are generated, and may also choose from a set of arpeggio patterns.</p>"},{"location":"opcodes/midiarp/#syntax","title":"Syntax","text":"<pre><code>kMidiNoteNum, kTrigger midiarp kRate[, kMode]\n</code></pre>"},{"location":"opcodes/midiarp/#performance","title":"Performance","text":"<p>kRate -- sets the rate in cycles per second at which new notes will be generated.</p> <p>kMode -- Optional. Sets the mode of the arpeggio. 0 for up and down, 1, for up, 2 for down, and 3 for random. If left out, it will default to mode 0, up and down.</p> <p>kMideNoteNum -- the current note number in the arpeggio pattern.</p> <p>kTrigger -- a metronomic pulse that can be used to trigger playback of the notes in the arpeggio. This signal will output a 1 followed by 0s on each cycle. The frequency is set using the kRate input parameter.</p> <p> Note</p> <p>It is important that the instrument which holds the midiarp opcode is not continuously triggered on each new MIDI note. To prevent this from happening use the massign opcode, as shown in the example below.</p>"},{"location":"opcodes/midiarp/#example","title":"Example","text":"<p>This example shows how midiarp can be used to trigger arpeggios using a secondary instrument for playback. Instrument 100 listens to incoming MIDI notes, and then triggers playback using instrument 200. massign is used to prevent instrument 100 from being triggered each time a new MIDI note is pressed. This examples uses the file midiarp.csd.</p> Example of the midiarp opcode<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac   -d    -m0d --midi-key-cps=4 --midi-velocity-amp=5  -F midiChords.mid\n; For Non-realtime ouput leave only the line below:\n; -o midiin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; Initialize the global variables. \nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nmassign 1, -1; prevent triggering of instrument with MIDI\n\ninstr 200\n\n    kMode = 0\n    kTempo = 8\n    kNote, kTrigger midiarp kTempo\n    kFilterFreq lfo 2000, .05, 1\n\n    ;if kTrigger is 1 trigger instrument 300 to play\n    if kTrigger==1 then         \n        event \"i\", 300, 0, .5, .5, kNote, abs(kFilterFreq)+200\n    endif\n\nendin\n\ninstr 300\n\n    kEnv expon p4, p3, .001\n    aOut vco2 kEnv, cpsmidinn(p5)               ;convert note number to cps\n    aFilter moogladder aOut, p6, .2\n    outs aFilter, aFilter\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni200 0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midiarp/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/midiarp/#credits","title":"Credits","text":"<p>Author: Rory Walsh 2017</p>"},{"location":"opcodes/midic14/","title":"Midic14","text":""},{"location":"opcodes/midic14/#midic14","title":"midic14","text":"<p>Allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/midic14/#syntax","title":"Syntax","text":"<pre><code>idest midic14 ictlno1, ictlno2, imin, imax [, ifn]\nkdest midic14 ictlno1, ictlno2, kmin, kmax [, ifn]\n</code></pre>"},{"location":"opcodes/midic14/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ictln1o -- most-significant byte controller number (0-127)</p> <p>ictlno2 -- least-significant byte controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to imin and imax values.</p>"},{"location":"opcodes/midic14/#performance","title":"Performance","text":"<p>kdest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>midic14 (i- and k-rate 14 bit MIDI control) allows a floating-point 14-bit MIDI signal scaled with a minimum and a maximum range. The minimum and maximum values can be varied at k-rate. It can use optional interpolated table indexing. It requires two MIDI controllers as input.</p> <p> Note</p> <p>Please note that the midic family of opcodes are designed for MIDI triggered events, and do not require a channel number since they will respond to the same channel as the one that triggered the instrument (see massign). However they will crash if called from a score driven event.</p>"},{"location":"opcodes/midic14/#examples","title":"Examples","text":"<p>Here is an example of the midic14 opcode. It uses the file midic14.csd.</p> Example of the midic14 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -M0 --midi-key-cps=4 --midi-velocity-amp=5   ;;;realtime audio out and realtime midi in, midi key cps is routed to p4 and velocity to p5\n; For Non-realtime ouput leave only the line below:\n; -o midic14.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by tgrey - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n        ; This example expects MIDI controller input on channel 1\n        ; run, play a note and move your midi controllers 1 and 7 to see results\n        ictlno1= 1      ; = cc #1 midi mod wheel (course tuning)\n        ictlno2= 7      ; = cc #7 midi volume (fine tuning)\n\n        ; max range is 3 octaves: (2^3) = 8\n        imax  = 8\n\n        ; read both controllers, scaling them between 1 and imax\n        kTune midic14 ictlno1, ictlno2, 1, imax \n        printk2 kTune\n\n        ; generate tones\n        asig oscili p5, p4*kTune\n        aref oscili p5, p4\n\n        ; combine detuned tone and reference tone\n        ; creates a beat effect from the detune\n        asig=(asig+aref)*.5\n\n        outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; run for 60 seconds\nf0 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midic14/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/midic14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct controller number range.</p>"},{"location":"opcodes/midic21/","title":"Midic21","text":""},{"location":"opcodes/midic21/#midic21","title":"midic21","text":"<p>Allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/midic21/#syntax","title":"Syntax","text":"<pre><code>idest midic21 ictlno1, ictlno2, ictlno3, imin, imax [, ifn]\nkdest midic21 ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]\n</code></pre>"},{"location":"opcodes/midic21/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ictln1o -- most-significant byte controller number (0-127)</p> <p>ictlno2 -- mid-significant byte controller number (0-127)</p> <p>ictlno3 -- least-significant byte controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to the imin and imax values.</p>"},{"location":"opcodes/midic21/#performance","title":"Performance","text":"<p>kdest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>midic21 (i- and k-rate 21 bit MIDI control) allows a floating-point 21-bit MIDI signal scaled with a minimum and a maximum range. Minimum and maximum values can be varied at k-rate. It can use optional interpolated table indexing. It requires three MIDI controllers as input.</p> <p> Note</p> <p>Please note that the midic family of opcodes are designed for MIDI triggered events, and do not require a channel number since they will respond to the same channel as the one that triggered the instrument (see massign). However they will crash if called from a score driven event.</p>"},{"location":"opcodes/midic21/#examples","title":"Examples","text":"<p>Here is an example of the midic21 opcode. It uses the file midic21.csd.</p> Example of the midic21 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -M0 --midi-key-cps=4 --midi-velocity-amp=5   ;;;realtime audio out and realtime midi in, midi key cps is routed to p4 and velocity to p5\n; For Non-realtime ouput leave only the line below:\n; -o midic21.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by tgrey - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n        ; This example expects MIDI controller input on channel 1\n        ; run, play a note and move your midi controllers 1, 7, and 10 to see results\n        ictlno1= 1      ; = cc #1 midi mod wheel (course tuning)\n        ictlno2= 7      ; = cc #7 midi volume (fine tuning)\n        ictlno3= 10 ; = cc #10 midi pan (extremely fine tuning)\n\n        ; max range is 4 octaves: (2^4) = 16\n        imax  = 16\n\n        ; read all 3 controllers, scaling them between 1 and imax\n        kTune midic21 ictlno1, ictlno2, ictlno3, 1, imax        \n        printk2 kTune\n\n        ; generate tones\n        asig oscili p5, p4*kTune\n        aref oscili p5, p4\n\n        ; combine detuned tone and reference tone\n        ; creates a beat effect from the detune\n        asig=(asig+aref)*.5\n\n        outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; run for 60 seconds\nf0 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midic21/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/midic21/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct controller number range.</p>"},{"location":"opcodes/midic7/","title":"Midic7","text":""},{"location":"opcodes/midic7/#midic7","title":"midic7","text":"<p>Allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range.</p>"},{"location":"opcodes/midic7/#syntax","title":"Syntax","text":"<pre><code>idest midic7 ictlno, imin, imax [, ifn]\nkdest midic7 ictlno, kmin, kmax [, ifn]\n</code></pre>"},{"location":"opcodes/midic7/#initialization","title":"Initialization","text":"<p>idest -- output signal</p> <p>ictlno -- MIDI controller number (0-127)</p> <p>imin -- user-defined minimum floating-point value of output</p> <p>imax -- user-defined maximum floating-point value of output</p> <p>ifn (optional) -- table to be read when indexing is required. Table must be normalized. Output is scaled according to the imin and imax values.</p>"},{"location":"opcodes/midic7/#performance","title":"Performance","text":"<p>kdest -- output signal</p> <p>kmin -- user-defined minimum floating-point value of output</p> <p>kmax -- user-defined maximum floating-point value of output</p> <p>midic7 (i- and k-rate 7 bit MIDI control) allows a floating-point 7-bit MIDI signal scaled with a minimum and a maximum range. It also allows optional non-interpolated table indexing. In midic7 minimum and maximum values can be varied at k-rate.</p> <p> Note</p> <p>Please note that the midic family of opcodes are designed for MIDI triggered events, and do not require a channel number since they will respond to the same channel as the one that triggered the instrument (see massign). However they will crash if called from a score driven event.</p>"},{"location":"opcodes/midic7/#examples","title":"Examples","text":"<p>Here is an example of the midic7 opcode. It uses the file midic7.csd</p> Example of the midic7 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0    ;;;realtime audio out and realtime midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midic7.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n; This example expects MIDI controller input on channel 1\n; run, play a note and move your midi controller 7 to see result\n\nimax  = 1\nimin  = 0\nichan = 1 \nictlno= 7       ; = midi volume\n\nkamp    midic7  ictlno, imin, imax      \n        printk2 kamp\nasig    oscili  kamp, 220, 1\n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; no score events allowed\nf 0 20          ;20 sec. for real-time MIDI events\nf 1 0 4096 10 1 ;sine wave\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midic7/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/midic7/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct controller number range.</p>"},{"location":"opcodes/midichannelaftertouch/","title":"Midichannelaftertouch","text":""},{"location":"opcodes/midichannelaftertouch/#midichannelaftertouch","title":"midichannelaftertouch","text":"<p>Gets a MIDI channel's aftertouch value.</p> <p>midichannelaftertouch is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midichannelaftertouch/#syntax","title":"Syntax","text":"<pre><code>midichannelaftertouch xchannelaftertouch [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/midichannelaftertouch/#initialization","title":"Initialization","text":"<p>ilow (optional) -- optional low value after rescaling, defaults to 0.</p> <p>ihigh (optional) -- optional high value after rescaling, defaults to 127.</p>"},{"location":"opcodes/midichannelaftertouch/#performance","title":"Performance","text":"<p>xchannelaftertouch -- returns the MIDI channel aftertouch during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the value of xchannelaftertouch with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the value of xchannelaftertouch remains unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midichannelaftertouch/#examples","title":"Examples","text":"<p>Here is an example of the midichannelaftertouch opcode. It uses the file midichannelaftertouch.csd.</p> Example of the midichannelaftertouch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midichannelaftertouch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidinoteoncps p4, p5                            ;puts MIDI key translated to cycles per second into p4, and MIDI velocity into p5\nkafter init 127                                 ;full open                              \nmidichannelaftertouch  kafter\nprintk2 kafter                                  ;display the key value when it changes and when key is pressed\n\nkvel = p5/127                                   ;scale midi velocity to 0-1\nkenv madsr 0.5, 0.8, 0.8, 0.5                   ;amplitude envelope multiplied by\nain  pluck kenv*kvel, p4, p4, 2, 1              ;velocity value \nasig moogvcf2 ain, 200+(kafter*40), .5          ;scale value of aftertouch and control filter frequency\n     outs  asig, asig                           ;base freq of filter = 200 Hz\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 440 100 ; play these notes from score as well\ni 1 + 2 1440 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1   127.00000\ni1    20.00000\ni1    44.00000\n</code></pre>"},{"location":"opcodes/midichannelaftertouch/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midichannelaftertouch/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midichn/","title":"Midichn","text":""},{"location":"opcodes/midichn/#midichn","title":"midichn","text":"<p>Returns the MIDI channel number (1 - 16) from which the note was activated.</p> <p>In the case of score notes, it returns 0.</p>"},{"location":"opcodes/midichn/#syntax","title":"Syntax","text":"<pre><code>ichn midichn\n</code></pre>"},{"location":"opcodes/midichn/#initialization","title":"Initialization","text":"<p>ichn -- channel number. If the current note was activated from score, it is set to zero.</p>"},{"location":"opcodes/midichn/#examples","title":"Examples","text":"<p>Here is a simple example of the midichn opcode. It uses the file midichn.csd.</p> Example of the midichn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -M0 -+rtmidi=virtual ;;; midi file input\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1  \n;change channel on virtual midi keyboard\ni1 midichn\n   print i1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 20  ;runs for 20 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an advanced example of the midichn opcode. It uses the file midichn_advanced.csd.</p> <p>Do not forget that you must include the -F flag when using an external MIDI file like \u201cmidichn_advanced.mid\u201d.</p> An advanced example of the midichn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -F midichn_advanced.mid ;;;realtime audio out with MIDI file input\n; For Non-realtime ouput leave only the line below:\n; -o midichn_advanced.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n        massign  1, 1           ; all channels use instr 1\n        massign  2, 1\n        massign  3, 1\n        massign  4, 1\n        massign  5, 1\n        massign  6, 1\n        massign  7, 1\n        massign  8, 1\n        massign  9, 1\n        massign 10, 1\n        massign 11, 1\n        massign 12, 1\n        massign 13, 1\n        massign 14, 1\n        massign 15, 1\n        massign 16, 1\n\ngicnt   =  0            ; note counter\n\n        instr 1\n\ngicnt   =  gicnt + 1    ; update note counter\nkcnt    init gicnt      ; copy to local variable\nichn    midichn         ; get channel number\nistime  times           ; note-on time\n\n        if (ichn &gt; 0.5) goto l2         ; MIDI note\n        printks \"note %.0f (time = %.2f) was activated from the score\\\\n\", \\\n                3600, kcnt, istime\n        goto l1\nl2:\n        printks \"note %.0f (time = %.2f) was activated from channel %.0f\\\\n\", \\\n                3600, kcnt, istime, ichn\nl1:\n\nicps    cpsmidi         ; convert midi note to pitch\nkenv    madsr   0.1, 0, 0.8, 0.9\nasig    pluck   kenv, icps, icps, 1, 1   \n        outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nt 0 60          ;beats per minute\n\nf 0 8           ;stay active for 8 seconds\nf 1 0 4096 10 1 ;sine\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>note 1 (time = 0.00) was activated from channel 1\nnote 2 (time = 2.00) was activated from channel 4\nnote 3 (time = 3.00) was activated from channel 2\nnote 4 (time = 5.00) was activated from channel 3\n</code></pre>"},{"location":"opcodes/midichn/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p> <p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midichn/#credits","title":"Credits","text":"<p>Author: Istvan Varga May 2002</p> <p>New in version 4.20</p>"},{"location":"opcodes/midicontrolchange/","title":"Midicontrolchange","text":""},{"location":"opcodes/midicontrolchange/#midicontrolchange","title":"midicontrolchange","text":"<p>Gets a MIDI control change value.</p> <p>midicontrolchange is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midicontrolchange/#syntax","title":"Syntax","text":"<pre><code>midicontrolchange xcontroller, xcontrollervalue [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/midicontrolchange/#initialization","title":"Initialization","text":"<p>ilow (optional) -- optional low value after rescaling, defaults to 0.</p> <p>ihigh (optional) -- optional high value after rescaling, defaults to 127.</p>"},{"location":"opcodes/midicontrolchange/#performance","title":"Performance","text":"<p>xcontroller -- specifies the MIDI controller number (0-127) to read from.</p> <p>xcontrollervalue -- returns the value of the MIDI controller during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the value of xcontrollervalue with the corresponding value from the MIDI data of the specified xcontroller. If the instrument was NOT activated by MIDI input, the value remains unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midicontrolchange/#examples","title":"Examples","text":"<p>Here is an example of the midicontrolchange opcode. It uses the file midicontrolchange.csd</p> Example of the midicontrolchange opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual   -M0  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midicontrolchange.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n; use slider of contr. 7 of virtual keyboard\nkcont init 1    ; max. volume\nmidicontrolchange 7, kcont, 0, 1; use controller 7, scaled between 0 and 1      \nprintk2 kcont   ; Display the key value when it changes and key is pressed\n\nkenv madsr 0.5, 0.8, 0.8, 0.5           ; envelope multiplied by\nasig pluck kenv*kcont, 220, 220, 2, 1   ; value of controller 7  \n     outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30\nf 2 0 4096 10 1 \n\ni 1 10 2        ; play a note from score as well\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midicontrolchange/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midicontrolchange/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/midictrl/","title":"Midictrl","text":""},{"location":"opcodes/midictrl/#midictrl","title":"midictrl","text":"<p>Get the current value (0-127) of a specified MIDI controller.</p>"},{"location":"opcodes/midictrl/#syntax","title":"Syntax","text":"<pre><code>ival midictrl inum [, imin] [, imax]\nkval midictrl inum [, imin] [, imax]\n</code></pre>"},{"location":"opcodes/midictrl/#initialization","title":"Initialization","text":"<p>inum -- MIDI controller number (0-127)</p> <p>imin, imax -- set minimum and maximum limits on values obtained.</p>"},{"location":"opcodes/midictrl/#performance","title":"Performance","text":"<p>Get the current value (0-127) of a specified MIDI controller.</p> <p> Warning</p> <p>midictrl should only be used in notes that were triggered from MIDI, so that an associated channel number is available. For notes activated from the score, line events, or orchestra, the ctrl7 opcode that takes an explicit channel number should be used instead.</p>"},{"location":"opcodes/midictrl/#examples","title":"Examples","text":"<p>Here is an example of the midictrl opcode. It uses the file midictrl.csd</p> Example of the midictrl opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0   ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midictrl.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nicps    cpsmidi          \niamp    ampmidi .5\nips     midictrl 9, 10, 500             ;controller 9    \n\nkenv    madsr   0.5, 0, 1, 0.5\nasig    pluck   kenv, icps, ips, 2, 1   ;change tone color       \n        outs    asig, asig                      \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 2 0 4096 10 1 ;sine wave\n; no score events allowed\nf0 30   ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midictrl/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/midictrl/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct controller number range.</p>"},{"location":"opcodes/mididefault/","title":"Mididefault","text":""},{"location":"opcodes/mididefault/#mididefault","title":"mididefault","text":"<p>Changes values, depending on MIDI activation.</p> <p>mididefault is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/mididefault/#syntax","title":"Syntax","text":"<pre><code>mididefault xdefault, xvalue\n</code></pre>"},{"location":"opcodes/mididefault/#performance","title":"Performance","text":"<p>xdefault -- specifies a default value that will be used during MIDI activation.</p> <p>xvalue -- overwritten by xdefault during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode will overwrite the value of xvalue with the value of xdefault. If the instrument was NOT activated by MIDI input, xvalue will remain unchanged.</p> <p>This enables score pfields to receive a default value during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/mididefault/#examples","title":"Examples","text":"<p>Here is an example of the mididefault opcode. It uses the file mididefault.csd.</p> Example of the mididefault opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mididefault.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmididefault 60, p3                                      ;ensures that a MIDI-activated instrument will have a positive p3 field\nmidinoteoncps p4, p5                                    ;puts MIDI key translated to cycles per second into p4, and MIDI velocity into p5\n\nkvel = p5/127                                           ;scale midi velocity to 0-1\nkenv madsr 0.5, 0.8, 0.8, 0.5                           ;amplitude envelope multiplied by\nasig pluck kenv*kvel, p4, p4, 2, 1                      ;velocity               \n     outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 440 100 ; play these notes from score as well\ni 1 + 2 1440 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mididefault/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/mididefault/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midifilestatus/","title":"Midifilestatus","text":""},{"location":"opcodes/midifilestatus/#midifilestatus","title":"midifilestatus","text":"<p>Returns the playback status of MIDI file input.</p> <p>Returns the current playback status at k-rate, of the input MIDI file, 1 if file is playing, 0 if the end-of-the file has been reached.</p>"},{"location":"opcodes/midifilestatus/#syntax","title":"Syntax","text":"<pre><code>ksig  midifilestatus\n</code></pre>"},{"location":"opcodes/midifilestatus/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/midifilestatus/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini March 2006 New in Csound6</p>"},{"location":"opcodes/midiin/","title":"Midiin","text":""},{"location":"opcodes/midiin/#midiin","title":"midiin","text":"<p>Returns a generic MIDI message received by the MIDI IN port.</p>"},{"location":"opcodes/midiin/#syntax","title":"Syntax","text":"<pre><code>kstatus, kchan, kdata1, kdata2 midiin\n</code></pre>"},{"location":"opcodes/midiin/#performance","title":"Performance","text":"<p>kstatus -- the type of MIDI message. Can be:</p> <ul> <li>128 (note off)</li> <li>144 (note on)</li> <li>160 (polyphonic aftertouch)</li> <li>176 (control change)</li> <li>192 (program change)</li> <li>208 (channel aftertouch)</li> <li>224 (pitch bend)</li> <li>0 if no MIDI message are pending in the MIDI IN buffer</li> </ul> <p>kchan -- MIDI channel (1-16)</p> <p>kdata1, kdata2 -- message-dependent data values</p> <p>midiin has no input arguments, because it reads at the MIDI in port implicitly. It works at k-rate. Normally (i.e., when no messages are pending) kstatus is zero, only when MIDI data are present in the MIDI IN buffer, is kstatus set to the type of the relevant messages.</p> <p> Note</p> <p>Be careful when using midiin in low numbered instruments, since a MIDI note will launch additional instances of the instrument, resulting in duplicate events and weird behaviour. Use massign to direct MIDI note on messages to a different instrument or to disable triggering of instruments from MIDI.</p>"},{"location":"opcodes/midiin/#examples","title":"Examples","text":"<p>Here is an example of the midiin opcode. It uses the file midiin.csd.</p> Example of the midiin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -+rtmidi=virtual ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o midiin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\nsr        =  44100\nksmps     =  10\nnchnls    =  1\n\n; Example by schwaahed 2006\n\n      massign         0, 130  ; make sure that all channels\n      pgmassign       0, 130  ; and programs are assigned to test instr\n\n\n  instr   130\n\nknotelength    init    0\nknoteontime    init    0\n\nkstatus, kchan, kdata1, kdata2                  midiin\n\nif (kstatus == 128) then\nknoteofftime    times\nknotelength    =    knoteofftime - knoteontime\nprintks \"kstatus= %d, kchan = %d, \\\\tnote#  = %d, velocity = %d \\\\tNote OFF\\\\t%f %f\\\\n\", 0, kstatus, kchan, kdata1,kdata2, knoteofftime, knotelength\n\nelseif (kstatus == 144) then\nknoteontime    times\nprintks \"kstatus= %d, kchan = %d, \\\\tnote#  = %d, velocity = %d \\\\tNote ON\\\\t%f\\\\n\", 0, kstatus, kchan, kdata1, kdata2, knoteontime\n\n\nelseif (kstatus == 160) then\nprintks \"kstatus= %d, kchan = %d, \\\\tkdata1 = %d, kdata2 = %d \\\\tPolyphonic Aftertouch\\\\n\", 0, kstatus, kchan, kdata1, kdata2\n\nelseif (kstatus == 176) then\nprintks \"kstatus= %d, kchan = %d, \\\\t CC = %d, value = %d \\\\tControl Change\\\\n\", 0, kstatus, kchan, kdata1, kdata2\n\nelseif (kstatus == 192) then\nprintks \"kstatus= %d, kchan = %d, \\\\tkdata1 = %d, kdata2 = %d \\\\tProgram Change\\\\n\", 0, kstatus, kchan, kdata1, kdata2\n\nelseif (kstatus == 208) then\nprintks  \"kstatus= %d, kchan = %d, \\\\tkdata1 = %d, kdata2 = %d \\\\tChannel Aftertouch\\\\n\", 0, kstatus, kchan, kdata1, kdata2\n\nelseif (kstatus == 224) then\nprintks \"kstatus= %d, kchan = %d, \\\\t ( data1 , kdata2 ) = ( %d, %d )\\\\tPitch Bend\\\\n\", 0, kstatus, kchan, kdata1, kdata2\n\nendif\n\n  endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni130 0 3600\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/midiin/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p> <p>Generic Input and Output</p>"},{"location":"opcodes/midiin/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/midinoteoff/","title":"Midinoteoff","text":""},{"location":"opcodes/midinoteoff/#midinoteoff","title":"midinoteoff","text":"<p>Gets a MIDI noteoff value.</p> <p>This opcode is incorrect. It is identical to midinoteonkey. It does not do what you would expect from its name, as it does not respond to Note-Off events, but is activated by Note-On. The midiin opcode can be used to receive noteoff events and their velocities.</p> <p>midinoteoff is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midinoteoff/#syntax","title":"Syntax","text":"<pre><code>midinoteoff xkey, xvelocity\n</code></pre>"},{"location":"opcodes/midinoteoff/#performance","title":"Performance","text":"<p>xkey -- returns MIDI key during MIDI activation, remains unchanged otherwise.</p> <p>xvelocity -- returns MIDI velocity during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the values of the xkey and xvelocity with the corresponding values from MIDI input. If the instrument was NOT activated by MIDI input, the values of xkey and xvelocity remain unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midinoteoff/#examples","title":"Examples","text":"<p>Here is an example of the midinoteoff opcode. It uses the file midinoteoff.csd.</p> Example of the midinoteoff opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1 -Q1  ;;;realtime audio out and midi in and midi out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midinoteoff.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;uses external midi device\n\nkkey init 0                             ;initialize key number\nkvel init 0                             ;initialize velocity\nmidinoteoff kkey,kvel                   ;MIDI noteoff value\nprintk2 kvel                            ;display noteoff value\nmidion 1, kkey, kvel                    ;sent note to external device\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds    \n\ni 1 0 2 62      ; play these notes from score as well\ni 1 + 2 65\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1    60.00000\ni1    76.00000\n</code></pre>"},{"location":"opcodes/midinoteoff/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midinoteoff/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midinoteoncps/","title":"Midinoteoncps","text":""},{"location":"opcodes/midinoteoncps/#midinoteoncps","title":"midinoteoncps","text":"<p>Gets a MIDI note number as a cycles-per-second frequency.</p> <p>midinoteoncps is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midinoteoncps/#syntax","title":"Syntax","text":"<pre><code>midinoteoncps xcps, xvelocity\n</code></pre>"},{"location":"opcodes/midinoteoncps/#performance","title":"Performance","text":"<p>xcps -- returns MIDI key translated to cycles per second during MIDI activation, remains unchanged otherwise.</p> <p>xvelocity -- returns MIDI velocity during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the values of xcps and xvelocity with the corresponding values from MIDI input. If the instrument was NOT activated by MIDI input, the values of xcps and xvelocity remain unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midinoteoncps/#examples","title":"Examples","text":"<p>Here is an example of the midinoteoncps opcode. It uses the file midinoteoncps.csd.</p> Example of the midinoteoncps opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midinoteoncps.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidinoteoncps p4, p5                            ;puts MIDI key translated to cycles per second into p4, and MIDI velocity into p5\n\nprint p4                                        ;display the key value when it changes and when key is pressed \nkvel = p5/127                                   ;scale midi velocity to 0-1\nkenv madsr 0.5, 0.8, 0.8, 0.5                   ;amplitude envelope multiplied by\nasig pluck kenv*kvel, p4, p4, 2, 1              ;velocity value                 \n     outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 440 100 ; play these notes from score as well\ni 1 + 2 1440 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1   261.62561\ni1   440.00006\n</code></pre>"},{"location":"opcodes/midinoteoncps/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midinoteoncps/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midinoteonkey/","title":"Midinoteonkey","text":""},{"location":"opcodes/midinoteonkey/#midinoteonkey","title":"midinoteonkey","text":"<p>Gets a MIDI note number value.</p> <p>midinoteonkey is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midinoteonkey/#syntax","title":"Syntax","text":"<pre><code>midinoteonkey xkey, xvelocity\n</code></pre>"},{"location":"opcodes/midinoteonkey/#performance","title":"Performance","text":"<p>xkey -- returns MIDI key during MIDI activation, remains unchanged otherwise.</p> <p>xvelocity -- returns MIDI velocity during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the values of xkey and xvelocity with the corresponding values from MIDI input. If the instrument was NOT activated by MIDI input, the values of xkey and xvelocity remain unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midinoteonkey/#examples","title":"Examples","text":"<p>Here is an example of the midinoteonkey opcode. It uses the file midinoteonkey.csd.</p> Example of the midinoteonkey opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1 -Q1  ;;;realtime audio out and midi in and midi out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midinoteonkey.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;uses external midi device\n\nkkey init 0                                             ;initialize key number\nkvel init 0                                             ;initialize velocity\nmidinoteonkey kkey, kvel                                ;MIDI note number value \nprintk2 kkey                                            ;display the key value when it changes and when key is pressed \nmidion 1, kkey, kvel                                    ;sent note to external device\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds    \n\ni 1 0 2 62      ; play these notes from score as well\ni 1 + 2 65\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1    60.00000\ni1    69.00000\n</code></pre>"},{"location":"opcodes/midinoteonkey/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midinoteonkey/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midinoteonoct/","title":"Midinoteonoct","text":""},{"location":"opcodes/midinoteonoct/#midinoteonoct","title":"midinoteonoct","text":"<p>Gets a MIDI note number value as octave-point-decimal value.</p> <p>midinoteonoct is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midinoteonoct/#syntax","title":"Syntax","text":"<pre><code>midinoteonoct xoct, xvelocity\n</code></pre>"},{"location":"opcodes/midinoteonoct/#performance","title":"Performance","text":"<p>xoct -- returns MIDI key translated to linear octaves during MIDI activation, remains unchanged otherwise.</p> <p>xvelocity -- returns MIDI velocity during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the values of xoct and xvelocity with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the values of xoct and xvelocity remain unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midinoteonoct/#examples","title":"Examples","text":"<p>Here is an example of the midinoteonoct opcode. It uses the file midinoteonoct.csd.</p> Example of the midinoteonoct opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midinoteonoct.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidinoteonoct p4, p5                    ;gets a MIDI note number value as octave-point-decimal value into p4, and MIDI velocity into p5\n\nprint   p4                              ;display the key value when it changes and when key is pressed \nkvel = p5/127                           ;scale midi velocity to 0-1\nioct =  p4\nicps =  cpsoct(ioct)                    ;convert octave-point-decimal value into Hz\nkenv madsr 0.5, 0.8, 0.8, 0.5           ;amplitude envelope multiplied by\nasig pluck kenv*kvel, icps, icps, 2, 1  ;velocity value                         \n     outs  asig, asig                           \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 8.000 100       ; play these notes from score as well\ni 1 + 2 8.917 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1     8.00000\ni1     8.91700\ni1     9.33333\n</code></pre>"},{"location":"opcodes/midinoteonoct/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midinoteonoct/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midinoteonpch/","title":"Midinoteonpch","text":""},{"location":"opcodes/midinoteonpch/#midinoteonpch","title":"midinoteonpch","text":"<p>Gets a MIDI note number as a pitch-class value.</p> <p>midinoteonpch is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midinoteonpch/#syntax","title":"Syntax","text":"<pre><code>midinoteonpch xpch, xvelocity\n</code></pre>"},{"location":"opcodes/midinoteonpch/#performance","title":"Performance","text":"<p>xpch -- returns MIDI key translated to octave.pch during MIDI activation, remains unchanged otherwise.</p> <p>xvelocity -- returns MIDI velocity during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the values of xpch and xvelocity with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the values of xpch and xvelocity remain unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midinoteonpch/#examples","title":"Examples","text":"<p>Here is an example of the midinoteonpch opcode. It uses the file midinoteonpch.csd.</p> Example of the midinoteonpch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midinoteonpch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidinoteonpch p4, p5                            ;gets a MIDI note number value as octave-point-decimal value into p4, and MIDI velocity into p5\n\nprint   p4                                      ;display the pitch value when it changes and when key is pressed \nkvel =  kvel/127                                ;scale midi velocity to 0-1\nipch =  p4\nicps =  cpspch(ipch)                            ;convert octave-point-decimal value into Hz\nkenv madsr 0.5, 0.8, 0.8, 0.5                   ;amplitude envelope multiplied by\nasig pluck kenv*kvel, icps, icps, 2, 1          ;velocity value                 \n     outs  asig, asig                           \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 8.09 100        ; play these notes from score as well\ni 1 + 2 9.05 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1     8.09000\ni1     9.05000\n</code></pre>"},{"location":"opcodes/midinoteonpch/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midinoteonpch/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midion/","title":"Midion","text":""},{"location":"opcodes/midion/#midion","title":"midion","text":"<p>Generates MIDI note messages at k-rate.</p>"},{"location":"opcodes/midion/#syntax","title":"Syntax","text":"<pre><code>midion kchn, knum, kvel\n</code></pre>"},{"location":"opcodes/midion/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>knum -- note number (0-127)</p> <p>kvel -- velocity (0-127)</p> <p>midion (k-rate note on) plays MIDI notes with current kchn, knum and kvel. These arguments can be varied at k-rate. Each time the MIDI converted value of any of these arguments changes, last MIDI note played by current instance of midion is immediately turned off and a new note with the new argument values is activated. This opcode, as well as moscil, can generate very complex melodic textures if controlled by complex k-rate signals.</p> <p>Any number of midion opcodes can appear in the same Csound instrument, allowing a counterpoint-style polyphony within a single instrument.</p>"},{"location":"opcodes/midion/#examples","title":"Examples","text":"<p>Here is a simple example of the midion opcode. It uses the file midion_simple.csd.</p> <p>This example generates a minor chord over every note received on the MIDI input. It generates MIDI notes on csound's MIDI output, so be sure to connect something.</p> Simple Example of the midion opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1 ;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\n\ninstr 1 ;Triggered by MIDI notes on channel 1\n\n  ifund notnum\n  ivel  veloc\n\n  knote1 init ifund\n  knote2 init ifund + 3\n  knote3 init ifund + 5\n\n  ;minor chord on MIDI out channel 1\n  ;Needs something plugged to csound's MIDI output\n  midion 1, knote1,ivel\n  midion 1, knote2,ivel\n  midion 1, knote3,ivel\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Dummy ftable\nf0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the midion opcode. It uses the file midion_scale.csd.</p> <p>This example generates random notes from a given scale for every note received on the MIDI input. It generates MIDI notes on csound's MIDI output, so be sure to connect something.</p> Example of the midion opcode to generate random notes from a scale.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d        -M0  -Q1 ;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\ninstr 1 ; Triggered by MIDI notes on channel 1\n\n  ivel  veloc\n\n  krate = 8\n  iscale = 100 ;f\n\n  ; Random sequence from table f100\n  krnd  randh int(14),krate,-1\n  knote table abs(krnd),iscale\n  ; Generates random notes from the scale on ftable 100\n  ; on channel 1 of csound's MIDI output\n  midion 1,knote,ivel\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf100 0 32 -2  40 50 60 70 80 44 54 65 74 84 39 49 69 69\n\n; Dummy ftable\nf0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midion/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/midion/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 1997</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/midion2/","title":"Midion2","text":""},{"location":"opcodes/midion2/#midion2","title":"midion2","text":"<p>Sends noteon and noteoff messages to the MIDI OUT port when triggered by a value different than zero.</p>"},{"location":"opcodes/midion2/#syntax","title":"Syntax","text":"<pre><code>midion2 kchn, knum, kvel, ktrig\n</code></pre>"},{"location":"opcodes/midion2/#performance","title":"Performance","text":"<p>kchn -- MIDI channel (1-16)</p> <p>knum -- MIDI note number (0-127)</p> <p>kvel -- note velocity (0-127)</p> <p>ktrig -- trigger input signal (normally 0)</p> <p>Similar to midion, this opcode sends noteon and noteoff messages to the MIDI out port, but only when ktrig is non-zero. This opcode is can work together with the output of the trigger opcode.</p>"},{"location":"opcodes/midion2/#examples","title":"Examples","text":"<p>Here is an example of the midion2 opcode. It uses the file midion2.csd.</p> Example of the midion2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n -M0 -Q1 ;;;midi in and midi out\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps line 3, p3, .1     \nklf  lfo 1, kcps, 3     ;use a unipolar square to trigger\nktr  trigger klf, 1, 1  ;from 3 times to .1 time per sec.\n     midion2 1, 60, 100, ktr\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 20\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midion2/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/midion2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.492</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/midiout/","title":"Midiout","text":""},{"location":"opcodes/midiout/#midiout","title":"midiout","text":"<p>Sends a generic MIDI message to the MIDI OUT port.</p>"},{"location":"opcodes/midiout/#syntax","title":"Syntax","text":"<pre><code>midiout kstatus, kchan, kdata1, kdata2\n</code></pre>"},{"location":"opcodes/midiout/#performance","title":"Performance","text":"<p>kstatus -- the type of MIDI message. Can be:</p> <ul> <li>128 (note off)</li> <li>144 (note on)</li> <li>160 (polyphonic aftertouch)</li> <li>176 (control change)</li> <li>192 (program change)</li> <li>208 (channel aftertouch)</li> <li>224 (pitch bend)</li> <li>0 when no MIDI messages must be sent to the MIDI OUT port</li> </ul> <p>kchan -- MIDI channel (1-16)</p> <p>kdata1, kdata2 -- message-dependent data values</p> <p>midiout has no output arguments, because it sends a message to the MIDI OUT port implicitly. It works at k-rate. It sends a MIDI message only when kstatus is non-zero.</p> <p> Warning</p> <p>Normally kstatus should be set to 0. Only when the user intends to send a MIDI message, can it be set to the corresponding message type number.</p>"},{"location":"opcodes/midiout/#examples","title":"Examples","text":"<p>Here is an example of the midiout opcode. It uses the file midiout.csd.</p> Example of the midiout opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac -Ma -Q1 ;;;realtime audio out and midi out and midi in (all midi inputs)\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidiout 192, 1, 21, 0   ;program change to instr. 21\ninum notnum\nivel veloc\nmidion 1, inum, ivel\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3  80 100         ;play note for 3 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midiout/#see-also","title":"See also","text":"<p>MIDI Message Output</p> <p>Generic Input and Output</p>"},{"location":"opcodes/midiout/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.492</p>"},{"location":"opcodes/midiout_i/","title":"Midiout i","text":""},{"location":"opcodes/midiout_i/#midiout_i","title":"midiout_i","text":"<p>Sends a generic MIDI message to the MIDI OUT port.</p>"},{"location":"opcodes/midiout_i/#syntax","title":"Syntax","text":"<pre><code>midiout_i istatus, ichan, idata1, idata2\n</code></pre> <p>Initialisation</p> <p>istatus -- the type of MIDI message. Can be:</p> <ul> <li>128 (note off)</li> <li>144 (note on)</li> <li>160 (polyphonic aftertouch)</li> <li>176 (control change)</li> <li>192 (program change)</li> <li>208 (channel aftertouch)</li> <li>224 (pitch bend)</li> <li>0 when no MIDI messages must be sent to the MIDI OUT port</li> </ul> <p>ichan -- MIDI channel (1-16)</p> <p>idata1, idata2 -- message-dependent data values</p> <p>midiout_i has no output arguments, because it sends a message to the MIDI OUT port implicitly. It works at i-time. It sends a MIDI message only when istatus is non-zero.</p>"},{"location":"opcodes/midiout_i/#examples","title":"Examples","text":"<p>Here is an example of the midiout_i opcode. It uses the file midiout_i.csd.</p> Example of the midiout_i opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac -Ma -Q1 ;;;realtime audio out and midi out and midi in (all midi inputs)\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidiout_i       192, 1, 21, 0   ;program change to instr. 21\ninum notnum\nivel veloc\nmidion 1, inum, ivel\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3  80 100         ;play note for 3 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midiout_i/#see-also","title":"See also","text":"<p>MIDI Message Output</p> <p>Generic Input and Output</p>"},{"location":"opcodes/midiout_i/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 6.10</p>"},{"location":"opcodes/midipitchbend/","title":"Midipitchbend","text":""},{"location":"opcodes/midipitchbend/#midipitchbend","title":"midipitchbend","text":"<p>Gets a MIDI pitchbend value.</p> <p>midipitchbend is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midipitchbend/#syntax","title":"Syntax","text":"<pre><code>midipitchbend xpitchbend [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/midipitchbend/#initialization","title":"Initialization","text":"<p>ilow (optional) -- optional low value after rescaling, defaults to 0.</p> <p>ihigh (optional) -- optional high value after rescaling, defaults to 127.</p>"},{"location":"opcodes/midipitchbend/#performance","title":"Performance","text":"<p>xpitchbend -- returns the MIDI pitch bend during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the value of xpitchbend with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the value of xpitchbend remains unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midipitchbend/#examples","title":"Examples","text":"<p>Here is an example of the midipitchbend opcode. It uses the file midipitchbend.csd.</p> Example of the midipitchbend opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midipitchbend.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nmidinoteonoct p4, p5                            ;gets a MIDI note number value as octave-point-decimal value into p4, and MIDI velocity into p5\n\nkvel = p5/127                                   ;scale midi velocity to 0-1\nkpb init 0\nmidipitchbend kpb\nprintk2 kpb                                     ;display the pitch-bend value when it changes\nkoct =  p4+kpb                                  ;add pitchbend values to octave-point-decimal value\nkcps =  cpsoct(koct)                            ;convert octave-point-decimal value into Hz                     \nkenv madsr 0.5, 0.8, 0.8, 0.5                   ;amplitude envelope multiplied by\nasig vco2 kenv*kvel, kcps                       ;velocity value                 \n     outs  asig, asig                           \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 \n\ni 1 0 2 8.000 100       ; play these notes from score as well\ni 1 + 2 8.917 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1     0.12695\ni1     0.00000\ni1    -0.01562\n</code></pre>"},{"location":"opcodes/midipitchbend/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midipitchbend/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midipolyaftertouch/","title":"Midipolyaftertouch","text":""},{"location":"opcodes/midipolyaftertouch/#midipolyaftertouch","title":"midipolyaftertouch","text":"<p>Gets a MIDI polyphonic aftertouch value.</p> <p>midipolyaftertouch is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midipolyaftertouch/#syntax","title":"Syntax","text":"<pre><code>midipolyaftertouch xpolyaftertouch, xkey [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/midipolyaftertouch/#initialization","title":"Initialization","text":"<p>ilow (optional) -- optional low value after rescaling, defaults to 0.</p> <p>ihigh (optional) -- optional high value after rescaling, defaults to 127.</p>"},{"location":"opcodes/midipolyaftertouch/#performance","title":"Performance","text":"<p>xpolyaftertouch -- returns MIDI polyphonic aftertouch of the selected note during MIDI activation, remains unchanged otherwise.</p> <p>xkey -- specifies the MIDI key to read from.  It normally should be set to the note number that the instrument instance is playing.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the value of xpolyaftertouch  with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the value remains unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midipolyaftertouch/#examples","title":"Examples","text":"<p>Here is an example of the midipolyaftertouch opcode. It uses the file midipolyaftertouch.csd.</p> Example of the midipolyaftertouch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1  ;;;realtime audio out and midi in \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midipolyaftertouch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1;midi keyboard and score are used\n\nmidinoteoncps p4, p5                            ;puts MIDI key translated to cycles per second into p4, and MIDI velocity into p5\n\nkafter  init 127                                ;full open                              \nmidipolyaftertouch  kafter, 1\nprintk2 kafter                                  ;display the key value when it changes and when key is pressed\n\nkvel = p5/127                                   ;scale midi velocity to 0-1\nkenv madsr 0.5, 0.8, 0.8, 0.5                   ;amplitude envelope multiplied by\nain  pluck kenv*kvel, p4, p4, 2, 1              ;velocity value                 \nasig moogvcf2 ain, 300+(kafter*100), .5         ;use value of aftertouch to control frequency of filter\n     outs  asig, asig                           ;base freq of filter = 300 Hz\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds\nf 2 0 4096 10 1 ;sine wave\n\ni 1 0 2 440 100 ;play these notes from score as well\ni 1 + 2 1440 100\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1   127.00000\ni1    20.00000\ni1    44.00000\n</code></pre>"},{"location":"opcodes/midipolyaftertouch/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midipolyaftertouch/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/midiprogramchange/","title":"Midiprogramchange","text":""},{"location":"opcodes/midiprogramchange/#midiprogramchange","title":"midiprogramchange","text":"<p>Gets a MIDI program change value.</p> <p>midiprogramchange is designed to simplify writing instruments that can be used interchangeably for either score or MIDI input, and to make it easier to adapt instruments originally written for score input to work with MIDI input.</p> <p>In general, it should be possible to write instrument definitions that work identically with both scores and MIDI, including both MIDI files and real-time MIDI input, without using any conditional statements, and that take full advantage of MIDI voice messages.</p> <p>Note that correlating Csound instruments with MIDI channel numbers is done using the massign opcode for real-time performance,.  For file-driven performance, instrument numbers default to MIDI channel number + 1, but the defaults are overridden by any MIDI program change messages in the file.</p>"},{"location":"opcodes/midiprogramchange/#syntax","title":"Syntax","text":"<pre><code>midiprogramchange xprogram\n</code></pre>"},{"location":"opcodes/midiprogramchange/#performance","title":"Performance","text":"<p>xprogram -- returns the MIDI program change value during MIDI activation, remains unchanged otherwise.</p> <p>If the instrument was activated by MIDI input, the opcode overwrites the value of xprogram with the corresponding value from MIDI input. If the instrument was NOT activated by MIDI input, the value of xprogram remains unchanged.</p> <p>This enables score p-fields to receive MIDI input data during MIDI activation, and score values otherwise.</p> <p> Adapting a score-activated Csound instrument.</p> <p>See the MIDI interop opcodes section for details on adapting score driven instruments for MIDI or vice-versa.</p>"},{"location":"opcodes/midiprogramchange/#examples","title":"Examples","text":"<p>Here is an example of the midiprogramchange opcode. It uses the file midiprogramchange.csd.</p> Example of the midiprogramchange opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    -M1 -Q1  ;;;realtime audio out and midi in and midi out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o midiprogramchange.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;uses external midi device\n\nkkey init 0                                     ;initialize key number\nkvel init 0                                     ;initialize velocity\nmidiprogramchange 52                            ;choose GM program number 52 = string pad\nmidinoteonkey kkey, kvel                        ;MIDI note number value\nprintk2 kkey                                    ;display the key value when it changes and when key is pressed \nmidion 1, kkey, kvel                            ;sent note to external device\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 30  ;runs for 30 seconds    \n\ni 1 0 2 62      ; play these notes from score as well\ni 1 + 2 65\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/midiprogramchange/#see-also","title":"See also","text":"<p>MIDI/Score Interoperability</p>"},{"location":"opcodes/midiprogramchange/#credits","title":"Credits","text":"<p>Author: Michael Gogins</p> <p>New in version 4.20</p>"},{"location":"opcodes/miditempo/","title":"Miditempo","text":""},{"location":"opcodes/miditempo/#miditempo","title":"miditempo","text":"<p>Returns the current tempo at k-rate, of either the MIDI file (if available) or the score. (provided the -t option is used).</p>"},{"location":"opcodes/miditempo/#syntax","title":"Syntax","text":"<pre><code>ksig  miditempo\n</code></pre>"},{"location":"opcodes/miditempo/#examples","title":"Examples","text":"<p>Here is an example of the miditempo opcode. It uses the files miditempo.csd.</p> Example of the miditempo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -F Anna.mid ;;;realtime audio out and midi file input\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o miditempo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nmassign   0, 1  ; make sure that all channels\npgmassign 0, 1  ; and programs are assigned to test instr\n\ninstr 1\n\nksig    miditempo\nprints \"miditempo = %d\\\\n\", ksig\n\nicps  cpsmidi           ; convert midi note to pitch\nkenv  madsr   0.1, 0, 0.8, 0.3\nasig  pluck   kenv*.15, icps, icps, 1, 1 ;low volume     \n      outs    asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 0 200         ;stay active for 120 seconds\nf 1 0 4096 10 1 ;sine\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>miditempo = 96\n</code></pre>"},{"location":"opcodes/miditempo/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/miditempo/#credits","title":"Credits","text":"<p>Author: Istvan Varga March 2005 New in Csound5</p>"},{"location":"opcodes/min/","title":"Min","text":""},{"location":"opcodes/min/#min","title":"min","text":"<p>Produces a signal that is the minimum of any number of input signals.</p> <p>The min opcode takes any number of a-rate, k-rate or i-rate signals as input (all of the same rate), and outputs a signal at the same rate that is the minimum of all of the inputs.  For a-rate signals, the inputs are compared one sample at a time (i.e. min does not scan an entire ksmps period of a signal for its local minimum as the max_k opcode does).</p>"},{"location":"opcodes/min/#syntax","title":"Syntax","text":"<pre><code>amin min ain1, ain2 [, ain3] [, ain4] [...]\nkmin min kin1, kin2 [, kin3] [, kin4] [...]\nimin min iin1, iin2 [, iin3] [, iin4] [...]\n</code></pre>"},{"location":"opcodes/min/#performance","title":"Performance","text":"<p>ain1, ain2, ... --  a-rate signals to be compared.</p> <p>kin1, kin2, ... --  k-rate signals to be compared.</p> <p>iin1, iin2, ... --  i-rate signals to be compared.</p>"},{"location":"opcodes/min/#examples","title":"Examples","text":"<p>Here is an example of the min opcode. It uses the file min.csd.</p> Example of the min opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o min.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   oscili 1, 10.0, 1                  ;combine 3 sinusses\nk2   oscili 1, 1.0, 1                   ;at different rates\nk3   oscili 1, 3.0, 1\nkmin min   k1, k2, k3\nkmin = kmin*250                         ;scale kmin\nprintk2 kmin                            ;check the values\n\naout vco2 .5, 220, 6                    ;sawtooth\nasig moogvcf2 aout, 600+kmin, .5        ;change filter around 600 Hz            \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 32768 10 1\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/min/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/min/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01; i-rate version new in 6.04</p>"},{"location":"opcodes/minabs/","title":"Minabs","text":""},{"location":"opcodes/minabs/#minabs","title":"minabs","text":"<p>Produces a signal that is the minimum of the absolute values of any number of input signals.</p> <p>The minabs opcode takes any number of a-rate or k-rate signals as input (all of the same rate), and outputs a signal at the same rate that is the minimum of all of the inputs.  It is identical to the min opcode except that it takes the absolute value of each input before comparing them.  Therefore, the output is always non-negative.    For a-rate signals, the inputs are compared one sample at a time (i.e. minabs does not scan an entire ksmps period of a signal for its local minimum as the max_k opcode does).</p>"},{"location":"opcodes/minabs/#syntax","title":"Syntax","text":"<pre><code>amin minabs ain1, ain2 [, ain3] [, ain4] [...]\nkmin minabs kin1, kin2 [, kin3] [, kin4] [...]\n</code></pre>"},{"location":"opcodes/minabs/#performance","title":"Performance","text":"<p>ain1, ain2, ... --  a-rate signals to be compared.</p> <p>kin1, kin2, ... --  k-rate signals to be compared.</p>"},{"location":"opcodes/minabs/#examples","title":"Examples","text":"<p>Here is an example of the minabs opcode. It uses the file minabs.csd.</p> Example of the minabs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o minabs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   oscili 1, 10.0, 1                  ;combine 3 sinusses\nk2   oscili 1, 1.0, 1                   ;at different rates\nk3   oscili 1, 3.0, 1\nkmin minabs   k1, k2, k3\nkmin = kmin*250                         ;scale kmin\nprintk2 kmin                            ;check the values\n\naout vco2 .5, 220, 6                    ;sawtooth\nasig moogvcf2 aout, 600+kmin, .5        ;change filter above 600 Hz             \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32768 10 1\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/minabs/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/minabs/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/minabsaccum/","title":"Minabsaccum","text":""},{"location":"opcodes/minabsaccum/#minabsaccum","title":"minabsaccum","text":"<p>Accumulates the minimum of the absolute values of audio signals.</p> <p>minabsaccum compares two audio-rate variables and stores the minimum of their absolute values into the first.</p>"},{"location":"opcodes/minabsaccum/#syntax","title":"Syntax","text":"<pre><code>minabsaccum aAccumulator, aInput\n</code></pre>"},{"location":"opcodes/minabsaccum/#performance","title":"Performance","text":"<p>aAccumulator -- audio variable to store the minimum value</p> <p>aInput -- signal that aAccumulator is compared to</p> <p>The minabsaccum opcode is designed to accumulate the minimum value from among many audio signals that may be in different note instances, different channels, or otherwise cannot all be compared at once using the minabs opcode.  minabsaccum is identical to minaccum except that it takes the absolute value of aInput before the comparison.  Its semantics are similar to vincr since aAccumulator is used as both an input and an output variable, except that minabsaccum keeps the minimum absolute value instead of adding the signals together.  minabsaccum performs the following operation on each pair of samples:</p> <pre><code>if  (abs(aInput) &amp;lt; aAccumulator)  aAccumulator = abs(aInput)\n</code></pre> <p>aAccumulator will usually be a global audio variable.  At the end of any given computation cycle (k-period), after its value is read and used in some way, the accumulator variable should usually be reset to some large enough positive value that will always be greater than the input signals to which it is compared.</p>"},{"location":"opcodes/minabsaccum/#examples","title":"Examples","text":"<p>Here is an example of the minabsaccum opcode. It uses the file minabsaccum.csd.</p> Example of the minabsaccum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o minabsaccum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;saw\n\nasig  vco2 .2, p4               \n      outs  asig, asig                          \ngasaw = asig\nendin\n\ninstr 2 ;sine\n\naout  poscil .3, p4, 1          \n      outs  aout, aout                          \ngasin = aout\nendin\n\ninstr 10\n\naccum init 0    \n      minabsaccum  accum, gasaw + gasin         ;saw and sine accumulated       \naccum dcblock2 accum                            ;get rid of DC\n      outs  accum, accum        \n\nclear accum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 \n\ni 1 0 7 330\ni 2 3 3 440\n\ni 1 10 7 330    ;same notes but without minabsaccum, for comparison\ni 2 13 3 440\n\ni 10 0 6        ;accumulation note stops after 6 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/minabsaccum/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/minabsaccum/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/minaccum/","title":"Minaccum","text":""},{"location":"opcodes/minaccum/#minaccum","title":"minaccum","text":"<p>Accumulates the minimum value of audio signals.</p> <p>minaccum compares two audio-rate variables and stores the minimum value between them into the first.</p>"},{"location":"opcodes/minaccum/#syntax","title":"Syntax","text":"<pre><code>minaccum aAccumulator, aInput\n</code></pre>"},{"location":"opcodes/minaccum/#performance","title":"Performance","text":"<p>aAccumulator -- audio variable to store the minimum value</p> <p>aInput -- signal that aAccumulator is compared to</p> <p>The minaccum opcode is designed to accumulate the minimum value from among many audio signals that may be in different note instances, different channels, or otherwise cannot all be compared at once using the min opcode.  Its semantics are similar to vincr since aAccumulator is used as both an input and an output variable, except that minaccum keeps the minimum value instead of adding the signals together.  minaccum performs the following operation on each pair of samples:</p> <pre><code>if  (aInput &amp;lt; aAccumulator)  aAccumulator = aInput\n</code></pre> <p>aAccumulator will usually be a global audio variable.  At the end of any given computation cycle (k-period), after its value is read and used in some way, the accumulator variable should usually be reset to some large enough positive value that will always be greater than the input signals to which it is compared.</p>"},{"location":"opcodes/minaccum/#examples","title":"Examples","text":"<p>Here is an example of the minaccum opcode. It uses the file minaccum.csd.</p> Example of the minaccum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o minaccum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;saw\n\nasig  vco2 .2, p4               \n      outs  asig, asig                          \ngasaw = asig\nendin\n\ninstr 2 ;sine\n\naout  poscil .3, p4, 1          \n      outs  aout, aout                          \ngasin = aout\nendin\n\ninstr 10\n\naccum init 0    \n      minaccum accum, gasaw + gasin             ;saw and sine accumulated               \n      outs  accum, accum\n\nclear accum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 \n\ni 1 0 7 330\ni 2 3 3 440\n\ni 1 10 7 330    ;same notes but without minaccum, for comparison\ni 2 13 3 440\n\ni 10 0 6        ;accumulation note stops after 6 seconds\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/minaccum/#see-also","title":"See also","text":"<p>Comparators and Accumulators</p>"},{"location":"opcodes/minaccum/#credits","title":"Credits","text":"<p>Author: Anthony Kozar March 2006</p> <p>New in Csound version 5.01</p>"},{"location":"opcodes/minarray/","title":"Minarray","text":""},{"location":"opcodes/minarray/#minarray","title":"minarray","text":"<p>Returns the minimum value in a k-rate array, and optional its index.</p>"},{"location":"opcodes/minarray/#syntax","title":"Syntax","text":"<pre><code>kmin [,kindx] minarray karray\n</code></pre>"},{"location":"opcodes/minarray/#performance","title":"Performance","text":"<p>kmin --  variable for result.</p> <p>kindx --  position (index) of result in array.</p> <p>karray --  array for reading.</p>"},{"location":"opcodes/minarray/#examples","title":"Examples","text":"<p>Here is an example of the minarray opcode. It uses the file minarray.csd.</p> Example of the minarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nksmps = 32\n;example by joachim heintz\n\n           seed       0\n\ninstr 1\n;create an array with 10 elements\nkArr[]     init       10\n;fill in random numbers and print them out\nkIndx      =          0\n  until kIndx == 10 do\nkNum       random     -100, 100\nkArr[kIndx] =         kNum\n           printf     \"kArr[%d] = %10f\\n\", kIndx+1, kIndx, kNum\nkIndx      +=         1\n  od\n;investigate minimum number and print it out\nkMin, kMinIndx minarray kArr\n           printf     \"Minimum of kArr = %f at index %d\\n\", kIndx+1, kMin, kMinIndx\n           turnoff\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/minarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/minarray/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.14</p> <p>Revised in Csound version 6.00 to work on multidimensional arrays</p>"},{"location":"opcodes/mirror/","title":"Mirror","text":""},{"location":"opcodes/mirror/#mirror","title":"mirror","text":"<p>Reflects the signal that exceeds the low and high thresholds.</p>"},{"location":"opcodes/mirror/#syntax","title":"Syntax","text":"<pre><code>ares mirror asig, klow, khigh\nires mirror isig, ilow, ihigh\nkres mirror ksig, klow, khigh\n</code></pre>"},{"location":"opcodes/mirror/#initialization","title":"Initialization","text":"<p>isig -- input signal</p> <p>ilow -- low threshold</p> <p>ihigh -- high threshold</p>"},{"location":"opcodes/mirror/#performance","title":"Performance","text":"<p>xsig -- input signal</p> <p>klow -- low threshold</p> <p>khigh -- high threshold</p> <p>mirror \u201creflects\u201d the signal that exceeds the low and high thresholds.</p> <p>This opcode is useful in several situations, such as table indexing or for clipping and modeling a-rate, i-rate or k-rate signals.</p>"},{"location":"opcodes/mirror/#examples","title":"Examples","text":"<p>Here is an example of the mirror opcode. It uses the file mirror.csd.</p> Example of the mirror opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mirror.wav -W  ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr    1 ; Limit / Mirror / Wrap\n\nigain    = p4                           ;gain\nilevl1   = p5                           ; + level\nilevl2   = p6                           ; - level\nimode    = p7                           ;1 = limit, 2 = mirror, 3 = wrap\n\nain   soundin  \"fox.wav\"\nain   = ain*igain\n\nif    imode = 1 goto limit\nif    imode = 2 goto mirror\n\nasig  wrap  ain, ilevl2, ilevl1\ngoto  outsignal\n\nlimit:\nasig  limit  ain, ilevl2, ilevl1\ngoto  outsignal\n\nmirror:\nasig  mirror  ain, ilevl2, ilevl1\noutsignal:\n\nouts  asig*.5, asig*.5                  ;mind your speakers\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;           Gain  +Levl -Levl Mode\ni1  0  3    4.00  .25  -1.00   1        ;limit\ni1  4  3    4.00  .25  -1.00   2        ;mirror\ni1  8  3    4.00  .25  -1.00   3        ;wrap\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mirror/#see-also","title":"See also","text":"<p>Signal Limiters</p>"},{"location":"opcodes/mirror/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/mode/","title":"Mode","text":""},{"location":"opcodes/mode/#mode","title":"mode","text":"<p>A filter that simulates a mass-spring-damper system</p> <p>Filters the incoming signal with the specified resonance frequency and quality factor. It can also be seen as a signal generator for high quality factor, with an impulse for the excitation. You can combine several modes to built complex instruments such as bells or guitar tables.</p>"},{"location":"opcodes/mode/#syntax","title":"Syntax","text":"<pre><code>aout mode ain, xfreq, xQ [, iskip]\n</code></pre>"},{"location":"opcodes/mode/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter.</p>"},{"location":"opcodes/mode/#performance","title":"Performance","text":"<p>aout -- filtered signal</p> <p>ain -- signal to filter</p> <p>xfreq -- resonant frequency of the filter</p> <p> Warning</p> <p>As this filter would become unstable if sr/xfreq &lt; pi, the value of the xfreq is limited to sr/pi-sr/100 internally (e.g xfreq &gt; 13596 Hz @ 44.1 kHz). The sr/100 term is because the filter while mathematically stable has a very large amplification as it approaches the unstable region.</p> <p>xQ -- quality factor of the filter</p> <p>The resonance time is roughly proportional to xQ/xfreq.</p> <p>See Modal Frequency Ratios for frequency ratios of real instruments which can be used to determine the values of xfreq.</p>"},{"location":"opcodes/mode/#examples","title":"Examples","text":"<p>Here is an example of the mode opcode. It uses the file mode.csd.</p> Example of the mode opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o moogvcf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\ninstr 1; 2 modes excitator\n\nidur init p3\nifreq11 init p4\nifreq12 init p5\niQ11    init p6\niQ12    init p7\niamp    init ampdb(p8)\nifreq21 init p9\nifreq22 init p10\niQ21    init p11\niQ22    init p12\n\n; to simulate the shock between the excitator and the resonator\nashock  mpulse  3,0 \n\naexc1  mode ashock,ifreq11,iQ11\naexc1 = aexc1*iamp\naexc2  mode ashock,ifreq12,iQ12\naexc2 = aexc2*iamp\n\n\naexc = (aexc1+aexc2)/2\n\n;\"Contact\" condition : when aexc reaches 0, the excitator looses \n;contact with the resonator, and stops \"pushing it\"\naexc limit aexc,0,3*iamp \n\n; 2modes resonator\n\nares1  mode aexc,ifreq21,iQ21\nares2  mode aexc,ifreq22,iQ22\n\nares = (ares1+ares2)/2\n\ndisplay aexc+ares,p3\nouts  aexc+ares,aexc+ares\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;wooden excitator against glass resonator\ni1 0 8  1000   3000  12  8  70  440   888   500  420 \n\n;felt against glass\ni1 4 8  80   188  8  3  70  440   888   500  420 \n\n;wood against wood\ni1 8 8  1000   3000  12  8  70  440  630   60  53 \n\n;felt against wood\ni1 12 8  80   180  8  3  70  440  630   60  53 \n\n\ni1 16 8  1000   3000  12  8  70  440  888   2000  1630\ni1 23 8  80   180  8  3  70  440  888   2000  1630\n\n\n;With a metallic excitator\n\ni1 33 8 1000  1800  1000  720  70   440   882  500  500\ni1 37 8 1000  1800  1000  850  70   440   630  60  53\n\ni1 42 8 1000  1800  2000  1720  70   440   442  500  500\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mode/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/mode/#credits","title":"Credits","text":"<p>Original UDO and documentation/example by Fran\u00e7ois Blanc</p> <p>Opcode translation to C-code by Steven Yi</p> <p>New in version 5.04</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/modulus/","title":"Modulus","text":""},{"location":"opcodes/modulus/#_1","title":"%","text":"<p>Modulus operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> <pre><code>a + b * c.\n</code></pre> <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p> <p>The operator % returns the value of \\(a\\) reduced by \\(b\\), so that the result, in absolute value, is less than the absolute value of \\(b\\), by repeated subtraction. This is technically a remainder, like the % operator in C and similar languages, and not actually a modulus. New in Csound version 3.50.</p>"},{"location":"opcodes/modulus/#syntax","title":"Syntax","text":"<pre><code>a % b  (no rate restriction)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/modulus/#arguments","title":"Arguments","text":"<p>The arguments of % can be scalar values or k-rate one dimensional arrays (vectors), or any combination.  If one of the arguments is an array, so is the value.</p>"},{"location":"opcodes/modulus/#examples","title":"Examples","text":"<p>Here is an example of the % operator. It uses the file modulus.csd.</p> Example of the % operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Ma --midi-key=4 --midi-velocity-amp=5 -m0  ;;;realtime audio out and midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o %.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiScale ftgen 1, 0, -12, -2, 0, -34, -7, 10, -14, 3, -21, -3, -27, -10, 7, -17  ;12 note scale with detuned keys\n\ninstr 1\n\nikey    = p4\nivel    = p5\nindx    = ikey % 12                                                             ;work on the twelftone scale\nicent   tab_i indx, giScale                                                     ;load the scale\nifreqeq = cpsmidinn(ikey)\nifreq   = ifreqeq * cent(icent)                                                 ;change frequency by cents from table\nprints  \"Key %d modulus 12 =  %d. \", ikey, indx\nprints  \"Equal-tempered frequency of this key  = %f,\", ifreqeq\nprints  \" but here with cent deviation %d = %f%n\", icent, ifreq\nasig    vco2 ivel*.5, ifreq\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 60          ;run for 60 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/modulus/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/modulus/#credits","title":"Credits","text":"<p>Arithmetic on vectors is new in version 6.00</p>"},{"location":"opcodes/monitor/","title":"Monitor","text":""},{"location":"opcodes/monitor/#monitor","title":"monitor","text":"<p>Returns the audio spout frame (if active), otherwise it returns zero.</p>"},{"location":"opcodes/monitor/#syntax","title":"Syntax","text":"<pre><code>aout1 [,aout2 ... aoutX] monitor\naarra monitor\n</code></pre>"},{"location":"opcodes/monitor/#performance","title":"Performance","text":"<p>In the array form it reads all chanels to a one dimensional array.</p> <p>This opcode can be used for monitoring the output signal from csound. It should not be used for processing the signal further.</p> <p>See the entry for the fout opcode for an example of usage of monitor.</p>"},{"location":"opcodes/monitor/#examples","title":"Examples","text":"<p>Here is an example of the monitor opcode. It uses the file monitor.csd.</p> Example of the monitor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o monitor.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nasig poscil3 .5, 880, giSine\n;write a raw file: 32 bits with header\n     fout \"fout_880.wav\", 15, asig      \n     outs asig, asig\n\nendin\n\ninstr 2\n\nklfo lfo 1, 2, 0\nasig poscil3 .5*klfo, 220, giSine\n;write an aiff file: 32 bits with header\n     fout \"fout_aif.aiff\", 25, asig     \n;        fout \"fout_all3.wav\", 14, asig\n     outs asig, asig\n\nendin\n\ninstr 99 ;read the stereo csound output buffer\n\nallL, allR monitor\n;write the output of csound to an audio file\n;to a wav file: 16 bits with header\n           fout \"fout_all.wav\", 14, allL, allR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 0 3\ni 99 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/monitor/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/monitor/#credits","title":"Credits","text":"<p>Istvan Varga 2006</p> <p>John ffitch 2016 for array form, new in 6.08</p>"},{"location":"opcodes/moog/","title":"Moog","text":""},{"location":"opcodes/moog/#moog","title":"moog","text":"<p>An emulation of a mini-Moog synthesizer.</p>"},{"location":"opcodes/moog/#syntax","title":"Syntax","text":"<pre><code>ares moog kamp, kfreq, kfiltq, kfiltrate, kvibf, kvamp, iafn, iwfn, ivfn\n</code></pre>"},{"location":"opcodes/moog/#initialization","title":"Initialization","text":"<p>iafn, iwfn, ivfn -- three table numbers containing the attack waveform (unlooped), the main looping wave form, and the vibrato waveform. The files mandpluk.aiff and impuls20.aiff are suitable for the first two, and a sine wave for the last.</p> <p> Note</p> <p>The files \u201cmandpluk.aiff\u201d and \u201cimpuls20.aiff\u201d are also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p>"},{"location":"opcodes/moog/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kfiltq -- Q of the filter, in the range 0.8 to 0.9</p> <p>kfiltrate -- rate control for the filter in the range 0 to 0.0002</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/moog/#examples","title":"Examples","text":"<p>Here is an example of the moog opcode. It uses the file moog.csd, mandpluk.aiff, and impuls20.aiff.</p> Example of the moog opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o moog.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq  = cpspch(p4)\nkfiltq = p5\nkfiltrate = 0.0002\nkvibf  = 5\nkvamp  = .01\n;low volume is needed\nasig moog .15, kfreq, kfiltq, kfiltrate, kvibf, kvamp, 1, 2, 3\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 8192 1 \"mandpluk.aiff\" 0 0 0\nf 2 0 256 1 \"impuls20.aiff\" 0 0 0\nf 3 0 256 10 1  ; sine\n\ni 1 0 3 6.00 .1\ni 1 + 3 6.05 .89\ni 1 + 3 6.09 .50\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moog/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/moog/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/moogladder/","title":"Moogladder","text":""},{"location":"opcodes/moogladder/#moogladder","title":"moogladder","text":"<p>Moog ladder lowpass filter.</p> <p>Moogladder is an new digital implementation of the Moog ladder filter based on the work of Antti Huovilainen, described in the paper \"Non-Linear Digital Implementation of the Moog Ladder Filter\" (Proceedings of DaFX04, Univ of Napoli). This implementation is probably a more accurate digital representation of the original analogue filter.</p>"},{"location":"opcodes/moogladder/#syntax","title":"Syntax","text":"<pre><code>asig moogladder ain, kcf, kres[, istor]\nasig moogladder ain, acf, kres[, istor]\nasig moogladder ain, kcf, ares[, istor]\nasig moogladder ain, acf, ares[, istor]\n</code></pre>"},{"location":"opcodes/moogladder/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/moogladder/#performance","title":"Performance","text":"<p>asig -- input signal.</p> <p>kcf/acf -- filter cutoff frequency</p> <p>kres/ares -- resonance, generally &lt; 1, but not limited to it.  Higher than 1 resonance values might cause aliasing, analogue synths generally allow resonances to be above 1.</p>"},{"location":"opcodes/moogladder/#examples","title":"Examples","text":"<p>Here is an example of the moogladder opcode. It uses the file moogladder.csd.</p> Example of the moogladder opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o moogladder.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfe  expseg 500, p3*0.9, 1800, p3*0.1, 3000\nasig buzz  1, 100, 20, 1\nkres line .1, p3, .99   ;increase resonance\nafil moogladder asig, kfe, kres\n     outs afil, afil\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moogladder/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/moogladder/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini January 2005</p> <p>New plugin in version 5</p> <p>January 2005.</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/moogladder2/","title":"Moogladder2","text":""},{"location":"opcodes/moogladder2/#moogladder2","title":"moogladder2","text":"<p>Moog ladder lowpass filter.</p> <p>Moogladder2 is an new digital implementation of the Moog ladder filter based on the work of Antti Huovilainen, described in the paper \"Non-Linear Digital Implementation of the Moog Ladder Filter\" (Proceedings of DaFX04, Univ of Napoli). This implementation uses approximations to the tanh function and so is faster but less accurate than moogladder.</p>"},{"location":"opcodes/moogladder2/#syntax","title":"Syntax","text":"<pre><code>asig moogladder2 ain, kcf, kres[, istor]\nasig moogladder2 ain, acf, kres[, istor]\nasig moogladder2 ain, kcf, ares[, istor]\nasig moogladder2 ain, acf, ares[, istor]\n</code></pre>"},{"location":"opcodes/moogladder2/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/moogladder2/#performance","title":"Performance","text":"<p>asig -- input signal.</p> <p>kcf/acf -- filter cutoff frequency</p> <p>kres/ares -- resonance, generally &lt; 1, but not limited to it.  Higher than 1 resonance values might cause aliasing, analogue synths generally allow resonances to be above 1.</p>"},{"location":"opcodes/moogladder2/#examples","title":"Examples","text":"<p>Here is an example of the moogladder2 opcode. It uses the file moogladder2.csd.</p> Example of the moogladder2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o moogladder2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfe  expseg 500, p3*0.9, 1800, p3*0.1, 3000\nasig buzz  1, 100, 20, 1\nkres line .1, p3, .99   ;increase resonance\nafil moogladder2 asig, kfe, kres\n     outs afil, afil\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moogladder2/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/moogladder2/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Author: John ffitch April 2016</p> <p>New in version 6.07</p>"},{"location":"opcodes/moogvcf/","title":"Moogvcf","text":""},{"location":"opcodes/moogvcf/#moogvcf","title":"moogvcf","text":"<p>A digital emulation of the Moog diode ladder filter configuration.</p>"},{"location":"opcodes/moogvcf/#syntax","title":"Syntax","text":"<pre><code>ares moogvcf asig, xfco, xres [,iscale, iskip]\n</code></pre>"},{"location":"opcodes/moogvcf/#initialization","title":"Initialization","text":"<p>iscale (optional, default=1) -- internal scaling factor. Use if asig is not in the range +/-1. Input is first divided by iscale, then output is mutliplied iscale. Default value is 1. (New in Csound version 3.50)</p> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/moogvcf/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xfco -- filter cut-off frequency in Hz. As of version 3.50, may i-,k-, or a-rate.</p> <p>xres -- amount of resonance. Self-oscillation occurs when xres is approximately one. As of version 3.50, may a-rate, i-rate, or k-rate.</p> <p>moogvcf is a digital emulation of the Moog diode ladder filter configuration. This emulation is based loosely on the paper \u201cAnalyzing the Moog VCF with Considerations for Digital Implementation\u201d by Stilson and Smith (CCRMA). This version was originally coded in Csound by Josep Comajuncosas. Some modifications and conversion to C were done by Hans Mikelson.</p> <p> Warning</p> <p>Before version 6.02 this filter required that the input signal be normalized to one. This can be easily achieved using 0dbfs, like this:</p> <pre><code>ares moogvcf asig, kfco, kres, 0dbfs\n</code></pre> <p>You can also use moogvcf2 which defaults scaling to 0dbfs.</p>"},{"location":"opcodes/moogvcf/#examples","title":"Examples","text":"<p>Here is an example of the moogvcf opcode. It uses the file moogvcf.csd.</p> Example of the moogvcf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o moogvcf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n; iscale does not need to be set here because already 0dbfs = 1  \naout vco .3, 220, 1     ; Use a nice sawtooth waveform.\nkfco line 200, p3, 2000 ; filter-cutoff frequency from .2 to 2 KHz\nkrez init p4\nasig moogvcf aout, kfco, krez\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;a sine wave\nf 1 0 16384 10 1\n\ni 1 0 3 .1\ni 1 + 3 .7\ni 1 + 3 .95\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moogvcf/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/moogvcf/#credits","title":"Credits","text":"<p>Author: Hans Mikelson October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/moogvcf2/","title":"Moogvcf2","text":""},{"location":"opcodes/moogvcf2/#moogvcf2","title":"moogvcf2","text":"<p>A digital emulation of the Moog diode ladder filter configuration.</p>"},{"location":"opcodes/moogvcf2/#syntax","title":"Syntax","text":"<pre><code>ares moogvcf2 asig, xfco, xres [,iscale, iskip]\n</code></pre>"},{"location":"opcodes/moogvcf2/#initialization","title":"Initialization","text":"<p>iscale (optional, default=0dBfs) -- internal scaling factor, as the operation of the code requires the signal to be in the range +/-1.  Input is first divided by iscale, then output is mutliplied by iscale.</p> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter.</p>"},{"location":"opcodes/moogvcf2/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xfco -- filter cut-off frequency in Hz. which may be i-,k-, or a-rate.</p> <p>xres -- amount of resonance. Self-oscillation occurs when xres is approximately one. May be a-rate, i-rate, or k-rate.</p> <p>moogvcf2 is a digital emulation of the Moog diode ladder filter configuration. This emulation is based loosely on the paper \u201cAnalyzing the Moog VCF with Considerations for Digital Implementation\u201d by Stilson and Smith (CCRMA). This version was originally coded in Csound by Josep Comajuncosas. Some modifications and conversion to C were done by Hans Mikelson and then adjusted.</p> <p>moogvcf2 is identical to moogvcf, except that the iscale parameter defaults to 0dbfs instead of 0, guaranteeing that amplitude will usually be OK.</p>"},{"location":"opcodes/moogvcf2/#examples","title":"Examples","text":"<p>Here is an example of the moogvcf2 opcode. It uses the file moogvcf2.csd.</p> Example of the moogvcf2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o moogvcf2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naout diskin2 \"drumsMlp.wav\", 1, 0, 1\nkfco line 100, p3, 10000                ;filter-cutoff\nkrez init p4\nasig moogvcf2 aout, kfco, krez\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 .1\ni 1 + 4 .6\ni 1 + 4 .9\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moogvcf2/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/moogvcf2/#credits","title":"Credits","text":"<p>Author: Hans Mikelson and John ffitch October 1998/ July 2006</p> <p>New in Csound version 5.03</p>"},{"location":"opcodes/moscil/","title":"Moscil","text":""},{"location":"opcodes/moscil/#moscil","title":"moscil","text":"<p>Sends a stream of the MIDI notes.</p>"},{"location":"opcodes/moscil/#syntax","title":"Syntax","text":"<pre><code>moscil kchn, knum, kvel, kdur, kpause\n</code></pre>"},{"location":"opcodes/moscil/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>knum -- note number (0-127)</p> <p>kvel -- velocity (0-127)</p> <p>kdur -- note duration in seconds</p> <p>kpause -- pause duration after each noteoff and before new note in seconds</p> <p>moscil and midion are the most powerful MIDI OUT opcodes. moscil (MIDI oscil) plays a stream of notes of kdur duration. Channel, pitch, velocity, duration and pause can be controlled at k-rate, allowing very complex algorithmically generated melodic lines. When current instrument is deactivated, the note played by current instance of moscil is forcedly truncated.</p> <p>Any number of moscil opcodes can appear in the same Csound instrument, allowing a counterpoint-style polyphony within a single instrument.</p>"},{"location":"opcodes/moscil/#examples","title":"Examples","text":"<p>Here is an example of the moscil opcode. It uses the file moscil.csd.</p> <p>This example generates a stream of notes for every note received on the MIDI input. It generates MIDI notes on csound's MIDI output, so be sure to connect something.</p> Example of the moscil opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\n\ninstr 1  ;Triggered by MIDI notes on channel 1\n\n  inote notnum\n  ivel  veloc\n\n  kpitch = 40\n  kfreq  = 2\n\n  kdur   =  .04\n  kpause =  .1\n\n  k1    lfo     kpitch, kfreq,5\n\n  ;plays a stream of notes of kdur duration on MIDI channel 1\n  moscil  1, inote + k1, ivel,   kdur, kpause\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Dummy ftable\nf0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/moscil/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/moscil/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 1997</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/mp3in/","title":"Mp3in","text":""},{"location":"opcodes/mp3in/#mp3in","title":"mp3in","text":"<p>Reads mono or stereo audio data from an external MP3 file.</p>"},{"location":"opcodes/mp3in/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 mp3in ifilcod[, iskptim, iformat, iskipinit, ibufsize]\nar1 mp3in ifilcod[, iskptim, iformat, iskipinit, ibufsize]\n</code></pre>"},{"location":"opcodes/mp3in/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.filcod ; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR.</p> <p>iskptim (optional) -- time in seconds of input sound to be skipped. The default value is 0.</p> <p>iformat (optional) -- specifies the audio data file format:  currently not implemented and always defaults to stereo.</p> <p>iskipinit (optional) -- switches off all initialisation if non zero (default =0).</p> <p>ibuffersize (optional) -- sets the internal buffer size for reading.  If the value is omitted, zero or negative it defaults to 4096 bytes.</p>"},{"location":"opcodes/mp3in/#performance","title":"Performance","text":"<p>Reads audio data from an external MP3 file.</p>"},{"location":"opcodes/mp3in/#examples","title":"Examples","text":"<p>Here is an example of the mp3in opcode. It uses the file mp3in.csd.</p> Example of the mp3in opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mp3in.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niskptim  = .3\nibufsize = 64\nar1, ar2 mp3in \"beats.mp3\", iskptim, 0, 0, ibufsize\n         outs ar1, ar2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mp3in/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/mp3in/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2009</p> <p>New in version 5.11</p> <p>Mono added in 6.05</p>"},{"location":"opcodes/mp3len/","title":"Mp3len","text":""},{"location":"opcodes/mp3len/#mp3len","title":"mp3len","text":"<p>Returns the length of an MP3 sound file.</p>"},{"location":"opcodes/mp3len/#syntax","title":"Syntax","text":"<pre><code>ir mp3len ifilcod\n</code></pre>"},{"location":"opcodes/mp3len/#initialization","title":"Initialization","text":"<p>ifilcod -- sound file to be queried</p>"},{"location":"opcodes/mp3len/#performance","title":"Performance","text":"<p>mp3len returns the length of the sound file ifilcod in seconds.</p>"},{"location":"opcodes/mp3len/#examples","title":"Examples","text":"<p>Here is an example of the mp3len opcode. It uses the file mp3len.csd.</p> Example of the mp3len opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o mp3len.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nilen   mp3len p4        ;calculate length of mp3 file\nprint  ilen\n\nasigL, asigR mp3in p4\n       outs  asigL, asigR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 30 \"XORNOT_jul-14-05.mp3\"    ; long signal\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mp3len/#see-also","title":"See also","text":"<p>Sound File Queries</p>"},{"location":"opcodes/mp3len/#credits","title":"Credits","text":"<p>Author: John ffitch Feb 2011</p> <p>New in Csound version 5.14</p>"},{"location":"opcodes/mpulse/","title":"Mpulse","text":""},{"location":"opcodes/mpulse/#mpulse","title":"mpulse","text":"<p>Generates a set of impulses.</p> <p>The impulses have amplitude kamp separated by kintvl seconds (or samples if kintvl is negative).  The first impulse is generated after a delay of ioffset seconds.</p>"},{"location":"opcodes/mpulse/#syntax","title":"Syntax","text":"<pre><code>ares mpulse kamp, kintvl [, ioffset]\n</code></pre>"},{"location":"opcodes/mpulse/#initialization","title":"Initialization","text":"<p>ioffset (optional, default=0) -- the delay before the first impulse. If it is negative, the value is taken as the number of samples, otherwise it is in seconds. Default is zero.</p>"},{"location":"opcodes/mpulse/#performance","title":"Performance","text":"<p>kamp -- amplitude of the impulses generated</p> <p>kintvl -- Interval of time in seconds (or samples if kintvl is negative) to the next pulse.</p> <p>After the initial delay, an impulse of kamp amplitude is generated as a single sample.  Immediately after generating the impulse, the time of the next one is determined from the value of kintvl at that precise moment. This means that any changes in kintvl between impulses are discarded. If kintvl is zero, there is an infinite wait to the next impulse. If kintvl is negative, the interval is counted in number of samples rather than seconds.</p>"},{"location":"opcodes/mpulse/#examples","title":"Examples","text":"<p>Here is an example of the mpulse opcode. It uses the file mpulse.csd.</p> Example of the mpulse opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o mpulse.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\ngkfreq init 0.1\n\ninstr 1\n  kamp = 10000\n\n  a1 mpulse kamp, gkfreq\n  out a1\nendin\n\ninstr 2\n; Assign the value of p4 to gkfreq\ngkfreq init p4\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 11\ni 2 2 1    0.05\ni 2 4 1    0.01\ni 2 6 1    0.005\n; only last notes are audible\ni 2 8 1    0.003\ni 2 10 1    0.002\n\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Another example of how to use mpulse can be found here: mode</p>"},{"location":"opcodes/mpulse/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/mpulse/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in version 4.08</p>"},{"location":"opcodes/mrtmsg/","title":"Mrtmsg","text":""},{"location":"opcodes/mrtmsg/#mrtmsg","title":"mrtmsg","text":"<p>Send system real-time messages to the MIDI OUT port.</p>"},{"location":"opcodes/mrtmsg/#syntax","title":"Syntax","text":"<pre><code>mrtmsg imsgtype\n</code></pre>"},{"location":"opcodes/mrtmsg/#initialization","title":"Initialization","text":"<p>imsgtype -- type of real-time message:</p> <ul> <li>1 sends a START message (0xFA);</li> <li>2 sends a CONTINUE message (0xFB);</li> <li>0 sends a STOP message (0xFC);</li> <li>-1 sends a SYSTEM RESET message (0xFF);</li> <li>-2 sends an ACTIVE SENSING message (0xFE)</li> </ul>"},{"location":"opcodes/mrtmsg/#performance","title":"Performance","text":"<p>Sends a real-time message once, in init stage of current instrument. imsgtype parameter is a flag to indicate the message type.</p>"},{"location":"opcodes/mrtmsg/#see-also","title":"See Also","text":"<p>mclock</p> <p>System Realtime Messages</p>"},{"location":"opcodes/mrtmsg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/ms2st/","title":"Ms2st","text":""},{"location":"opcodes/ms2st/#ms2st","title":"ms2st","text":"<p>Mid-Side to stereo Conversion with a width control.</p> <p>It is a pure function with no side effects.</p> <p>The ms2st opcode decodes the MS stereo signal, but it also opens up the possibility to adjust the stereo width for every stereo sound; A stereo file can be encoded, using the st2ms opcode, and then decoded by ms2st. It is then possible to adjust the stereo width.</p>"},{"location":"opcodes/ms2st/#syntax","title":"Syntax","text":"<pre><code>aleft,aright ms2st am, as, kwidth\n</code></pre>"},{"location":"opcodes/ms2st/#performance","title":"Performance","text":"<p>aleft -- left channel output.</p> <p>aright -- right channel output.</p> <p>am -- mid signal input.</p> <p>as -- side signal input.</p> <p>kwidth -- stereo width (0 to 1). At 0, no side signal is output, and at 1 no mid signal is present. A value of 0.5 restores a stereo to MS conversion (st2ms) exactly.</p>"},{"location":"opcodes/ms2st/#examples","title":"Examples","text":"<p>Here is an example of the ms2st opcode. It uses the files ms2st.csd, MSjungle_interleaved.wav, MSjungleMid.wav and MSjungleSide.wav.</p> Example of the ms2st opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ms2st.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by  Menno Knevel - 2021\n; sample = ambient sound of waterfall + animals (monkey, birds)\n\ninstr 1 ; MS sample is interleaved\n\nam, as    diskin2    \"MSjungle_interleaved.wav\", 1, 0, 1 ; interleaved stereo, MS encoded\nkwidth = p4                                              ; left = M, right = S\nal, ar ms2st  am, as, kwidth\nouts al, ar\nendin\n\ninstr 2 ; 2 separate samples \n\nam    diskin2    \"MSjungleMid.wav\", 1        ; M sound as a separate mono sound\nas    diskin2    \"MSjungleSide.wav\", 1       ; S sound as a separate mono sound\nkwidth = p4     \nal, ar ms2st  am, as, kwidth\nouts al, ar\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 6.7 0          ; M only\ni1 + 6.7 .3         ; M and a bit of S\ni1 + 6.7 .5         ; M + S equal volume\ni1 + 6.7 1          ; S only \n\ni2 28 6.7 0         ; M only\ni2 +  6.7 .3        ; M and a bit of S\ni2 +  6.7 .5        ; M + S equal volume\ni2 +  6.7 1         ; S only\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>In instr 1 of the example, the encoded MS stereo file is interleaved. The left channel of this interleaved signal will be decoded as the M (=Mid) signal. The right channel will be decoded as Left and Right. In instr 2 however, two separate channels are used. The user decides which one will be appointed as the middle signal (M) and the side signal (S).</p> on top the interleaved encoded MS file (instr 1), at the bottom are the two separate files (instr 2)"},{"location":"opcodes/ms2st/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/ms2st/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini April 2021</p>"},{"location":"opcodes/mtof/","title":"Mtof","text":""},{"location":"opcodes/mtof/#mtof","title":"mtof","text":"<p>Convert a midi note number value to frequency, taking global value of A4 into account.</p> <p>Plugin opcode in emugens.</p>"},{"location":"opcodes/mtof/#syntax","title":"Syntax","text":"<pre><code>ifreq mtof imidi\nkfreq mtof kmidi\nifreqs[] mtof imidis[]\nkfreqs[] mtof kmidis[]\n</code></pre>"},{"location":"opcodes/mtof/#performance","title":"Performance","text":"<p>kmidi / imidi -- Midi note number (also as array)</p> <p>kfreq / ifreq -- Frequency corresponding to midi note value. An array is returned if the input is an array</p>"},{"location":"opcodes/mtof/#examples","title":"Examples","text":"<p>Here is an example of the mtof opcode. It uses the file mtof-ftom.csd.</p> Example of the mtof opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\nA4 = 440\n\ninstr 1\n  kfreq = mtof(69)\n  printks2 \"midi 69   -&gt; %f\\n\", kfreq\n\n  kmidi = ftom(442)\n  printks2 \"freq 442  -&gt; %f\\n\", kmidi\n\n  kmidi = ftom(442,1)\n  printks2 \"freq 442  -&gt; %f rounded\\n\", kmidi\n\n  kfreq = mtof(kmidi)\n  printks \"midi %f -&gt; %f\\n\", 1, kmidi, kfreq\n\n  imidi = ftom:i(440)\n  print imidi\n\n  ifreq = mtof:i(60)\n  print ifreq\n\n  turnoff\nendin\n\ninstr 2\n  imidis0[] fillarray 60, 62, 64, 69\n  ifreqs0[] mtof imidis0\n  printarray ifreqs0, \"\", \"ifreqs0\"\n\n  kfreqs[] fillarray 220, 440, 880\n  kmidis[] ftom kfreqs\n  puts \"kfreqs\", 1\n  printarray kmidis, 1, \"%.2f\", \"kmidis\"\n  turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ni 2 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mtof/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/mtof/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p> <p>New plugin in version 6.11</p> <p>Array version new in 6.13</p>"},{"location":"opcodes/mton/","title":"Mton","text":""},{"location":"opcodes/mton/#mton","title":"mton","text":"<p>Convert midi note number to string note name, with an accuracy of 1 cent.</p>"},{"location":"opcodes/mton/#syntax","title":"Syntax","text":"<pre><code>Snote mton kmidi\nSnote mton imidi\n</code></pre>"},{"location":"opcodes/mton/#performance","title":"Performance","text":"<p>kmidi / imidi -- Midi note number</p> <p>Snote -- Note name</p> <p>Example of note names:</p> <pre><code>midi    note number\n-------------------\n60      4C\n60.4    4C+40\n60.5    4C+\n60.9    4Db-10\n61      4C#\n61.5    4D-\n</code></pre>"},{"location":"opcodes/mton/#examples","title":"Examples","text":"<p>Here is an example of the mton opcode. It uses the file mton-ntom.csd.</p> Example of the ftom opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n    S4 mton ntom(\"7D+63\")\n    puts S4, 1\n\n    S1  mton 60\n    printf_i \"midi 60 = %s \\n\", 1, S1\n\n    S2 mton ftom(442)\n    printf_i \"442 Hz = %s \\n\", 1, S2\n\n    S3 = mton(48.25)\n    printf_i \"midi 48.25 = %s \\n\", 1, S3\n\n    k1 = ntom(\"4C\")\n    printf_i \"4C = midi %f \\n\", 1, k1\n\n    i2  ntom \"4E\"\n    printf_i \"4E = %f \\n\", 1, i2\n\n    S5 = mton(ntom(\"4G+\"))\n    printf_i \"roundtrip 4G+: %s \\n\", 1, S5\n\n    turnoff\nendin\n\ninstr 2\n    ; test i-time and k-time execution\n    k1 = ntom(\"4Eb-31\")\n    printf \"4Eb-31 = %f \\n\", 1, k1\n\n    i0  ntom \"4C+\"\n    printf_i \"4C+ = %f \\n\", 1, i0\n\n    i1 = ntom:i(\"4A\")\n    printf_i \"4A = %f \\n\", 1, i1\n    turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 2 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mton/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/mton/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/multiplies/","title":"Multiplies","text":""},{"location":"opcodes/multiplies/#_1","title":"*","text":"<p>Multiplication operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/multiplies/#syntax","title":"Syntax","text":"<pre><code>a * b  (no rate restriction)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/multiplies/#arguments","title":"Arguments","text":"<p>The arguments of * can be scalar values or k-rate one dimensional arrays (vectors), or any combination.  If one of the arguments is an array, so is the value.</p>"},{"location":"opcodes/multiplies/#examples","title":"Examples","text":"<p>Here is an example of the * operator. It uses the file multiplies.csd.</p> Example of the * operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o multiplies.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkenv    expon 0.01, p3, 1\naout    poscil  0.8*kenv, 440, 1        ;multiply amplitude from 0 to 1 * 0.8\nprintks \"base amplitude * rising expon output = 0.8 * %f\\n\", .1, kenv\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 16384 10 1        ; sine wave\n\ni 1 0 2\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>base amplitude * rising expon output = 0.8 * 0.010000\nbase amplitude * rising expon output = 0.8 * 0.012589\n..........\nbase amplitude * rising expon output = 0.8 * 0.794328\nbase amplitude * rising expon output = 0.8 * 0.998466\n</code></pre>"},{"location":"opcodes/multiplies/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/multiplies/#credits","title":"Credits","text":"<p>Arithmetic on vectors is new in version 6.00</p>"},{"location":"opcodes/multitap/","title":"Multitap","text":""},{"location":"opcodes/multitap/#multitap","title":"multitap","text":"<p>Multitap delay line implementation.</p>"},{"location":"opcodes/multitap/#syntax","title":"Syntax","text":"<pre><code>ares multitap asig [, itime1, igain1] [, itime2, igain2] [...]\n</code></pre>"},{"location":"opcodes/multitap/#initialization","title":"Initialization","text":"<p>The arguments itime and igain set the position and gain of each tap.</p> <p>The delay line is fed by asig.</p>"},{"location":"opcodes/multitap/#examples","title":"Examples","text":"<p>Here is an example of the multitap opcode. It uses the file multitap.csd</p> Example of the multitap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o multitap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nga1 init 0\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1,0\n     outs asig, asig\n\nga1  = ga1+asig\nendin\n\ninstr 2\n\nasig multitap ga1, 1.2, .5, 1.4, .2\n     outs     asig, asig\n\nga1  = 0\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 .5 .2       ; short sound\ni 2  0  3       ; echoes\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This results in two delays, one with length of 1.2 and gain of .5, and one with length of 1.4 and gain of .2.</p>"},{"location":"opcodes/multitap/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/multitap/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1996</p>"},{"location":"opcodes/mute/","title":"Mute","text":""},{"location":"opcodes/mute/#mute","title":"mute","text":"<p>Mutes/unmutes new instances of a given instrument.</p>"},{"location":"opcodes/mute/#syntax","title":"Syntax","text":"<pre><code>mute insnum [, iswitch]\nmute \"insname\" [, iswitch]\n</code></pre>"},{"location":"opcodes/mute/#initialization","title":"Initialization","text":"<p>insnum -- instrument number. Equivalent to p1 in a score i statement.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>iswitch (optional, default=0) -- represents a switch to mute/unmute an instrument. A value of 0 will mute new instances of an instrument, other values will unmute them. The default value is 0.</p>"},{"location":"opcodes/mute/#performance","title":"Performance","text":"<p>All new instances of instrument inst will me muted (iswitch = 0) or unmuted (iswitch not equal to 0). There is no difficulty with muting muted instruments or unmuting unmuted instruments. The mechanism is the same as used by the score q statement. For example, it is possible to mute in the score and unmute in some instrument.</p> <p>Muting/Unmuting is indicated by a message (depending on message level).</p>"},{"location":"opcodes/mute/#examples","title":"Examples","text":"<p>Here is an example of the mute opcode. It uses the file mute.csd.</p> Example of the mute opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mute.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; Mute Instrument #2.\nmute 2\n; Mute Instrument three.\nmute \"three\"\n\ninstr 1\n\na1 oscils 0.2, 440, 0\n   outs a1, a1\nendin\n\ninstr 2 ; gets muted\n\na1 oscils 0.2, 880, 0\n   outs a1, a1\nendin\n\ninstr three     ; gets muted\n\na1 oscils 0.2, 1000, 0\n   outs a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 2 0 1\ni \"three\" 0 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mute/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/mute/#credits","title":"Credits","text":"<p>New in version 4.22</p>"},{"location":"opcodes/mvchpf/","title":"Mvchpf","text":""},{"location":"opcodes/mvchpf/#mvchpf","title":"mvchpf","text":"<p>Moog voltage-controlled highpass filter emulation.</p> <p>Mvchpf is an digital implementation of the 4th-order (24 dB/oct)  Moog high-pass filter, originally written by Fons Andriaensen. According to the author, mvchpf \"...is based on the voltage controlled highpass filter by Robert Moog. again with some attention to the nonlinear effects.\"</p>"},{"location":"opcodes/mvchpf/#syntax","title":"Syntax","text":"<pre><code>asig mvchpf ain, xcf[, istor]\n</code></pre>"},{"location":"opcodes/mvchpf/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mvchpf/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency. The useful range is around six octaves below and above middle C (pch 8.00).</p>"},{"location":"opcodes/mvchpf/#examples","title":"Examples","text":"<p>Here is an example of the mvchpf opcode. It uses the file mvchpf.csd.</p> Example of the mvchpf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\n kenv linen p4,0.1,p3,0.1\n ain rand kenv \n kfr expon 220, p3, 1760\n asig mvchpf ain,kfr\n   out asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.9\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvchpf/#see-also","title":"See also","text":"<p>Standard Filters: Hi-pass filters</p>"},{"location":"opcodes/mvchpf/#credits","title":"Credits","text":"<p>Author: Fons Andriaensen,  ported to Csound by Victor Lazzarini January 2016</p> <p>New in version 6.07</p> <p>January 2016.</p>"},{"location":"opcodes/mvclpf1/","title":"Mvclpf1","text":""},{"location":"opcodes/mvclpf1/#mvclpf1","title":"mvclpf1","text":"<p>Moog voltage-controlled lowpass filter emulation.</p> <p>Mvclpf1 is an digital implementation of the 4th-order (24 dB/oct)  Moog ladder filter originally written by Fons Andriaensen. According to the author, mvclpf1 \"is a fairly simple design, and it does not even pretend to come close the 'real thing'. It uses a very crude approximation of the non-linear resistor in the first filter section only. [...] [I]t is [a] cheap (in terms of CPU usage) general purpose 24 dB/oct lowpass filter that could be useful\".</p>"},{"location":"opcodes/mvclpf1/#syntax","title":"Syntax","text":"<pre><code>asig mvclpf1 ain, xcf, xres[,istor]\n</code></pre>"},{"location":"opcodes/mvclpf1/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mvclpf1/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency. The useful range is around six octaves below and above middle C (pch 8.00).</p> <p>xres -- resonance, limited to the interval [0,1].</p>"},{"location":"opcodes/mvclpf1/#examples","title":"Examples","text":"<p>Here is an example of the mvclpf1 opcode. It uses the file mvclpf1.csd.</p> Example of the mvclpf1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\n kenv linen p4,0.1,p3,0.1\n ain rand kenv \n kfr expon 220, p3, 1760\n asig mvclpf1 ain,kfr,0.9\n   out asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.9\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvclpf1/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/mvclpf1/#credits","title":"Credits","text":"<p>Author: Fons Andriaensen,  ported to Csound by Victor Lazzarini January 2016</p> <p>New in version 6.07</p> <p>January 2016.</p>"},{"location":"opcodes/mvclpf2/","title":"Mvclpf2","text":""},{"location":"opcodes/mvclpf2/#mvclpf2","title":"mvclpf2","text":"<p>Moog voltage-controlled lowpass filter emulation.</p> <p>Mvclpf2 is an digital implementation of the 4th-order (24 dB/oct) Moog ladder filter originally written by Fons Andriaensen. According to the author, mvclpf2 \"uses five non-linear elements, in the input and in all four filter sections. It works by using the derivative of the nonlinearity (for which 1 / (1 + x * x) is reasonable approximation). The main advantage of this is that only one evaluation of the non-linear function is required for each section\".</p>"},{"location":"opcodes/mvclpf2/#syntax","title":"Syntax","text":"<pre><code>asig mvclpf2 ain, xcf, xres[, istor]\n</code></pre>"},{"location":"opcodes/mvclpf2/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mvclpf2/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency. The useful range is around six octaves below and above middle C (pch 8.00).</p> <p>xres  -- resonance, limited to the interval [0,1].</p>"},{"location":"opcodes/mvclpf2/#examples","title":"Examples","text":"<p>Here is an example of the mvclpf2 opcode. It uses the file mvclpf2.csd.</p> Example of the mvclpf2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\n kenv linen p4,0.1,p3,0.1\n ain rand kenv \n kfr expon 220, p3, 1760\n asig mvclpf1 ain,kfr,0.9\n   out asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.9\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvclpf2/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/mvclpf2/#credits","title":"Credits","text":"<p>Author: Fons Andriaensen,  ported to Csound by Victor Lazzarini January 2016</p> <p>New in version 6.07</p> <p>January 2016.</p>"},{"location":"opcodes/mvclpf3/","title":"Mvclpf3","text":""},{"location":"opcodes/mvclpf3/#mvclpf3","title":"mvclpf3","text":"<p>Moog voltage-controlled lowpass filter emulation.</p> <p>Mvclpf3 is an digital implementation of the 4th-order (24 dB/oct) Moog ladder filter originally written by Fons Andriaensen. According to the author, mvclpf3 \"is based on mvclpf2 , with two differences. It uses the the technique described by Stilson and Smith to extend the constant-Q range, and the internal sample frequency is doubled, giving a better approximation to the non-linear behaviour at high freqencies. This version has high Q over the entire frequency range and will oscillate up to above 10 kHz, while the two others show a decreasing Q at high frequencies. Mvclpf3  is reasonably well tuned, and can be 'played' as a VCO up to at least 5 kHz\".</p>"},{"location":"opcodes/mvclpf3/#syntax","title":"Syntax","text":"<pre><code>asig mvclpf3 ain, xcf, xres[, istor]\n</code></pre>"},{"location":"opcodes/mvclpf3/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mvclpf3/#performance","title":"Performance","text":"<p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency. The useful range is around six octaves below and above middle C (pch 8.00).</p> <p>xres -- resonance, limited to the interval [0,1].</p>"},{"location":"opcodes/mvclpf3/#examples","title":"Examples","text":"<p>Here is an example of the mvclpf3 opcode. It uses the file mvclpf3.csd.</p> Example of the mvclpf3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\n kenv linen p4,0.1,p3,0.1\n ain rand kenv \n kfr expon 220, p3, 1760\n asig mvclpf3 ain,kfr,0.9\n   out asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.9\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvclpf3/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/mvclpf3/#credits","title":"Credits","text":"<p>Author: Fons Andriaensen,  ported to Csound by Victor Lazzarini January 2016</p> <p>New in version 6.07</p> <p>January 2016.</p>"},{"location":"opcodes/mvclpf4/","title":"Mvclpf4","text":""},{"location":"opcodes/mvclpf4/#mvclpf4","title":"mvclpf4","text":"<p>Moog voltage-controlled lowpass filter emulation.</p> <p>Mvclpf4 is an digital implementation of the 4th-order (24 dB/oct) Moog ladder filter originally written by Fons Andriaensen. It is a version of the mvclpf3 opcode with four outputs, for 6dB, 12dB, 18dB, and 24 dB/octave responses.</p>"},{"location":"opcodes/mvclpf4/#syntax","title":"Syntax","text":"<pre><code>asig1,asig2,asig3,asig4 mvclpf4 ain, xcf, xres[, istor]\n</code></pre>"},{"location":"opcodes/mvclpf4/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/mvclpf4/#performance","title":"Performance","text":"<p>asig1 -- 6dB/oct low-pass response output.</p> <p>asig2 -- 12dB/oct low-pass response output.</p> <p>asig3 -- 18dB/oct low-pass response output..</p> <p>asig4 -- 24dB/oct low-pass response output.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency. The useful range is around six octaves below and above middle C (pch 8.00).</p> <p>xres -- resonance, limited to the interval [0,1].</p>"},{"location":"opcodes/mvclpf4/#examples","title":"Examples","text":"<p>Here is an example of the mvclpf4 opcode. It uses the file mvclpf4.csd.</p> Example of the mvclpf4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\n asig[] init 4\n kenv linen p4,0.1,p3,0.1\n ain rand kenv \n kfr expon 220, p3, 1760\n asig[0],asig[1],asig[2],asig[3] mvclpf4 ain,kfr,0.9\n  out asig[p5]\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.9 0\ni1 + 5 0.9 1\ni1 + 5 0.9 2\ni1 + 5 0.9 3\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvclpf4/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/mvclpf4/#credits","title":"Credits","text":"<p>Author: Fons Andriaensen,  ported to Csound by Victor Lazzarini January 2016</p> <p>New in version 6.07</p> <p>January 2016.</p>"},{"location":"opcodes/mvmfilter/","title":"Mvmfilter","text":""},{"location":"opcodes/mvmfilter/#mvmfilter","title":"mvmfilter","text":"<p>A filter with pronounced resonance and controllable decay time.</p> <p>Filters the incoming signal with the specified resonance frequency and decay time. This can be used to overlay a specific resonance on to an incoming sound or to model short bursts of sinusoids at a desired frequency. With a sufficiently long decay time it can be used as a sinusoidal oscillator.</p>"},{"location":"opcodes/mvmfilter/#syntax","title":"Syntax","text":"<pre><code>aout mvmfilter ain, xfreq, xTau [, iskip]\n</code></pre>"},{"location":"opcodes/mvmfilter/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter.</p>"},{"location":"opcodes/mvmfilter/#performance","title":"Performance","text":"<p>aout -- filtered signal</p> <p>ain -- signal to filter</p> <p>xfreq -- resonant frequency of the filter</p> <p> Warning</p> <p>The filter output can rapidly grow to very large output if the input signal correlates with the output. The worst case is that it grows by the magnitude of the input with every sample. To limit the growth so the filter does not explode, it is best to scale down any continuous input significantly. The required scale is related to the value of the decay-time tau so if you select a maximum decay-time you can calculate the required scaling: factor = 1 / $M_E / (sr*tau)</p> <p>xTau -- Decay time of the filter in seconds</p> <p>The decay time is the time in seconds for filter to decay to 1/e</p>"},{"location":"opcodes/mvmfilter/#examples","title":"Examples","text":"<p>Here is an example of the mvmfilter opcode. It uses the file mvmfilter.csd.</p> Example of the mvmfilter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;real-time audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o mvmfilter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\n0dbfs=1\nnchnls=2\n\ngaverb init 0\n\ninstr highQResonator\n  ap mpulse .5, 0\n  a1 mvmfilter ap, p4, .25\n  out a1, a1\nendin\n\ninstr dustyResonator\n  ap dust .1, 30\n  a1 mvmfilter ap, p4, .15\n  out a1, a1\nendin\n\ninstr oscillator\n  ap mpulse .5, 0\n  kenv madsr .1, .2, .6, .4\n  a1 mvmfilter ap, p4, 1e6\n  a1 *= kenv\n  out a1, a1\nendin\n\ninstr resonatorBank1\n  ap mpulse .5, 0\n  kampenv madsr .01, .2, .6, .4\n  kenv init 1\n  iDecayTime init 1\n  a1 mvmfilter ap, p4*1*kenv, iDecayTime \n  a2 mvmfilter ap, p4*3*kenv, iDecayTime*.8\n  a3 mvmfilter ap, p4*5*kenv, iDecayTime*.4\n  a4 mvmfilter ap, p4*7*kenv, iDecayTime*.3\n  a5 mvmfilter ap, p4*9*kenv, iDecayTime*.2\n  a6 mvmfilter ap, p4*11*kenv, iDecayTime*.1\n  aout = (a1+a2+a3+a4+a5+a6) * kampenv * (.1667)\n  gaverb += aout * .3 \n  out aout, aout\nendin\n\ninstr resonatorBank2\n  ap noise 0.005, 0\n  kampenv madsr .01, .2, .6, .4\n  kenv init 1\n  iDecayTime init 1\n  a1 mvmfilter ap, p4*1*kenv, iDecayTime\n  a2 mvmfilter ap, p4*3*kenv, iDecayTime*.8\n  a3 mvmfilter ap, p4*5*kenv, iDecayTime*.5\n  a4 mvmfilter ap, p4*7*kenv, iDecayTime*.4\n  a5 mvmfilter ap, p4*9*kenv, iDecayTime*.3\n  a6 mvmfilter ap, p4*11*kenv, iDecayTime*.2\n  aout = (a1+a2+a3+a4+a5+a6) * kampenv * (.1667)\n  gaverb += aout * .3 \n  out aout, aout\nendin\n\ninstr harmonicArp\n  avco vco2 .01, 50\n  avco moogladder2 avco, 3000, .1\n  kenv linseg 1.3,p3,2\n  kampenv madsr 4, .1, 1, .4\n  iDecayTime init .02\n  a1 mvmfilter avco, p4*1*kenv, iDecayTime\n  a2 mvmfilter avco, p4*2*kenv, iDecayTime\n  a3 mvmfilter avco, p4*3*kenv, iDecayTime\n  a4 mvmfilter avco, p4*4*kenv, iDecayTime\n  a5 mvmfilter avco, p4*5*kenv, iDecayTime\n  a6 mvmfilter avco, p4*6*kenv, iDecayTime\n  aout = (a1+a2+a3+a4+a5+a6) * kampenv * .3\n  aout tanh aout\n  gaverb += aout*.3\n  out aout, aout\nendin\n\ninstr reverb\n  adel  init 0\n  ain = gaverb\n  aleftout, arightout reverbsc ain, ain, .91, 12000\n  outs    aleftout, arightout\n  gaverb = 0\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\n; mvmfilter is basically a damped resonator\ni \"highQResonator\"      0 1 220\n\n; putting some 'dust' through it\ni \"dustyResonator\"      2 2 300\n\n; with a large time-constant it becomes an oscillator\ni \"oscillator\"          4 3 440\n\ns\n; It works for a modal synthesis type use\ni \"resonatorBank1\"      0 5 50\ni \"resonatorBank1\"      2 5 100\ni \"resonatorBank1\"      4 5 150\n\ns\n; and some slightly more interesting effects...\ni \"resonatorBank2\"      0 5 50\ni \"resonatorBank2\"      2 5 125\ni \"harmonicArp\"         4 12 100\ni \"resonatorBank2\"      7 5 50\ni \"resonatorBank2\"      10 5 180\ni \"reverb\"              0 21\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mvmfilter/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/mvmfilter/#references","title":"References","text":"<p>This filter is based on the work of Max Mathews and Julius O. Smith III. This filter was originally used by Max Mathews in an application which applied a bank of these filters to an incoming sound with live controls over the decay time and frequency parameters. This setup was the basis for collaborative live performance and was referred to as Phasor Filters.</p> <ol> <li>Max Mathews and Julius O. Smith III, \"Very High Q Parametrically WellBehaved Two Pole Filters\"</li> </ol>"},{"location":"opcodes/mvmfilter/#credits","title":"Credits","text":"<p>Original design by Max V. Mathews and Julius O. Smith III</p> <p>Opcode implementation by Joel Ross</p> <p>New in version 6.16</p> <p>May 2021.</p>"},{"location":"opcodes/mxadsr/","title":"Mxadsr","text":""},{"location":"opcodes/mxadsr/#mxadsr","title":"mxadsr","text":"<p>Calculates the classical ADSR envelope using the expsegr mechanism.</p>"},{"location":"opcodes/mxadsr/#syntax","title":"Syntax","text":"<pre><code>ares mxadsr iatt, idec, islev, irel [, idel] [, ireltim]\nkres mxadsr iatt, idec, islev, irel [, idel] [, ireltim]\n</code></pre>"},{"location":"opcodes/mxadsr/#initialization","title":"Initialization","text":"<p>iatt -- duration of attack phase</p> <p>idec -- duration of decay</p> <p>islev -- level for sustain phase</p> <p>irel -- duration of release phase</p> <p>idel (optional, default=0) -- period of zero before the envelope starts</p> <p>ireltim (optional, default=-1) -- Control release time after receiving a MIDI noteoff event. If less than zero, the longest release time given in the current instrument is used. If zero or more, the given value will be used for release time. Its default value is -1. (New in Csound 3.59 - not yet properly tested)</p>"},{"location":"opcodes/mxadsr/#performance","title":"Performance","text":"<p>The envelope is in the range 0 to 1 and may need to be scaled further. The envelope may be described as:</p> Picture of an exponential ADSR envelope. <p>The length of the sustain is calculated from the length of the note. This means adsr is not suitable for use with MIDI events. The opcode madsr uses the linsegr mechanism, and so can be used in MIDI applications. The opcode mxadsr is identical to madsr except it uses exponential, rather than linear, line segments.</p> <p>You can use other pre-made envelopes which start a release segment upon receiving a note off message, like linsegr and expsegr, or you can construct more complex envelopes using xtratim and release. Note that you do not need to use xtratim if you are using mxadsr, since the time is extended automatically.</p> <p>mxadsr is new in Csound version 3.51.</p>"},{"location":"opcodes/mxadsr/#examples","title":"Examples","text":"<p>Here is an example of the mxadsr opcode. It uses the file mxadsr.csd.</p> Example of the mxadsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -m0  --midi-key=4 --midi-velocity-amp=5 ; treat p4 and p5 as midi data\n; For Non-realtime ouput leave only the line below:\n; -o mxadsr-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel - 2021\n\ninstr 1                               ; use score and treat p4 and p5 as midi data\nicps    = cpsmidinn(p4)               ; take midi note (p4) from score\niveloc  ampmidid p5, 92               ; take velocity (p5) from score\n;               att, dec, lvl, release\nkenv    mxadsr  .001, .2,   1,    p6 \nprints  \"duration of note (%ds) + release (%2.1fs)\\\\n\", p3, p6                ; \nasig    vco2    iveloc, icps\nasig    butlp   asig, 2000 \n                outs    asig*kenv, asig*kenv\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;      note vel release \ns\ni 1 0 1 62  60  0\ni 1 2 1 62  80  0       \ni 1 4 1 62  100 0       \ni 1 6 1 58  50  0\ns\ni 1 1 1 62  60  0\ni 1 3 1 62  80  1       \ni 1 5 1 62  100 3       \ni 1 7 1 58  50  5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the adsr-group, comparing the different adsr opcodes. It uses the file adsr-group.csd.</p> Example of the adsr group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsr-group.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel - 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; both amplitude and filter use same ADSR curves \ninstr 1                  \nkenv    adsr    .01, .5, .5, p4         ; linear envelope \nasig    vco2    kenv, 110                       ; A+D+S+R = p3  \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig       \nendin\n\ninstr 2 ; midi behavior                  \nkenv    madsr   .01, .5, .5, p4         ; linear envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage                \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled  \n                outs    asig, asig                      \nendin\n\ninstr 3                  \nkenv    xadsr   .01, .5 , .5, p4    ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S+R = p3   \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig\nendin\n\ninstr 4 ; midi behavior          \nkenv    mxadsr  .01, .5 , .5, p4        ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage         \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig                      \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 1 2 .01      ; same notes for everyone!\ni1 5 . .5\ni1 9 . 1.5\ns\ni2 1 2 .01\ni2 5 . .5\ni2 9 . 1.5\ns\ni3 1 2 .01\ni3 5 . .5\ni3 9 . 1.5\ns\ni4 1 2 .01\ni4 5 . .5\ni4 9 . 1.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/mxadsr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/mxadsr/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>November 2002. Thanks to Rasmus Ekman, added documentation for the ireltim parameter.</p> <p>November 2003. Thanks to Kanata Motohashi, fixed the link to the linsegr opcode.</p>"},{"location":"opcodes/nestedap/","title":"Nestedap","text":""},{"location":"opcodes/nestedap/#nestedap","title":"nestedap","text":"<p>Three different nested all-pass filters, useful for implementing reverbs.</p>"},{"location":"opcodes/nestedap/#syntax","title":"Syntax","text":"<pre><code>ares nestedap asig, imode, imaxdel, idel1, igain1 [, idel2] [, igain2] \\\n              [, idel3] [, igain3] [, istor]\n</code></pre>"},{"location":"opcodes/nestedap/#initialization","title":"Initialization","text":"<p>imode -- operating mode of the filter:</p> <ul> <li>1 = simple all-pass filter</li> <li>2 = single nested all-pass filter</li> <li>3 = double nested all-pass filter</li> </ul> <p>idel1, idel2, idel3 -- delay times of the filter stages. Delay times are in seconds and must be greater than zero. idel1 must be greater than the sum of idel2 and idel3.</p> <p>igain1, igain2, igain3 -- gain of the filter stages.</p> <p>imaxdel -- will be necessary if k-rate delays are implemented. Not currently used.</p> <p>istor -- Skip initialization if non-zero (default: 0).</p>"},{"location":"opcodes/nestedap/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>If imode = 1, the filter takes the form:</p> Picture of imode 1 filter. <p>If imode = 2, the filter takes the form:</p> Picture of imode 2 filter. <p>If imode = 3, the filter takes the form:</p> Picture of imode 3 filter."},{"location":"opcodes/nestedap/#examples","title":"Examples","text":"<p>Here is an example of the nestedap opcode. It uses the file nestedap.csd, and drumsMlp.wav.</p> Example of the nestedap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o nestedap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\ninstr 5\n  insnd     =           p4\n  gasig     diskin2     insnd, 1\nendin\n\ninstr 10\n  imax      =           1\n  idel1     =           p4/1000\n  igain1    =           p5\n  idel2     =           p6/1000\n  igain2    =           p7\n  idel3     =           p8/1000\n  igain3    =           p9\n  idel4     =           p10/1000\n  igain4    =           p11\n  idel5     =           p12/1000\n  igain5    =           p13\n  idel6     =           p14/1000\n  igain6    =           p15\n\n  afdbk     init 0\n\n  aout1     nestedap gasig+afdbk*.4, 3, imax, idel1, igain1, idel2, igain2, idel3, igain3\n\n  aout2     nestedap aout1, 2, imax, idel4, igain4, idel5, igain5\n\n  aout      nestedap aout2, 1, imax, idel6, igain6\n\n  afdbk     butterlp aout, 1000\n\n            outs gasig+(aout+aout1)/2, gasig-(aout+aout1)/2\n\ngasig     =           0\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 8192 10 1\n\n; Diskin\n;   Sta  Dur  Soundin\ni5  0    3    \"drumsMlp.wav\"\n\n; Reverb\n;   St  Dur  Del1 Gn1  Del2  Gn2  Del3  Gn3  Del4  Gn4  Del5  Gn5  Del6  Gn6\ni10 0   6    97   .11  23   .07   43   .09   72    .2   53    .2   119   .3\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/nestedap/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/nestedap/#credits","title":"Credits","text":"<p>Author: Hans Mikelson February 1999</p> <p>New in Csound version 3.53</p> <p>The example was updated May 2002, thanks to Hans Mikelson</p>"},{"location":"opcodes/nlfilt/","title":"Nlfilt","text":""},{"location":"opcodes/nlfilt/#nlfilt","title":"nlfilt","text":"<p>A filter with a non-linear effect.</p> <p>Implements the filter:</p> <pre><code>Y{n} = a Y{n-1} + b Y{n-2} + d Y^2{n-L} + X{n} - C\n</code></pre> <p>described in Dobson and Fitch (ICMC'96)</p>"},{"location":"opcodes/nlfilt/#syntax","title":"Syntax","text":"<pre><code>ares nlfilt ain, ka, kb, kd, kC, kL\n</code></pre>"},{"location":"opcodes/nlfilt/#performance","title":"Performance","text":"<ol> <li>Non-linear effect. The range of parameters are: <pre><code>a = b = 0\nd = 0.8, 0.9, 0.7\nC = 0.4, 0.5, 0.6\nL = 20\n</code></pre> This affects the lower register most but there are audible effects over the whole range. We suggest that it may be useful for coloring drums, and for adding arbitrary highlights to notes.</li> <li>Low Pass with non-linear. The range of parameters are: <pre><code>a = 0.4\nb = 0.2\nd = 0.7\nC = 0.11\nL = 20, ... 200\n</code></pre> There are instability problems with this variant but the effect is more pronounced of the lower register, but is otherwise much like the pure comb. Short values of L can add attack to a sound.</li> <li> <p>High Pass with non-linear. The range of parameters are: <pre><code>a = 0.35\nb = -0.3\nd = 0.95\nC = 0,2, ... 0.4\nL = 200\n</code></pre></p> </li> <li> <p>High Pass with non-linear. The range of parameters are: <pre><code>a = 0.7\nb = -0.2, ... 0.5\nd = 0.9\nC = 0.12, ... 0.24\nL = 500, 10\n</code></pre> The high pass version is less likely to oscillate. It adds scintillation to medium-high registers. With a large delay L it is a little like a reverberation, while with small values there appear to be formant-like regions. There are arbitrary color changes and resonances as the pitch changes. Works well with individual notes.</p> </li> </ol> <p> Warning</p> <p>The \"useful\" ranges of parameters are not yet mapped.</p>"},{"location":"opcodes/nlfilt/#examples","title":"Examples","text":"<p>Here is an example of the nlfilt opcode. It uses the file nlfilt.csd.</p> Example of the nlfilt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o nlfilt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;unfiltered noise\n\nasig rand .7\n     outs asig, asig\n\nendin\n\ninstr 2 ;filtered noise\n\nka = p4\nkb = p5\nkd = p6\nkC = p7\nkL = p8\nasig  rand .3\nafilt nlfilt asig, ka, kb, kd, kC, kL\nasig  clip afilt, 2, .9\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2                         ; unfiltersd\n\n;        a    b    d    C    L\ni 2 2 2  0    0   0.8  0.5  20  ; non-linear effect\ni 2 + 2 .4   0.2  0.7  0.11 200 ; low=paas with non-linear\ni 2 + 2 0.35 -0.3 0.95 0.1  200 ; high-pass with non-linear\ni 2 + 2 0.7 -0.2  0.9  0.2  20  ; high-pass with non-linear\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/nlfilt/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/nlfilt/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK 1997</p> <p>New in version 3.44</p>"},{"location":"opcodes/noise/","title":"Noise","text":""},{"location":"opcodes/noise/#noise","title":"noise","text":"<p>A white noise generator with an IIR lowpass filter.</p>"},{"location":"opcodes/noise/#syntax","title":"Syntax","text":"<pre><code>ares noise xamp, kbeta\n</code></pre>"},{"location":"opcodes/noise/#performance","title":"Performance","text":"<p>xamp -- amplitude of final output</p> <p>kbeta -- beta of the lowpass filter. Should be in the range of -1 to 1, exclusive of the end-points.</p> <p>The filter equation is:</p> <p>where x<sub>n</sub> is the original white noise and y<sub>n</sub> is lowpass filtered noise. The higher \u03b2 is, the lower the filter's cut-off frequency. The cutoff frequency is roughly sr * ((1-kbeta)/2).</p>"},{"location":"opcodes/noise/#examples","title":"Examples","text":"<p>Here is an example of the noise opcode. It uses the file noise.csd.</p> Example of the noise opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o noise.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkbeta line -0.9999, p3, 0.9999  ;change beta value between -1 to 1\nasig  noise .3, kbeta\nasig  clip asig, 2, .9  ;clip signal\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/noise/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/noise/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK December 2000</p> <p>New in Csound version 4.10</p>"},{"location":"opcodes/noteoff/","title":"Noteoff","text":""},{"location":"opcodes/noteoff/#noteoff","title":"noteoff","text":"<p>Send a noteoff message to the MIDI OUT port.</p>"},{"location":"opcodes/noteoff/#syntax","title":"Syntax","text":"<pre><code>noteoff ichn, inum, ivel\n</code></pre>"},{"location":"opcodes/noteoff/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inum -- note number (0-127)</p> <p>ivel -- velocity (0-127)</p>"},{"location":"opcodes/noteoff/#performance","title":"Performance","text":"<p>noteon (i-rate note on) and noteoff (i-rate note off) are the simplest MIDI OUT opcodes. noteon sends a MIDI noteon message to MIDI OUT port, and noteoff sends a noteoff message. A noteon opcode must always be followed by an noteoff with the same channel and number inside the same instrument, otherwise the note will play endlessly.</p> <p>These noteon and noteoff opcodes are useful only when introducing a timout statement to play a non-zero duration MIDI note. For most purposes, it is better to use noteondur and noteondur2.</p>"},{"location":"opcodes/noteoff/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/noteoff/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/noteon/","title":"Noteon","text":""},{"location":"opcodes/noteon/#noteon","title":"noteon","text":"<p>Send a noteon message to the MIDI OUT port.</p>"},{"location":"opcodes/noteon/#syntax","title":"Syntax","text":"<pre><code>noteon ichn, inum, ivel\n</code></pre>"},{"location":"opcodes/noteon/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inum -- note number (0-127)</p> <p>ivel -- velocity (0-127)</p>"},{"location":"opcodes/noteon/#performance","title":"Performance","text":"<p>noteon (i-rate note on) and noteoff (i-rate note off) are the simplest MIDI OUT opcodes. noteon sends a MIDI noteon message to MIDI OUT port, and noteoff sends a noteoff message. A noteon opcode must always be followed by an noteoff with the same channel and number inside the same instrument, otherwise the note will play endlessly.</p> <p>These noteon and noteoff opcodes are useful only when introducing a timout statement to play a non-zero duration MIDI note. For most purposes, it is better to use noteondur and noteondur2.</p>"},{"location":"opcodes/noteon/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/noteon/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/noteondur/","title":"Noteondur","text":""},{"location":"opcodes/noteondur/#noteondur","title":"noteondur","text":"<p>Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity.</p>"},{"location":"opcodes/noteondur/#syntax","title":"Syntax","text":"<pre><code>noteondur ichn, inum, ivel, idur\n</code></pre>"},{"location":"opcodes/noteondur/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inum -- note number (0-127)</p> <p>ivel -- velocity (0-127)</p> <p>idur -- how long, in seconds, this note should last.</p>"},{"location":"opcodes/noteondur/#performance","title":"Performance","text":"<p>noteondur (i-rate note on with duration) sends a noteon and a noteoff MIDI message both with the same channel, number and velocity. Noteoff message is sent after idur seconds are elapsed by the time noteondur was active.</p> <p>noteondur differs from noteondur2 in that noteondur truncates note duration when current instrument is deactivated by score or by real-time playing, while noteondur2 will extend performance time of current instrument until idur seconds have elapsed. In real-time playing, it is suggested to use noteondur also for undefined durations, giving a large idur value.</p> <p>Any number of noteondur opcodes can appear in the same Csound instrument, allowing chords to be played by a single instrument.</p>"},{"location":"opcodes/noteondur/#examples","title":"Examples","text":"<p>Here is an example of the noteondur opcode. It uses the file noteondur.csd.</p> <p>This example generates notes for every note received on the MIDI input. It generates MIDI notes on csound's MIDI output, so be sure to connect something.</p> Example of the noteondur opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\ninstr 1  ;Turned on by MIDI notes on channel 1\n\n  ifund   notnum\n  ivel  veloc\n  idur = 1\n\n  ;chord with single key\n  noteondur     1, ifund,   ivel, idur\n  noteondur     1, ifund+3, ivel, idur\n  noteondur     1, ifund+7, ivel, idur\n  noteondur     1, ifund+9, ivel, idur\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Play Instrument #1 for 60 seconds.\n\ni1 0 60\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/noteondur/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/noteondur/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/noteondur2/","title":"Noteondur2","text":""},{"location":"opcodes/noteondur2/#noteondur2","title":"noteondur2","text":"<p>Sends a noteon and a noteoff MIDI message both with the same channel, number and velocity.</p>"},{"location":"opcodes/noteondur2/#syntax","title":"Syntax","text":"<pre><code>noteondur2 ichn, inum, ivel, idur\n</code></pre>"},{"location":"opcodes/noteondur2/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inum -- note number (0-127)</p> <p>ivel -- velocity (0-127)</p> <p>idur -- how long, in seconds, this note should last.</p>"},{"location":"opcodes/noteondur2/#performance","title":"Performance","text":"<p>noteondur2 (i-rate note on with duration) sends a noteon and a noteoff MIDI message both with the same channel, number and velocity. Noteoff message is sent after idur seconds are elapsed by the time noteondur2 was active.</p> <p>noteondur differs from noteondur2 in that noteondur truncates note duration when current instrument is deactivated by score or by real-time playing, while noteondur2 will extend performance time of current instrument until idur seconds have elapsed. In real-time playing, it is suggested to use noteondur also for undefined durations, giving a large idur value.</p> <p>Any number of noteondur2 opcodes can appear in the same Csound instrument, allowing chords to be played by a single instrument.</p>"},{"location":"opcodes/noteondur2/#examples","title":"Examples","text":"<p>Here is an example of the noteondur2 opcode. It uses the file noteondur2.csd.</p> <p>This example generates notes for every note received on the MIDI input. It generates MIDI notes on csound's MIDI output, so be sure to connect something.</p> Example of the noteondur2 opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\ninstr 1\n\n  ifund   notnum \n  ivel  veloc\n  idur = 1\n\n  ;chord with single key\n  noteondur2    1, ifund,   ivel, idur\n  noteondur2    1, ifund+3, ivel, idur\n  noteondur2    1, ifund+7, ivel, idur\n  noteondur2    1, ifund+9, ivel, idur\n\nendin\n\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Dummy ftable\nf 0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/noteondur2/#see-also","title":"See also","text":"<p>Note-on/Note-off Output</p>"},{"location":"opcodes/noteondur2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/notequal/","title":"Notequal","text":""},{"location":"opcodes/notequal/#_1","title":"!=","text":"<p>Determines if one value is not equal to another.</p>"},{"location":"opcodes/notequal/#syntax","title":"Syntax","text":"<pre><code>(a != b ? v1 : v2)\n</code></pre> <p>where a, b, v1 and v2 may be expressions, but a, b not audio-rate.</p>"},{"location":"opcodes/notequal/#performance","title":"Performance","text":"<p>In the above conditional, a and b are first compared. If the indicated relation is true (a not equal to b), then the conditional expression has the value of v1; if the relation is false, the expression has the value of v2.</p> <p>NB.: If v1 or v2 are expressions, these will be evaluated before the conditional is determined.</p> <p>In terms of binding strength, all conditional operators (i.e. the relational operators (&lt;, etc.), and ?, and : ) are weaker than the arithmetic and logical operators (+, -, *, /, &amp;&amp; and ||).</p> <p>These are operators not opcodes. Therefore, they can be used within orchestra statements, but do not form complete statements themselves.</p>"},{"location":"opcodes/notequal/#examples","title":"Examples","text":"<p>Here is an example of the != operator. It uses the file notequal.csd.</p> Example of the != operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o notequal.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nipch   = cpspch(p4)\niprint = p5\nif (iprint != 1) goto skipPrint\nprint  ipch\nasig   vco .7, ipch, 2, 0.5, 1\n       outs asig, asig\n\nskipPrint:\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 65536 10 1        ;sine wave\n\ni1 0 .5 8.00 0\ni1 + .5 8.01 1 ; this note will print it's ipch value and only this one will be played\ni1 + .5 8.02 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  ipch = 277.167\n</code></pre>"},{"location":"opcodes/notequal/#see-also","title":"See also","text":"<p>Conditional Values</p>"},{"location":"opcodes/notnum/","title":"Notnum","text":""},{"location":"opcodes/notnum/#notnum","title":"notnum","text":"<p>Get a note number from a MIDI event.</p>"},{"location":"opcodes/notnum/#syntax","title":"Syntax","text":"<pre><code>ival notnum\n</code></pre>"},{"location":"opcodes/notnum/#performance","title":"Performance","text":"<p>Get the MIDI byte value (0 - 127) denoting the note number of the current event.</p>"},{"location":"opcodes/notnum/#examples","title":"Examples","text":"<p>Here is an example of the notnum opcode. It uses the file notnum.csd.</p> Example of the notnum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -M0 -+rtmidi=virtual ;;;realtime audio out with virtual MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nmassign 1, 1    ; set MIDI channel 1 to play instr 1\n\ninstr   1\n\niNum notnum\n     print iNum\n; Convert MIDI note number to Hz\niHz  = (440.0*exp(log(2.0)*((iNum)-69.0)/12.0))\naosc oscil 0.6, iHz, 1\n     outs  aosc, aosc\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0  16384 10 1       ;sine wave\n\nf 0 60                  ;play 60 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/notnum/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/notnum/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Example written by David Akbari.</p>"},{"location":"opcodes/nreverb/","title":"Nreverb","text":""},{"location":"opcodes/nreverb/#nreverb","title":"nreverb","text":"<p>A reverberator consisting of 6 parallel comb-lowpass filters.</p> <p>It is fed into a series of 5 allpass filters. nreverb replaces reverb2 (version 3.48) and so both opcodes are identical.</p>"},{"location":"opcodes/nreverb/#syntax","title":"Syntax","text":"<pre><code>ares nreverb asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] \\\n             [, inumAlpas] [, ifnAlpas]\n</code></pre>"},{"location":"opcodes/nreverb/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- Skip initialization if present and non-zero.</p> <p>inumCombs (optional) -- number of filter constants in comb filter. If omitted, the values default to the nreverb constants. New in Csound version 4.09.</p> <p>ifnCombs - function table with inumCombs comb filter time values, followed the same number of gain values.  The ftable should not be rescaled (use negative fgen number). Positive time values are in seconds. The time values are converted internally into number of samples, then set to the next greater prime number. If the time is negative, it is interpreted directly as time in sample frames, and no processing is done (except negation). New in Csound version 4.09.</p> <p>inumAlpas, ifnAlpas (optional) -- same as inumCombs/ifnCombs, for allpass filter. New in Csound 4.09.</p>"},{"location":"opcodes/nreverb/#performance","title":"Performance","text":"<p>The input signal asig is reverberated for ktime seconds. The parameter khdif controls the high frequency diffusion amount. The values of khdif should be from 0 to 1. If khdif is set to 0 the all the frequencies decay with the same speed. If khdif is 1, high frequencies decay faster than lower ones. If ktime is inadvertently set to a non-positive number, ktime will be reset automatically to 0.01. (New in Csound version 4.07.)</p> <p>As of Csound version 4.09, nreverb may read any number of comb and allpass filter from an ftable.</p>"},{"location":"opcodes/nreverb/#examples","title":"Examples","text":"<p>Here is a simple example of the nreverb opcode. It uses the file nreverb.csd.</p> Simple example of the nreverb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n;-o nreverb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngaout init  0\n\ninstr 1\na1      oscili  .5, 440\nouts    a1, a1\n\ngaout = gaout+a1\nendin\n\ninstr 99\n\na2      nreverb gaout, 2, .3\nouts    a2*.15, a2*.15          ;volume of reverb               \n\ngaout = 0\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 .5\ni 1 1 .5\ni 1 2 .5\ni 1 3 .5\ni 1 4 .5\ni 99 0 9 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the nreverb opcode using an ftable for filter constants. It uses the file nreverb_ftable.csd, and drumsMlp.wav.</p> An example of the nreverb opcode using an ftable for filter constants.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n;-o nreverb_ftable.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\na1  soundin \"drumsMlp.wav\"\na2  nreverb a1, 1.5, .75, 0, 8, 71, 4, 72\nouts a1 + a2 * .4, a1 + a2 * .4\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; freeverb time constants, as direct (negative) sample, with arbitrary gains\nf71 0 16   -2  -1116 -1188 -1277 -1356 -1422 -1491 -1557 -1617  0.8  0.79  0.78  0.77  0.76  0.75  0.74  0.73\nf72 0 16   -2  -556 -441 -341 -225  0.7  0.72  0.74  0.76\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/nreverb/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/nreverb/#credits","title":"Credits","text":"<p>Authors: Paris Smaragdis (reverb2) MIT, Cambridge 1995</p> <p>Author: Richard Karpen (nreverb) Seattle, Wash 1998</p>"},{"location":"opcodes/nrpn/","title":"Nrpn","text":""},{"location":"opcodes/nrpn/#nrpn","title":"nrpn","text":"<p>Sends a NPRN (Non-Registered Parameter Number) message to the MIDI OUT port each time one of the input arguments changes.</p>"},{"location":"opcodes/nrpn/#syntax","title":"Syntax","text":"<pre><code>nrpn kchan, kparmnum, kparmvalue\n</code></pre>"},{"location":"opcodes/nrpn/#performance","title":"Performance","text":"<p>kchan -- MIDI channel (1-16)</p> <p>kparmnum -- number of NRPN parameter</p> <p>kparmvalue -- value of NRPN parameter</p> <p>This opcode sends new message when the MIDI translated value of one of the input arguments changes. It operates at k-rate. Useful with the MIDI instruments that recognize NRPNs (for example with the newest sound-cards with internal MIDI synthesizer such as SB AWE32, AWE64, GUS etc. in which each patch parameter can be changed during the performance via NRPN)</p>"},{"location":"opcodes/nrpn/#examples","title":"Examples","text":"<p>Here is an example of the nrpn opcode. It uses the file nrpn.csd.</p> Example of the nrpn opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac  -Q1   ;;;realtime audio out with MIDI out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; change attack time of external synth\n\ninitc7 1, 6, 0          ; set controller 6 to 0\nnrpn 1, 99, 1           ; set MSB\nnrpn 1, 98, 99          ; set LSB\nkatt ctrl7 1, 6, 1, 127 ; DataEntMSB\nidur = 2\nnoteondur2 1, 60, 100, idur ; play note on synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/nrpn/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/nrpn/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.492</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/nsamp/","title":"Nsamp","text":""},{"location":"opcodes/nsamp/#nsamp","title":"nsamp","text":"<p>Returns the number of samples loaded into a stored function table number.</p>"},{"location":"opcodes/nsamp/#syntax","title":"Syntax","text":"<pre><code>nsamp(x) (init-rate args only)\n</code></pre>"},{"location":"opcodes/nsamp/#performance","title":"Performance","text":"<p>Returns the number of samples loaded into stored function table number x by GEN01. This is useful when a sample is shorter than the power-of-two function table that holds it. New in Csound version 3.49.</p> <p>As of Csound version 5.02, nsamp works with deferred-length function tables (see GEN01).</p> <p>nsamp differs from ftlen in that nsamp gives the number of sample frames loaded, while ftlen gives the total number of samples. For example, with a stereo sound file of 10000 samples, ftlen() would return 19999 (i.e. a total of 20000 mono samples, not including a guard point), but nsamp() returns 10000.</p>"},{"location":"opcodes/nsamp/#examples","title":"Examples","text":"<p>Here is an example of the nsamp opcode. It uses the file nsamp.csd, drumsSlp.wav. and fox.wav.</p> Example of the nsamp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o nsamp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; slightly adapted example from Jonathan Murphy Dec 2006\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn   =  p4     ; table number\nilen  =  nsamp(ifn)\nprints \"\\nactual numbers of samples = %d\\n\\n\", ilen\nitrns =  1      ; no transposition\nilps  =  0      ; loop starts at index 0\nilpe  =  ilen   ; ends at value returned by nsamp above\nimode =  1      ; loops forward\nistrt =  0      ; commence playback at index 0 samples\n; lphasor provides index into f1 \nalphs lphasor itrns, ilps, ilpe, imode, istrt\natab  tablei  alphs, ifn\n      outs atab, atab\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 262144 1 \"drumsSlp.wav\" 0 4 1     ;stereo file in table, with lots of zeroes\nf 2 0 262144 1 \"fox.wav\" 0 4 1          ;mono file in table, with lots of zeroes\n\ni1 0 10 1\ni1 + 10 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Since the stereo audio file \u201cdrumsSlp.wav\u201d has 176400 samples and the mono file \u201cfox.wav\u201d has 121569 samples, its output should include lines like these:</p> <pre><code>actual numbers of samples = 176400\nactual numbers of samples = 121569\n</code></pre>"},{"location":"opcodes/nsamp/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/nsamp/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy October 1998</p>"},{"location":"opcodes/nstance/","title":"Nstance","text":""},{"location":"opcodes/nstance/#nstance","title":"nstance","text":"<p>Schedules a new instrument instance, storing the instance handle in a variable.</p> <p>This handle can be used later to refer directly to the running nstance. This opcode is similar to schedule, but has the added facility of retrieving the nstance handle.</p>"},{"location":"opcodes/nstance/#syntax","title":"Syntax","text":"<pre><code>iHandle nstance insnum, iwhen, idur [, ip4] [, ip5] [...]\niHandle nstance \"insname\", iwhen, idur [, ip4] [, ip5] [...]\n</code></pre>"},{"location":"opcodes/nstance/#initialization","title":"Initialization","text":"<p>iHandle -- this variable will contain a handle to the event instance. It can be used, for example, to stop the given instrument instance via the turnoff opcode. Note that the instance handle is only valid once the instrument is initialised.</p> <p>insnum -- instrument number. Equivalent to p1 in a score i statement. insnum must be a number greater than the number of the calling instrument.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>iwhen -- start time of the new event. Equivalent to p2 in a score i statement. iwhen must be nonnegative. If iwhen is zero, insum must be greater than or equal to the p1 of the current instrument.</p> <p>idur -- duration of event. Equivalent to p3 in a score i statement.</p> <p>ip4, ip5, ... -- Equivalent to p4, p5, etc., in a score i statement.</p>"},{"location":"opcodes/nstance/#performance","title":"Performance","text":"<p>nstance adds a new score event. The arguments, including options, are the same as in a score. The iwhen time (p2) is measured from the time of this event.</p> <p>If the duration is zero or negative the new event is of MIDI type, and inherits the release sub-event from the scheduling instruction.</p> <p> Note</p> <p>Note that the nstance opcode cannot accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/nstance/#examples","title":"Examples","text":"<p>Here is an example of the nstance opcode. It uses the file nstance.csd.</p> Example of the nstance opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac         ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o nstance.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1 ; Instrument #1 - oscillator with a high note.\n\n  iHandle nstance 2, .3, p3     ; Play Instrument #2 0.3 seconds later\n  a1 oscils .5, 880, 1          ; a high note\n  outs a1 * .5, a1              ; ... a bit to the right\n  print iHandle\nendin\n\n\ninstr 2 ; Instrument #2 - oscillator with a low note.\n\n  a1 oscils .5, 110, 1          ; a low note\n  outs a1, a1 * .5              ; ... a bit to the left\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1    ; a sine wave.\n\ni 1 0 1\ni 1 2 .5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/nstance/#see-also","title":"See also","text":"<p>Instrument Invocation</p> <p>More information on this opcode: http://www.csoundjournal.com/issue15/phrase_loops.html, written by Jim Aikin</p>"},{"location":"opcodes/nstance/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini November 2013</p>"},{"location":"opcodes/nstrnum/","title":"Nstrnum","text":""},{"location":"opcodes/nstrnum/#nstrnum","title":"nstrnum","text":"<p>Returns the number of a named instrument.</p>"},{"location":"opcodes/nstrnum/#syntax","title":"Syntax","text":"<pre><code>insno nstrnum \"name\"\n</code></pre>"},{"location":"opcodes/nstrnum/#initialization","title":"Initialization","text":"<p>insno -- the instrument number of the named instrument.</p>"},{"location":"opcodes/nstrnum/#performance","title":"Performance","text":"<p>\"name\" -- the named instrument's name.</p> <p>If an instrument with the specified name does not exist, an init error occurs, and -1 is returned.</p>"},{"location":"opcodes/nstrnum/#examples","title":"Examples","text":"<p>Here is an example of the nstrnum opcode. It uses the file nstrnum_nstrstr.csd.</p> Example of the nstrnum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      = 44100\nksmps = 32\nnchnls  = 2\n0dbfs   = 1\n\ninstr nothing\nendin\n\ninstr john\n prints \"instrument name = \"\n puts nstrstr(p1),1\n prints \"instrument number = %d\\n\", nstrnum(\"john\")\nendin\n\ninstr test\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni \"john\" 0 0\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>instrument name = john\ninstrument number = 2\n</code></pre> <p>A musical examples featuring the nstrnum opcode: TivalNstrnum_Yi.csd by Steven Yi.</p>"},{"location":"opcodes/nstrnum/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p>"},{"location":"opcodes/nstrnum/#credits","title":"Credits","text":"<p>Author: Istvan Varga New in version 4.23 Written in the year 2002.</p>"},{"location":"opcodes/ntof/","title":"Ntof","text":""},{"location":"opcodes/ntof/#ntof","title":"ntof","text":"<p>Convert note name to frequency</p> <p>Plugin opcode in emugens.</p> <p>It allows note name to include microtones or a deviation in cents.</p>"},{"location":"opcodes/ntof/#syntax","title":"Syntax","text":"<pre><code>kfreq ntof Snote\nifreq ntof Snote\n</code></pre>"},{"location":"opcodes/ntof/#performance","title":"Performance","text":"<p>Snote -- Note name</p> <p>kfreq -- Frequency</p> <p> Note</p> <p>The frequency returned depends on the value of the global variable A4</p> <p> Note</p> <p>4C is the central C in the piano.</p>"},{"location":"opcodes/ntof/#examples","title":"Examples","text":"<p>Here is an example of the ntof opcode. It uses the file ntof.csd.</p> Example of the ntof opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/*\n\nExample for ntof: notename to frequency \n\nA notename is a string of the form\n\n&lt;octave&gt;&lt;pitchclass&gt;[cents]\n\nExample notenames are:\n\n\"4A\"     -&gt; A in the 4th octave\n\"5C+31\"  -&gt; C5, 31 cents higher\n\"4Db-13\" -&gt; D flat, 4th octave, 13 cents lower\n\"7F#+\"   -&gt; F# quarter tone higher \n\"5G-\"    -&gt; G5 a quarter tone lower\n\nNB: the frequency returned by ntof depends on the value of A4\n\n*/\n\nA4 = 442\n\ninstr 1\n    ifreq ntof \"4A\"\n    print ifreq\n\n    koctave = 1\n    while (koctave &lt;= 8) do\n        Snote sprintfk \"%dC\", koctave\n        kfreq ntof Snote\n        printf \"notename: %s  freq: %.2f \\n\", koctave, Snote, kfreq\n        koctave += 1\n    od\n\n    turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ntof/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/ntof/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2019</p> <p>New in 6.13</p>"},{"location":"opcodes/ntom/","title":"Ntom","text":""},{"location":"opcodes/ntom/#ntom","title":"ntom","text":"<p>Convert note name to midi note number</p> <p>Plugin opcode in emugens.</p> <p>It allows note name to include microtones or a deviation in cents.</p>"},{"location":"opcodes/ntom/#syntax","title":"Syntax","text":"<pre><code>kmidi ntom Snote\nimidi ntom Snote\n</code></pre>"},{"location":"opcodes/ntom/#performance","title":"Performance","text":"<p>Snote -- Note name</p> <p>kmidi -- Midi note number</p> <p>Example of note names:</p> <pre><code>midi    note name\n-------------------\n60      4C\n60.4    4C+40\n60.5    4C+\n60.9    4Db-10\n61      4C#\n61.5    4D-\n</code></pre> <p> Note</p> <p>4C is the central C in the piano</p>"},{"location":"opcodes/ntom/#examples","title":"Examples","text":"<p>Here is an example of the ntom opcode. It uses the file mton-ntom.csd.</p> Example of the ftom opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n    S4 mton ntom(\"7D+63\")\n    puts S4, 1\n\n    S1  mton 60\n    printf_i \"midi 60 = %s \\n\", 1, S1\n\n    S2 mton ftom(442)\n    printf_i \"442 Hz = %s \\n\", 1, S2\n\n    S3 = mton(48.25)\n    printf_i \"midi 48.25 = %s \\n\", 1, S3\n\n    k1 = ntom(\"4C\")\n    printf_i \"4C = midi %f \\n\", 1, k1\n\n    i2  ntom \"4E\"\n    printf_i \"4E = %f \\n\", 1, i2\n\n    S5 = mton(ntom(\"4G+\"))\n    printf_i \"roundtrip 4G+: %s \\n\", 1, S5\n\n    turnoff\nendin\n\ninstr 2\n    ; test i-time and k-time execution\n    k1 = ntom(\"4Eb-31\")\n    printf \"4Eb-31 = %f \\n\", 1, k1\n\n    i0  ntom \"4C+\"\n    printf_i \"4C+ = %f \\n\", 1, i0\n\n    i1 = ntom:i(\"4A\")\n    printf_i \"4A = %f \\n\", 1, i1\n    turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1\ni 2 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ntom/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/ntom/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/ntrpol/","title":"Ntrpol","text":""},{"location":"opcodes/ntrpol/#ntrpol","title":"ntrpol","text":"<p>Calculates the weighted mean value (i.e. linear interpolation) of two input signals</p>"},{"location":"opcodes/ntrpol/#syntax","title":"Syntax","text":"<pre><code>ares ntrpol asig1, asig2, kpoint [, imin] [, imax]\nires ntrpol isig1, isig2, ipoint [, imin] [, imax]\nkres ntrpol ksig1, ksig2, kpoint [, imin] [, imax]\n</code></pre>"},{"location":"opcodes/ntrpol/#initialization","title":"Initialization","text":"<p>imin -- minimum xpoint value (optional, default 0)</p> <p>imax -- maximum xpoint value (optional, default 1)</p>"},{"location":"opcodes/ntrpol/#performance","title":"Performance","text":"<p>xsig1, xsig2 -- input signals</p> <p>xpoint -- interpolation point between the two values</p> <p>ntrpol opcode outputs the linear interpolation between two input values. xpoint is the distance of evaluation point from the first value. With the default values of imin and imax, (0 and 1) a zero value indicates no distance from the first value and the maximum distance from the second one. With a 0.5 value, ntrpol will output the mean value of the two inputs, indicating the exact half point between xsig1 and xsig2. A 1 value indicates the maximum distance from the first value and no distance from the second one. The range of xpoint can be also defined with imin and imax to make its management easier.</p> <p>These opcodes are useful for crossfading two signals.</p>"},{"location":"opcodes/ntrpol/#examples","title":"Examples","text":"<p>Here is an example of the ntrpol opcode. It uses the file ntrpol.csd.</p> Example of the ntrpol opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ntrpol.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSin ftgen 1, 0, 1024, 10, 1\n\ninstr 1\n\navco vco2   .5, 110                     ;sawtootyh wave\nasin poscil .5, 220, giSin              ;sine wave but octave higher\nkx   linseg 0, p3*.4, 1, p3*.6, 1       ;crossfade between saw and sine\nasig ntrpol avco, asin, kx\n     outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ntrpol/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/ntrpol/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/octave/","title":"Octave","text":""},{"location":"opcodes/octave/#octave","title":"octave","text":"<p>Calculates a factor to raise/lower a frequency by a given amount of octaves.</p>"},{"location":"opcodes/octave/#syntax","title":"Syntax","text":"<pre><code>octave(x)\n</code></pre> <p>This function works at a-rate, i-rate, and k-rate.</p>"},{"location":"opcodes/octave/#initialization","title":"Initialization","text":"<p>x -- a value expressed in octaves.</p>"},{"location":"opcodes/octave/#performance","title":"Performance","text":"<p>The value returned by the octave function is a factor. You can multiply a frequency by this factor to raise/lower it by the given amount of octaves.</p>"},{"location":"opcodes/octave/#examples","title":"Examples","text":"<p>Here is an example of the octave opcode. It uses the file octave.csd.</p> Example of the octave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o octave.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niroot = 440             ; root note is A above middle-C (440 Hz)\nkoct  lfo 5, 1, 5       ; generate sawtooth, go from 5 octaves higher to root\nkoc = int(koct)         ; produce only whole numbers\nkfactor = octave(koc)   ; for octave\nknew = iroot * kfactor\nprintk2 knew\n\nasig pluck 1, knew, 1000, 0, 1 \nasig dcblock asig       ;remove DC\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1  3520.00000\ni1  1760.00000\ni1   880.00000\ni1   440.00000\ni1  7040.00000\ni1  3520.00000\ni1  1760.00000\ni1   880.00000\ni1   440.00000\n.......\n</code></pre>"},{"location":"opcodes/octave/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/octave/#credits","title":"Credits","text":"<p>New in version 4.16</p>"},{"location":"opcodes/octcps/","title":"Octcps","text":""},{"location":"opcodes/octcps/#octcps","title":"octcps","text":"<p>Converts a cycles-per-second value to octave-point-decimal.</p>"},{"location":"opcodes/octcps/#syntax","title":"Syntax","text":"<pre><code>octcps (cps)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/octcps/#performance","title":"Performance","text":"<p>octcps and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/octcps/#examples","title":"Examples","text":"<p>Here is an example of the octcps opcode. It uses the file octcps.csd.</p> Example of the octcps opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o octcps.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Convert a cycles-per-second value into an \n  ; octave value.\n  icps = 440\n  ioct = octcps(icps)\n\n  print ioct\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  ioct = 8.750\n</code></pre>"},{"location":"opcodes/octcps/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/octcps/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/octmidi/","title":"Octmidi","text":""},{"location":"opcodes/octmidi/#octmidi","title":"octmidi","text":"<p>Get the note number, in octave-point-decimal units, of the current MIDI event.</p>"},{"location":"opcodes/octmidi/#syntax","title":"Syntax","text":"<pre><code>ioct octmidi\n</code></pre>"},{"location":"opcodes/octmidi/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, expressed in octave-point-decimal units, for local processing.</p> <p> octmidi vs. octmidinn</p> <p>The octmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With octmidi, the Midi note number value is taken from the Midi event that is internally associated with the instrument instance.  On the other hand, the octmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for octmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.</p>"},{"location":"opcodes/octmidi/#examples","title":"Examples","text":"<p>Here is an example of the octmidi opcode. It uses the file octmidi.csd.</p> Example of the octmidi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o octmidi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; This example expects MIDI note inputs on channel 1\n  i1 octmidi\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;Dummy f-table to give time for real-time MIDI events\nf 0 8000\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/octmidi/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/octmidi/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/octmidib/","title":"Octmidib","text":""},{"location":"opcodes/octmidib/#octmidib","title":"octmidib","text":"<p>Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in octave-point-decimal.</p>"},{"location":"opcodes/octmidib/#syntax","title":"Syntax","text":"<pre><code>ioct octmidib [irange]\nkoct octmidib [irange]\n</code></pre>"},{"location":"opcodes/octmidib/#initialization","title":"Initialization","text":"<p>irange (optional) -- the pitch bend range in semitones</p>"},{"location":"opcodes/octmidib/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, modify it by the current pitch-bend value, and express the result in octave-point-decimal units. Available as an i-time value or as a continuous k-rate value.</p>"},{"location":"opcodes/octmidib/#examples","title":"Examples","text":"<p>Here is an example of the octmidib opcode. It uses the file octmidib.csd.</p> Example of the octmidib opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o octmidib.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; This example expects MIDI note inputs on channel 1\n  i1 octmidib\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;Dummy f-table to give time for real-time MIDI events\nf 0 8000\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/octmidib/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/octmidib/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/octmidinn/","title":"Octmidinn","text":""},{"location":"opcodes/octmidinn/#octmidinn","title":"octmidinn","text":"<p>Converts a Midi note number value to octave-point-decimal.</p>"},{"location":"opcodes/octmidinn/#syntax","title":"Syntax","text":"<pre><code>octmidinn (MidiNoteNumber)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/octmidinn/#performance","title":"Performance","text":"<p>octmidinn is a function that takes an i-rate or k-rate value representing a Midi note number and returns the equivalent pitch value in Csound's octave-point-decimal format. This conversion assumes that Middle C (8.000 in oct) is Midi note number 60. Midi note number values are typically integers in the range from 0 to 127 but fractional values or values outside of this range will be interpreted consistently.</p> <p> octmidinn vs. octmidi</p> <p>The octmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for octmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.  You must specify an i-rate or k-rate expression for the Midi note number that is to be converted.  On the other hand, the octmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With octmidi, the Midi note number value is taken from the Midi event associated with the instrument instance, and no location or expression for this value may be specified.</p> <p>octmidinn and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/octmidinn/#examples","title":"Examples","text":"<p>Here is an example of the octmidinn opcode. It uses the file cpsmidinn.csd.</p> Example of the octmidinn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n; Prints a table showing the equivalents of all Midi\n; note numbers from 0-127 in cycles-per-second, \n; octave.decimal, and octave.pitchclass units.\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform.\n; This example produces no audio, so we render in\n; non-realtime and turn off sound to disk:\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n  ; i-time loop to print conversion table\n  imidiNN =   0\n  loop1:\n    icps  = cpsmidinn(imidiNN)\n    ioct  = octmidinn(imidiNN)\n    ipch  = pchmidinn(imidiNN)\n\n    print   imidiNN, icps, ioct, ipch\n\n    imidiNN = imidiNN + 1\n  if (imidiNN &lt; 128) igoto loop1\nendin\n\ninstr 2\n  ; test k-rate converters\n  kMiddleC  =   60\n  kcps  = cpsmidinn(kMiddleC)\n  koct  = octmidinn(kMiddleC)\n  kpch  = pchmidinn(kMiddleC)\n\n  printks \"%d %f %f %f\\n\", 1.0, kMiddleC, kcps, koct, kpch\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\ni2 0 0.1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/octmidinn/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/octmidinn/#credits","title":"Credits","text":"<p>Derived from original value converters by Barry Vercoe.</p> <p>New in version 5.07</p>"},{"location":"opcodes/octpch/","title":"Octpch","text":""},{"location":"opcodes/octpch/#octpch","title":"octpch","text":"<p>Converts a pitch-class value to octave-point-decimal.</p>"},{"location":"opcodes/octpch/#syntax","title":"Syntax","text":"<pre><code>octpch (pch)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/octpch/#performance","title":"Performance","text":"<p>octpch and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/octpch/#examples","title":"Examples","text":"<p>Here is an example of the octpch opcode. It uses the file octpch.csd.</p> Example of the octpch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o octpch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Convert a pitch-class value into an \n  ; octave-point-decimal value.\n  ipch = 8.09\n  ioct = octpch(ipch)\n\n  print ioct\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  ioct = 8.750\n</code></pre>"},{"location":"opcodes/octpch/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/octpch/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/opa/","title":"Opa","text":""},{"location":"opcodes/opa/#a","title":"a","text":"<p>Converts a k-rate parameter to an a-rate value with interpolation.</p>"},{"location":"opcodes/opa/#syntax","title":"Syntax","text":"<pre><code>a(x) (control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/opa/#examples","title":"Examples","text":"<p>Here is an example of the a opcode. It uses the file opa.csd.</p> Example of the a opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o a.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; hear the difference between instr.1 and 2\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ;sine wave at k-rate\n\nksig    oscil 0.8, 440, 1\n; k-rate to the audio-rate conversion\nasig =  a(ksig)\n        outs asig, asig\n\nendin\n\ninstr 2 ;sine wave at a-rate\n\nasig    oscil 0.8, 440, 1\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 2 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/opa/#see-also","title":"See also","text":"<p>Sample Level Operators</p> <p>More information on this opcode can be found in the Csound Journal, issue 10, written by Andr\u00e9s Cabrera.</p>"},{"location":"opcodes/opa/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 4.21</p>"},{"location":"opcodes/opand/","title":"Opand","text":""},{"location":"opcodes/opand/#_1","title":"&amp;&amp;","text":"<p>Logical AND operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opand/#syntax","title":"Syntax","text":"<pre><code>a &amp;&amp; b  (logical AND; not audio-rate)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/opand/#examples","title":"Examples","text":"<p>Here is an example of the Logical AND operator. It uses the file opand.csd.</p> Example of the opand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o opand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkval    randomh 0, 1.2, 20              ;choose between 0 and 1.2\nif kval &gt;0 &amp;&amp; kval&lt;=.5 then             ;3 possible outcomes\n        kval = 1                        \nelseif kval &gt;.5 &amp;&amp; kval&lt;=1 then\n        kval =2\nelseif kval &gt;1 then\n        kval =3\nendif\n\nprintk2 kval                            ;print value when it changes\nasig    poscil .7, 440*kval, 1\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     0.00000\ni1     3.00000\ni1     1.00000\ni1     3.00000\ni1     1.00000\ni1     2.00000\ni1     3.00000\n.....\n</code></pre>"},{"location":"opcodes/opand/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opbitand/","title":"Opbitand","text":""},{"location":"opcodes/opbitand/#_1","title":"&amp;","text":"<p>Bitwise AND operator.</p> <p>The bitwise operators perform operations of bitwise AND, bitwise OR, bitwise NOT and bitwise non-equivalence.</p>"},{"location":"opcodes/opbitand/#syntax","title":"Syntax","text":"<pre><code>a &amp; b  (bitwise AND)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.  They are converted to the nearest integer to machine precision and then the operation is performed.</p>"},{"location":"opcodes/opbitand/#performance","title":"Performance","text":"<p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opbitand/#examples","title":"Examples","text":"<p>Here is an example of the bitwise AND and OR operators. It uses the file bitwise.csd.</p> Example of the bitwise operators.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\niresultOr = p4 | p5\niresultAnd = p4 &amp; p5\nprints \"%i | %i  = %i\\\\n\", p4, p5, iresultOr\nprints \"%i &amp; %i  = %i\\\\n\", p4, p5, iresultAnd\nendin\n\n\ninstr 2 ; decimal to binary converter\nSbinary = \"\"\ninumbits = 8\nicount init inumbits - 1\n\npass:\n\n        ivalue = 2 ^ icount\n        if ((p4 &amp; ivalue) &gt;= ivalue) then\n                Sdigit = \"1\"\n        else\n                Sdigit = \"0\"\n        endif\n        Sbinary strcat Sbinary, Sdigit\n\nloop_ge icount, 1, 0, pass\n\nStext sprintf \"%i is %s in binary\\\\n\", p4, Sbinary\nprints Stext\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.1  1  2\ni 1 +  .   1  3\ni 1 +  .   2  4\ni 1 +  .   3  10\n\ni 2 2 0.1   12\ni 2 +  .    9\ni 2 +  .    15\ni 2 +  .    49\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the bitwise-group, comparing the different bitwise opcodes. It uses the file bitwise-group.csd.</p> Example of the bitwise group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nksmps  =    32\nnchnls =    2\n0dbfs  =    1\n\n; By Daniele Cucchi - 2020\n\n;a &amp; b: bitwise AND\n;a | b: bitwise OR\n;a # b: bitwise NON EQUIVALENCE - XOR\n; ~ a: bitwise NOT\n\ninstr 1\n\nkArrayA[] fillarray 0, 0, 1, 1  ; Fill array \"A\" with 4 values: 0, 0, 1, 1\ni0A = i(kArrayA, 0)\ni1A = i(kArrayA, 1)\ni2A = i(kArrayA, 2)\ni3A = i(kArrayA, 3)\n\nkArrayB[] fillarray 0, 1, 0, 1  ; Fill array \"B\" with 4 values: 0, 1, 0, 1\ni0B = i(kArrayB, 0)\ni1B = i(kArrayB, 1)\ni2B = i(kArrayB, 2)\ni3B = i(kArrayB, 3)\n\n; Bitwise operations &amp; fill arrays\nkAND[] = kArrayA &amp; kArrayB\nkOR[] = kArrayA | kArrayB\nkNON[] fillarray i0B # i0A, i1B # i1A, i2B # i2A, i3B # i3A\nkNOT[] fillarray  ~ i0A, ~ i1A, ~ i2A, ~ i3A\n\n; Print values \nprintarray kAND, \"%d\", \"= bitwise AND\"\nprintarray kOR, \"%d\", \"= bitwise OR\"\nprintarray kNON, \"%d\", \"= bitwise NON\"\nprintarray kNOT, \"%d\", \"= bitwise NOT\\n\"\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/opbitand/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opbitnot/","title":"Opbitnot","text":""},{"location":"opcodes/opbitnot/#_1","title":"~","text":"<p>Bitwise NOT operator.</p> <p>The bitwise operators perform operations of bitwise AND, bitwise OR, bitwise NOT and bitwise non-equivalence.</p> <p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opbitnot/#syntax","title":"Syntax","text":"<pre><code>~ a  (bitwise NOT)\n</code></pre> <p>where the argument \\(a\\) may be a further expression.  It is converted to the nearest integer to machine precision and then the operation is performed.</p>"},{"location":"opcodes/opbitnot/#examples","title":"Examples","text":"<p>Here is an example for the bitwise-group, comparing the different bitwise opcodes. It uses the file bitwise-group.csd.</p> Example of the bitwise group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nksmps  =    32\nnchnls =    2\n0dbfs  =    1\n\n; By Daniele Cucchi - 2020\n\n;a &amp; b: bitwise AND\n;a | b: bitwise OR\n;a # b: bitwise NON EQUIVALENCE - XOR\n; ~ a: bitwise NOT\n\ninstr 1\n\nkArrayA[] fillarray 0, 0, 1, 1  ; Fill array \"A\" with 4 values: 0, 0, 1, 1\ni0A = i(kArrayA, 0)\ni1A = i(kArrayA, 1)\ni2A = i(kArrayA, 2)\ni3A = i(kArrayA, 3)\n\nkArrayB[] fillarray 0, 1, 0, 1  ; Fill array \"B\" with 4 values: 0, 1, 0, 1\ni0B = i(kArrayB, 0)\ni1B = i(kArrayB, 1)\ni2B = i(kArrayB, 2)\ni3B = i(kArrayB, 3)\n\n; Bitwise operations &amp; fill arrays\nkAND[] = kArrayA &amp; kArrayB\nkOR[] = kArrayA | kArrayB\nkNON[] fillarray i0B # i0A, i1B # i1A, i2B # i2A, i3B # i3A\nkNOT[] fillarray  ~ i0A, ~ i1A, ~ i2A, ~ i3A\n\n; Print values \nprintarray kAND, \"%d\", \"= bitwise AND\"\nprintarray kOR, \"%d\", \"= bitwise OR\"\nprintarray kNON, \"%d\", \"= bitwise NON\"\nprintarray kNOT, \"%d\", \"= bitwise NOT\\n\"\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/opbitnot/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opbitor/","title":"Opbitor","text":""},{"location":"opcodes/opbitor/#_1","title":"|","text":"<p>Bitwise OR operator.</p> <p>The bitwise operators perform operations of bitwise AND, bitwise OR, bitwise NOT and bitwise non-equivalence.</p>"},{"location":"opcodes/opbitor/#syntax","title":"Syntax","text":"<pre><code>a | b  (bitwise OR)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.  They are converted to the nearest integer to machine precision and then the operation is performed.</p>"},{"location":"opcodes/opbitor/#performance","title":"Performance","text":"<p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opbitor/#examples","title":"Examples","text":"<p>Here is an example of the bitwise AND and OR operators. It uses the file bitwise.csd.</p> Example of the bitwise operators.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\niresultOr = p4 | p5\niresultAnd = p4 &amp; p5\nprints \"%i | %i  = %i\\\\n\", p4, p5, iresultOr\nprints \"%i &amp; %i  = %i\\\\n\", p4, p5, iresultAnd\nendin\n\n\ninstr 2 ; decimal to binary converter\nSbinary = \"\"\ninumbits = 8\nicount init inumbits - 1\n\npass:\n\n        ivalue = 2 ^ icount\n        if ((p4 &amp; ivalue) &gt;= ivalue) then\n                Sdigit = \"1\"\n        else\n                Sdigit = \"0\"\n        endif\n        Sbinary strcat Sbinary, Sdigit\n\nloop_ge icount, 1, 0, pass\n\nStext sprintf \"%i is %s in binary\\\\n\", p4, Sbinary\nprints Stext\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0.1  1  2\ni 1 +  .   1  3\ni 1 +  .   2  4\ni 1 +  .   3  10\n\ni 2 2 0.1   12\ni 2 +  .    9\ni 2 +  .    15\ni 2 +  .    49\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the bitwise-group, comparing the different bitwise opcodes. It uses the file bitwise-group.csd.</p> Example of the bitwise group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nksmps  =    32\nnchnls =    2\n0dbfs  =    1\n\n; By Daniele Cucchi - 2020\n\n;a &amp; b: bitwise AND\n;a | b: bitwise OR\n;a # b: bitwise NON EQUIVALENCE - XOR\n; ~ a: bitwise NOT\n\ninstr 1\n\nkArrayA[] fillarray 0, 0, 1, 1  ; Fill array \"A\" with 4 values: 0, 0, 1, 1\ni0A = i(kArrayA, 0)\ni1A = i(kArrayA, 1)\ni2A = i(kArrayA, 2)\ni3A = i(kArrayA, 3)\n\nkArrayB[] fillarray 0, 1, 0, 1  ; Fill array \"B\" with 4 values: 0, 1, 0, 1\ni0B = i(kArrayB, 0)\ni1B = i(kArrayB, 1)\ni2B = i(kArrayB, 2)\ni3B = i(kArrayB, 3)\n\n; Bitwise operations &amp; fill arrays\nkAND[] = kArrayA &amp; kArrayB\nkOR[] = kArrayA | kArrayB\nkNON[] fillarray i0B # i0A, i1B # i1A, i2B # i2A, i3B # i3A\nkNOT[] fillarray  ~ i0A, ~ i1A, ~ i2A, ~ i3A\n\n; Print values \nprintarray kAND, \"%d\", \"= bitwise AND\"\nprintarray kOR, \"%d\", \"= bitwise OR\"\nprintarray kNON, \"%d\", \"= bitwise NON\"\nprintarray kNOT, \"%d\", \"= bitwise NOT\\n\"\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/opbitor/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opbitshl/","title":"Opbitshl","text":""},{"location":"opcodes/opbitshl/#_1","title":"&lt;&lt;","text":"<p>Bitshift left operator.</p> <p>The bitshift operators shift the bits to the left or to the right the number of bits given.</p> <p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opbitshl/#syntax","title":"Syntax","text":"<pre><code>a &lt;&lt; b  (bitshift left)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/opbitshl/#examples","title":"Examples","text":"<p>Here is an example of the bitshift left operator. It uses the file bitshift.csd.</p> Example of the bitshift left operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n;-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n-o bitshift.wav -W --nosound ;;; for file output any platform \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n\ninstr 1 ;bit shift right\nival = p4&gt;&gt;p5\nprintf_i \"%i&gt;&gt;%i = %i\\n\", 1, p4, p5, ival\nendin\n\ninstr 2 ;bit shift left\nival = p4&lt;&lt;p5\nprintf_i \"%i&lt;&lt;%i = %i\\n\", 1, p4, p5, ival\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1   0   0.1  2   1\ni 1   +    .   3   1\ni 1   +    .   7   2\ni 1   +    .   16   1\ni 1   +    .   16   2\ni 1   +    .   16   3\n\ni 2   5    0.1 1   1\ni 2   +    .   1   2\ni 2   +    .   1   3\ni 2   +    .   1   4\ni 2   +    .   2   1\ni 2   +    .   2   2\ni 2   +    .   2   3\ni 2   +    .   3   2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example above will produce the following output:</p> <pre><code>2&gt;&gt;1 = 1\nB  0.000 ..  0.100 T  0.100 TT  0.100 M:      0.0      0.0\n3&gt;&gt;1 = 1\nB  0.100 ..  0.200 T  0.200 TT  0.200 M:      0.0      0.0\n7&gt;&gt;2 = 1\nB  0.200 ..  0.300 T  0.300 TT  0.300 M:      0.0      0.0\n16&gt;&gt;1 = 8\nB  0.300 ..  0.400 T  0.400 TT  0.400 M:      0.0      0.0\n16&gt;&gt;2 = 4\nB  0.400 ..  0.500 T  0.500 TT  0.500 M:      0.0      0.0\n16&gt;&gt;3 = 2\nB  0.500 ..  5.000 T  5.000 TT  5.000 M:      0.0      0.0\nnew alloc for instr 2:\n1&lt;&lt;1 = 2\nB  5.000 ..  5.100 T  5.100 TT  5.100 M:      0.0      0.0\n1&lt;&lt;2 = 4\nB  5.100 ..  5.200 T  5.200 TT  5.200 M:      0.0      0.0\n1&lt;&lt;3 = 8\nB  5.200 ..  5.300 T  5.300 TT  5.300 M:      0.0      0.0\n1&lt;&lt;4 = 16\nB  5.300 ..  5.400 T  5.400 TT  5.400 M:      0.0      0.0\n2&lt;&lt;1 = 4\nB  5.400 ..  5.500 T  5.500 TT  5.500 M:      0.0      0.0\n2&lt;&lt;2 = 8\nB  5.500 ..  5.600 T  5.600 TT  5.600 M:      0.0      0.0\n2&lt;&lt;3 = 16\nB  5.600 ..  5.700 T  5.700 TT  5.700 M:      0.0      0.0\n3&lt;&lt;2 = 12\n</code></pre>"},{"location":"opcodes/opbitshl/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opbitshr/","title":"Opbitshr","text":""},{"location":"opcodes/opbitshr/#_1","title":"&gt;&gt;","text":"<p>Bitshift right operator.</p> <p>The bitshift operators shift the bits to the left or to the right the number of bits given.</p> <p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opbitshr/#syntax","title":"Syntax","text":"<pre><code>a &gt;&gt; b  (bitshift left)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/opbitshr/#examples","title":"Examples","text":"<p>See the entry for the &lt;&lt; operator for an example.</p>"},{"location":"opcodes/opbitshr/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opi/","title":"Opi","text":""},{"location":"opcodes/opi/#i","title":"i","text":"<p>Returns an init-type equivalent of a k-rate argument or array element or directly returns an i-rate argument.</p>"},{"location":"opcodes/opi/#syntax","title":"Syntax","text":"<pre><code>i(x) (control-rate or init-rate arg)\ni(karray,index1, ...) (k-array with indices)\n</code></pre> <p>Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p> <p> Note</p> <p>Using i() with a k-rate expression argument is not recommended, and can produce unexpected results.</p> <p>To get the value from an array element reliably the second form should be used.</p>"},{"location":"opcodes/opi/#see-also","title":"See also","text":"<p>Sample Level Operators</p> <p>More information on this opcode can be found in the Csound Journal, issue 10, written by Andr\u00e9s Cabrera.</p>"},{"location":"opcodes/opi/#credits","title":"Credits","text":"<p>i-rate arg version of function new since 5.14</p> <p>Array format new in version 6.08</p>"},{"location":"opcodes/opk/","title":"Opk","text":""},{"location":"opcodes/opk/#k","title":"k","text":"<p>Converts a i-rate parameter to an k-rate value or an a-rate value to a k-rate value by down-sampling.</p> <p>For example to be used with rnd() and birnd() to generate random numbers at k-rate.</p>"},{"location":"opcodes/opk/#syntax","title":"Syntax","text":"<pre><code>k(x) (i-rate args only)\nk(x) (a-rate args only)\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/opk/#see-also","title":"See also","text":"<p>Sample Level Operators</p> <p>More information on this opcode can be found in the Csound Journal, issue 10, written by Andr\u00e9s Cabrera.</p>"},{"location":"opcodes/opk/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version Csound 5.00</p> <p>Author: John ffitch</p> <p>arate to krate new in version Csound 6.00</p>"},{"location":"opcodes/opnonequiv/","title":"Opnonequiv","text":""},{"location":"opcodes/opnonequiv/#_1","title":"#","text":"<p>Bitwise NON EQUIVALENCE operator.</p> <p>The bitwise operators perform operations of bitwise AND, bitwise OR, bitwise NOT and bitwise non-equivalence.</p> <p>The priority of these operators is less binding that the arithmetic ones, but more binding that the comparisons.</p> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opnonequiv/#syntax","title":"Syntax","text":"<pre><code>a # b  (bitwise NON EQUIVALENCE)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.  They are converted to the nearest integer to machine precision and then the operation is performed.</p>"},{"location":"opcodes/opnonequiv/#examples","title":"Examples","text":"<p>Here is an example for the bitwise-group, comparing the different bitwise opcodes. It uses the file bitwise-group.csd.</p> Example of the bitwise group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n--nosound\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nksmps  =    32\nnchnls =    2\n0dbfs  =    1\n\n; By Daniele Cucchi - 2020\n\n;a &amp; b: bitwise AND\n;a | b: bitwise OR\n;a # b: bitwise NON EQUIVALENCE - XOR\n; ~ a: bitwise NOT\n\ninstr 1\n\nkArrayA[] fillarray 0, 0, 1, 1  ; Fill array \"A\" with 4 values: 0, 0, 1, 1\ni0A = i(kArrayA, 0)\ni1A = i(kArrayA, 1)\ni2A = i(kArrayA, 2)\ni3A = i(kArrayA, 3)\n\nkArrayB[] fillarray 0, 1, 0, 1  ; Fill array \"B\" with 4 values: 0, 1, 0, 1\ni0B = i(kArrayB, 0)\ni1B = i(kArrayB, 1)\ni2B = i(kArrayB, 2)\ni3B = i(kArrayB, 3)\n\n; Bitwise operations &amp; fill arrays\nkAND[] = kArrayA &amp; kArrayB\nkOR[] = kArrayA | kArrayB\nkNON[] fillarray i0B # i0A, i1B # i1A, i2B # i2A, i3B # i3A\nkNOT[] fillarray  ~ i0A, ~ i1A, ~ i2A, ~ i3A\n\n; Print values \nprintarray kAND, \"%d\", \"= bitwise AND\"\nprintarray kOR, \"%d\", \"= bitwise OR\"\nprintarray kNON, \"%d\", \"= bitwise NON\"\nprintarray kNOT, \"%d\", \"= bitwise NOT\\n\"\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/opnonequiv/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opnot/","title":"Opnot","text":""},{"location":"opcodes/opnot/#_1","title":"!","text":"<p>Logical NOT operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opnot/#syntax","title":"Syntax","text":"<pre><code>! a  (logical NOT; not audio-rate)\n</code></pre> <p>where the argument \\(a\\) may be further expressions.</p>"},{"location":"opcodes/opnot/#examples","title":"Examples","text":"<p>Here is an example of the Logical NOT operator. It uses the file opnot.csd.</p> Example of the opnot opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o opand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkval    randomh 0, 1.2, 20              ;choose between 0 and 1.2\nif !(kval &gt;0 &amp;&amp; kval&lt;=.5) then          ;3 possible outcomes\n        kval = 1                        \nelseif !(kval &gt;.5 &amp;&amp; kval&lt;=1) then\n        kval =2\nelseif !(kval &gt;1) then\n        kval =3\nendif\n\nprintk2 kval                            ;print value when it changes\nasig    poscil .7, 440*kval, 1\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     1.00000\ni1     2.00000\ni1     1.00000\ni1     2.00000\ni1     1.00000\ni1     2.00000\ni1     1.00000\n.....\n</code></pre>"},{"location":"opcodes/opnot/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/opor/","title":"Opor","text":""},{"location":"opcodes/opor/#_1","title":"||","text":"<p>Logical OR operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/opor/#syntax","title":"Syntax","text":"<pre><code>a || b  (logical OR; not audio-rate)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/opor/#examples","title":"Examples","text":"<p>Here is an example of the | operator. It uses the file logicOR.csd.</p> Example of the | operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -+rtmidi=virtual -M0   ;;;realtime audio out and virtual midi keyboard\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;after a UDO from Rory Walsh\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1 ;displays notes, midi channel and control number information\n\nkstatus, kchan, kdata1, kdata2 midiin\nk1 changed kstatus\nk2 changed kchan\nk3 changed kdata1\nk4 changed kdata2\nif((k1==1)||(k2==1)||(k3==1)||(k4==1)) then\nprintks \"Value:%d ChanNo:%d CtrlNo:%d\\n\" , 0, kdata2, kchan, kdata1  \nendif \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1  0  60       ;print values for 60 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like these:</p> <pre><code>Value:127 ChanNo:11 CtrlNo:62\nValue:127 ChanNo:11 CtrlNo:60\nValue:127 ChanNo:11 CtrlNo:60\nValue:127 ChanNo:11 CtrlNo:60\nValue:127 ChanNo:11 CtrlNo:60\n....\nValue:0 ChanNo:11 CtrlNo:62\nValue:0 ChanNo:11 CtrlNo:62\nValue:0 ChanNo:11 CtrlNo:62\nValue:0 ChanNo:11 CtrlNo:62\n....\nValue:77 ChanNo:11 CtrlNo:23\nValue:77 ChanNo:11 CtrlNo:23\nValue:76 ChanNo:11 CtrlNo:23\nValue:76 ChanNo:11 CtrlNo:23\n....\n</code></pre>"},{"location":"opcodes/opor/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/ops/","title":"Ops","text":""},{"location":"opcodes/ops/#s","title":"S","text":"<p>Returns a string containg the numeric value of its argument.</p>"},{"location":"opcodes/ops/#syntax","title":"Syntax","text":"<pre><code>S(x) (control-rate or init-rate arg)\n</code></pre>"},{"location":"opcodes/ops/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/ops/#credits","title":"Credits","text":"<p>V Lazzarini, 2016. New in version 6.07</p>"},{"location":"opcodes/oscbnk/","title":"Oscbnk","text":""},{"location":"opcodes/oscbnk/#oscbnk","title":"oscbnk","text":"<p>Mixes the output of any number of oscillators.</p> <p>This unit generator mixes the output of any number of oscillators. The frequency, phase, and amplitude of each oscillator can be modulated by two LFOs (all oscillators have a separate set of LFOs, with different phase and frequency); additionally, the output of each oscillator can be filtered through an optional parametric equalizer (also controlled by the LFOs).  This opcode is most useful for rendering ensemble (strings, choir, etc.) instruments.</p> <p>Although the LFOs run at k-rate, amplitude, phase and filter modulation are interpolated internally, so it is possible (and recommended in most cases) to use this unit at low (~1000 Hz) control rates without audible quality degradation.</p> <p>The start phase and frequency of all oscillators and LFOs can be set by a built-in seedable 31-bit random number generator, or specified manually in a function table (GEN2).</p>"},{"location":"opcodes/oscbnk/#syntax","title":"Syntax","text":"<pre><code>ares oscbnk  kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, \\\n             kl2minf, kl2maxf, ilfomode, keqminf, keqmaxf, keqminl, keqmaxl, \\\n             keqminq, keqmaxq, ieqmode, kfn [, il1fn] [, il2fn] [, ieqffn]   \\\n             [, ieqlfn] [, ieqqfn] [, itabl] [, ioutfn]\n</code></pre>"},{"location":"opcodes/oscbnk/#initialization","title":"Initialization","text":"<p>iovrlap -- Number of oscillator units.</p> <p>iseed -- Seed value for random number generator (positive integer in the range 1 to 2147483646 (2 ^ 31 - 2)). iseed &lt;= 0 seeds from the current time.</p> <p>ieqmode -- Parametric equalizer mode</p> <ul> <li>-1: disable EQ (faster)</li> <li>0: peak</li> <li>1: low shelf</li> <li>2: high shelf</li> <li>3: peak (filter interpolation disabled)</li> <li>4: low shelf (interpolation disabled)</li> <li>5: high shelf (interpolation disabled)</li> </ul> <p>The non-interpolated modes are faster, and in some cases (e.g. high shelf filter at low cutoff frequencies) also more stable; however, interpolation is useful for avoiding zipper noise at low control rates.</p> <p>ilfomode -- LFO modulation mode, sum of:</p> <ul> <li>128: LFO1 to frequency</li> <li>64: LFO1 to amplitude</li> <li>32: LFO1 to phase</li> <li>16: LFO1 to EQ</li> <li>8: LFO2 to frequency</li> <li>4: LFO2 to amplitude</li> <li>2: LFO2 to phase</li> <li>1: LFO2 to EQ</li> </ul> <p>If an LFO does not modulate anything, it is not calculated, and the ftable number (il1fn or il2fn) can be omitted.</p> <p>il1fn (optional: default=0) -- LFO1 function table number. The waveform in this table has to be normalized (absolute value &lt;= 1), and is read with linear interpolation.</p> <p>il2fn (optional: default=0) -- LFO2 function table number. The waveform in this table has to be normalized, and is read with linear interpolation.</p> <p>ieqffn, ieqlfn, ieqqfn (optional: default=0) -- Lookup tables for EQ frequency, level, and Q (optional if EQ is disabled). Table read position is 0 if the modulator signal is less than, or equal to -1, (table length / 2) if the modulator signal is zero, and the guard point if the modulator signal is greater than, or equal to 1. These tables have to be normalized to the range 0 - 1, and have an extended guard point (table length = power of two + 1). All tables are read with linear interpolation.</p> <p>itabl (optional: default=0) -- Function table storing phase and frequency values for all oscillators (optional). The values in this table are in the following order (5 for each oscillator unit):</p> <pre><code>oscillator phase, lfo1 phase, lfo1 frequency, lfo2 phase, lfo2 frequency, ...\n</code></pre> <p>All values are in the range 0 to 1; if the specified number is greater than 1, it is wrapped (phase) or limited (frequency) to the allowed range. A negative value (or end of table) will use the output of the random number generator.  The random seed is always updated (even if no random number was used), so switching one value between random and fixed will not change others.</p> <p>ioutfn (optional: default=0) -- Function table to write phase and frequency values (optional). The format is the same as in the case of itabl. This table is useful when experimenting with random numbers to record the best values.</p> <p>The two optional tables (itabl and ioutfn) are accessed only at i-time. This is useful to know, as the tables can be safely overwritten after opcode initialization, which allows precalculating parameters at i-time and storing in a temporary table before oscbnk initialization.</p>"},{"location":"opcodes/oscbnk/#performance","title":"Performance","text":"<p>ares -- Output signal.</p> <p>kcps -- Oscillator frequency in Hz.</p> <p>kamd -- AM depth (0 - 1).</p> <pre><code>(AM output) = (AM input) * ((1 - (AM depth)) + (AM depth) * (modulator))\n</code></pre> <p>If ilfomode is not set to modulate the amplitude, then (AM output) = (AM input) regardless of the value of kamd. That means that kamd will have no effect.</p> <p>Note: Amplitude modulation is applied before the parametric equalizer.</p> <p>kfmd -- FM depth (in Hz).</p> <p>kpmd -- Phase modulation depth.</p> <p>kl1minf, kl1maxf -- LFO1 minimum and maximum frequency in Hz.</p> <p>kl2minf, kl2maxf --  LFO2 minimum and maximum frequency in Hz. (Note: oscillator and LFO frequencies are allowed to be zero or negative.)</p> <p>keqminf, keqmaxf -- Parametric equalizer minimum and maximum frequency in Hz.</p> <p>keqminl, keqmaxl -- Parametric equalizer minimum and maximum level.</p> <p>keqminq, keqmaxq -- Parametric equalizer minimum and maximum Q.</p> <p>kfn -- Oscillator waveform table. Table number can be changed at k-rate (this is useful to select from a set of band-limited tables generated by GEN30, to avoid aliasing). The table is read with linear interpolation.</p> <p> Note</p> <p>oscbnk uses the same random number generator as rnd31. So reading its documentation is also recommended. </p>"},{"location":"opcodes/oscbnk/#examples","title":"Examples","text":"<p>Here is an example of oscbnk opcode. It uses the file oscbnk.csd.</p> Example of the oscbnk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac       ;;    -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o oscbnk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =   44100\nksmps  =   32\nnchnls =   2\n0dbfs = 1\n\n; By Stefano Cucchi 2020\n\n\ninstr 1\n\nkcps = 300\nkamd = 3\nkfmd = 2\nkpmd = 2.3\niovrlap = p4\niseed = 0.2\nkl1minf = 1.1\nkl1maxf = 2.3\nkl2minf = 0.2\nkl2maxf = 1.5\nilfomode = 64 + 16 + 8 + 2 ; LFO1 to amplitude + LFO1 to EQ + LFO2 to frequency + LFO2 to phase \nkeqminf = 20\nkeqmaxf = 12000\nkeqminl = 0.1\nkeqmaxl = 23\nkeqminq = 0.2\nkeqmaxq = 2\nieqmode = 1\nkfn = 1\n\na1 oscbnk kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, kl2minf, kl2maxf, ilfomode, keqminf, keqmaxf, keqminl, keqmaxl, keqminq, keqmaxq, ieqmode, kfn, 2 ,2 ,2 ,2 ,2 \nkdeclick linseg 0, 0.3, 0.9, p3-0.6, 0.9, 0.3, 0\nouts a1*0.003*kdeclick, a1*0.003*kdeclick\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\nf2 0 4096 10 1 \n\ni1 0 4 3\ni1 5 4 32\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an advanced example of oscbnk opcode. It uses the file oscbnk-advanced.csd.</p> Advanced example of the oscbnk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac         ;  -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o oscbnk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Istvan Varga */\nsr     =  48000\nkr     =  750\nksmps  =  64\nnchnls =  2\n\nga01    init 0\nga02    init 0\n\n/* sawtooth wave */\ni_      ftgen 1, 0, 16384, 7, 1, 16384, -1\n/* FM waveform */\ni_      ftgen 3, 0, 4096, 7, 0, 512, 0.25, 512, 1, 512, 0.25, 512,  \\\n                        0, 512, -0.25, 512, -1, 512, -0.25, 512, 0\n/* AM waveform */\ni_      ftgen 4, 0, 4096, 5, 1, 4096, 0.01\n/* FM to EQ */\ni_      ftgen 5, 0, 1024, 5, 1, 512, 32, 512, 1\n/* sine wave */\ni_      ftgen 6, 0, 1024, 10, 1\n/* room parameters */\ni_      ftgen 7, 0, 64, -2, 4, 50, -1, -1, -1, 11,                      \\\n                            1, 26.833, 0.05, 0.85, 10000, 0.8, 0.5, 2,  \\\n                            1,  1.753, 0.05, 0.85,  5000, 0.8, 0.5, 2,  \\\n                            1, 39.451, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 33.503, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 36.151, 0.05, 0.85,  7000, 0.8, 0.5, 2,  \\\n                            1, 29.633, 0.05, 0.85,  7000, 0.8, 0.5, 2\n\n/* generate bandlimited sawtooth waves */\n\ni0      =  0\nloop1:\nimaxh   =  sr / (2 * 440.0 * exp(log(2.0) * (i0 - 69) / 12))\ni_      ftgen i0 + 256, 0, 4096, -30, 1, 1, imaxh\ni0      =  i0 + 1\n        if (i0 &lt; 127.5) igoto loop1\n\n        instr 1\n\np3      =  p3 + 0.4\n\n; note frequency\nkcps    =  440.0 * exp(log(2.0) * (p4 - 69) / 12)\n; lowpass max. frequency\nklpmaxf limit 64 * kcps, 1000.0, 12000.0\n; FM depth in Hz\nkfmd1   =  0.02 * kcps\n; AM frequency\nkamfr   =  kcps * 0.02\nkamfr2  =  kcps * 0.1\n; table number\nkfnum   =  (256 + 69 + 0.5 + 12 * log(kcps / 440.0) / log(2.0))\n; amp. envelope\naenv    linseg 0, 0.1, 1.0, p3 - 0.5, 1.0, 0.1, 0.5, 0.2, 0, 1.0, 0\n\n/* oscillator / left */\n\na1      oscbnk kcps, 0.0, kfmd1, 0.0, 40, 200, 0.1, 0.2, 0, 0, 144,           \\\n                0.0, klpmaxf, 0.0, 0.0, 1.5, 1.5, 2,                          \\\n                kfnum, 3, 0, 5, 5, 5\na2      oscbnk kcps, 1.0, kfmd1, 0.0, 40, 201, 0.1, 0.2, kamfr, kamfr2, 148,  \\\n                0, 0, 0, 0, 0, 0, -1,                                         \\\n                kfnum, 3, 4\na2      pareq a2, kcps * 8, 0.0, 0.7071, 2\na0      =  a1 + a2 * 0.12\n/* delay */\nadel    =  0.001\na01     vdelayx a0, adel, 0.01, 16\na_      oscili 1.0, 0.25, 6, 0.0\nadel    =  adel + 1.0 / (exp(log(2.0) * a_) * 8000)\na02     vdelayx a0, adel, 0.01, 16\na0      =  a01 + a02\n\nga01    =  ga01 + a0 * aenv * 2500\n\n/* oscillator / right */\n\n; lowpass max. frequency\n\na1      oscbnk kcps, 0.0, kfmd1, 0.0, 40, 202, 0.1, 0.2, 0, 0, 144,           \\\n                0.0, klpmaxf, 0.0, 0.0, 1.0, 1.0, 2,                          \\\n                kfnum, 3, 0, 5, 5, 5\na2      oscbnk kcps, 1.0, kfmd1, 0.0, 40, 203, 0.1, 0.2, kamfr, kamfr2, 148,  \\\n                0, 0, 0, 0, 0, 0, -1,                                         \\\n                kfnum, 3, 4\na2      pareq a2, kcps * 8, 0.0, 0.7071, 2\na0  =  a1 + a2 * 0.12\n/* delay */\nadel    =  0.001\na01     vdelayx a0, adel, 0.01, 16\na_      oscili 1.0, 0.25, 6, 0.25\nadel    =  adel + 1.0 / (exp(log(2.0) * a_) * 8000)\na02     vdelayx a0, adel, 0.01, 16\na0      =  a01 + a02\n\nga02    =  ga02 + a0 * aenv * 2500\n\n\n        endin\n\n/* output / left */\n\n        instr 81\n\ni1      =  0.000001\naLl, aLh, aRl, aRh  spat3di ga01 + i1*i1*i1*i1, -8.0, 4.0, 0.0, 0.3, 7, 4\nga01    =  0\naLl     butterlp aLl, 800.0\naRl     butterlp aRl, 800.0\n\n        outs aLl + aLh, aRl + aRh\n\n        endin\n\n/* output / right */\n\n        instr 82\n\ni1      =  0.000001\naLl, aLh, aRl, aRh  spat3di ga02 + i1*i1*i1*i1, 8.0, 4.0, 0.0, 0.3, 7, 4\nga02    =  0\naLl     butterlp aLl, 800.0\naRl     butterlp aRl, 800.0\n\n        outs aLl + aLh, aRl + aRh\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Istvan Varga */\nt 0 60\n\ni 1 0 4 41\ni 1 0 4 60\ni 1 0 4 65\ni 1 0 4 69\n\ni 81 0 5.5\ni 82 0 5.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscbnk/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscbnk/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2001</p> <p>New in version 4.15</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/oscil/","title":"Oscil","text":""},{"location":"opcodes/oscil/#oscil","title":"oscil","text":"<p>A simple oscillator without any interpolation.</p> <p>oscil reads table ifn sequentially and repeatedly at a frequency xcps. The amplitude is scaled by xamp.</p>"},{"location":"opcodes/oscil/#syntax","title":"Syntax","text":"<pre><code>ares oscil xamp, xcps [, ifn, iphs]\nkres oscil kamp, kcps [, ifn, iphs]\n</code></pre>"},{"location":"opcodes/oscil/#initialization","title":"Initialization","text":"<p>ifn -- (optional) function table number. Requires a wrap-around guard point. The table number defaults to -1 which indicates a sinewave.</p> <p>iphs (optional, default=0) -- initial phase of sampling, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/oscil/#performance","title":"Performance","text":"<p>kamp, xamp -- amplitude</p> <p>kcps, xcps -- frequency in cycles per second.</p> <p>The oscil opcode generates periodic control (or audio) signals consisting of the value of kamp (xamp) times the value returned from control rate (audio rate) sampling of a stored function table. The internal phase is simultaneously advanced in accordance with the kcps or xcps input value.</p> <p>Table ifn is incrementally sampled modulo the table length and the value obtained is multiplied by amp.</p> <p>If you need to change the oscillator table with a k-rate signal, you can use oscilikt.</p> <p> Note</p> <p>This opcode does not perform any interpolation. This can lead to unexpected behaviour or unclean signals, e.g. for small table sizes and low frequencies. As standard oscillators the usage of oscili or poscil is recommended.</p>"},{"location":"opcodes/oscil/#examples","title":"Examples","text":"<p>Here is an example of the oscil opcode. It uses the file oscil.csd.</p> Example of the oscil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil kamp, kcps, ifn\n     outs asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1                                          ; Sine\nf2 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth\nf3 0 16384 10 1 0   0.3 0    0.2 0     0.14 0     .111   ; Square\nf4 0 16384 10 1 1   1   1    0.7 0.5   0.3  0.1          ; Pulse\n\ni 1 0 2 1\ni 1 3 2 2\ni 1 6 2 3\ni 1 9 2 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscil/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscil1/","title":"Oscil1","text":""},{"location":"opcodes/oscil1/#oscil1","title":"oscil1","text":"<p>Accesses table values by incremental sampling.</p>"},{"location":"opcodes/oscil1/#syntax","title":"Syntax","text":"<pre><code>kres oscil1 idel, kamp, idur [, ifn]\n</code></pre>"},{"location":"opcodes/oscil1/#initialization","title":"Initialization","text":"<p>idel -- delay in seconds before oscil1 incremental sampling begins.</p> <p>idur -- duration in seconds to sample through the oscil1 table just once. A negative value will make the table be read from the end to the beginning.</p> <p>ifn -- (optional) function table number. tablei, oscil1i require the extended guard point.  The number defaults to -1 which indicates a sinewave.</p>"},{"location":"opcodes/oscil1/#performance","title":"Performance","text":"<p>kamp -- amplitude factor.</p> <p>oscil1 accesses values by sampling once through the function table at a rate determined by idur. For the first idel seconds, the point of scan will reside at the first location of the table; it will then begin moving through the table at a constant rate, reaching the end in another idur seconds; from that time on (i.e. after idel + idur seconds) it will remain pointing at the last location. Each value obtained from sampling is then multiplied by an amplitude factor kamp before being written into the result.</p>"},{"location":"opcodes/oscil1/#examples","title":"Examples","text":"<p>Here is an example of the oscil1 opcode. It uses the file oscil1.csd.</p> Example of the oscil1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiPan ftgen 0, 0, 8, -2, .5, .2, .8, .1, .9, 0, 1, .5\n\ninstr     1   \n\nistay = 2 ;how many seconds to stay on the first table value\nasig   vco2 .3, 220\nkpan   oscil1 istay, 1, p3-istay, giPan ;create panning \n       printk2 kpan ;print when new value\naL, aR pan2 asig, kpan ;apply panning\n       outs aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;                                                                                  \ni 1  0  10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>i1     0.50000\ni1     0.20000\ni1     0.80000\ni1     0.10000\ni1     0.90000\ni1     0.00000\ni1     1.00000\ni1     0.50000\n</code></pre>"},{"location":"opcodes/oscil1/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/oscil1i/","title":"Oscil1i","text":""},{"location":"opcodes/oscil1i/#oscil1i","title":"oscil1i","text":"<p>Accesses table values by incremental sampling with linear interpolation.</p>"},{"location":"opcodes/oscil1i/#syntax","title":"Syntax","text":"<pre><code>kres oscil1i idel, kamp, idur [, ifn]\n</code></pre>"},{"location":"opcodes/oscil1i/#initialization","title":"Initialization","text":"<p>idel -- delay in seconds before oscil1i incremental sampling begins.</p> <p>idur -- duration in seconds to sample through the oscil1i table just once. A negative value will make the table be read from the end to the beginning.</p> <p>ifn -- (optional) function table number. oscil1i requires the extended guard point.  The default value is -1 indicating a sine wave.</p>"},{"location":"opcodes/oscil1i/#performance","title":"Performance","text":"<p>kamp -- amplitude factor</p> <p>oscil1i is an interpolating unit in which the fractional part of index is used to interpolate between adjacent table entries. The smoothness gained by interpolation is at some small cost in execution time (see also oscili, etc.), but the interpolating and non-interpolating units are otherwise interchangeable.</p>"},{"location":"opcodes/oscil1i/#examples","title":"Examples","text":"<p>Here is an example of the oscil1i opcode. It uses the file oscil1i.csd.</p> Example of the oscil1i opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil1i.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr     1   \n\nipanfn = p4\nasig   vco2 .3, 220\nkpan   oscil1i 0, 1, p3, ipanfn  ;create panning &amp;\nkleft  = sqrt(kpan)              ;start right away\nkright = sqrt(1-kpan)     \n       outs kleft*asig, kright*asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;                                                                                  \nf 1 0  3 -7 .5  3  .5            ;remain in center (.5 CONSTANT)                                                                          \nf 2 0 129 7  1 129 0             ;left--&gt;right                                                                                                     \nf 3 0 129 7 .5  32 1 64 0 33 .5  ;center--&gt;left--&gt;right--&gt;center    \n\ni 1  0  2  1                     ;use table 1\ni 1  3  2  2                     ;use table 2\ni 1  6  2  3                     ;use table 3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscil1i/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/oscil3/","title":"Oscil3","text":""},{"location":"opcodes/oscil3/#oscil3","title":"oscil3","text":"<p>A simple oscillator with cubic interpolation.</p> <p>oscil3 reads table ifn sequentially and repeatedly at a frequency xcps. The amplitude is scaled by xamp. Cubic interpolation is applied for table look up from internal phase values.</p>"},{"location":"opcodes/oscil3/#syntax","title":"Syntax","text":"<pre><code>ares oscil3 xamp, xcps [, ifn, iphs]\nkres oscil3 kamp, kcps [, ifn, iphs]\n</code></pre>"},{"location":"opcodes/oscil3/#initialization","title":"Initialization","text":"<p>ifn (optional) -- function table number. Requires a wrap-around guard point.  Defaults to -1 indicating a sinewave.</p> <p>iphs (optional) -- initial phase of sampling, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/oscil3/#performance","title":"Performance","text":"<p>kamp, xamp -- amplitude</p> <p>kcps, xcps -- frequency in cycles per second.</p> <p>oscil3 is identical to oscili, except that it uses cubic interpolation.</p> <p>Table ifn is incrementally sampled modulo the table length and the value obtained is multiplied by amp.</p> <p>If you need to change the oscillator table with a k-rate signal, you can use oscilikt.</p>"},{"location":"opcodes/oscil3/#examples","title":"Examples","text":"<p>Here is an example of the oscil3 opcode. It uses the file oscil3.csd.</p> Example of the oscil3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil kamp, kcps, ifn\n     outs asig,asig\n\nendin\n\ninstr 2\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil3 kamp, kcps, ifn\n     outs asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 10 1                                          ; Sine with a small amount of data\nf2 0 128 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth with a small amount of data\nf3 0 128 10 1 0   0.3 0    0.2 0     0.14 0     .111   ; Square with a small amount of data\nf4 0 128 10 1 1   1   1    0.7 0.5   0.3  0.1          ; Pulse with a small amount of data\n\ni 1  0 2 1\ni 2  3 2 1\ni 1  6 2 2\ni 2  9 2 2\ni 1 12 2 3\ni 2 15 2 3\ni 1 18 2 4\ni 2 21 2 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscil3/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscil3/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in Csound version 3.50</p>"},{"location":"opcodes/oscili/","title":"Oscili","text":""},{"location":"opcodes/oscili/#oscili","title":"oscili","text":"<p>A simple oscillator with linear interpolation.</p> <p>oscili reads table ifn sequentially and repeatedly at a frequency xcps. The amplitude is scaled by xamp. Linear interpolation is applied for table look up from internal phase values.</p>"},{"location":"opcodes/oscili/#syntax","title":"Syntax","text":"<pre><code>ares oscili xamp, xcps[, ifn, iphs]\nkres oscili kamp, kcps[, ifn, iphs]\n</code></pre>"},{"location":"opcodes/oscili/#initialization","title":"Initialization","text":"<p>ifn(optional) -- function table number. Requires a wrap-around guard point. The table number defaults to -1 which indicates a sine wave.</p> <p>iphs (optional) -- initial phase of sampling, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/oscili/#performance","title":"Performance","text":"<p>kamp, xamp -- amplitude</p> <p>kcps, xcps -- frequency in cycles per second.</p> <p>oscili differs from oscil in that the standard procedure of using a truncated phase as a sampling index is here replaced by a process that interpolates between two successive lookups. Interpolating generators will produce a noticeably cleaner output signal, but they may take as much as twice as long to run. Adequate accuracy can also be gained without the time cost of interpolation by using large stored function tables of 2K, 4K or 8K points if the space is available.</p> <p>Table ifn is incrementally sampled modulo the table length and the value obtained is multiplied by amp.</p> <p>If you need to change the oscillator table with a k-rate signal, you can use oscilikt.</p>"},{"location":"opcodes/oscili/#examples","title":"Examples","text":"<p>Here is an example of the oscili opcode. It uses the file oscili.csd.</p> Example of the oscili opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscili.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil kamp, kcps, ifn\n     outs asig,asig\n\nendin\n\ninstr 2\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscili kamp, kcps, ifn\n     outs asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 10 1                                          ; Sine with a small amount of data\nf2 0 128 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth with a small amount of data\nf3 0 128 10 1 0   0.3 0    0.2 0     0.14 0     .111   ; Square with a small amount of data\nf4 0 128 10 1 1   1   1    0.7 0.5   0.3  0.1          ; Pulse with a small amount of data\n\ni 1  0 2 1\ni 2  3 2 1\ni 1  6 2 2\ni 2  9 2 2\ni 1 12 2 3\ni 2 15 2 3\ni 1 18 2 4\ni 2 21 2 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscili/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscilikt/","title":"Oscilikt","text":""},{"location":"opcodes/oscilikt/#oscilikt","title":"oscilikt","text":"<p>A linearly interpolated oscillator that allows changing the table number at k-rate.</p> <p>oscilikt is very similar to oscili, but allows changing the table number at k-rate. It is slightly slower than oscili (especially with high control rate), although also more accurate as it uses a 31-bit phase accumulator, as opposed to the 24-bit one used by oscili.</p>"},{"location":"opcodes/oscilikt/#syntax","title":"Syntax","text":"<pre><code>ares oscilikt xamp, xcps, kfn [, iphs] [, istor]\nkres oscilikt kamp, kcps, kfn [, iphs] [, istor]\n</code></pre>"},{"location":"opcodes/oscilikt/#initialization","title":"Initialization","text":"<p>iphs (optional, defaults to 0) -- initial phase in the range 0 to 1. Other values are wrapped to the allowed range.</p> <p>istor (optional, defaults to 0) -- skip initialization.</p>"},{"location":"opcodes/oscilikt/#performance","title":"Performance","text":"<p>kamp, xamp -- amplitude.</p> <p>kcps, xcps -- frequency in Hz. Zero and negative values are allowed. However, the absolute value must be less than sr (and recommended to be less than sr/2).</p> <p>kfn -- function table number. Can be varied at control rate (useful to morph waveforms, or select from a set of band-limited tables generated by GEN30).</p>"},{"location":"opcodes/oscilikt/#examples","title":"Examples","text":"<p>Here is an example of the oscilikt opcode. It uses the file oscilikt.csd.</p> Example of the oscilikt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o oscilikt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Generate a uni-polar (0-1) square wave.\n  kamp1 init 1 \n  kcps1 init 2\n  itype = 3\n  ksquare lfo kamp1, kcps1, itype\n\n  ; Use the square wave to switch between Tables #1 and #2.\n  kamp2 init 20000\n  kcps2 init 220\n  kfn = ksquare + 1\n\n  a1 oscilikt kamp2, kcps2, kfn\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine waveform.\nf 1 0 4096 10 0 1\n; Table #2: a sawtooth wave\nf 2 0 3 -2 1 0 -1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscilikt/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscilikt/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>Example written by Kevin Conder.</p> <p>New in version 4.22</p>"},{"location":"opcodes/osciliktp/","title":"Osciliktp","text":""},{"location":"opcodes/osciliktp/#osciliktp","title":"osciliktp","text":"<p>A linearly interpolated oscillator that allows allows phase modulation.</p> <p>osciliktp allows phase modulation (which is actually implemented as k-rate frequency modulation, by differentiating phase input). The disadvantage is that there is no amplitude control, and frequency can be varied only at the control-rate. This opcode can be faster or slower than oscilikt, depending on the control-rate.</p>"},{"location":"opcodes/osciliktp/#syntax","title":"Syntax","text":"<pre><code>ares osciliktp kcps, kfn, kphs [, istor]\n</code></pre>"},{"location":"opcodes/osciliktp/#initialization","title":"Initialization","text":"<p>istor (optional, defaults to 0) -- Skips initialization.</p>"},{"location":"opcodes/osciliktp/#performance","title":"Performance","text":"<p>ares -- audio-rate ouptut signal.</p> <p>kcps -- frequency in Hz. Zero and negative values are allowed. However, the absolute value must be less than sr (and recommended to be less than sr/2).</p> <p>kfn -- function table number. Can be varied at control rate (useful to morph waveforms, or select from a set of band-limited tables generated by GEN30).</p> <p>kphs -- phase (k-rate), the expected range is 0 to 1. The absolute value of the difference of the current and previous value of kphs must be less than ksmps.</p>"},{"location":"opcodes/osciliktp/#examples","title":"Examples","text":"<p>Here is an example of the osciliktp opcode. It uses the file osciliktp.csd.</p> Example of the osciliktp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o osciliktp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1: osciliktp example\ninstr 1\n  kphs line 0, p3, 4\n\n  a1x osciliktp 220.5, 1, 0\n  a1y osciliktp 220.5, 1, -kphs\n  a1 =  a1x - a1y\n\n  out a1 * 14000\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: Sawtooth wave\nf 1 0 3 -2 1 0 -1\n\n; Play Instrument #1 for four seconds.\ni 1 0 4\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/osciliktp/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/osciliktp/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/oscilikts/","title":"Oscilikts","text":""},{"location":"opcodes/oscilikts/#oscilikts","title":"oscilikts","text":"<p>A linearly interpolated oscillator with sync status that allows changing the table number at k-rate.</p> <p>oscilikts is the same as oscilikt. Except it has a sync input that can be used to re-initialize the oscillator to a k-rate phase value. It is slower than oscilikt and osciliktp.</p>"},{"location":"opcodes/oscilikts/#syntax","title":"Syntax","text":"<pre><code>ares oscilikts xamp, xcps, kfn, async, kphs [, istor]\n</code></pre>"},{"location":"opcodes/oscilikts/#initialization","title":"Initialization","text":"<p>istor (optional, defaults to 0) -- skip initialization.</p>"},{"location":"opcodes/oscilikts/#performance","title":"Performance","text":"<p>xamp -- amplitude.</p> <p>xcps -- frequency in Hz. Zero and negative values are allowed. However, the absolute value must be less than sr (and recommended to be less than sr/2).</p> <p>kfn -- function table number. Can be varied at control rate (useful to morph waveforms, or select from a set of band-limited tables generated by GEN30).</p> <p>async -- any positive value resets the phase of oscilikts to kphs. Zero or negative values have no effect.</p> <p>kphs -- sets the phase, initially and when it is re-initialized with async.</p>"},{"location":"opcodes/oscilikts/#examples","title":"Examples","text":"<p>Here is an example of the oscilikts opcode. It uses the file oscilikts.csd.</p> Example of the oscilikts opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o oscilikts.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1: oscilikts example.\ninstr 1\n  ; Frequency envelope.\n  kfrq expon 400, p3, 1200\n  ; Phase.\n  kphs line 0.1, p3, 0.9\n\n  ; Sync 1\n  atmp1 phasor 100\n  ; Sync 2\n  atmp2 phasor 150\n  async diff 1 - (atmp1 + atmp2)\n\n  a1 oscilikts 14000, kfrq, 1, async, 0\n  a2 oscilikts 14000, kfrq, 1, async, -kphs\n\n  out a1 - a2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: Sawtooth wave\nf 1 0 3 -2 1 0 -1\n\n; Play Instrument #1 for four seconds.\ni 1 0 4\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscilikts/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscilikts/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/osciln/","title":"Osciln","text":""},{"location":"opcodes/osciln/#osciln","title":"osciln","text":"<p>Accesses table values at a user-defined frequency.</p> <p>This opcode can also be written as oscilx.</p>"},{"location":"opcodes/osciln/#syntax","title":"Syntax","text":"<pre><code>ares osciln kamp, ifrq, ifn, itimes\n</code></pre>"},{"location":"opcodes/osciln/#initialization","title":"Initialization","text":"<p>ifrq, itimes -- rate and number of times through the stored table.</p> <p>ifn -- function table number.</p>"},{"location":"opcodes/osciln/#performance","title":"Performance","text":"<p>kamp -- amplitude factor</p> <p>osciln will sample several times through the stored table at a rate of ifrq times per second, after which it will output zeros. Generates audio signals only, with output values scaled by kamp.</p>"},{"location":"opcodes/osciln/#examples","title":"Examples","text":"<p>Here is an example of the osciln opcode. It uses the file osciln.csd.</p> Example of the osciln opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o osciln.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngione ftgen 1, 0, 1024, 7, 0, 1,   1, 1024, 0\ngitwo ftgen 2, 0, 1024, 7, 0, 512, 1, 512,  0\n\ninstr 1 ;very simple waveguide system\n\nifn     = p4\nipitch  = p5\nitimes  = p6\niperiod = 1000/ipitch\n\nafeed   init   0\naimpl   osciln 1, ipitch, ifn, itimes   ;use as excitation signal\narefl   tone   aimpl + afeed, 4000\naout    atone  arefl, 5000\nafeed   vdelay arefl, iperiod, 10\n        outs   aout*3, aout*3\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0  4 1 110 1    ;use different tables,\ni 1 5  4 2 110 1    ;&amp; different pitch\ni 1 10 4 1 110 10   ;&amp; different number of times the table is read\ni 1 15 4 2 110 10\ni 1 20 6 1 880 1\ni 1 25 3 2 880 1\ni 1 30 3 1 880 10\ni 1 35 3 2 880 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/osciln/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/oscils/","title":"Oscils","text":""},{"location":"opcodes/oscils/#oscils","title":"oscils","text":"<p>A simple, fast sine oscillator.</p> <p>It uses only one multiply, and two add operations to generate one sample of output, and does not require a function table.</p>"},{"location":"opcodes/oscils/#syntax","title":"Syntax","text":"<pre><code>ares oscils iamp, icps, iphs [, iflg]\n</code></pre>"},{"location":"opcodes/oscils/#initialization","title":"Initialization","text":"<p>iamp -- output amplitude.</p> <p>icps -- frequency in Hz (may be zero or negative, however the absolute value must be less than sr/2).</p> <p>iphs -- start phase between 0 and 1.</p> <p>iflg -- sum of the following values:</p> <ul> <li>2: use double precision even if Csound was compiled to use floats.  This improves quality (especially in the case of long performance time), but may be up to twice as slow.</li> <li>1: skip initialization.</li> </ul>"},{"location":"opcodes/oscils/#performance","title":"Performance","text":"<p>ares -- audio output</p>"},{"location":"opcodes/oscils/#examples","title":"Examples","text":"<p>Here is an example of the oscils opcode. It uses the file oscils.csd.</p> Example of the oscils opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscils.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niflg = p4\nasig oscils .7, 220, 0, iflg\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 0\ni 1 3 2 2   ;double precision\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/oscils/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/oscils/#credits","title":"Credits","text":"<p>Author: Istvan Varga January 2002</p> <p>New in version 4.18</p>"},{"location":"opcodes/oscilx/","title":"Oscilx","text":""},{"location":"opcodes/oscilx/#oscilx","title":"oscilx","text":"<p>Same as the  osciln  opcode.  </p>"},{"location":"opcodes/out/","title":"Out","text":""},{"location":"opcodes/out/#out","title":"out","text":"<p>Writes audio data to an external device or stream, either from audio variables or from an audio array.</p>"},{"location":"opcodes/out/#syntax","title":"Syntax","text":"<pre><code>out asig1[, asig2,....]\nout aarray\n</code></pre>"},{"location":"opcodes/out/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>In the array case each element of the arrary is sent to the corresponding channel. This provides a way of using many channels.  The nonarray version is limited  to 1999.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with nchnls statement.</p>"},{"location":"opcodes/out/#examples","title":"Examples","text":"<p>Here is an example of the out opcode. It uses the file out.csd.</p> Example of the out opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o out.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 1\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil kamp, kcps, ifn\n     out asig   ;one channel\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1                                          ; Sine\nf2 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth\n\ni 1 0 2 1\ni 1 3 2 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/out/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/out/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997 Author: John ffitch NUIM, 2013</p> <p>Original in Csound v1</p> <p>Array version in 6.01</p>"},{"location":"opcodes/out32/","title":"Out32","text":""},{"location":"opcodes/out32/#out32","title":"out32","text":"<p>Writes 32-channel audio data to an external device or stream.</p>"},{"location":"opcodes/out32/#syntax","title":"Syntax","text":"<pre><code>out32 asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, asig10, \\\n      asig11, asig12, asig13, asig14, asig15, asig16, asig17, asig18, \\\n      asig19, asig20, asig21, asig22, asig23, asig24, asig25, asig26, \\\n      asig27, asig28, asig29, asig30, asig31, asig32\n</code></pre>"},{"location":"opcodes/out32/#performance","title":"Performance","text":"<p>out32 outputs 32 channels of audio.</p>"},{"location":"opcodes/out32/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/out32/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/outall/","title":"Outall","text":""},{"location":"opcodes/outall/#outall","title":"outall","text":"<p>Writes a single audio value to all available audio channels</p>"},{"location":"opcodes/outall/#syntax","title":"Syntax","text":"<pre><code>outall asig\n</code></pre>"},{"location":"opcodes/outall/#performance","title":"Performance","text":"<p>Sends audio samples to all accumulating output buffers (created at the beginning of performance) which serve to collect the output of all active instruments before the sound is written to disk. There can be any number of channels specified in nchnls which all receive the same data.</p>"},{"location":"opcodes/outall/#examples","title":"Examples","text":"<p>Here is an example of the outall opcode. It uses the file outall.csd.</p> Example of the outall opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil3 kamp, kcps, ifn\n     outall asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 10 1                                          ; Sine with a small amount of data\nf2 0 128 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth with a small amount of data\nf3 0 128 10 1 0   0.3 0    0.2 0     0.14 0     .111   ; Square with a small amount of data\nf4 0 128 10 1 1   1   1    0.7 0.5   0.3  0.1          ; Pulse with a small amount of data\n\ni 1  0 2 1\ni 2  3 2 1\ni 1  6 2 2\ni 2  9 2 2\ni 1 12 2 3\ni 2 15 2 3\ni 1 18 2 4\ni 2 21 2 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outall/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outall/#credits","title":"Credits","text":"<p>Author: John ffitch November 2020</p> <p>New in version 6.16</p>"},{"location":"opcodes/outc/","title":"Outc","text":""},{"location":"opcodes/outc/#outc","title":"outc","text":"<p>Writes audio data with an arbitrary number of channels to an external device or stream.</p>"},{"location":"opcodes/outc/#syntax","title":"Syntax","text":"<pre><code>outc asig1 [, asig2] [...]\n</code></pre>"},{"location":"opcodes/outc/#performance","title":"Performance","text":"<p>outc outputs as many channels as provided.  Any channels greater than nchnls are ignored. Zeros are added as necessary</p>"},{"location":"opcodes/outc/#examples","title":"Examples","text":"<p>Here is an example of the outc opcode. It uses the file outc.csd.</p> Example of the outc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 5\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .05, 30       ; sawtooth waveform at low volume\n\nkcut line 100, p3, 30   ; Vary cutoff frequency\nkresonance = 7\ninumlayer = 2\nasig lowresx asig, kcut, kresonance, inumlayer\n; output same sound to 5 channels\n     outc asig,asig,asig,asig,asig      \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outc/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outc/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/outh/","title":"Outh","text":""},{"location":"opcodes/outh/#outh","title":"outh","text":"<p>Writes 6-channel audio data to an external device or stream.</p>"},{"location":"opcodes/outh/#syntax","title":"Syntax","text":"<pre><code>outh asig1, asig2, asig3, asig4, asig5, asig6\n</code></pre>"},{"location":"opcodes/outh/#performance","title":"Performance","text":"<p>Sends 6-channel audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with nchnls statement.</p>"},{"location":"opcodes/outh/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outh/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>Introduced before Version 3</p>"},{"location":"opcodes/outiat/","title":"Outiat","text":""},{"location":"opcodes/outiat/#outiat","title":"outiat","text":"<p>Sends MIDI aftertouch messages at i-rate.</p>"},{"location":"opcodes/outiat/#syntax","title":"Syntax","text":"<pre><code>outiat ichn, ivalue, imin, imax\n</code></pre>"},{"location":"opcodes/outiat/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>ivalue -- floating point value</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p>"},{"location":"opcodes/outiat/#performance","title":"Performance","text":"<p>outiat (i-rate aftertouch output) sends aftertouch messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outiat/#examples","title":"Examples","text":"<p>Here is an example of the outiat opcode. It uses the file outiat.csd.</p> Example of the outiat opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outiat.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel  veloc\n\nivib = 25               ;low value.\noutiat 1, ivib, 0, 127  ;assign aftertouch on\nprint ivib              ;external synth for example to\nmidion 1, ikey, ivel    ;change depth of filter modulation\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30                   ;play for 30 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outiat/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outiat/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outic/","title":"Outic","text":""},{"location":"opcodes/outic/#outic","title":"outic","text":"<p>Sends MIDI controller output at i-rate.</p>"},{"location":"opcodes/outic/#syntax","title":"Syntax","text":"<pre><code>outic ichn, inum, ivalue, imin, imax\n</code></pre>"},{"location":"opcodes/outic/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inum -- controller number (0-127 for example 1 = ModWheel; 2 = BreathControl etc.)</p> <p>ivalue -- floating point value</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p>"},{"location":"opcodes/outic/#performance","title":"Performance","text":"<p>outic (i-rate MIDI controller output) sends controller messages to the MIDI OUT device. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outic/#examples","title":"Examples","text":"<p>Here is an example of the outic opcode. It uses the file outic.csd.</p> Example of the outic opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -Q1 -M0  ;;;realtime audio out -+rtmidi=virtual\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outic.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel veloc\nkbrt = 40                       ;set controller 74 (=brightness)                        \noutic 1, 74, kbrt, 0, 127       ;so filter closes a bit\nmidion 1, ikey, ivel            ;play external synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30   ;runs 30 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outic/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outic/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outic14/","title":"Outic14","text":""},{"location":"opcodes/outic14/#outic14","title":"outic14","text":"<p>Sends 14-bit MIDI controller output at i-rate.</p>"},{"location":"opcodes/outic14/#syntax","title":"Syntax","text":"<pre><code>outic14 ichn, imsb, ilsb, ivalue, imin, imax\n</code></pre>"},{"location":"opcodes/outic14/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>imsb -- most significant byte controller number when using 14-bit parameters (0-127)</p> <p>ilsb -- least significant byte controller number when using 14-bit parameters (0-127)</p> <p>ivalue -- floating point value</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 16383 (14-bit))</p>"},{"location":"opcodes/outic14/#performance","title":"Performance","text":"<p>outic14 (i-rate MIDI 14-bit controller output) sends a pair of controller messages. This opcode can drive 14-bit parameters on MIDI instruments that recognize them. The first control message contains the most significant byte of ivalue argument while the second message contains the less significant byte. imsb and ilsb are the number of the most and less significant controller.</p> <p>This opcode can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outic14/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outic14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outipat/","title":"Outipat","text":""},{"location":"opcodes/outipat/#outipat","title":"outipat","text":"<p>Sends polyphonic MIDI aftertouch messages at i-rate.</p>"},{"location":"opcodes/outipat/#syntax","title":"Syntax","text":"<pre><code>outipat ichn, inotenum, ivalue, imin, imax\n</code></pre>"},{"location":"opcodes/outipat/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>inotenum -- MIDI note number (used in polyphonic aftertouch messages)</p> <p>ivalue -- floating point value</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p>"},{"location":"opcodes/outipat/#performance","title":"Performance","text":"<p>outipat (i-rate polyphonic aftertouch output) sends polyphonic aftertouch messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outipat/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outipat/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outipb/","title":"Outipb","text":""},{"location":"opcodes/outipb/#outipb","title":"outipb","text":"<p>Sends MIDI pitch-bend messages at i-rate.</p>"},{"location":"opcodes/outipb/#syntax","title":"Syntax","text":"<pre><code>outipb ichn, ivalue, imin, imax\n</code></pre>"},{"location":"opcodes/outipb/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>ivalue -- floating point value</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p>"},{"location":"opcodes/outipb/#performance","title":"Performance","text":"<p>outipb (i-rate pitch bend output) sends pitch bend messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outipb/#examples","title":"Examples","text":"<p>Here is an example of the outipb opcode. It uses the file outipb.csd.</p> Example of the outipb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outipb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel  veloc\n\nipb = 10                ;a little out of tune\noutipb 1, ipb, 0, 127   ;(= pitchbend)\nmidion 1, ikey, ivel    ;of external synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outipb/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outipb/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outipc/","title":"Outipc","text":""},{"location":"opcodes/outipc/#outipc","title":"outipc","text":"<p>Sends MIDI program change messages at i-rate</p>"},{"location":"opcodes/outipc/#syntax","title":"Syntax","text":"<pre><code>outipc ichn, iprog, imin, imax\n</code></pre>"},{"location":"opcodes/outipc/#initialization","title":"Initialization","text":"<p>ichn -- MIDI channel number (1-16)</p> <p>iprog -- program change number in floating point</p> <p>imin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>imax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p>"},{"location":"opcodes/outipc/#performance","title":"Performance","text":"<p>outipc (i-rate program change output) sends program change messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale an i-value floating-point argument according to the imin and imax values. For example, set imin = 1.0 and imax = 2.0. When the ivalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the ivalue argument receives a 1.0 value, it will send a 0 value. i-rate opcodes send their message once during instrument initialization.</p>"},{"location":"opcodes/outipc/#examples","title":"Examples","text":"<p>Here is an example of the outipc opcode. It uses the file outipc.csd.</p> Example of the outipc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outipc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\noutipc 1, 80, 0, 127    ;program change --&gt; 80\nikey notnum \nivel veloc\nmidion 1, ikey, ivel    ;play external synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30   ;runs 30 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outipc/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outipc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkat/","title":"Outkat","text":""},{"location":"opcodes/outkat/#outkat","title":"outkat","text":"<p>Sends MIDI aftertouch messages at k-rate.</p>"},{"location":"opcodes/outkat/#syntax","title":"Syntax","text":"<pre><code>outkat kchn, kvalue, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkat/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>kvalue -- floating point value</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 127)</p> <p>outkat (k-rate aftertouch output) sends aftertouch messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkat/#examples","title":"Examples","text":"<p>Here is an example of the outkat opcode. It uses the file outkat.csd.</p> Example of the outkat opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outkat.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel  veloc\n\nkvib linseg 100, .5, 120        ;vary aftertouch in .5 second\nkvbr = int(kvib)                ;whole numbers only\noutkat 1, kvbr, 0, 127          ;assign aftertouch on\nprintk2 kvbr                    ;external synth for example to\nmidion 1, ikey, ivel            ;change depth of filter modulation\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30                           ;play for 30 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outkat/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkat/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkc/","title":"Outkc","text":""},{"location":"opcodes/outkc/#outkc","title":"outkc","text":"<p>Sends MIDI controller messages at k-rate.</p>"},{"location":"opcodes/outkc/#syntax","title":"Syntax","text":"<pre><code>outkc kchn, knum, kvalue, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkc/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>knum -- controller number (0-127 for example 1 = ModWheel; 2 = BreathControl etc.)</p> <p>kvalue -- floating point value</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p> <p>outkc (k-rate MIDI controller output) sends controller messages to MIDI OUT device. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkc/#examples","title":"Examples","text":"<p>Here is an example of the outkc opcode. It uses the file outkc.csd.</p> Example of the outkc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outkc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel  veloc\n\nkcut linseg 100, .5, 20         ;vary controller in .5 second\nkbrt = int(kcut)                ;whole numbers only\noutkc 1, 74, kbrt, 0, 127       ;controller 74 (= brightness)\nmidion 1, ikey, ivel            ;of external synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30   ;runs 30 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outkc/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkc14/","title":"Outkc14","text":""},{"location":"opcodes/outkc14/#outkc14","title":"outkc14","text":"<p>Sends 14-bit MIDI controller output at k-rate.</p>"},{"location":"opcodes/outkc14/#syntax","title":"Syntax","text":"<pre><code>outkc14 kchn, kmsb, klsb, kvalue, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkc14/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>kmsb -- most significant byte controller number when using 14-bit parameters (0-127)</p> <p>klsb -- least significant byte controller number when using 14-bit parameters (0-127)</p> <p>kvalue -- floating point value</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 16383 (14-bit))</p> <p>outkc14 (k-rate MIDI 14-bit controller output) sends a pair of controller messages. It works only with MIDI instruments which recognize them. These opcodes can drive 14-bit parameters on MIDI instruments that recognize them. The first control message contains the most significant byte of kvalue argument while the second message contains the less significant byte. kmsb and klsb are the number of the most and less significant controller.</p> <p>It can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkc14/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkc14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkpat/","title":"Outkpat","text":""},{"location":"opcodes/outkpat/#outkpat","title":"outkpat","text":"<p>Sends polyphonic MIDI aftertouch messages at k-rate.</p>"},{"location":"opcodes/outkpat/#syntax","title":"Syntax","text":"<pre><code>outkpat kchn, knotenum, kvalue, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkpat/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>knotenum -- MIDI note number (used in polyphonic aftertouch messages)</p> <p>kvalue -- floating point value</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p> <p>outkpat (k-rate polyphonic aftertouch output) sends polyphonic aftertouch messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkpat/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkpat/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkpb/","title":"Outkpb","text":""},{"location":"opcodes/outkpb/#outkpb","title":"outkpb","text":"<p>Sends MIDI pitch-bend messages at k-rate.</p>"},{"location":"opcodes/outkpb/#syntax","title":"Syntax","text":"<pre><code>outkpb kchn, kvalue, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkpb/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>kvalue -- floating point value</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p> <p>outkpb (k-rate pitch-bend output) sends pitch-bend messages. It works only with MIDI instruments which recognize them. It can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkpb/#examples","title":"Examples","text":"<p>Here is an example of the outkpb opcode. It uses the file outkpb.csd.</p> Example of the outkpb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -M0  ;;;realtime audio out and midi in and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outkpb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n\ninstr 1\n\nikey notnum \nivel  veloc\n\nkpch linseg 100, 1, 0   ;vary in 1 second\nkpb = int(kpch)         ;whole numbers only\noutkpb 1, kpb, 0, 127   ;(= pitchbend)\nmidion 1, ikey, ivel    ;of external synth\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 30\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outkpb/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkpb/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outkpc/","title":"Outkpc","text":""},{"location":"opcodes/outkpc/#outkpc","title":"outkpc","text":"<p>Sends MIDI program change messages at k-rate.</p>"},{"location":"opcodes/outkpc/#syntax","title":"Syntax","text":"<pre><code>outkpc kchn, kprog, kmin, kmax\n</code></pre>"},{"location":"opcodes/outkpc/#performance","title":"Performance","text":"<p>kchn -- MIDI channel number (1-16)</p> <p>kprog -- program change number in floating point</p> <p>kmin -- minimum floating point value (converted in MIDI integer value 0)</p> <p>kmax -- maximum floating point value (converted in MIDI integer value 127 (7 bit))</p> <p>outkpc (k-rate program change output) sends program change messages. It works only with MIDI instruments which recognize them. These opcodes can drive a different value of a parameter for each note currently active.</p> <p>It can scale the k-value floating-point argument according to the kmin and kmax values. For example: set kmin = 1.0 and kmax = 2.0. When the kvalue argument receives a 2.0 value, the opcode will send a 127 value to the MIDI OUT device. When the kvalue argument receives a 1.0 value, it will send a 0 value. k-rate opcodes send a message each time the MIDI converted value of argument kvalue changes.</p>"},{"location":"opcodes/outkpc/#examples","title":"Examples","text":"<p>Here is an example of the outkpc opcode. It uses the file outkpc.csd.</p> Example of the outkpc opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1 ;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\nkprogram init 0\n\ninstr 1 ;Triggered by MIDI notes on channel 1\n\n  ifund   notnum\n  ivel  veloc\n  idur = 1\n\n; Sends a MIDI program change message according to\n; the triggering note's velocity\noutkpc     1 ,ivel ,0 ,127\n\nnoteondur  1 ,ifund ,ivel ,idur\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Dummy ftable\nf 0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the outkpc opcode. It uses the file outkpc_flkt.csd.</p> Example of the outkpc opcode using FLTK.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d         -M0  -Q1;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 2\n\n; Example by Giorgio Zucco 2007\n\nFLpanel \"outkpc\",200,100,90,90;start of container\ngkpg, gihandle FLcount \"Midi-Program change\",0,127,1,5,1,152,40,16,23,-1\nFLpanelEnd\n\nFLrun\n\ninstr 1\n\nktrig changed gkpg\noutkpc     ktrig,gkpg,0,127\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Run instrument 1 for 60 seconds\ni 1 0  60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outkpc/#see-also","title":"See also","text":"<p>MIDI Message Output</p>"},{"location":"opcodes/outkpc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/outo/","title":"Outo","text":""},{"location":"opcodes/outo/#outo","title":"outo","text":"<p>Writes 8-channel audio data to an external device or stream.</p>"},{"location":"opcodes/outo/#syntax","title":"Syntax","text":"<pre><code>outo asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8\n</code></pre>"},{"location":"opcodes/outo/#performance","title":"Performance","text":"<p>Sends 8-channel audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with nchnls statement.</p>"},{"location":"opcodes/outo/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outo/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New after 3.30</p>"},{"location":"opcodes/outq/","title":"Outq","text":""},{"location":"opcodes/outq/#outq","title":"outq","text":"<p>Writes 4-channel audio data to an external device or stream.</p>"},{"location":"opcodes/outq/#syntax","title":"Syntax","text":"<pre><code>outq asig1, asig2, asig3, asig4\n</code></pre>"},{"location":"opcodes/outq/#performance","title":"Performance","text":"<p>Sends 4-channel audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outq/#examples","title":"Examples","text":"<p>Here is an example of the outq opcode. It uses the file outq.csd.</p> Example of the outq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .01, 110      ; sawtooth waveform at low volume\n\n;filter the first channel\nkcut1 line 60, p3, 300  ; Vary cutoff frequency\nkresonance1 = 3\ninumlayer1 = 3\nasig1 lowresx asig, kcut1, kresonance1, inumlayer1\n\n;filter the second channel\nkcut2 line 300, p3, 60  ; Vary cutoff frequency\nkresonance2 = 3\ninumlayer2 = 3\nasig2 lowresx asig, kcut2, kresonance2, inumlayer2\n\n;filter the third channel\nkcut3 line 30, p3, 100; Vary cutoff frequency\nkresonance3 = 6\ninumlayer3 = 3\nasig3 lowresx asig, kcut3, kresonance3, inumlayer3\nasig3 = asig3*.1        ; lower volume\n\n;filter the fourth channel\nkcut4 line 100, p3, 30; Vary cutoff frequency\nkresonance4 = 6\ninumlayer4 = 3\nasig4 lowresx asig, kcut4, kresonance4, inumlayer4\nasig4 = asig4*.1        ; lower volume\n\n      outq asig1, asig2, asig3, asig4; output channels 1, 2, 3 &amp; 4\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outq/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outq/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outq1/","title":"Outq1","text":""},{"location":"opcodes/outq1/#outq1","title":"outq1","text":"<p>Writes samples to quad channel 1 of an external device or stream.</p>"},{"location":"opcodes/outq1/#syntax","title":"Syntax","text":"<pre><code>outq1 asig\n</code></pre>"},{"location":"opcodes/outq1/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outq1/#examples","title":"Examples","text":"<p>Here is an example of the outq1 opcode. It uses the file outq1.csd.</p> Example of the outq1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outq1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .05, 30       ; sawtooth waveform at low volume\n\nkcut line 60, p3, 300   ; Vary cutoff frequency\nkresonance = 7\ninumlayer = 2\nasig lowresx asig, kcut, kresonance, inumlayer\n\n      outq1 asig        ; output channel 1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outq1/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outq1/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outq2/","title":"Outq2","text":""},{"location":"opcodes/outq2/#outq2","title":"outq2","text":"<p>Writes samples to quad channel 2 of an external device or stream.</p>"},{"location":"opcodes/outq2/#syntax","title":"Syntax","text":"<pre><code>outq2 asig\n</code></pre>"},{"location":"opcodes/outq2/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outq2/#examples","title":"Examples","text":"<p>Here is an example of the outq2 opcode. It uses the file outq2.csd.</p> Example of the outq2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outq2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .05, 30       ; sawtooth waveform at low volume\n\nkcut line 300, p3, 60   ; Vary cutoff frequency\nkresonance = 7\ninumlayer = 2\nasig lowresx asig, kcut, kresonance, inumlayer\n\n      outq2 asig        ; output channel 2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outq2/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outq2/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outq3/","title":"Outq3","text":""},{"location":"opcodes/outq3/#outq3","title":"outq3","text":"<p>Writes samples to quad channel 3 of an external device or stream.</p>"},{"location":"opcodes/outq3/#syntax","title":"Syntax","text":"<pre><code>outq3 asig\n</code></pre>"},{"location":"opcodes/outq3/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outq3/#examples","title":"Examples","text":"<p>Here is an example of the outq3 opcode. It uses the file outq3.csd.</p> Example of the outq3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outq3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .05, 30       ; sawtooth waveform at low volume\n\nkcut line 30, p3, 100   ; Vary cutoff frequency\nkresonance = 7\ninumlayer = 2\nasig lowresx asig, kcut, kresonance, inumlayer\n\n      outq3 asig        ; output channel 3\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outq3/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outq3/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outq4/","title":"Outq4","text":""},{"location":"opcodes/outq4/#outq4","title":"outq4","text":"<p>Writes samples to quad channel 4 of an external device or stream.</p>"},{"location":"opcodes/outq4/#syntax","title":"Syntax","text":"<pre><code>outq4 asig\n</code></pre>"},{"location":"opcodes/outq4/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outq4/#examples","title":"Examples","text":"<p>Here is an example of the outq4 opcode. It uses the file outq4.csd.</p> Example of the outq4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outq4.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .05, 30       ; sawtooth waveform at low volume\n\nkcut line 100, p3, 30   ; Vary cutoff frequency\nkresonance = 7\ninumlayer = 2\nasig lowresx asig, kcut, kresonance, inumlayer\n\n      outq4 asig        ; output channel 4\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outq4/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outq4/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outrg/","title":"Outrg","text":""},{"location":"opcodes/outrg/#outrg","title":"outrg","text":"<p>Outputs audio to a range of adjacent audio channels on the audio output device.</p>"},{"location":"opcodes/outrg/#syntax","title":"Syntax","text":"<pre><code>outrg kstart, aout1 [,aout2, aout3, ..., aoutN]\n</code></pre>"},{"location":"opcodes/outrg/#performance","title":"Performance","text":"<p>kstart - the number of the first channel of the output device to be accessed (channel numbers starts with 1, which is the first channel)</p> <p>aout1, aout2, ... aoutN - the arguments containing the audio to be output to the corresponding output channels.</p> <p>outrg allows to output a range of adjacent channels to the output device. kstart indicates the first channel to be accessed (channel 1 is the first channel). The user must be sure that the number obtained by summing kstart plus the number of accessed channels -1 is &lt;= nchnls.</p>"},{"location":"opcodes/outrg/#examples","title":"Examples","text":"<p>Here is an example of the outrg opcode. It uses the file outrg.csd.</p> Example of the outrg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outrg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4        ;quad\n0dbfs  = 1\n\ninstr 1\n\nkleft init 1\nasig  vco2 .5, 220                      ;sawtooth\nidur = p3/(nchnls-1)\nknext init idur\nkpos init 0\nkrate init 1/idur\nkbase init 0\nktime timeinsts\nif ktime&gt;=knext then\n  kleft = kleft + 1\n  knext = knext + idur\n  kpos = 0\n  kbase = ktime\nelse\n  kpos = (ktime-kbase)/idur\nendif\nprintks \"speaker %d position %f\\n\", 0, kleft, kpos\na1,a2 pan2 asig, kpos\n      outrg  kleft, a1, a2\nkpos = kbase/idur\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>speaker 1 position 0.000200\nspeaker 1 position 0.000400\nspeaker 1 position 0.000600\n.....\nspeaker 1 position 1.000000\nspeaker 2 position 0.000000\nspeaker 2 position 0.000200\n....\nspeaker 2 position 0.999800\nspeaker 3 position 0.000000\nspeaker 3 position 0.000200\n....\nspeaker 3 position 0.999600\nspeaker 4 position 0.000000\n.....\n</code></pre>"},{"location":"opcodes/outrg/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outrg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/outs/","title":"Outs","text":""},{"location":"opcodes/outs/#outs","title":"outs","text":"<p>Writes stereo audio data to an external device or stream.</p>"},{"location":"opcodes/outs/#syntax","title":"Syntax","text":"<pre><code>outs asig1, asig2\n</code></pre>"},{"location":"opcodes/outs/#performance","title":"Performance","text":"<p>Sends stereo audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outs/#examples","title":"Examples","text":"<p>Here is an example of the outs opcode. It uses the file outs.csd.</p> Example of the outs opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .01, 110      ; sawtooth waveform at low volume\n;filter a channel\nkcut1 line 60, p3, 300  ; Vary cutoff frequency\nkresonance1 = 3\ninumlayer1 = 3\nasig1 lowresx asig, kcut1, kresonance1, inumlayer1\n;filter the other channel\nkcut2 line 300, p3, 60  ; Vary cutoff frequency\nkresonance2 = 3\ninumlayer2 = 3\nasig2 lowresx asig, kcut2, kresonance2, inumlayer2\n\n      outs asig1, asig2 ; output both channels 1 &amp; 2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outs/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outs/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outs1/","title":"Outs1","text":""},{"location":"opcodes/outs1/#outs1","title":"outs1","text":"<p>Writes samples to stereo channel 1 of an external device or stream.</p>"},{"location":"opcodes/outs1/#syntax","title":"Syntax","text":"<pre><code>outs1 asig\n</code></pre>"},{"location":"opcodes/outs1/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outs1/#examples","title":"Examples","text":"<p>Here is an example of the outs1 opcode. It uses the file outs1.csd.</p> Example of the outs1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outs1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .01, 110      ; sawtooth waveform at low volume\nkcut line 60, p3, 300   ; Vary cutoff frequency\nkresonance = 3\ninumlayer = 3\nasig lowresx asig, kcut, kresonance, inumlayer\n     outs1 asig         ; output stereo channel 1 only\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outs1/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outs1/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outs2/","title":"Outs2","text":""},{"location":"opcodes/outs2/#outs2","title":"outs2","text":"<p>Writes samples to stereo channel 2 of an external device or stream.</p>"},{"location":"opcodes/outs2/#syntax","title":"Syntax","text":"<pre><code>outs2 asig\n</code></pre>"},{"location":"opcodes/outs2/#performance","title":"Performance","text":"<p>Sends audio samples to an accumulating output buffer (created at the beginning of performance) which serves to collect the output of all active instruments before the sound is written to disk. There can be any number of these output units in an instrument.</p> <p>The type (mono, stereo, quad, hex, or oct) should agree with nchnls. But as of version 3.50, Csound will attempt to change an incorrect opcode to agree with the nchnls statement. Opcodes can be chosen to direct sound to any particular channel: outs1 sends to stereo channel 1, outq3 to quad channel 3, etc.</p>"},{"location":"opcodes/outs2/#examples","title":"Examples","text":"<p>Here is an example of the outs2 opcode. It uses the file outs2.csd.</p> Example of the outs2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o outs2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig vco2 .01, 110      ; sawtooth waveform at low volume\nkcut line 300, p3, 60   ; Vary cutoff frequency\nkresonance = 3\ninumlayer = 3\nasig lowresx asig, kcut, kresonance, inumlayer\n     outs2 asig         ; output stereo channel 2 only\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outs2/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outs2/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/outvalue/","title":"Outvalue","text":""},{"location":"opcodes/outvalue/#outvalue","title":"outvalue","text":"<p>Sends an i-rate or k-rate signal or string to a user-defined channel.</p>"},{"location":"opcodes/outvalue/#syntax","title":"Syntax","text":"<pre><code>outvalue \"channel name\", ivalue\noutvalue \"channel name\", kvalue\noutvalue \"channel name\", \"string\"\n</code></pre>"},{"location":"opcodes/outvalue/#performance","title":"Performance","text":"<p>\"channel name\" -- An integer or string (in double-quotes) representing channel.</p> <p>ivalue, kvalue -- The value that is sent to the channel.</p> <p>string -- The string or string variable that is sent to the channel.</p>"},{"location":"opcodes/outvalue/#examples","title":"Examples","text":"<p>Here is an example of the outvalue opcode. It uses the file outvalue.csd.</p> Example of the outvalue opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;run this example in CsoundQt, a Csound editor that provides widgets\n;make the Widgets-panel visible, by clicking the Widgets symbol in the menu or pressing (Alt+1).\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n; written by Alex Hofmann\n\ninstr 1 ;move fader\n\nkMoveUp  linseg 0, 3, 1, 1, 1, 0.5, 0\noutvalue \"movefader\", kMoveUp\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/outvalue/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outvalue/#credits","title":"Credits","text":"<p>Author: Matt Ingalls</p> <p>i-rate version new in Csound 6.04</p>"},{"location":"opcodes/outx/","title":"Outx","text":""},{"location":"opcodes/outx/#outx","title":"outx","text":"<p>Writes 16-channel audio data to an external device or stream.</p>"},{"location":"opcodes/outx/#syntax","title":"Syntax","text":"<pre><code>outx asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, \\\n     asig9, asig10, asig11, asig12, asig13, asig14, asig15, asig16\n</code></pre>"},{"location":"opcodes/outx/#performance","title":"Performance","text":"<p>outx outputs 16 channels of audio.</p>"},{"location":"opcodes/outx/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outx/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/outz/","title":"Outz","text":""},{"location":"opcodes/outz/#outz","title":"outz","text":"<p>Writes multi-channel audio data from a ZAK array to an external device or stream.</p>"},{"location":"opcodes/outz/#syntax","title":"Syntax","text":"<pre><code>outz ksig1\n</code></pre>"},{"location":"opcodes/outz/#performance","title":"Performance","text":"<p>outz outputs from a ZAK array for nchnls of audio.</p>"},{"location":"opcodes/outz/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/outz/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.06</p>"},{"location":"opcodes/p/","title":"P","text":""},{"location":"opcodes/p/#p","title":"p","text":"<p>Show the value in a given p-field.</p>"},{"location":"opcodes/p/#syntax","title":"Syntax","text":"<pre><code>p(x)\n</code></pre> <p>This function works at i-rate and k-rate.</p>"},{"location":"opcodes/p/#initialization","title":"Initialization","text":"<p>x -- the number of the p-field.</p>"},{"location":"opcodes/p/#performance","title":"Performance","text":"<p>The value returned by the p function is the value in a p-field.</p>"},{"location":"opcodes/p/#examples","title":"Examples","text":"<p>Here is an example of the p opcode. It uses the file p.csd.</p> Example of the p opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o p.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel - 2022\n\ninstr 1\n\nipr     = p(4)\nprints  \"\\nrandom number is now %f\\n\", ipr               ; find out the values of p4\naenv    linen   1, 0, p3, .2\nasig    poscil  .5, p4\nouts    asig * aenv, asig * aenv\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1  0   1   [~ * 200]    ; random between 0-200    \ni1  +   1   [~ * 200]\ni1  +   2   [~ * 200]  \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>random number is now 105.248963\nrandom number is now 32.504969\nrandom number is now 139.496898\n</code></pre>"},{"location":"opcodes/p/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p>"},{"location":"opcodes/pan/","title":"Pan","text":""},{"location":"opcodes/pan/#pan","title":"pan","text":"<p>Distribute an audio signal amongst four channels with localization control.</p>"},{"location":"opcodes/pan/#syntax","title":"Syntax","text":"<pre><code>a1, a2, a3, a4 pan asig, kx, ky, ifn [, imode] [, ioffset]\n</code></pre>"},{"location":"opcodes/pan/#initialization","title":"Initialization","text":"<p>ifn -- function table number of a stored pattern describing the amplitude growth in a speaker channel as sound moves towards it from an adjacent speaker. Requires extended guard-point.</p> <p>imode (optional) -- mode of the kx, ky position values. 0 signifies raw index mode, 1 means the inputs are normalized (0 - 1). The default value is 0.</p> <p>ioffset (optional) -- offset indicator for kx, ky. 0 infers the origin to be at channel 3 (left rear); 1 requests an axis shift to the quadraphonic center. The default value is 0.</p>"},{"location":"opcodes/pan/#performance","title":"Performance","text":"<p>pan takes an input signal asig and distributes it amongst four outputs (essentially quad speakers) according to the controls kx and ky. For normalized input (mode=1) and no offset, the four output locations are in order: left-front at (0,1), right-front at (1,1), left-rear at the origin (0,0), and right-rear at (1,0). In the notation (kx, ky), the coordinates kx and ky, each ranging 0 - 1, thus control the 'rightness' and 'forwardness' of a sound location.</p> <p>Movement between speakers is by amplitude variation, controlled by the stored function table ifn. As kx goes from 0 to 1, the strength of the right-hand signals will grow from the left-most table value to the right-most, while that of the left-hand signals will progress from the right-most table value to the left-most. For a simple linear pan, the table might contain the linear function 0 - 1. A more correct pan that maintains constant power would be obtained by storing the first quadrant of a sinusoid. Since pan will scale and truncate kx and ky in simple table lookup, a medium-large table (say 8193) should be used.</p> <p>kx, ky values are not restricted to 0 - 1. A circular motion passing through all four speakers (inscribed) would have a diameter of root 2, and might be defined by a circle of radius R = root 1/2 with center at (.5,.5). kx, ky would then come from Rcos(angle), Rsin(angle), with an implicit origin at (.5,.5) (i.e. ioffset = 1). Unscaled raw values operate similarly. Sounds can thus be located anywhere in the polar or Cartesian plane; points lying outside the speaker square are projected correctly onto the square's perimeter as for a listener at the center.</p>"},{"location":"opcodes/pan/#example","title":"Example","text":"<p>Here is an example of the pan opcodes. It uses the file pan.csd.</p> Example of the pan opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pan.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1\n\nkcps = p4\nk1   phasor kcps                ; \"fraction\" of circle - controls speed of rotation - can be negative\nk2   tablei k1, 1, 1            ; sin of angle (sinusoid in f1)\nk3   tablei k1, 1, 1, .25, 1    ; cos of angle (sin offset 1/4 circle)\narnd randomi 400, 1000, 50      ; produce random values \nasig poscil .7, arnd, 1         ; audio signal.. \n\na1,a2,a3,a4 pan asig, k2/2, k3/2, 2, 1, 1       ; sent in a circle (f2=1st quad sin)\n        outq    a1, a2, a3, a4\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 8192 10 1\nf2 0 8193 9 .25 1 0\n\ni1 0 10 .2      ;move to the tight\ni1 11 10 -.2    ;move to the left\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pan/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/pan2/","title":"Pan2","text":""},{"location":"opcodes/pan2/#pan2","title":"pan2","text":"<p>Distribute an audio signal across two channels with a choice of methods.</p>"},{"location":"opcodes/pan2/#syntax","title":"Syntax","text":"<pre><code>a1, a2 pan2 asig, xp [, imode]\n</code></pre>"},{"location":"opcodes/pan2/#initialization","title":"Initialization","text":"<p>imode (optional) -- mode of the stereo positioning algorithm. 0 signifies equal power (harmonic) panning, 1 means the square root method, 2 means simple linear and 3 means an alternative equal-power pan (based on an UDO). The default value is 0.</p>"},{"location":"opcodes/pan2/#performance","title":"Performance","text":"<p>pan2 takes an input signal asig and distributes it across two outputs (essentially stereo speakers) according to the control xp which can be k- or a-rate. A zero value for xp indicates hard left, and a 1 is hard right.</p>"},{"location":"opcodes/pan2/#example","title":"Example","text":"<p>Here is an example of the pan2 opcodes. It uses the file pan2.csd.</p> Example of the pan2 opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pan2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkline   line    0, p3, 1     ; straight line\nain     oscili  .6, 440, giSine ; audio signal..\naL,aR   pan2    ain, kline   ; sent across image\n        outs    aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pan2/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/pan2/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK September 2007</p> <p>New in version 5.07</p>"},{"location":"opcodes/pareq/","title":"Pareq","text":""},{"location":"opcodes/pareq/#pareq","title":"pareq","text":"<p>Implementation of Zoelzer's parametric equalizer filters, with some modifications by the author.</p> <p>The formula for the low shelf filter is:</p> <pre><code>omega = 2*pi*f/sr\nK     = tan(omega/2)\n\nb0    = 1 + sqrt(2*V)*K + V*K^2\nb1    = 2*(V*K^2 - 1)\nb2    = 1 - sqrt(2*V)*K + V*K^2\n\na0    = 1 + K/Q + K^2\na1    = 2*(K^2 - 1)\na2    = 1 - K/Q + K^2\n</code></pre> <p>The formula for the high shelf filter is:</p> <pre><code>omega = 2*pi*f/sr\nK     = tan((pi-omega)/2)\n\nb0    = 1 + sqrt(2*V)*K + V*K^2\nb1    = -2*(V*K^2 - 1)\nb1    = 1 - sqrt(2*V)*K + V*K^2\n\na0    = 1 + K/Q + K^2\na1    = -2*(K^2 - 1)\na2    = 1 - K/Q + K^2\n</code></pre> <p>The formula for the peaking filter is:</p> <pre><code>omega = 2*pi*f/sr\nK     = tan(omega/2)\n\nb0 =  1 + V*K/2 + K^2\nb1 =  2*(K^2 - 1)\nb2 =  1 - V*K/2 + K^2\n\na0 =  1 + K/Q + K^2\na1 =  2*(K^2 - 1)\na2 =  1 - K/Q + K^2\n</code></pre>"},{"location":"opcodes/pareq/#syntax","title":"Syntax","text":"<pre><code>ares pareq asig, kc, kv, kq [, imode] [, iskip]\n</code></pre>"},{"location":"opcodes/pareq/#initialization","title":"Initialization","text":"<p>imode (optional, default: 0) -- operating mode</p> <ul> <li>0 = Peaking</li> <li>1 = Low Shelving</li> <li>2 = High Shelving</li> </ul> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/pareq/#performance","title":"Performance","text":"<p>kc -- center frequency in peaking mode, corner frequency in shelving mode.</p> <p>kv -- amount of boost or cut. A value less than 1 is a cut. A value greater than 1 is a boost. A value of 1 is a flat response.</p> <p>kq -- Q of the filter (sqrt(.5) is no resonance)</p> <p>asig -- the incoming signal</p>"},{"location":"opcodes/pareq/#examples","title":"Examples","text":"<p>Here is an example of the pareq opcode. It uses the file pareq.csd.</p> Example of the pareq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o pareq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr  = 4410\nksmps = 10\nnchnls = 2\n\ninstr 15\n  ifc     =       p4                       ; Center / Shelf\n  kq      =       p5                       ; Quality factor sqrt(.5) is no resonance\n  kv      =       ampdb(p6)                ; Volume Boost/Cut\n  imode   =       p7                       ; Mode 0=Peaking EQ, 1=Low Shelf, 2=High Shelf\n  kfc     linseg  ifc*2, p3, ifc/2\n  asig    rand    5000                     ; Random number source for testing\n  aout    pareq   asig, kfc, kv, kq, imode ; Parmetric equalization\n          outs    aout, aout               ; Output the results\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; SCORE:\n  ;   Sta  Dur  Fcenter  Q        Boost/Cut(dB)  Mode\n  i15 0    1    10000   .2          12             1\n  i15 +    .    5000    .2          12             1\n  i15 .    .    1000    .707       -12             2\n  i15 .    .    5000    .1         -12             0\n  e\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pareq/#see-also","title":"See also","text":"<p>Specialized Filters: Parametric EQ</p>"},{"location":"opcodes/pareq/#credits","title":"Credits","text":"<p>Hans Mikelson December 1998</p> <p>New in Csound version 3.50</p>"},{"location":"opcodes/partikkel/","title":"Partikkel","text":""},{"location":"opcodes/partikkel/#partikkel","title":"partikkel","text":"<p>Granular synthesizer with \"per grain\" control over many of its parameters.  Has a sync input to sychronize its internal grain scheduler clock to an external clock source.</p> <p>partikkel was conceived after reading Curtis Roads' book \"Microsound\", and the goal was to create an opcode that was capable of all time-domain varieties of granular synthesis described in this book. The idea being that most of the techniques only differ in parameter values, and by having a single opcode that can do all varieties of granular synthesis makes it possible to interpolate between techniques. Granular synthesis is sometimes dubbed particle synthesis, and it was thought apt to name the opcode partikkel to distinguish it from other granular opcodes.</p> <p>Some of the input parameters to partikkel is table numbers, pointing to tables where values for the \"per grain\" parameter changes are stored.  partikkel can use single-cycle or complex (e.g. sampled sound) waveforms as source waveforms for grains. Each grain consists of a mix of 4 source waveforms. Individual tuning of the base frequency can be done for each of the 4 source waveforms. Frequency modulation inside each grain is enabled via an auxillary audio input (awavfm). Trainlet synthesis is available, and trainlets can be mixed with wavetable based grains. Up to 8 separate audio outputs can be used. Fractional output values will distribute a grain between two outputs and a \"panning law\" table can be devised to control the amplitude scaling between output pairs.</p>"},{"location":"opcodes/partikkel/#syntax","title":"Syntax","text":"<pre><code>a1 [, a2, a3, a4, a5, a6, a7, a8] partikkel agrainfreq, \\\n    kdistribution, idisttab, async, kenv2amt, ienv2tab, ienv_attack, \\\n    ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, \\\n    kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \\\n    ifmamptab, kfmenv, icosine, ktraincps, knumpartials, kchroma, \\\n    ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, \\\n    kwaveform4, iwaveamptab, asamplepos1, asamplepos2, asamplepos3, \\\n    asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains \\\n    [, iopcode_id, ipanlaws]\n</code></pre>"},{"location":"opcodes/partikkel/#initialization","title":"Initialization","text":"<p>idisttab -- function table number, distribution for random grain displacements over time. The table values are interpreted as \"displacement amount\" scaled by 1/grainrate. This means that a value of 0.5 in the table will displace a grain by half the grainrate period. The table values are read randomly, and scaled by kdistribution. For realistic stochastic results, it is advisable not to use a too small table size, as this limits the amount of possible displacement values. This can also be utilized for other purposes, e.g. using quantized displacement values to work with controlled time displacement from the periodic grain rate. If kdistribution is negative, the table values will be read sequentially. A default table might be selected by using -1 as the ftable number, for idisttab the default uses a zero distribution (no displacement).</p> <p>ienv_attack -- function table number, attack shape of grain. Needs extended guard point. A default table might be selected by using -1 as the ftable number, for ienv_attack the default uses a square window (no enveloping).</p> <p>ienv_decay -- function table number, decay shape of grain. Needs extended guard point. A default table might be selected by using -1 as the ftable number, for ienv_decay the default uses a square window (no enveloping).</p> <p>ienv2tab -- function table number, additional envelope applied to grain, done after attack and decay envelopes. Can be used e.g. for fof formant synthesis. Needs extended guard point. A default table might be selected by using -1 as the ftable number, for ienv2tab the default uses a square window (no enveloping).</p> <p>icosine -- function table number, must contain a cosine, used for trainlets. Table size should be at least 2048 for good quality trainlets.</p> <p>igainmasks -- function table number, gain per grain. The sequence of values in the table is as follows: index 0 is used as a loop start point in reading the values, index 1 is used as a loop end point. Remaining indices contain gain values (normally in range 0 - 1, but other values are allowed, negative values will invert phase of waveform inside grain) for a sequence of grains, these are read at grain rate enabling exact patterns of \"gain per grain\". The loop start and end points are zero based with an origin at index 2, e.g. a loop start value of 0 and loop end value of 3 will read indices 2,3,4,5 in a loop at grain rate. A default table might be selected by using -1 as the ftable number, for igainmasks the default disables gain masking (all grains are given a gain masking value of 1).</p> <p>ichannelmasks -- function table number, see igainmasks for a description of how the values in the table are read. Range is 0 to N, where N is the number of output channels. A value of zero will send the grain to audio output 1 from the opcode. Fractional values are allowed, e.g. a value of 3.5 will mix the grain equally to outputs 4 and 5. The channelmask value wraps around from the last to the first output, so that a vaalue of N-0.5 will mix the grain equally between the last and the first output. If another panning law between outputs is desired, this can be described in the ipanlaws table. The user is responsible for keeping the values in range, the opcode will crash with out of range values. A default table might be selected by using -1 as the ftable number, for ichannelmasks the default disables channel masking (all grains are given a channel masking value of 0 and are sent to partikkel audio out 1).</p> <p>iwavfreqstarttab -- function table number, see igainmasks for a description of how the values in the table are read. Start frequency multiplicator for each grain. Pitch will glide from start frequency to end frequency following a line or curve as set by ksweepshape. A default table might be selected by using -1 as the ftable number, for iwavfreqstarttab the default uses a multiplicator of 1, disabling any start frequency modification.</p> <p>iwavfreqendtab -- function table number, see iwavfreqstarttab. End frequency multiplicator for each grain. A default table might be selected by using -1 as the ftable number, for iwavfreqendtab the default uses a multiplicator of 1, disabling any end frequency modification.</p> <p>ifmamptab -- function table number, see igainmasks for a description of how the values in the table are read. Frequency modulation index per grain. The signal awavfm will be multiplied by values read from this table. A default table might be selected by using -1 as the ftable number, for ifmamptab the default uses 1 as the index multiplicator, enabling fm for all grains.</p> <p>iwaveamptab -- function table number, the indices are read in a similar way to what is used for igainmasks. Index 0 is used as a loop start point, and index 1 is used as a loop end point. The rest of the indices are read in groups of 5, where each value represent a gain value for each of the 4 source waveforms, and the 5th value represent trainlet amplitude. A default table might be selected by using -1 as the ftable number, for iwaveamptab the default uses an equal mix of all 4 source waveforms (each with an amplitude of 0.5) and setting trainlet amp to zero.</p> <p>Computation of trainlets can be CPU intensive, and setting ktrainamp to zero will skip most of the trainlet computations. Trainlets will be normalized to peak (ktrainamp), compensating for amplitude variations caused by variations in kpartials and kchroma.</p> <p>imax_grains -- maximum number of grains per k-period. Estimating a large value should not affect performance, exceeding this value will lead to \"oldest grains\" being deleted.</p> <p>iopcode_id -- the opcode id, linking an instance of partikkel to an instance of partikkelsync, the linked partikkelsync will output trigger pulses synchronized to partikkel's grain maker scheduler. The default value is zero, which means no connection to any partikkelsync instances.</p> <p>ipanlaws -- function table number. The table describes the panning curve used for fractional channelmask values. Fractional channelmask values will mix a grain to two neighbouring outputs, with the relative gain set by the fractional value. By default if no ipanlaws table is described, a linear gain relationship is used, so that a channelmask value of e.g. 1.5 distributes the grain with 0.5 gain to output 2 and 0.5 gain to output 3. The ipanlaws table can be used to describe other gain control curves (panning laws). The table should contain 8 such gain control curves, each governing the panning between two neighbouring outputs. The curves should appear one after another in the table, in a concatenated fashion. GEN 18 can be used to create this table from separate panning curve tables (see example below). The first curve describes the panning law between output 1 and output 2, the next is for panning between outputs 2 and 3, and so on. The last curve describes the panning law between the last and the first output. The table is indexed by the channelmask value such that one output (of an output pair goverened by the panning law) uses the index (tablesize/8channelmask) while the other of the two outputs reads the value at index (tablesize/8(int(channelmask+1)-frac(channelmask))). This means that if the panning law value halfway between these two channel masks is e.g. 0.7 (which would give approximately equal power panning), then each of those two outputs will use 0.7 as the gain value.</p>"},{"location":"opcodes/partikkel/#performance","title":"Performance","text":"<p>xgrainfreq -- number of grains per second. A value of zero is allowed, and this will defer all grain scheduling to the sync input.</p> <p>async -- sync input. Input values are added to the phase value of the internal grain maker clock, enabling tempo synchronization with an external clock source. As this is an a-rate signal, inputs are usually pulses of length 1/sr. Using such pulses, the internal phase value can be \"nudged\" up or down, enabling soft or hard synchronization. Negative input values decrements the internal phase, while positive values in the range 0 to 1 increments the internal phase. An input value of 1 will always make partikkel generate a grain. If the value remains at 1, the internal grain scheduler clock will pause but any currently playing grains will still play to end.</p> <p>kdistribution -- periodic or stochastic distribution of grains, 0 = periodic. Stochastic grain displacement is in the range of kdistribution/grainrate seconds. The stochastic distribution profile (random distribution) can be set in the idisttab table. If kdistribution is negative, the result is deterministic time displacement as described by idisttab (sequential read of displacement values). Maximum grain displacement in all cases is limited to 10 seconds, and a grain will keep the values (duration, pitch etc) it was given when it was first generated (before time displacement). Since grain displacement is relative to the grain rate, displacement amount is undefined at 0Hz grain rate and kdistribution is completely disabled in this case.</p> <p>kenv2amt -- amount of enveloping for the secondary envelope for each grain. Range 0 to 1, where 0 is no secondary enveloping (square window), a value of 0.5 will use an interpolation between a square window and the shape set by ienv2tab.</p> <p>ksustain_amount -- sustain time as fraction of grain duration. I.e. balance between enveloped time(attack+decay) and sustain level time. The sustain level is taken from the last value of the ienv_attack ftable.</p> <p>ka_d_ratio -- balance between attack time and decay time. For example, with ksustain_amount set to 0.5 and ka_d_ratio set to 0.5, the attack envelope of each grain will take 25% of the grain duration, full amplitude (sustain) will be held for 50% of the grain duration, and the decay envelope will take the remaining 25% of the grain duration.</p> <p>kduration -- grain duration in milliseconds.</p> <p>kamp -- amplitude scaling of the opcode's output. Multiplied by per grain amplitude read from igainmasks. Source waveform playback inside grains can consume a significant amount of CPU cycles, especially if grain duration is long so that we have a lot of overlapping grains. Setting kamp to zero will skip waveform playback inside grains (and not generate any sound, obviously). This can be used as a \"soft\" bypass method if we want to keep the opcode active but silent for some periods of time.</p> <p>kwavfreq -- transposition scaling. Multiplied with start and end transposition values read from iwavfreqstarttab and iwavfreqendtab.</p> <p>ksweepshape -- transposition sweep shape, controls the curvature of the transposition sweep. Range 0 to 1. Low values will hold the transposition at the start value longer and then drop to the end value quickly, high values will drop to the end value quickly. A value of 0.5 will give a linear sweep. A value of exactly 0 will bypass sweep and only use the start frequency, while a value of exactly 1 will bypass sweep and only use the end frequency. The sweep generator might be slightly inaccurate in hitting the end frequency when using a steep curve and very long grains.</p> <p>awavfm -- audio input for frequency modulation inside grain.</p> <p>kfmenv -- function table number, envelope for FM modulator signal enabling the modulation index to change over the duration of a grain.</p> <p>ktraincps -- trainlet fundamental frequency.</p> <p>knumpartials -- number of partials in trainlets.</p> <p>kchroma -- chroma of trainlets. A value of 1 give equal amplitude to each partial, higher values will reduce the amplitude of lower partials while strengthening the amplitude of the higher partials.</p> <p>krandommask -- random masking (muting) of individual grains. Range 0 to 1, where a value of 0 will give no masking (all grains are played), and a value of 1 will mute all grains.</p> <p>kwaveform1 -- table number for source waveform 1.</p> <p>kwaveform2 -- table number for source waveform 2.</p> <p>kwaveform3 -- table number for source waveform 3.</p> <p>kwaveform4 -- table number for source waveform 4.</p> <p>asamplepos1 -- start position for reading source waveform 1 (in range 0..1).</p> <p>asamplepos2 -- start position for reading source waveform 2.</p> <p>asamplepos3 -- start position for reading source waveform 3.</p> <p>asamplepos4 -- start position for reading source waveform 4.</p> <p>kwavekey1 -- original key of source waveform 1. Can be used to transpose each source waveform independently.</p> <p>kwavekey2 -- as kwavekey1, but for source waveform 2.</p> <p>kwavekey3 -- as kwavekey1, but for source waveform 3.</p> <p>kwavekey4 -- as kwavekey1, but for source waveform 4.</p>"},{"location":"opcodes/partikkel/#examples","title":"Examples","text":"<p>Here is an example of the partikkel opcode. It uses the file partikkel.csd.</p> Example of the partikkel opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o partikkel.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 20\nnchnls = 2\n\ngiSine           ftgen   0, 0, 65537, 10, 1\ngiCosine         ftgen   0, 0, 8193, 9, 1, 1, 90\n\ninstr 1\n\nkgrainfreq       = 200                   ; 4 grains per second\nkdistribution    = 0                     ; periodic grain distribution\nidisttab         = -1                    ; (default) flat distribution used for grain distribution\nasync            = 0                     ; no sync input\nkenv2amt         = 0                     ; no secondary enveloping\nienv2tab         = -1                    ; default secondary envelope (flat)\nienv_attack      = -1 ;                  ; default attack envelope (flat)\nienv_decay       = -1 ;                  ; default decay envelope (flat)\nksustain_amount  = 0.5                   ; time (in fraction of grain dur) at sustain level for each grain\nka_d_ratio       = 0.5                   ; balance between attack and decay time\nkduration        = (0.5/kgrainfreq)*1000 ; set grain duration relative to grain rate\nkamp             = 5000                  ; amp\nigainmasks       = -1                    ; (default) no gain masking\nkwavfreq         = 440                   ; fundamental frequency of source waveform\nksweepshape      = 0                     ; shape of frequency sweep (0=no sweep)\niwavfreqstarttab = -1                    ; default frequency sweep start (value in table = 1, which give no frequency modification)\niwavfreqendtab   = -1                    ; default frequency sweep end (value in table = 1, which give no frequency modification)\nawavfm           = 0                     ; no FM input\nifmamptab        = -1                    ; default FM scaling (=1)\nkfmenv           = -1                    ; default FM envelope (flat)\nicosine          = giCosine              ; cosine ftable\nkTrainCps        = kgrainfreq            ; set trainlet cps equal to grain rate for single-cycle trainlet in each grain\nknumpartials     = 3                     ; number of partials in trainlet\nkchroma          = 1                     ; balance of partials in trainlet\nichannelmasks    = -1                    ; (default) no channel masking, all grains to output 1\nkrandommask      = 0                     ; no random grain masking\nkwaveform1       = giSine                ; source waveforms\nkwaveform2       = giSine                ;\nkwaveform3       = giSine                ;\nkwaveform4       = giSine                ;\niwaveamptab      = -1                    ; (default) equal mix of all 4 sourcve waveforms and no amp for trainlets\nasamplepos1      = 0                     ; phase offset for reading source waveform\nasamplepos2      = 0                     ;\nasamplepos3      = 0                     ;\nasamplepos4      = 0                     ;\nkwavekey1        = 1                     ; original key for source waveform\nkwavekey2        = 1                     ;\nkwavekey3        = 1                     ;\nkwavekey4        = 1                     ;\nimax_grains      = 100                   ; max grains per k period\n\nasig    partikkel kgrainfreq, kdistribution, idisttab, async, kenv2amt, ienv2tab, \\\n               ienv_attack, ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, \\\n               kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \\\n               ifmamptab, kfmenv, icosine, kTrainCps, knumpartials, \\\n               kchroma, ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, kwaveform4, \\\n               iwaveamptab, asamplepos1, asamplepos2, asamplepos3, asamplepos4, \\\n               kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains\n\nouts    asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5    ; partikkel\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the partikkel opcode. It uses the file partikkel-2.csd.</p> Example 2 of the partikkel opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out  \n-odac           ;;;RT audio \n; For Non-realtime ouput leave only the line below:\n; -o partikkel-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 20\nnchnls = 2\n\n; Example by Joachim Heintz and Oeyvind Brandtsegg 2008\n\ngiCosine        ftgen   0, 0, 8193, 9, 1, 1, 90         ; cosine\ngiDisttab       ftgen   0, 0, 32768, 7, 0, 32768, 1     ; for kdistribution\ngiFile          ftgen   0, 0, 0, 1, \"Mathews.wav\", 0, 0, 0      ; soundfile for source waveform\ngiWin           ftgen   0, 0, 4096, 20, 9, 1            ; grain envelope\ngiPan           ftgen   0, 0, 32768, -21, 1             ; for panning (random values between 0 and 1)\n\n\n; *************************************************\n; partikkel example, processing of soundfile\n; uses the file \"fox.wav\" \n; *************************************************\n                instr 1\n\n/*score parameters*/\nispeed            = p4            ; 1 = original speed \nigrainrate        = p5            ; grain rate\nigrainsize        = p6            ; grain size in ms\nicent             = p7            ; transposition in cent\niposrand          = p8            ; time position randomness (offset) of the pointer in ms\nicentrand         = p9            ; transposition randomness in cents\nipan              = p10           ; panning narrow (0) to wide (1)\nidist             = p11           ; grain distribution (0=periodic, 1=scattered)\n\n/*get length of source wave file, needed for both transposition and time pointer*/\nifilen            tableng giFile\nifildur           = ifilen / sr\n\n/*sync input (disabled)*/\nasync             = 0             \n\n/*grain envelope*/\nkenv2amt          = 1             ; use only secondary envelope\nienv2tab          = giWin         ; grain (secondary) envelope\nienv_attack       = -1            ; default attack envelope (flat)\nienv_decay        = -1            ; default decay envelope (flat)\nksustain_amount   = 0.5           ; no meaning in this case (use only secondary envelope, ienv2tab)\nka_d_ratio        = 0.5           ; no meaning in this case (use only secondary envelope, ienv2tab)\n\n/*amplitude*/\nkamp              = 0.4*0dbfs     ; grain amplitude\nigainmasks        = -1            ; (default) no gain masking\n\n/*transposition*/\nkcentrand         rand icentrand  ; random transposition\niorig             = 1 / ifildur   ; original pitch\nkwavfreq          = iorig * cent(icent + kcentrand)\n\n/*other pitch related (disabled)*/\nksweepshape       = 0             ; no frequency sweep\niwavfreqstarttab  = -1            ; default frequency sweep start\niwavfreqendtab    = -1            ; default frequency sweep end\nawavfm            = 0             ; no FM input\nifmamptab         = -1            ; default FM scaling (=1)\nkfmenv            = -1            ; default FM envelope (flat)\n\n/*trainlet related (disabled)*/\nicosine           = giCosine      ; cosine ftable\nkTrainCps         = igrainrate    ; set trainlet cps equal to grain rate for single-cycle trainlet in each grain\nknumpartials      = 1             ; number of partials in trainlet\nkchroma           = 1             ; balance of partials in trainlet\n\n/*panning, using channel masks*/\nimid              = .5; center\nileftmost         = imid - ipan/2\nirightmost        = imid + ipan/2\ngiPanthis         ftgen   0, 0, 32768, -24, giPan, ileftmost, irightmost  ; rescales giPan according to ipan\n                  tableiw         0, 0, giPanthis                         ; change index 0 ...\n                  tableiw         32766, 1, giPanthis                     ; ... and 1 for ichannelmasks\nichannelmasks     = giPanthis             ; ftable for panning\n\n/*random gain masking (disabled)*/\nkrandommask       = 0     \n\n/*source waveforms*/\nkwaveform1        = giFile        ; source waveform\nkwaveform2        = giFile        ; all 4 sources are the same\nkwaveform3        = giFile\nkwaveform4        = giFile\niwaveamptab       = -1            ; (default) equal mix of source waveforms and no amplitude for trainlets\n\n/*time pointer*/\nafilposphas       phasor ispeed / ifildur\n/*generate random deviation of the time pointer*/\niposrandsec       = iposrand / 1000       ; ms -&gt; sec\niposrand          = iposrandsec / ifildur ; phase values (0-1)\nkrndpos           linrand  iposrand       ; random offset in phase values\n/*add random deviation to the time pointer*/\nasamplepos1       = afilposphas + krndpos ; resulting phase values (0-1)\nasamplepos2       = asamplepos1\nasamplepos3       = asamplepos1   \nasamplepos4       = asamplepos1   \n\n/*original key for each source waveform*/\nkwavekey1         = 1\nkwavekey2         = kwavekey1     \nkwavekey3         = kwavekey1\nkwavekey4         = kwavekey1\n\n/* maximum number of grains per k-period*/\nimax_grains       = 100           \n\naL, aR          partikkel igrainrate, idist, giDisttab, async, kenv2amt, ienv2tab, \\\n                ienv_attack, ienv_decay, ksustain_amount, ka_d_ratio, igrainsize, kamp, igainmasks, \\\n                kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \\\n                ifmamptab, kfmenv, icosine, kTrainCps, knumpartials, \\\n                kchroma, ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, kwaveform4, \\\n                iwaveamptab, asamplepos1, asamplepos2, asamplepos3, asamplepos4, \\\n                kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains\n\n                outs                    aL, aR\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;i1     st      dur     speed   grate   gsize   cent    posrnd  cntrnd  pan     dist\ni1      0        3       1       200    15      0       0       0       0       0\ns\ni1      0        3       1       200    15      400     0       0       0       0\ns\ni1      0        3       1       15     450     400     0       0       0       0\ns\ni1      0        3       1       15     450     400     0       0       0       0.4\ns\ni1      0        3       1       200    15      0       400     0       0       1\ns\ni1      0        6      .5       200    20      0       0       600     .5      1\ns\ni1      0       12      .25      200    15      0       1000    400     1       1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of using panning laws with channelmasks in partikkel. It uses the file partikkel-panlaws.csd.</p> Example with panning laws with channel masks.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out  \n-odac           ;;;RT audio \n; For Non-realtime ouput leave only the line below:\n; -o partikkel-panlaws.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nnchnls  = 4\n0dbfs   = 1\n\ngiSine ftgen 0, 0, 65536, 10, 1\ngiCosine ftgen 0, 0, 8192, 9, 1, 1, 90\ngiSigmoRise ftgen 0, 0, 8193, 19, 0.5, 1, 270, 1\ngiSigmoFall ftgen 0, 0, 8193, 19, 0.5, 1, 90, 1\ngiLinUp ftgen 0, 0, 8192, 7, 0, 8192, 1\ngiConcaveUp ftgen 0, 0, 8192, 16, 0, 8192, 1.5, 1\ngiConvexUp ftgen 0, 0, 8192, 16, 0, 8192, -1.5, 1\ngiPanLaws ftgen 0, 0, 8192, 18, \n                giLinUp, 1, 0, 1023, \n                giConcaveUp, 1, 1024, 2047,  \n                giConvexUp, 1, 2048, 3071,  \n                giSigmoRise, 1, 3072, 4095\n\ninstr 1\n\n; channel masking table, using just one single mask here\nichannelmasks   ftgentmp        0, 0, 32, -2,  0, 0,   0\n\n; continuously write to masking table, \n; slowly panning the grains from output to output \n; over a 10 second period\nkchn phasor 0.1\nkchn = kchn*4\ntablew kchn, 2, ichannelmasks\n\n; init unused arate signals\nawavfm = 0\nasamplepos1 = 0\nasync = 0\n\na1,a2,a3,a4 partikkel 4, 0, -1, async, 0, -1, giSigmoRise, giSigmoFall, \n    0.9, 0.5, 100, ampdbfs(-9), -1, 1, 0, -1, -1, awavfm, \n    -1, -1, giCosine, 1, 1, 1, ichannelmasks, 0, \n    giSine, giSine, giSine, giSine, \n    -1, asamplepos1, asamplepos1, asamplepos1, asamplepos1, \n    440, 440, 440, 440, 100, 1, giPanLaws\n\noutch 1, a1, 2, a2, 3, a3, 4, a4\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 12\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/partikkel/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/partikkel/#credits","title":"Credits","text":"<p>Author: Thom Johansen Author: Torgeir Strand Henriksen Author: \u00d8yvind Brandtsegg April 2007</p> <p>Examples written by Joachim Heintz and \u00d8yvind Brandtsegg.</p> <p>New in version 5.06</p>"},{"location":"opcodes/partikkelsync/","title":"Partikkelsync","text":""},{"location":"opcodes/partikkelsync/#partikkelsync","title":"partikkelsync","text":"<p>Outputs partikkel's grain scheduler clock pulse and phase to synchronize several instances of the partikkel opcode to the same clock source.</p> <p>partikkelsync is an opcode for outputting partikkel's grain scheduler clock pulse and phase. partikkelsync's output can be used to synchronize other instances of the partikkel opcode to the same clock.</p>"},{"location":"opcodes/partikkelsync/#syntax","title":"Syntax","text":"<pre><code>async [,aphase] partikkelsync iopcode_id\n</code></pre>"},{"location":"opcodes/partikkelsync/#initialization","title":"Initialization","text":"<p>iopcode_id -- the opcode id, linking an instance of partikkel to an instance of partikkelsync.</p>"},{"location":"opcodes/partikkelsync/#performance","title":"Performance","text":"<p>async -- trigger pulse signal. Outputs trigger pulses synchronized to a partikkel opcode's grain scheduler clock. One trigger pulse is generated for each grain started in the partikkel opcode with the same opcode_id. The normal usage would be to send this signal to another partikkel opcode's async input to synchronize several instances of partikkel.</p> <p>aphase -- clock phase. Outputs a linear ramping phase signal. Can be used e.g. for softsynchronization, or just as a phase generator ala phasor.</p> <p>Example</p> <p>Here is an example of the partikkelsync opcodes. It uses the file partikkelsync.csd.</p> Example with soft sync of two partikkel generators.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out  \n-odac           ;;;RT audio \n; For Non-realtime ouput leave only the line below:\n; -o partikkel_softsync.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 20\nnchnls = 2\n\n; Example by Oeyvind Brandtsegg 2007, revised 2008\n\ngiSine          ftgen   0, 0, 65537, 10, 1\ngiCosine        ftgen   0, 0, 8193, 9, 1, 1, 90\ngiSigmoRise     ftgen   0, 0, 8193, 19, 0.5, 1, 270, 1                  ; rising sigmoid \ngiSigmoFall     ftgen   0, 0, 8193, 19, 0.5, 1, 90, 1                   ; falling sigmoid \n\n; *************************************************\n; example of soft synchronization of two partikkel instances\n; *************************************************\n        instr 1\n\n\n/*score parameters*/\nigrainrate      = p4            ; grain rate\nigrainsize      = p5            ; grain size in ms\nigrainFreq      = p6            ; fundamental frequency of source waveform\niosc2Dev        = p7            ; partikkel instance 2 grain rate deviation factor\niMaxSync        = p8            ; max soft sync amount (increasing to this value during length of note)\n\n/*overall envelope*/\niattack         = 0.001\nidecay          = 0.2\nisustain        = 0.7\nirelease        = 0.2\namp             linsegr 0, iattack, 1, idecay, isustain, 1, isustain, irelease, 0\n\nkgrainfreq      = igrainrate            ; grains per second\nkdistribution   = 0                     ; periodic grain distribution\nidisttab        = -1                    ; (default) flat distribution used\n                                        ; for grain distribution\nasync           = 0                     ; no sync input\nkenv2amt        = 0                     ; no secondary enveloping\nienv2tab        = -1                    ; default secondary envelope (flat)\nienv_attack     = giSigmoRise           ; default attack envelope (flat)\nienv_decay      = giSigmoFall           ; default decay envelope (flat)\nksustain_amount = 0.3                   ; time (in fraction of grain dur) at\n                                        ; sustain level for each grain\nka_d_ratio      = 0.2                   ; balance between attack and decay time\nkduration       = igrainsize            ; set grain duration in ms\nkamp            = 0.2*0dbfs             ; amp\nigainmasks      = -1                    ; (default) no gain masking\nkwavfreq        = igrainFreq            ; fundamental frequency of source waveform\nksweepshape     = 0                     ; shape of frequency sweep (0=no sweep)\niwavfreqstarttab = -1                   ; default frequency sweep start\n                                        ; (value in table = 1, which give\n                                        ; no frequency modification)\niwavfreqendtab  = -1                    ; default frequency sweep end\n                                        ; (value in table = 1, which give\n                                        ; no frequency modification)\nawavfm          = 0                     ; no FM input\nifmamptab       = -1                    ; default FM scaling (=1)\nkfmenv          = -1                    ; default FM envelope (flat)\nicosine         = giCosine              ; cosine ftable\nkTrainCps       = kgrainfreq            ; set trainlet cps equal to grain\n                                        ; rate for single-cycle trainlet in\n                                        ; each grain\nknumpartials    = 3                     ; number of partials in trainlet\nkchroma         = 1                     ; balance of partials in trainlet\nichannelmasks   = -1                    ; (default) no channel masking,\n                                        ; all grains to output 1\nkrandommask     = 0                     ; no random grain masking\nkwaveform1      = giSine                ; source waveforms\nkwaveform2      = giSine                ;\nkwaveform3      = giSine                ;\nkwaveform4      = giSine                ;\niwaveamptab     = -1                    ; mix of 4 source waveforms and\n                                        ; trainlets (set to default)\nasamplepos1     = 0                     ; phase offset for reading source waveform\nasamplepos2     = 0                     ;\nasamplepos3     = 0                     ;\nasamplepos4     = 0                     ;\nkwavekey1       = 1                     ; original key for source waveform\nkwavekey2       = 1                     ;\nkwavekey3       = 1                     ;\nkwavekey4       = 1                     ;\nimax_grains     = 100                   ; max grains per k period\niopcode_id      = 1                     ; id of opcode, linking partikkel\n                                        ; to partikkelsync\n\na1  partikkel kgrainfreq, kdistribution, idisttab, async, kenv2amt, \\\n       ienv2tab,ienv_attack, ienv_decay, ksustain_amount, ka_d_ratio, \\\n       kduration, kamp, igainmasks, kwavfreq, ksweepshape, \\\n       iwavfreqstarttab, iwavfreqendtab, awavfm, ifmamptab, kfmenv, \\\n       icosine, kTrainCps, knumpartials, kchroma, ichannelmasks, \\\n       krandommask, kwaveform1, kwaveform2, kwaveform3, kwaveform4, \\\n       iwaveamptab, asamplepos1, asamplepos2, asamplepos3, asamplepos4, \\\n       kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains, iopcode_id\n\nasync1          partikkelsync   iopcode_id   ; clock pulse output of the \n                                             ; partikkel instance above\nksyncGravity    line 0, p3, iMaxSync         ; strength of synchronization\naphase2         init 0                                  \nasyncPolarity   limit (int(aphase2*2)*2)-1, -1, 1\n; use the phase of partikkelsync instance 2 to find sync \n; polarity for partikkel instance 2.\n; If the phase of instance 2 is less than 0.5, we want to\n; nudge it down when synchronizing,\n; and if the phase is &gt; 0.5 we want to nudge it upwards.\nasync1          = async1*ksyncGravity*asyncPolarity  ; prepare sync signal\n                                                     ; with polarity and strength\n\nkgrainfreq2     = igrainrate * iosc2Dev  ; grains per second for second partikkel instance\niopcode_id2     = 2\na2 partikkel kgrainfreq2, kdistribution, idisttab, async1, kenv2amt, \\\n       ienv2tab, ienv_attack, ienv_decay, ksustain_amount, ka_d_ratio, \\\n       kduration, kamp, igainmasks, kwavfreq, ksweepshape, \\\n       iwavfreqstarttab, iwavfreqendtab, awavfm, ifmamptab, kfmenv, \\\n       icosine, kTrainCps, knumpartials, kchroma, ichannelmasks, \\\n       krandommask, kwaveform1, kwaveform2, kwaveform3, kwaveform4, \\\n       iwaveamptab, asamplepos1, asamplepos2, asamplepos3, \\ \n       asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, \\\n       imax_grains, iopcode_id2\n\nasync2, aphase2 partikkelsync   iopcode_id2\n; clock pulse and phase \n; output of the partikkel instance above,\n; we will only use the phase\n\nouts    a1*amp, a2*amp\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/*score parameters\nigrainrate      = p4            ; grain rate\nigrainsize      = p5            ; grain size in ms\nigrainFreq      = p6            ; frequency of source wave within grain\niosc2Dev        = p7            ; partikkel instance 2 grain rate deviation factor\niMaxSync        = p8            ; max soft sync amount (increasing to this value during length of note)\n*/\n;               GrRate  GrSize  GrFund  Osc2Dev MaxSync\n\ni1 0    10      2       20      880     1.3     0.3\ns\ni1 0    10      5       20      440     0.8     0.3     \ns\ni1 0    6       55      15      660     1.8     0.45\ns\ni1 0    6       110     10      440     0.6     0.6     \ns\ni1 0    6       220     3       660     2.6     0.45\ns\ni1 0    6       220     3       660     2.1     0.45\ns\ni1 0    6       440     3       660     0.8     0.22\ns\n\ne\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/partikkelsync/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/partikkelsync/#credits","title":"Credits","text":"<p>Author: Thom Johansen Author: Torgeir Strand Henriksen Author: \u00d8yvind Brandtsegg April 2007</p> <p>New in version 5.06</p>"},{"location":"opcodes/passign/","title":"Passign","text":""},{"location":"opcodes/passign/#passign","title":"passign","text":"<p>Assigns a range of p-fields to ivariables, or i- or k-array.</p>"},{"location":"opcodes/passign/#syntax","title":"Syntax","text":"<pre><code>ivar1, ... passign [istart][, iend]\niarray passign [istart][, iend]\nkarray passign [istart][, iend]\n</code></pre>"},{"location":"opcodes/passign/#initialisation","title":"Initialisation","text":"<p>The optional argument istart gives the index of the first p-field to assign.  The default value is 1, corresponding to the instrument number.</p> <p>The optional argument iend gives the index of the last p-field to assign.  The default value is 0, which means all.</p> <p>One of the variables can be a string variable, in which case it is assigned the only string parameter, if there is one, or an error otherwise.</p>"},{"location":"opcodes/passign/#performance","title":"Performance","text":"<p>passign transfers the instrument p-fields to instrument variables, starting with the one identified by the istart argument.   There should not be more variables than p-fields, but there may be fewer.</p> <p>passign can transfer the instrument p-fields to a one dimensional array, either an iarray or a karray.</p> <p>Example</p> <p>Here is an example of the passign opcode. It uses the file passign.csd.</p> A variant of toot8.csd that uses passign.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o passign.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 8\n\nidur,iamp,iskiptime,iattack,irelease,irvbtime,irvbgain  passign   3\n\nkamp      linen     iamp, iattack, idur, irelease\nasig      soundin   \"fox.wav\", iskiptime\narampsig  =         kamp * asig\naeffect   reverb    asig, irvbtime\narvbretrn =         aeffect * irvbgain\n;mix dry &amp; wet signals\n          outs      arampsig + arvbretrn, arampsig + arvbretrn\n\n          endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;ins strt dur  amp  skip atk  rel       rvbt rvbgain\ni8   0    4    .3   0    .03  .1        1.5  .3\ni8   4    4    .3   1.6  .1   .1        3.1  .7\ni8   8    4    .3   0    .5   .1        2.1  .2\ni8   12   4    .4   0    .01  .1        1.1  .1\ni8   16   4    .5   0.1  .01  .1        0.1  .1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/passign/#see-also","title":"See also","text":"<p>assign, pcount.</p> <p>Initialization and Reinitialization</p>"},{"location":"opcodes/passign/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK December 2009</p> <p>New in version 5.12; end point and array version after 5.12</p>"},{"location":"opcodes/paulstretch/","title":"Paulstretch","text":""},{"location":"opcodes/paulstretch/#paulstretch","title":"paulstretch","text":"<p>Extreme time-stretching algorithm by Nasca Octavian Paul.</p> <p>The paulstretch opcode is a lightweight implementation of the PaulStretch time-stretching algorithm by Nasca Octavian Paul. It is ideal for timestretching a signal by very large amounts.</p> <p>The Paulstretch algorithm works very similarly to other STFT-based timestretching methods, using overlap-add with a hanning window. Unique to paulstretch are the use of scrambled phase and very large window sizes (specified in seconds).</p>"},{"location":"opcodes/paulstretch/#syntax","title":"Syntax","text":"<pre><code>asig paulstretch istretch, iwindowsize, ift\n</code></pre>"},{"location":"opcodes/paulstretch/#initialization","title":"Initialization","text":"<p>istretch -- Stretch factor.</p> <p>iwindowsize -- Window size, in seconds.</p> <p>ift -- source signal function table. Deferred-allocation tables (see GEN01) are accepted, but the opcode expects a mono source.</p>"},{"location":"opcodes/paulstretch/#examples","title":"Examples","text":"<p>Here is an example of the paulstretch opcode. It uses the file paulstretch.csd</p> Example of the paulstretch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o paulstretch.wav -W\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 100\n0dbfs = 1\nnchnls = 2\n\ngiwav ftgen 0, 0, 0, 1, \"fox.wav\", 0, 0, 1\n\ninstr 1\naout paulstretch 10, 0.2, giwav\nouts aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 30\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/paulstretch/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/paulstretch/#credits","title":"Credits","text":"<p>Author: Paul Batchelor May 2016</p>"},{"location":"opcodes/pcauchy/","title":"Pcauchy","text":""},{"location":"opcodes/pcauchy/#pcauchy","title":"pcauchy","text":"<p>Cauchy distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/pcauchy/#syntax","title":"Syntax","text":"<pre><code>ares pcauchy kalpha\nires pcauchy kalpha\nkres pcauchy kalpha\n</code></pre>"},{"location":"opcodes/pcauchy/#performance","title":"Performance","text":"<p>pcauchy kalpha -- controls the spread from zero (big kalpha = big spread). Outputs positive numbers only.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/pcauchy/#examples","title":"Examples","text":"<p>Here is an example of the pcauchy opcode. It uses the file pcauchy.csd.</p> Example of the pcauchy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pcauchy.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; every run time same values\n\nkalpha  pcauchy 1000\n        printk  .2, kalpha              ; look\naout    oscili  0.8, 440+kalpha, 1      ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nkalpha  pcauchy 1000\n        printk  .2, kalpha              ; look \naout    oscili  0.8, 440+kalpha, 1      ; &amp; listen\n        outs    aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>i   1 time     0.00033:    10.48851\ni   1 time     0.20033:     0.29508\ni   1 time     0.40033:     1.75214\ni   1 time     0.60033:    22.88281\ni   1 time     0.80033:    16.06435\ni   1 time     1.00000:     0.43110\ni   1 time     1.20033:    16.51694\ni   1 time     1.40033:     2.98797\ni   1 time     1.60033:     1.32767\ni   1 time     1.80000:    17.94039\ni   1 time     2.00000:     4.85994\nSeeding from current time 1526147515\ni   2 time     3.00033:     0.89797\ni   2 time     3.20033:     9.19447\ni   2 time     3.40033:     0.73053\ni   2 time     3.60000:     7.43371\ni   2 time     3.80033:     5.87640\ni   2 time     4.00000:     0.80456\ni   2 time     4.20000:     4.50637\ni   2 time     4.40033:     2.08145\ni   2 time     4.60033:    13.47125\ni   2 time     4.80033:     3.16399\ni   2 time     5.00000:    11.05428\n</code></pre>"},{"location":"opcodes/pcauchy/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/pcauchy/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/pchbend/","title":"Pchbend","text":""},{"location":"opcodes/pchbend/#pchbend","title":"pchbend","text":"<p>Get the current pitch-bend value for this channel.</p>"},{"location":"opcodes/pchbend/#syntax","title":"Syntax","text":"<pre><code>ibend pchbend [imin] [, imax]\nkbend pchbend [imin] [, imax]\n</code></pre>"},{"location":"opcodes/pchbend/#initialization","title":"Initialization","text":"<p>imin, imax (optional) -- set minimum and maximum limits on values obtained</p>"},{"location":"opcodes/pchbend/#performance","title":"Performance","text":"<p>Get the current pitch-bend value for this channel. Note that this access to pitch-bend data is independent of the MIDI pitch, enabling the value here to be used for any arbitrary purpose.</p>"},{"location":"opcodes/pchbend/#examples","title":"Examples","text":"<p>Here is an example of the pchbend opcode. It uses the file pchbend.csd.</p> Example of the pchbend opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -Q1 -Ma  ;;;realtime audio out and midi in (on all inputs) and out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pchbend.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt; \n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr   1       ;use external midi keyboard\n\nicps cpsmidi\nkbnd pchbend 0, 100                                     ;one octave lower and higher\nkenv linsegr 0,.001, 1, .1, 0                           ;amplitude envelope \nasig pluck .8 * kenv, icps+kbnd, 440, 0, 1\n     outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\nf 0 30  ;runs 30 seconds\n\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt;   \n</code></pre>"},{"location":"opcodes/pchbend/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/pchbend/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/pchmidi/","title":"Pchmidi","text":""},{"location":"opcodes/pchmidi/#pchmidi","title":"pchmidi","text":"<p>Get the note number of the current MIDI event, expressed in pitch-class units.</p>"},{"location":"opcodes/pchmidi/#syntax","title":"Syntax","text":"<pre><code>ipch pchmidi\n</code></pre>"},{"location":"opcodes/pchmidi/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, expressed in pitch-class units for local processing.</p> <p> pchmidi vs. pchmidinn</p> <p>The pchmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With pchmidi, the Midi note number value is taken from the Midi event that is internally associated with the instrument instance.  On the other hand, the pchmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for pchmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.</p>"},{"location":"opcodes/pchmidi/#examples","title":"Examples","text":"<p>Here is an example of the pchmidi opcode. It uses the file pchmidi.csd.</p> Example of the pchmidi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o pchmidi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; This example expects MIDI note inputs on channel 1\n  i1 pchmidi\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;Dummy f-table to give time for real-time MIDI events\nf 0 8000\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pchmidi/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/pchmidi/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/pchmidib/","title":"Pchmidib","text":""},{"location":"opcodes/pchmidib/#pchmidib","title":"pchmidib","text":"<p>Get the note number of the current MIDI event and modify it by the current pitch-bend value, express it in pitch-class units.</p>"},{"location":"opcodes/pchmidib/#syntax","title":"Syntax","text":"<pre><code>ipch pchmidib [irange]\nkpch pchmidib [irange]\n</code></pre>"},{"location":"opcodes/pchmidib/#initialization","title":"Initialization","text":"<p>irange (optional) -- the pitch bend range in semitones</p>"},{"location":"opcodes/pchmidib/#performance","title":"Performance","text":"<p>Get the note number of the current MIDI event, modify it by the current pitch-bend value, and express the result in pitch-class units. Available as an i-time value or as a continuous k-rate value.</p>"},{"location":"opcodes/pchmidib/#examples","title":"Examples","text":"<p>Here is an example of the pchmidib pchmidib. It uses the file pchmidib.csd.</p> Example of the pchmidib pchmidib.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o pchmidib.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; This example expects MIDI note inputs on channel 1\n  i1 pchmidib\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;Dummy f-table to give time for real-time MIDI events\nf 0 8000\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pchmidib/#see-also","title":"See also","text":"<p>Midi Converters</p>"},{"location":"opcodes/pchmidib/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/pchmidinn/","title":"Pchmidinn","text":""},{"location":"opcodes/pchmidinn/#pchmidinn","title":"pchmidinn","text":"<p>Converts a Midi note number value to octave point pitch-class units.</p>"},{"location":"opcodes/pchmidinn/#syntax","title":"Syntax","text":"<pre><code>pchmidinn (MidiNoteNumber)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/pchmidinn/#performance","title":"Performance","text":"<p>pchmidinn is a function that takes an i-rate or k-rate value representing a Midi note number and returns the equivalent pitch value in Csound's octave point pitch-class format. This conversion assumes that Middle C (8.00 in pch) is Midi note number 60. Midi note number values are typically integers in the range from 0 to 127 but fractional values or values outside of this range will be interpreted consistently.</p> <p> pchmidinn vs. pchmidi</p> <p>The pchmidinn opcode may be used in any Csound instrument instance whether it is activated from a Midi event, score event, line event, or from another instrument.  The input value for pchmidinn might for example come from a p-field in a textual score or it may have been retrieved from the real-time Midi event that activated the current note using the notnum opcode.  You must specify an i-rate or k-rate expression for the Midi note number that is to be converted.  On the other hand, the pchmidi opcode only produces meaningful results in a Midi-activated note (either real-time or from a Midi score with the -F flag).  With pchmidi, the Midi note number value is taken from the Midi event associated with the instrument instance, and no location or expression for this value may be specified.</p> <p>pchmidinn and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/pchmidinn/#examples","title":"Examples","text":"<p>Here is an example of the pchmidinn opcode. It uses the file cpsmidinn.csd.</p> Example of the pchmidinn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n; Prints a table showing the equivalents of all Midi\n; note numbers from 0-127 in cycles-per-second, \n; octave.decimal, and octave.pitchclass units.\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform.\n; This example produces no audio, so we render in\n; non-realtime and turn off sound to disk:\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n  ; i-time loop to print conversion table\n  imidiNN =   0\n  loop1:\n    icps  = cpsmidinn(imidiNN)\n    ioct  = octmidinn(imidiNN)\n    ipch  = pchmidinn(imidiNN)\n\n    print   imidiNN, icps, ioct, ipch\n\n    imidiNN = imidiNN + 1\n  if (imidiNN &lt; 128) igoto loop1\nendin\n\ninstr 2\n  ; test k-rate converters\n  kMiddleC  =   60\n  kcps  = cpsmidinn(kMiddleC)\n  koct  = octmidinn(kMiddleC)\n  kpch  = pchmidinn(kMiddleC)\n\n  printks \"%d %f %f %f\\n\", 1.0, kMiddleC, kcps, koct, kpch\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0\ni2 0 0.1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pchmidinn/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/pchmidinn/#credits","title":"Credits","text":"<p>Derived from original value converters by Barry Vercoe.</p> <p>New in version 5.07</p>"},{"location":"opcodes/pchoct/","title":"Pchoct","text":""},{"location":"opcodes/pchoct/#pchoct","title":"pchoct","text":"<p>Converts an octave-point-decimal value to pitch-class.</p>"},{"location":"opcodes/pchoct/#syntax","title":"Syntax","text":"<pre><code>pchoct (oct)  (init- or control-rate args only)\n</code></pre> <p>where the argument within the parentheses may be a further expression.</p>"},{"location":"opcodes/pchoct/#performance","title":"Performance","text":"<p>pchoct and its related opcodes are really value converters with a special function of manipulating pitch data.</p> <p>Data concerning pitch and frequency can exist in any of the following forms:</p> Name Abbreviation octave point pitch-class (8ve.pc) pch octave point decimal oct cycles per second cps Midi note number (0-127) midinn <p>The first two forms consist of a whole number, representing octave registration, followed by a specially interpreted fractional part. For pch, the fraction is read as two decimal digits representing the 12 equal-tempered pitch classes from .00 for C to .11 for B. For oct, the fraction is interpreted as a true decimal fractional part of an octave. The two fractional forms are thus related by the factor 100/12. In both forms, the fraction is preceded by a whole number octave index such that 8.00 represents Middle C, 9.00 the C above, etc. Midi note number values range between 0 and 127 (inclusively) with 60 representing Middle C, and are usually whole numbers. Thus A440 can be represented alternatively by 440 (cps), 69 (midinn), 8.09 (pch), or 8.75 (oct). Microtonal divisions of the pch semitone can be encoded by using more than two decimal places.</p> <p>The mnemonics of the pitch conversion units are derived from morphemes of the forms involved, the second morpheme describing the source and the first morpheme the object (result). Thus cpspch(8.09) will convert the pitch argument 8.09 to its cps (or Hertz) equivalent, giving the value of 440. Since the argument is constant over the duration of the note, this conversion will take place at i-time, before any samples for the current note are produced.</p> <p>By contrast, the conversion cpsoct(8.75 + k1) which gives the value of A440 transposed by the octave interval k1. The calculation will be repeated every k-period since that is the rate at which k1 varies.</p> <p> Note</p> <p>The conversion from pch, oct, or midinn into cps is not a linear operation but involves an exponential process that could be time-consuming when executed repeatedly. Csound now uses a built-in table lookup to do this efficiently, even at audio rates. Because the table index is truncated without interpolation, pitch resolution when using one of these opcodes is limited to 8192 discrete and equal divisions of the octave, and some pitches of the standard 12-tone equally-tempered scale are very slightly mistuned (by at most 0.15 cents).</p>"},{"location":"opcodes/pchoct/#examples","title":"Examples","text":"<p>Here is an example of the pchoct opcode. It uses the file pchoct.csd.</p> Example of the pchoct opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o pchoct.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Convert an octave-point-decimal value into a \n  ; pitch-class value.\n  ioct = 8.75\n  ipch = pchoct(ioct)\n\n  print ipch\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  ipch = 8.090\n</code></pre>"},{"location":"opcodes/pchoct/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/pchoct/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/pchtom/","title":"Pchtom","text":""},{"location":"opcodes/pchtom/#pchtom","title":"pchtom","text":"<p>Convert pch to midi note number</p> <p>Plugin opcode in emugens.</p> <p>pch representation has the form Octave.pitchclass, pitchclass being a number between 00 and 12.</p> <pre><code>pch        midi    note name\n----------------------------\n8.09       69      4A\n8.00       60      4C\n</code></pre>"},{"location":"opcodes/pchtom/#syntax","title":"Syntax","text":"<pre><code>imidi pchtom ipch\nkmidi pchtom kpch\n</code></pre>"},{"location":"opcodes/pchtom/#performance","title":"Performance","text":"<p>kpch / ipch -- pitch represented as Octave.pitchclass</p> <p>kmidi / imidi -- midi note number</p> <p> Note</p> <p>Use pchmidinn to perform the opposite operation of this opcode.</p>"},{"location":"opcodes/pchtom/#examples","title":"Examples","text":"<p>Here is an example of the pchtom opcode. It uses the file pchtom.csd.</p> Example of the pchtom opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\n; Show some conversions, both at i- and at k-time\n\ninstr 1\n  imidi = pchtom(8.09)\n  print imidi\n\n  kidx init 0\n\n  kpch = 8 + kidx / 100\n  kmidi = pchtom(kpch)\n  kidx += 1\n  printf \"kpch: %f    kmidi: %f\\n\", kidx+1, kpch, kmidi\n\n  if kidx &gt;= 12 then\n    turnoff\n  endif\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pchtom/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p> <p>Midi Converters</p>"},{"location":"opcodes/pchtom/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/pconvolve/","title":"Pconvolve","text":""},{"location":"opcodes/pconvolve/#pconvolve","title":"pconvolve","text":"<p>Convolution based on a uniformly partitioned overlap-save algorithm</p> <p>Compared to the convolve opcode, pconvolve has these benefits:</p> <ul> <li>small delay</li> <li>possible to run in real-time for shorter impulse files</li> <li>no pre-process analysis pass</li> <li>can often render faster than convolve</li> </ul>"},{"location":"opcodes/pconvolve/#syntax","title":"Syntax","text":"<pre><code>ar1 [, ar2] [, ar3] [, ar4] pconvolve ain, ifilcod [, ipartitionsize, ichannel]\n</code></pre>"},{"location":"opcodes/pconvolve/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting an impulse response soundfile. Multichannel files are supported, the file must have the same sample-rate as the orc. [Note: cvanal files cannot be used!]  Keep in mind that longer files require more calculation time [and probably larger partition sizes and more latency].  At current processor speeds, files longer than a few seconds may not render in real-time.</p> <p>ipartitionsize (optional, defaults to the output buffersize [-b]) -- the size in samples of each partition of the impulse file.  This is the parameter that needs tweaking for best performance depending on the impulse file size. Generally, a small size means smaller latency but more computation time. If you specify a value that is not a power-of-2 the opcode will find the next power-of-2 greater and use that as the actual partition size.</p> <p>ichannel (optional) -- which channel to use from the impulse response data file.</p>"},{"location":"opcodes/pconvolve/#performance","title":"Performance","text":"<p>ain -- input audio signal.</p> <p>The overall latency of the opcode can be calculated as such [assuming ipartitionsize is a power of 2]</p> <pre><code>ilatency = (ksmps &lt;&gt; ipartitionsize ? ipartitionsize + ksmps : ipartitionsize)/sr\n</code></pre>"},{"location":"opcodes/pconvolve/#examples","title":"Examples","text":"<p>Instrument 1 shows an example of real-time convolution.</p> <p>Instrument 2 shows how to do file-based convolution with a 'look ahead' method to remove all delay.</p> <p> NOTE</p> <p>You can download impulse response files from noisevault.com or replace the filenames with your own impulse files.</p> <p>Here is an example of the pconvolve opcode. It uses the file pconvolve.csd.</p> Example of the pconvolve opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pconvolve.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; additions by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\nnchnls_i = 1    ; assume only one mono signal for audio input!\n0dbfs  = 1\n\ninstr   1\n\nkmix = .5                                   ; Wet/dry mix\nkvol  = .05*kmix                            ; volume level of reverb\n\nkmix = (kmix &lt; 0 || kmix &gt; 1 ? .5 : kmix)   ; do some safety checking\nkvol  = (kvol &lt; 0 ? 0 : .5*kvol*kmix)       ; to make sure we the parameters a good\n\nipartitionsize = p4                         ; size of each convolution partion\n                                            ; for best performance, this parameter needs to be tweaked\nidel = (ksmps &lt; ipartitionsize ? ipartitionsize + ksmps : ipartitionsize)/sr    ; calculate latency\nprints \"\\nConvolving with a latency of %f seconds\\n\", idel\nprints \"***if no live input is given, nothing will sound...***\\n\\n\"\n\nalive in                                    ; get live input (mono)\nawetl, awetr pconvolve kvol* (alive), \"drumsSlp.wav\", ipartitionsize\n\nadryl delay (1-kmix)*alive, idel            ; delay dry signal, to align it with the convoled sig\nadryr delay (1-kmix)*alive, idel\n      outs adryl+awetl, adryr+awetr\n\nendin\n\ninstr 2\n\nimix = 0.5                                  ; Wet/dry mix\nivol = .05*imix                             ; volume level of reverb when wet/dry mix is changed, to avoid clipping\n\nipartitionsize = 1024                       ; size of each convolution partion\nidel = (ksmps &lt; ipartitionsize ? ipartitionsize + ksmps : ipartitionsize)/sr   ; latency of pconvolve opcode\n\nkcount  init    idel*kr\n; since we are using a soundin [instead of in] we can do a kind of \"look ahead\"\n; without output, creating zero-latency  by looping during one k-pass\nloop:\n    asig soundin p4, 0\n    awetl, awetr pconvolve ivol*(asig),\"rv_stereo.wav\", ipartitionsize\n    adry delay  (1-imix)*asig,idel  ; Delay dry signal, to align it with\n    kcount = kcount - 1\n if kcount &gt; 0 kgoto loop\n    outs awetl+adry, awetr+adry\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 20 1024       ;play live for 20 seconds\n\ni 2 20 5 \"fox.wav\"\ni 2 25 5 \"flute.aiff\"\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pconvolve/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/pconvolve/#credits","title":"Credits","text":"<p>Author: Matt Ingalls 2004</p>"},{"location":"opcodes/pcount/","title":"Pcount","text":""},{"location":"opcodes/pcount/#pcount","title":"pcount","text":"<p>Returns the number of pfields belonging to a note event.</p>"},{"location":"opcodes/pcount/#syntax","title":"Syntax","text":"<pre><code>icount pcount\n</code></pre>"},{"location":"opcodes/pcount/#initialization","title":"Initialization","text":"<p>icount - stores the number of pfields for the current note event.</p> <p> Note</p> <p>Note that the reported number of pfields is not necessarily what is explicitly written in the score, but the pfields available to the instrument through mechanisms like pfield carry.</p>"},{"location":"opcodes/pcount/#examples","title":"Examples","text":"<p>Here is an example of the pcount opcode. It uses the file pcount.csd.</p> Example of the pcount opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pcount.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; This UDO returns a pfield value but returns 0 if it does not exist.\nopcode  mypvalue, i, i\n        index  xin\n        inum   pcount\n        if        (index &gt; inum)  then\n                iout = 0.0\n        else\n                iout pindex index\n        endif\n\n        xout    iout\nendop\n\n; Envelope UDO that reads parameters from a flexible number of pfields\n; Syntax:   kenv  flexlinseg  ipstart\n;           ipstart is the first pfield of the envelope\n;               parameters.  Reads remaining pfields (up to 21 of them).\n;           kenv is the output envelope.\n\nopcode  flexlinseg, k, i\n        ipstart xin\n\n        iep1   mypvalue ipstart\n        iep2   mypvalue ipstart + 1\n        iep3   mypvalue ipstart + 2\n        iep4   mypvalue ipstart + 3\n        iep5   mypvalue ipstart + 4\n        iep6   mypvalue ipstart + 5\n        iep7   mypvalue ipstart + 6\n        iep8   mypvalue ipstart + 7\n        iep9   mypvalue ipstart + 8\n        iepa   mypvalue ipstart + 9\n        iepb   mypvalue ipstart + 10\n        iepc   mypvalue ipstart + 11\n        iepd   mypvalue ipstart + 12\n        iepe   mypvalue ipstart + 13\n        iepf   mypvalue ipstart + 14\n        iepg   mypvalue ipstart + 15\n        ieph   mypvalue ipstart + 16\n        iepi   mypvalue ipstart + 17\n        iepj   mypvalue ipstart + 18\n        iepk   mypvalue ipstart + 19\n        iepl   mypvalue ipstart + 20\n\n        kenv   linseg    iep1, iep2, iep3, iep4, iep5, iep6, iep7, iep8, \\\n                           iep9, iepa, iepb, iepc, iepd, iepe, iepf, iepg, \\\n                           ieph, iepi, iepj, iepk, iepl \n        xout   kenv\nendop\n\ninstr 1\n; This instrument only requires 3 pfields but can accept up to 24.\n; (You will still get warnings about more than 3).      \nkenv flexlinseg  4              ; envelope params start at p4\naout oscili kenv*.5, 256, 1\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1  0 8192 10 1\n\ni1  0 2  0.0 1.0 1.0 1.0 0.0\ni1  2 2  0.0 0.1 1.0 1.0 1.0 0.1 0.0\ni1  4 2  0.0 0.5 0.0                            ; one problem is that \"missing\" pfields carry\ni1  6 2  0.0 0.5 0.0 !                          ; now we can fix this problem with !\ni1  8 10  0.0  3.0 1.0  0.3 0.1  0.3 1.0  0.3 0.1  0.3 1.0  0.3 0.1  0.8 0.9  5.0 0.0\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>WARNING: instr 1 uses 3 p-fields but is given 8\nB  0.000 ..  2.000 T  2.000 TT  2.000 M:  0.49966  0.49966\nWARNING: instr 1 uses 3 p-fields but is given 10\nB  2.000 ..  4.000 T  4.000 TT  4.000 M:  0.50000  0.50000\nWARNING: instr 1 uses 3 p-fields but is given 10\nB  4.000 ..  6.000 T  6.000 TT  6.000 M:  0.49943  0.49943\nWARNING: instr 1 uses 3 p-fields but is given 6\nB  6.000 ..  8.000 T  8.000 TT  8.000 M:  0.00000  0.00000\nWARNING: instr 1 uses 3 p-fields but is given 20\nB  8.000 .. 18.000 T 18.000 TT 18.000 M:  0.49994  0.49994\n</code></pre> <p>The warnings occur because pfields are not used explicitly by the instrument.</p>"},{"location":"opcodes/pcount/#see-also","title":"See also","text":"<p>Sensing and Control: Score control</p>"},{"location":"opcodes/pcount/#credits","title":"Credits","text":"<p>Example by: Anthony Kozar</p> <p>Dec. 2006</p>"},{"location":"opcodes/pdclip/","title":"Pdclip","text":""},{"location":"opcodes/pdclip/#pdclip","title":"pdclip","text":"<p>Performs linear clipping on an audio signal or a phasor.</p> <p>The pdclip opcode allows a percentage of the input range of a signal to be clipped to fullscale. It is similar to simply multiplying the signal and limiting the range of the result, but pdclip allows you to think about how much of the signal range is being distorted instead of the scalar factor and has a offset parameter for assymetric clipping of the signal range. pdclip is also useful for remapping phasors for phase distortion synthesis.</p>"},{"location":"opcodes/pdclip/#syntax","title":"Syntax","text":"<pre><code>aout pdclip ain, kWidth, kCenter [, ibipolar [, ifullscale]]\n</code></pre>"},{"location":"opcodes/pdclip/#initialization","title":"Initialization","text":"<p>ibipolar -- an optional parameter specifying either unipolar (0) or bipolar (1) mode.  Defaults to unipolar mode.</p> <p>ifullscale -- an optional parameter specifying the range of input and output values. The maximum will be ifullscale. The minimum depends on the mode of operation: zero for unipolar or -ifullscale for bipolar.  Defaults to 1.0 -- you should set this parameter to the maximum expected input value.</p>"},{"location":"opcodes/pdclip/#performance","title":"Performance","text":"<p>ain --  the input signal to be clipped.</p> <p>aout --  the output signal.</p> <p>kWidth --  the percentage of the signal range that is clipped (must be between 0 and 1).</p> <p>kCenter --  an offset for shifting the unclipped window of the signal higher or lower in the range (essentially a DC offset).   Values should be in the range [-1, 1] with a value of zero representing no shift (regardless of whether bipolar or unipolar mode is used).</p> <p>The pdclip opcode performs linear clipping on the input signal ain. kWidth specifies the percentage of the signal range that is clipped. The rest of the input range is mapped linearly from zero to ifullscale in unipolar mode and from -ifullscale to ifullscale in bipolar mode.  When kCenter is zero, equal amounts of the top and bottom of the signal range are clipped.  A negative value shifts the unclipped range more towards the bottom of the input range and a positive value shifts it more towards the top.  ibipolar should be 1 for bipolar operation and 0 for unipolar mode.  The default is unipolar mode (ibipolar = 0).  ifullscale sets the maximum amplitude of the input and output signals (defaults to 1.0).</p> <p>This amounts to waveshaping the input with the following transfer function (normalized to ifullscale=1.0 in bipolar mode):</p> <pre><code>        1|   _______      x-axis is input range, y-axis is output\n         |  /\n         | /              width of clipped region is 2*kWidth\n-1       |/        1      width of unclipped region is 2*(1 - kWidth)\n--------------------      kCenter shifts the unclipped region\n        /|                 left or right (up to kWidth)\n       / |\n      /  |\n------   |-1\n</code></pre> <p>Bipolar mode can be used for direct, linear distortion of an audio signal.  Alternatively, unipolar mode is useful for modifying the output of a phasor before it is used to index a function table, effectively making this a phase distortion technique.</p>"},{"location":"opcodes/pdclip/#examples","title":"Examples","text":"<p>Here is an example of the pdclip opcode. It uses the file pdclip.csd.</p> Example of the pdclip opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o abs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; test instrument for pdclip opcode\ninstr 3\n\n        idur            = p3\n        iamp            = p4\n        ifreq           = p5\n        ifn                     = p6\n\n        kenv            linseg          0, .05, 1.0, idur - .1, 1.0, .05, 0\n        aosc            oscil           1.0, ifreq, ifn\n\n        kmod            expseg          0.00001, idur, 1.0\n        aout            pdclip          aosc, kmod, 0.0, 1.0\n\n                                out                     kenv*aout*iamp          \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16385 10 1\nf2 0 16385 10 1 .5 .3333 .25 .5\n\n; pdclipped sine wave\ni3 0 3 15000 440 1\ni3 + 3 15000 330 1\ni3 + 3 15000 220 1\ns\n\n; pdclipped composite wave\ni3 0 3 15000 440 2\ni3 + 3 15000 330 2\ni3 + 3 15000 220 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pdclip/#see-also","title":"See also","text":"<p>Phase Distortion</p>"},{"location":"opcodes/pdclip/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/pdhalf/","title":"Pdhalf","text":""},{"location":"opcodes/pdhalf/#pdhalf","title":"pdhalf","text":"<p>Distorts a phasor for reading the two halves of a table at different rates.</p> <p>The pdhalf opcode is designed to emulate the \"classic\" phase distortion synthesis method of the Casio CZ-series of synthesizers from the mid-1980's.  This technique reads the first and second halves of a function table at different rates in order to warp the waveform.  For example, pdhalf can smoothly transform a sine wave into something approximating the shape of a saw wave.</p>"},{"location":"opcodes/pdhalf/#syntax","title":"Syntax","text":"<pre><code>aout pdhalf ain, kShapeAmount [, ibipolar [, ifullscale]]\n</code></pre>"},{"location":"opcodes/pdhalf/#initialization","title":"Initialization","text":"<p>ibipolar -- an optional parameter specifying either unipolar (0) or bipolar (1) mode.  Defaults to unipolar mode.</p> <p>ifullscale -- an optional parameter specifying the range of input and output values. The maximum will be ifullscale. The minimum depends on the mode of operation: zero for unipolar or -ifullscale for bipolar.  Defaults to 1.0 -- you should set this parameter to the maximum expected input value.</p>"},{"location":"opcodes/pdhalf/#performance","title":"Performance","text":"<p>ain --  the input signal to be distorted.</p> <p>aout --  the output signal.</p> <p>kShapeAmount --  the amount of distortion applied to the input.  Must be between negative one and one (-1 to 1). An amount of zero means no distortion.</p> Transfer function created by pdhalf and a negative kShapeAmount. <p>The pdhalf opcode calculates a transfer function that is composed of two linear segments (see the graph).  These segments meet at a \"pivot point\" which always lies on the same horizontal axis.  (In unipolar mode, the axis is y = 0.5, and for bipolar mode it is the x axis).  The kShapeAmount parameter specifies where on the horizontal axis this point falls.  When kShapeAmount is zero, the pivot point is in the middle of the input range, forming a straight line for the transfer function and thus causing no change in the input signal.  As kShapeAmount changes from zero (0) to negative one (-1), the pivot point moves towards the left side of the graph, producing a phase distortion pattern like the Casio CZ's \"sawtooth waveform\".  As it changes from zero (0) to positive one (1), the pivot point moves toward the right, producing an inverted pattern.</p> <p>If the input to pdhalf is a phasor and the output is used to index a table, values for kShapeAmount that are less than zero will cause the first half of the table to be read more quickly than the second half.  The reverse is true for values of kShapeAmount greater than zero. The rates at which the halves are read are calculated so that the frequency of the phasor is unchanged.  Thus, this method of phase distortion can only produce higher partials in a harmonic series.  It cannot produce inharmonic sidebands in the way that frequency modulation does.</p> <p>pdhalf can work in either unipolar or bipolar modes. Unipolar mode is appropriate for signals like phasors that range between zero and some maximum value (selectable with ifullscale). Bipolar mode is appropriate for signals that range above and below zero by roughly equal amounts such as most audio signals.  Applying pdhalf directly to an audio signal in this way results in a crude but adjustable sort of waveshaping/distortion.</p>"},{"location":"opcodes/pdhalf/#examples","title":"Examples","text":"<p>A typical example of the use of pdhalf is</p> <pre><code>aphase    phasor    ifreq\napd       pdhalf    aphase, kamount\naout      tablei    apd, 1, 1\n</code></pre> <p>Here is an example of the pdhalf opcode. It uses the file pdhalf.csd.</p> Example of the pdhalf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pdhalf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 4\n\n    idur        = p3\n    iamp        = p4\n    ifreq       = p5\n    itable      = p6\n\n    aenv        linseg      0, .001, 1.0, idur - .051, 1.0, .05, 0\n    aosc        phasor      ifreq\n    kamount     linseg      0.0, 0.02, -0.99, 0.05, -0.9, idur-0.06, 0.0\n    apd         pdhalf      aosc, kamount\n    aout        tablei      apd, itable, 1\n\n                outs         aenv*aout*iamp, aenv*aout*iamp     \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16385 10 1\nf2 0 16385 10 1 .5 .3333 .25 .5\nf3 0 16385  9 1 1 270           ; inverted cosine\n\n; descending \"just blues\" scale\n\n; pdhalf with cosine table\n; (imitates the CZ-101 \"sawtooth waveform\")\nt 0 100\ni4 0 3   .6     512     3\ni. + .    .     448\ni. + .    .     384\ni. + .    .     358.4\ni. + .    .     341.33\ni. + .    .     298.67\ni. + 5    .     256\ns\n; pdhalf with a sine table\nt 0 120\ni4 0 3   .6     512     1\ni. + .    .     448\ni. + .    .     384\ni. + .    .     358.4\ni. + .    .     341.33\ni. + .    .     298.67\ni. + 5    .     256\ns\n; pdhalf with a sawtooth-like table\nt 0 150\ni4 0 3   .6     512     2\ni. + .    .     448\ni. + .    .     384\ni. + .    .     358.4\ni. + .    .     341.33\ni. + .    .     298.67\ni. + 5    .     256\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pdhalf/#see-also","title":"See also","text":"<p>Phase Distortion</p> <p>More information about phase distortion on Wikipedia: http://en.wikipedia.org/wiki/Phase_distortion_synthesis</p>"},{"location":"opcodes/pdhalf/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/pdhalfy/","title":"Pdhalfy","text":""},{"location":"opcodes/pdhalfy/#pdhalfy","title":"pdhalfy","text":"<p>Distorts a phasor for reading two unequal portions of a table in equal periods.</p> <p>The pdhalfy opcode is a variation on the phase distortion synthesis method of the pdhalf opcode.  It is useful for distorting a phasor in order to read two unequal portions of a table in the same number of samples.</p>"},{"location":"opcodes/pdhalfy/#syntax","title":"Syntax","text":"<pre><code>aout pdhalfy ain, kShapeAmount [, ibipolar [, ifullscale]]\n</code></pre>"},{"location":"opcodes/pdhalfy/#initialization","title":"Initialization","text":"<p>ibipolar -- an optional parameter specifying either unipolar (0) or bipolar (1) mode.  Defaults to unipolar mode.</p> <p>ifullscale -- an optional parameter specifying the range of input and output values. The maximum will be ifullscale. The minimum depends on the mode of operation: zero for unipolar or -ifullscale for bipolar.  Defaults to 1.0 -- you should set this parameter to the maximum expected input value.</p>"},{"location":"opcodes/pdhalfy/#performance","title":"Performance","text":"<p>ain --  the input signal to be distorted.</p> <p>aout --  the output signal.</p> <p>kShapeAmount --  the amount of distortion applied to the input.  Must be between negative one and one (-1 to 1). An amount of zero means no distortion.</p> Transfer function created by pdhalfy and a negative kShapeAmount. <p>The pdhalfy opcode calculates a transfer function that is composed of two linear segments (see the graph).  These segments meet at a \"pivot point\" which always lies on the same vertical axis.  (In unipolar mode, the axis is x = 0.5, and for bipolar mode it is the y axis).  So, pdhalfy is a variation of the pdhalf opcode that places the pivot point of the phase distortion pattern on a vertical axis instead of a horizontal axis.</p> <p>The kShapeAmount parameter specifies where on the vertical axis this point falls.  When kShapeAmount is zero, the pivot point is in the middle of the output range, forming a straight line for the transfer function and thus causing no change in the input signal.  As kShapeAmount changes from zero (0) to negative one (-1), the pivot point downward towards the bottom of the graph.  As it changes from zero (0) to positive one (1), the pivot point moves upward, producing an inverted pattern.</p> <p>If the input to pdhalfy is a phasor and the output is used to index a table, the use of pdhalfy will divide the table into two segments of different sizes with each segment being mapped to half of the oscillator period.  Values for kShapeAmount that are less than zero will cause less than half of the table to be read in the first half of the period of oscillation.  The rest of the table will be read in the second half of the period.  The reverse is true for values of kShapeAmount greater than zero. Note that the frequency of the phasor is always unchanged.  Thus, this method of phase distortion can only produce higher partials in a harmonic series.  It cannot produce inharmonic sidebands in the way that frequency modulation does. pdhalfy tends to have a milder quality to its distortion than pdhalf.</p> <p>pdhalfy can work in either unipolar or bipolar modes. Unipolar mode is appropriate for signals like phasors that range between zero and some maximum value (selectable with ifullscale). Bipolar mode is appropriate for signals that range above and below zero by roughly equal amounts such as most audio signals.  Applying pdhalfy directly to an audio signal in this way results in a crude but adjustable sort of waveshaping/distortion.</p>"},{"location":"opcodes/pdhalfy/#examples","title":"Examples","text":"<p>A typical example of the use of pdhalfy is</p> <pre><code>aphase    phasor     ifreq\napd       pdhalfy    aphase, kamount\naout      tablei     apd, 1, 1\n</code></pre> <p>Here is an example of the pdhalfy opcode. It uses the file pdhalfy.csd.</p> Example of the pdhalfy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pdhalfy.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 5\n\n    idur        = p3\n    iamp        = p4\n    ifreq       = p5\n    iamtinit    = p6      ; initial amount of phase distortion\n    iatt        = p7      ; attack time\n    isuslvl     = p8      ; sustain amplitude\n    idistdec    = p9      ; time for distortion amount to reach zero\n    itable      = p10\n\n    idec        =  idistdec - iatt\n    irel        =  .05\n    isus        =  idur - (idistdec + irel)\n\n    aenv        linseg      0, iatt, 1.0, idec, isuslvl, isus, isuslvl, irel, 0, 0, 0\n    kamount     linseg      -iamtinit, idistdec, 0.0, idur-idistdec, 0.0\n    aosc        phasor      ifreq\n    apd         pdhalfy     aosc, kamount\n    aout        tablei      apd, itable, 1\n\n                outs        aenv*aout*iamp, aenv*aout*iamp       \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16385 10 1                 ; sine\nf3 0 16385  9 1 1 270           ; inverted cosine\n\n; descending \"just blues\" scale\n\n; pdhalfy with cosine table\nt 0 100\ni5 0 .333 .6    512     1.0   .02  0.5  .12   3\ni. + .    .     448     &lt;\ni. + .    .     384     &lt;\ni. + .    .     358.4   &lt;\ni. + .    .     341.33  &lt;\ni. + .    .     298.67  &lt;\ni. + 2    .     256     0.5\ns\n\n; pdhalfy with sine table\nt 0 100\ni5 0 .333 .6    512     1.0   .001 0.1  .07   1\ni. + .    .     448     &lt;\ni. + .    .     384     &lt;\ni. + .    .     358.4   &lt;\ni. + .    .     341.33  &lt;\ni. + .    .     298.67  &lt;\ni. + 2    .     256     0.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pdhalfy/#see-also","title":"See also","text":"<p>Phase Distortion</p> <p>More information about phase distortion on Wikipedia: http://en.wikipedia.org/wiki/Phase_distortion_synthesis</p>"},{"location":"opcodes/pdhalfy/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/peak/","title":"Peak","text":""},{"location":"opcodes/peak/#peak","title":"peak","text":"<p>Maintains the output equal to the highest absolute value received.</p>"},{"location":"opcodes/peak/#syntax","title":"Syntax","text":"<pre><code>kres peak asig\nkres peak ksig\n</code></pre>"},{"location":"opcodes/peak/#performance","title":"Performance","text":"<p>kres -- Output equal to the highest absolute value received so far. This is effectively an input to the opcode as well, since it reads kres in order to decide whether to write something higher into it.</p> <p>ksig -- k-rate input signal.</p> <p>asig -- a-rate input signal.</p>"},{"location":"opcodes/peak/#examples","title":"Examples","text":"<p>Here is an example of the peak opcode. It uses the file peak.csd, and drumsMlp.wav.</p> Example of the peak opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o peak.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 ; Capture the highest amplitude in the \"drumsMlp.wav\" file.\n\nasig soundin \"drumsMlp.wav\"\nkp peak asig\nprintk .5, kp    ; Print out the peak value once per second.\nouts asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>i   1 time     0.00000:     0.00118\ni   1 time     0.50068:     0.71418\ni   1 time     1.00136:     0.80155\ni   1 time     1.50204:     0.89209\ni   1 time     2.00272:     0.89209\ni   1 time     2.50340:     0.89209\n</code></pre>"},{"location":"opcodes/peak/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/peak/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/pgmassign/","title":"Pgmassign","text":""},{"location":"opcodes/pgmassign/#pgmassign","title":"pgmassign","text":"<p>Assigns an instrument number to a specified MIDI program.</p> <p>By default, the instrument is the same as the program number. If the selected instrument is zero or negative or does not exist, the program change is ignored. This opcode is normally used in the orchestra header. Although, like massign, it also works in instruments.</p>"},{"location":"opcodes/pgmassign/#syntax","title":"Syntax","text":"<pre><code>pgmassign ipgm, inst[, ichn]\npgmassign ipgm, \"insname\"[, ichn]\n</code></pre>"},{"location":"opcodes/pgmassign/#initialization","title":"Initialization","text":"<p>ipgm -- MIDI program number (1 to 128). A value of zero selects all programs.</p> <p>inst -- instrument number. If set to zero, or negative, MIDI program changes to ipgm are ignored. Currently, assignment to an instrument that does not exist has the same effect. This may be changed in a later release to print an error message.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>\u201cichn\u201d (optional, defaults to zero) -- channel number. If zero, program changes are assigned on all channels.</p> <p>You can disable the turning on of any instruments by using the following in the header:</p> <pre><code>massign 0, 0\npgmassign 0, 0\n</code></pre>"},{"location":"opcodes/pgmassign/#examples","title":"Examples","text":"<p>Here is an example of the pgmassign opcode. It uses the file pgmassign.csd.</p> Example of the pgmassign opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o pgmassign.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Program 55 (synth vox) uses Instrument #10.\npgmassign 55, 10 \n\n; Instrument #10.\ninstr 10\n  ; Just an example, no working code in here!\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #10 for one second.\ni 10 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the pgmassign opcode that will ignore program change events. It uses the file pgmassign_ignore.csd.</p> Example of the pgmassign opcode that will ignore program change events.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o pgmassign_ignore.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Ignore all program change events.\npgmassign 0, -1\n\n; Instrument #1.\ninstr 1\n  ; Just an example, no working code in here!\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an advanced example of the pgmassign opcode. It uses the file pgmassign_advanced.csd.</p> <p>Do not forget that you must include the -F flag when using an external MIDI file like \u201cpgmassign_advanced.mid\u201d.</p> An advanced example of the pgmassign opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   -F   pgmassign_advanced.mid  ;;;realtime audio out with midifile in\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pgmassign_advanced.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n        massign 1, 1    ; channels 1 to 4 use instr 1 by default\n        massign 2, 1\n        massign 3, 1\n        massign 4, 1\n\n; pgmassign_advanced.mid can be found in /manual/examples\n; pgmassign.mid has 4 notes with these parameters:\n;\n;           Start time  Channel Program\n;\n; note 1        0.5        1      10\n; note 2        1.5        2      11\n; note 3        2.5        3      12\n; note 4        3.5        4      13\n\n        pgmassign 0, 0          ; disable program changes\n        pgmassign 11, 3         ; program 11 uses instr 3\n        pgmassign 12, 2         ; program 12 uses instr 2\n\n; waveforms for instruments\nitmp    ftgen 1, 0, 1024, 10, 1\nitmp    ftgen 2, 0, 1024, 10, 1, 0.5, 0.3333, 0.25, 0.2, 0.1667, 0.1429, 0.125\nitmp    ftgen 3, 0, 1024, 10, 1, 0, 0.3333, 0, 0.2, 0, 0.1429, 0, 0.10101\n\n        instr 1         /* sine */\n\nkcps    cpsmidib 2      ; note frequency\nasnd    oscili .6, kcps, 1\n        outs asnd, asnd\n\n        endin\n\n        instr 2         /* band-limited sawtooth */\n\nkcps    cpsmidib 2      ; note frequency\nasnd    oscili .6, kcps, 2\n        outs asnd, asnd\n\n        endin\n\n        instr 3         /* band-limited square */\n\nkcps    cpsmidib 2      ; note frequency\nasnd    oscili .6, kcps, 3\n        outs asnd, asnd\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nt 0 120\nf 0 8.5 2 -2 0\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pgmassign/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/pgmassign/#credits","title":"Credits","text":"<p>Author: Istvan Varga May 2002</p> <p>New in version 4.20</p>"},{"location":"opcodes/phaser1/","title":"Phaser1","text":""},{"location":"opcodes/phaser1/#phaser1","title":"phaser1","text":"<p>First-order allpass filters arranged in a series.</p>"},{"location":"opcodes/phaser1/#syntax","title":"Syntax","text":"<pre><code>ares phaser1 asig, kfreq, kord, kfeedback [, iskip]\n</code></pre>"},{"location":"opcodes/phaser1/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- used to control initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/phaser1/#performance","title":"Performance","text":"<p>kfreq -- frequency (in Hz) of the filter(s). This is the frequency at which each filter in the series shifts its input by 90 degrees.</p> <p>kord -- the number of allpass stages in series. These are first-order filters and can range from 1 to 4999.</p> <p> Note</p> <p>Although kord is listed as k-rate, it is in fact accessed only at init-time. So if you are using a k-rate argument, it must be assigned with init.</p> <p>kfeedback -- amount of the output which is fed back into the input of the allpass chain. With larger amounts of feedback, more prominent notches appear in the spectrum of the output. kfeedback must be between -1 and +1. for stability.</p> <p>phaser1 implements iord number of first-order allpass sections, serially connected, all sharing the same coefficient. Each allpass section can be represented by the following difference equation:</p> <pre><code>y(n) = C * x(n) + x(n-1) - C * y(n-1)\n</code></pre> <p>where x(n) is the input, x(n-1) is the previous input, y(n) is the output, y(n-1) is the previous output, and C is a coefficient which is calculated from the value of kfreq, using the bilinear z-transform.</p> <p>By slowly varying kfreq, and mixing the output of the allpass chain with the input, the classic \"phase shifter\" effect is created, with notches moving up and down in frequency. This works best with iord between 4 and 16. When the input to the allpass chain is mixed with the output, 1 notch is generated for every 2 allpass stages, so that with iord = 6, there will be 3 notches in the output. With higher values for iord, modulating kfreq will result in a form of nonlinear pitch modulation.</p>"},{"location":"opcodes/phaser1/#examples","title":"Examples","text":"<p>Here is an example of the phaser1 opcode. It uses the file phaser1.csd.</p> Example of the phaser1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o phaser1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; demonstration of phase shifting abilities of phaser1.\ninstr 1\n  ; Input mixed with output of phaser1 to generate notches.\n  ; Shows the effects of different iorder values on the sound\n  idur   = p3 \n  iamp   = p4 * .05\n  iorder = p5        ; number of 1st-order stages in phaser1 network.\n                     ; Divide iorder by 2 to get the number of notches.\n  ifreq  = p6        ; frequency of modulation of phaser1\n  ifeed  = p7        ; amount of feedback for phaser1\n\n  kamp   linseg 0, .2, iamp, idur - .2, iamp, .2, 0\n\n  iharms = (sr*.4) / 100\n\n  asig   gbuzz 1, 100, iharms, 1, .95, 2  ; \"Sawtooth\" waveform modulation oscillator for phaser1 ugen.\n  kfreq  oscili 5500, ifreq, 1\n  kmod   = kfreq + 5600\n\n  aphs   phaser1 asig, kmod, iorder, ifeed\n\n  out    (asig + aphs) * iamp\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; inverted half-sine, used for modulating phaser1 frequency\nf1 0  16384 9 .5 -1 0\n; cosine wave for gbuzz\nf2 0  8192 9 1 1 .25\n\n; phaser1\ni1 0  5 7000 4  .2 .9\ni1 6  5 7000 6  .2 .9\ni1 12 5 7000 8  .2 .9\ni1 18 5 7000 16 .2 .9\ni1 24 5 7000 32 .2 .9\ni1 30 5 7000 64 .2 .9\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/phaser1/#technical-history","title":"Technical History","text":"<p>A general description of the differences between flanging and phasing can be found in Hartmann [1]. An early implementation of first-order allpass filters connected in series can be found in Beigel [2], where the bilinear z-transform is used for determining the phase shift frequency of each stage. Cronin [3] presents a similar implementation for a four-stage phase shifting network. Chamberlin [4] and Smith [5] both discuss using second-order allpass sections for greater control over notch depth, width, and frequency.</p>"},{"location":"opcodes/phaser1/#references","title":"References","text":"<ol> <li>Hartmann, W.M. \"Flanging and Phasers.\" Journal of the Audio Engineering Society, Vol. 26, No. 6, pp. 439-443, June 1978.</li> <li>Beigel, Michael I. \"A Digital 'Phase Shifter' for Musical Applications, Using the Bell Labs (Alles-Fischer) Digital Filter Module.\" Journal of the Audio Engineering Society, Vol. 27, No. 9, pp. 673-676,September 1979.</li> <li>Cronin, Dennis. \"Examining Audio DSP Algorithms.\" Dr. Dobb's Journal, July 1994, p. 78-83.</li> <li>Chamberlin, Hal. Musical Applications of Microprocessors. Second edition. Indianapolis, Indiana: Hayden Books, 1985.</li> <li>Smith, Julius O. \"An Allpass Approach to Digital Phasing and Flanging.\" Proceedings of the 1984 ICMC, p. 103-108.</li> </ol>"},{"location":"opcodes/phaser1/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/phaser1/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>November 2002. Added a note about the kord parameter, thanks to Rasmus Ekman.</p> <p>New in Csound version 4.0</p>"},{"location":"opcodes/phaser2/","title":"Phaser2","text":""},{"location":"opcodes/phaser2/#phaser2","title":"phaser2","text":"<p>Second-order allpass filters arranged in a series.</p>"},{"location":"opcodes/phaser2/#syntax","title":"Syntax","text":"<pre><code>ares phaser2 asig, kfreq, kq, kord, kmode, ksep, kfeedback\n</code></pre>"},{"location":"opcodes/phaser2/#performance","title":"Performance","text":"<p>kfreq -- frequency (in Hz) of the filter(s). This is the center frequency of the notch of the first allpass filter in the series. This frequency is used as the base frequency from which the frequencies of the other notches are derived.</p> <p>kq -- Q of each notch. Higher Q values result in narrow notches. A Q between 0.5 and 1 results in the strongest \"phasing\" effect, but higher Q values can be used for special effects.</p> <p>kord -- the number of allpass stages in series. These are second-order filters, and iord can range from 1 to 2499. With higher orders, the computation time increases.</p> <p>kfeedback -- amount of the output which is fed back into the input of the allpass chain. With larger amounts of feedback, more prominent notches appear in the spectrum of the output. kfeedback must be between -1 and +1. for stability.</p> <p>kmode -- used in calculation of notch frequencies.</p> <p> Note</p> <p>Although kord and kmode are listed as k-rate, they are in fact accessed only at init-time. So if you are using k-rate arguments, they must be assigned with init.</p> <p>ksep -- scaling factor used, in conjunction with imode, to determine the frequencies of the additional notches in the output spectrum.</p> <p>phaser2 implements iord number of second-order allpass sections, connected in series. The use of second-order allpass sections allows for the precise placement of the frequency, width, and depth of notches in the frequency spectrum. iord is used to directly determine the number of notches in the spectrum; e.g. for iord = 6, there will be 6 notches in the output spectrum.</p> <p>There are two possible modes for determining the notch frequencies. When imode = 1, the notch frequencies are determined by the following function:</p> <pre><code>frequency of notch N = kbf + (ksep * kbf * N-1)\n</code></pre> <p>For example, with imode = 1 and ksep = 1, the notches will be in harmonic relationship with the notch frequency determined by kfreq (i.e. if there are 8 notches, with the first at 100 Hz, the next notches will be at 200, 300, 400, 500, 600, 700, and 800 Hz). This is useful for generating a \"comb filtering\" effect, with the number of notches determined by iord. Different values of ksep allow for inharmonic notch frequencies and other special effects. ksep can be swept to create an expansion or contraction of the notch frequencies. A useful visual analogy for the effect of sweeping ksep would be the bellows of an accordion as it is being played - the notches will be seperated, then compressed together, as ksep changes.</p> <p>When imode = 2, the subsequent notches are powers of the input parameter ksep times the initial notch frequency specified by kfreq. This can be used to set the notch frequencies to octaves and other musical intervals. For example, the following lines will generate 8 notches in the output spectrum, with the notches spaced at octaves of kfreq:</p> <pre><code>aphs    phaser2    ain, kfreq, 0.5, 8, 2, 2, 0\naout    =          ain + aphs\n</code></pre> <p>When imode = 2, the value of ksep must be greater than 0. ksep can be swept to create a compression and expansion of notch frequencies (with more dramatic effects than when imode = 1).</p>"},{"location":"opcodes/phaser2/#examples","title":"Examples","text":"<p>Here is an example of the phaser2 opcode. It uses the file phaser2.csd.</p> Example of the phaser2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o phaser2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\ninstr 2              ; demonstration of phase shifting abilities of phaser2. \n  ; Input mixed with output of phaser2 to generate notches. \n  ; Demonstrates the interaction of imode and ksep.\n  idur   = p3 \n  iamp   = p4 * .04\n  iorder = p5        ; number of 2nd-order stages in phaser2 network\n  ifreq  = p6        ; not used\n  ifeed  = p7        ; amount of feedback for phaser2\n  imode  = p8        ; mode for frequency scaling\n  isep   = p9        ; used with imode to determine notch frequencies\n  kamp   linseg 0, .2, iamp, idur - .2, iamp, .2, 0\n  iharms = (sr*.4) / 100\n\n  ; \"Sawtooth\" waveform exponentially decaying function, to control notch frequencies\n  asig   gbuzz 1, 100, iharms, 1, .95, 2  \n  kline  expseg 1, idur, .005\n  aphs   phaser2 asig, kline * 2000, .5, iorder, imode, isep, ifeed\n\n  out (asig + aphs) * iamp\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; cosine wave for gbuzz\nf2 0  8192 9 1 1 .25     \n\n; phaser2, imode=1\ni2 00 10 7000 8 .2 .9 1 .33\ni2 11 10 7000 8 .2 .9 1 2 \n\n; phaser2, imode=2\ni2 22 10 7000 8 .2 .9 2 .33\ni2 33 10 7000 8 .2 .9 2 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/phaser2/#technical-history","title":"Technical History","text":"<p>A general description of the differences between flanging and phasing can be found in Hartmann [1]. An early implementation of first-order allpass filters connected in series can be found in Beigel [2], where the bilinear z-transform is used for determining the phase shift frequency of each stage. Cronin [3] presents a similar implementation for a four-stage phase shifting network. Chamberlin [4] and Smith [5] both discuss using second-order allpass sections for greater control over notch depth, width, and frequency.</p>"},{"location":"opcodes/phaser2/#references","title":"References","text":"<ol> <li>Hartmann, W.M. \"Flanging and Phasers.\" Journal of the Audio Engineering Society, Vol. 26, No. 6, pp. 439-443, June 1978.</li> <li>Beigel, Michael I. \"A Digital 'Phase Shifter' for Musical Applications, Using the Bell Labs (Alles-Fischer) Digital Filter Module.\" Journal of the Audio Engineering Society, Vol. 27, No. 9, pp. 673-676,September 1979.</li> <li>Cronin, Dennis. \"Examining Audio DSP Algorithms.\" Dr. Dobb's Journal, July 1994, p. 78-83.</li> <li>Chamberlin, Hal. Musical Applications of Microprocessors. Second edition. Indianapolis, Indiana: Hayden Books, 1985.</li> <li>Smith, Julius O. \"An Allpass Approach to Digital Phasing and Flanging.\" Proceedings of the 1984 ICMC, p. 103-108.</li> </ol>"},{"location":"opcodes/phaser2/#see-also","title":"See also","text":"<p>Special Effects</p>"},{"location":"opcodes/phaser2/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>November 2002. Added a note about the kord and kmode parameters, thanks to Rasmus Ekman.</p> <p>New in Csound version 4.0</p>"},{"location":"opcodes/phasor/","title":"Phasor","text":""},{"location":"opcodes/phasor/#phasor","title":"phasor","text":"<p>Produce a normalized moving phase value.</p>"},{"location":"opcodes/phasor/#syntax","title":"Syntax","text":"<pre><code>ares phasor xcps [, iphs]\nkres phasor kcps [, iphs]\n</code></pre>"},{"location":"opcodes/phasor/#initialization","title":"Initialization","text":"<p>iphs (optional) -- initial phase, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is zero.</p>"},{"location":"opcodes/phasor/#performance","title":"Performance","text":"<p>An internal phase is successively accumulated in accordance with the kcps or xcps frequency to produce a moving phase value, normalized to lie in the range 0 &lt;= phs &lt; 1.</p> <p>When used as the index to a table unit, this phase (multiplied by the desired function table length) will cause it to behave like an oscillator.</p> <p>Note that phasor is a special kind of integrator, accumulating phase increments that represent frequency settings.</p>"},{"location":"opcodes/phasor/#examples","title":"Examples","text":"<p>Here is an example of the phasor opcode. It uses the file phasor.csd.</p> Example of the phasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o phasor.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn = 1                 ;read table 1 with our index\nixmode = 1\nkndx phasor p4\nkfrq table kndx, ifn, ixmode\nasig poscil .6, kfrq, 2 ;re-synthesize with sine\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1025 -7 200 1024 2000 ;a line from 200 to 2,000   \nf 2 0 16384 10 1;sine wave\n\ni 1 0 1 1       ;once per second\ni 1 2 2 .5      ;once per 2 seconds\ni 1 5 1 2       ;twice per second\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the phasor opcode: PhasorTablei_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/phasor/#see-also","title":"See also","text":"<p>Phasors</p>"},{"location":"opcodes/phasorbnk/","title":"Phasorbnk","text":""},{"location":"opcodes/phasorbnk/#phasorbnk","title":"phasorbnk","text":"<p>Produce an arbitrary number of normalized moving phase values, accessable by an index.</p>"},{"location":"opcodes/phasorbnk/#syntax","title":"Syntax","text":"<pre><code>ares phasorbnk xcps, kndx, icnt [, iphs]\nkres phasorbnk kcps, kndx, icnt [, iphs]\n</code></pre>"},{"location":"opcodes/phasorbnk/#initialization","title":"Initialization","text":"<p>icnt -- maximum number of phasors to be used.</p> <p>iphs -- initial phase, expressed as a fraction of a cycle (0 to 1). If -1 initialization is skipped. If iphas&gt;1 each phasor will be initialized with a random value.</p>"},{"location":"opcodes/phasorbnk/#performance","title":"Performance","text":"<p>kndx -- index value to access individual phasors</p> <p>For each independent phasor, an internal phase is successively accumulated in accordance with the kcps or xcps frequency to produce a moving phase value, normalized to lie in the range 0 &lt;= phs &lt; 1. Each individual phasor is accessed by index kndx.</p> <p>This phasor bank can be used inside a k-rate loop to generate multiple independent voices, or together with the adsynt opcode to change parameters in the tables used by adsynt.</p>"},{"location":"opcodes/phasorbnk/#examples","title":"Examples","text":"<p>Here is an example of the phasorbnk opcode. It uses the file phasorbnk.csd.</p> Example of the phasorbnk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o phasorbnk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Generate a sinewave table.\ngiwave ftgen 1, 0, 1024, 10, 1 \n\n; Instrument #1\ninstr 1\n  ; Generate 10 voices.\n  icnt = 10 \n  ; Empty the output buffer.\n  asum = 0 \n  ; Reset the loop index.\n  kindex = 0 \n\n; This loop is executed every k-cycle.\nloop: \n  ; Generate non-harmonic partials.\n  kcps = (kindex+1)*100+30 \n  ; Get the phase for each voice.\n  aphas phasorbnk kcps, kindex, icnt \n  ; Read the wave from the table.\n  asig table aphas, giwave, 1 \n  ; Accumulate the audio output.\n  asum = asum + asig \n\n  ; Increment the index.\n  kindex = kindex + 1\n\n  ; Perform the loop until the index (kindex) reaches \n  ; the counter value (icnt).\n  if (kindex &lt; icnt) kgoto loop \n\n  out asum*3000\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Generate multiple voices with independent partials. This example is better with adsynt. See also the example under adsynt, for k-rate use of phasorbnk.</p>"},{"location":"opcodes/phasorbnk/#see-also","title":"See also","text":"<p>Phasors</p>"},{"location":"opcodes/phasorbnk/#credits","title":"Credits","text":"<p>Author: Peter Neub\u00e4cker Munich, Germany August 1999</p> <p>New in Csound version 3.58</p>"},{"location":"opcodes/pindex/","title":"Pindex","text":""},{"location":"opcodes/pindex/#pindex","title":"pindex","text":"<p>Returns the value of a specified pfield.</p>"},{"location":"opcodes/pindex/#syntax","title":"Syntax","text":"<pre><code>ivalue pindex ipfieldIndex\n</code></pre>"},{"location":"opcodes/pindex/#initialization","title":"Initialization","text":"<p>ipfieldIndex - pfield number to query.</p> <p>ivalue - value of the pfield.</p>"},{"location":"opcodes/pindex/#examples","title":"Examples","text":"<p>Here is an example of the pindex opcode. It uses the file pindex.csd.</p> Example of the pindex opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc    ; -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n;-o pindex.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;Example by Anthony Kozar Dec 2006\n\ninstr 1\n    inum    pcount\n    index   init 1\n    loop1:\n        ivalue pindex index\n        printf_i \"p%d = %f\\n\", 1, index, ivalue\n        index   = index + 1\n    if  (index &lt;= inum) igoto loop1\n    print inum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1  0 3 40 50         ; has 5 pfields\ni1  1 2 80            ; has 5 due to carry\ni1  2 1 40 50 60 70   ; has 7\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>new alloc for instr 1:\nWARNING: instr 1 uses 3 p-fields but is given 5\np1 = 1.000000\np2 = 0.000000\np3 = 3.000000\np4 = 40.000000\np5 = 50.000000\ninstr 1:  inum = 5.000\nB  0.000 ..  1.000 T  1.000 TT  1.000 M:      0.0\nnew alloc for instr 1:\nWARNING: instr 1 uses 3 p-fields but is given 5\np1 = 1.000000\np2 = 1.000000\np3 = 2.000000\np4 = 80.000000\np5 = 50.000000\ninstr 1:  inum = 5.000\nB  1.000 ..  2.000 T  2.000 TT  2.000 M:      0.0\nnew alloc for instr 1:\nWARNING: instr 1 uses 3 p-fields but is given 7\np1 = 1.000000\np2 = 2.000000\np3 = 1.000000\np4 = 40.000000\np5 = 50.000000\np6 = 60.000000\np7 = 70.000000\ninstr 1:  inum = 7.000\n</code></pre> <p>The warnings can be ignored, because the pfields are used indirectly through pindex instead of explicitly through p4, p5, etc.</p> <p>Here is another example of the pindex opcode. It uses the file pindex-2.csd.</p> Second example of the pindex opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pindex-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; This UDO returns a pfield value but returns 0 if it does not exist.\nopcode  mypvalue, i, i\n        index  xin\n        inum   pcount\n        if        (index &gt; inum)  then\n                iout = 0.0\n        else\n                iout pindex index\n        endif\n\n        xout    iout\nendop\n\n; Envelope UDO that reads parameters from a flexible number of pfields\n; Syntax:   kenv  flexlinseg  ipstart\n;           ipstart is the first pfield of the envelope\n;               parameters.  Reads remaining pfields (up to 21 of them).\n;           kenv is the output envelope.\n\nopcode  flexlinseg, k, i\n        ipstart xin\n\n        iep1   mypvalue ipstart\n        iep2   mypvalue ipstart + 1\n        iep3   mypvalue ipstart + 2\n        iep4   mypvalue ipstart + 3\n        iep5   mypvalue ipstart + 4\n        iep6   mypvalue ipstart + 5\n        iep7   mypvalue ipstart + 6\n        iep8   mypvalue ipstart + 7\n        iep9   mypvalue ipstart + 8\n        iepa   mypvalue ipstart + 9\n        iepb   mypvalue ipstart + 10\n        iepc   mypvalue ipstart + 11\n        iepd   mypvalue ipstart + 12\n        iepe   mypvalue ipstart + 13\n        iepf   mypvalue ipstart + 14\n        iepg   mypvalue ipstart + 15\n        ieph   mypvalue ipstart + 16\n        iepi   mypvalue ipstart + 17\n        iepj   mypvalue ipstart + 18\n        iepk   mypvalue ipstart + 19\n        iepl   mypvalue ipstart + 20\n\n        kenv   linseg    iep1, iep2, iep3, iep4, iep5, iep6, iep7, iep8, \\\n                           iep9, iepa, iepb, iepc, iepd, iepe, iepf, iepg, \\\n                           ieph, iepi, iepj, iepk, iepl \n        xout   kenv\nendop\n\ninstr 1\n; This instrument only requires 3 pfields but can accept up to 24.\n; (You will still get warnings about more than 3).      \nkenv flexlinseg  4              ; envelope params start at p4\naout oscili kenv*.5, 256, 1\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1  0 8192 10 1\n\ni1  0 2  0.0 1.0 1.0 1.0 0.0\ni1  2 2  0.0 0.1 1.0 1.0 1.0 0.1 0.0\ni1  4 2  0.0 0.5 0.0                            ; one problem is that \"missing\" pfields carry\ni1  6 2  0.0 0.5 0.0 !                          ; now we can fix this problem with !\ni1  8 10  0.0  3.0 1.0  0.3 0.1  0.3 1.0  0.3 0.1  0.3 1.0  0.3 0.1  0.8 0.9  5.0 0.0\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>WARNING: instr 1 uses 3 p-fields but is given 8\nB  0.000 ..  2.000 T  2.000 TT  2.000 M:  0.49966  0.49966\nWARNING: instr 1 uses 3 p-fields but is given 10\nB  2.000 ..  4.000 T  4.000 TT  4.000 M:  0.50000  0.50000\nWARNING: instr 1 uses 3 p-fields but is given 10\nB  4.000 ..  6.000 T  6.000 TT  6.000 M:  0.49943  0.49943\nWARNING: instr 1 uses 3 p-fields but is given 6\nB  6.000 ..  8.000 T  8.000 TT  8.000 M:  0.00000  0.00000\nWARNING: instr 1 uses 3 p-fields but is given 20\nB  8.000 .. 18.000 T 18.000 TT 18.000 M:  0.49994  0.49994\n</code></pre>"},{"location":"opcodes/pindex/#see-also","title":"See also","text":"<p>Sensing and Control: Score control</p>"},{"location":"opcodes/pindex/#credits","title":"Credits","text":"<p>Example by: Anthony Kozar</p> <p>Dec. 2006</p>"},{"location":"opcodes/pinker/","title":"Pinker","text":""},{"location":"opcodes/pinker/#pinker","title":"pinker","text":"<p>Generates pink noise (-3dB/oct response) by the NewShade of Pink algorithm of Stefan Stenzel.</p>"},{"location":"opcodes/pinker/#syntax","title":"Syntax","text":"<pre><code>ares pinker\n</code></pre>"},{"location":"opcodes/pinker/#performance","title":"Performance","text":"<p>pinker generates pink noise (i.e., noise with equal energy in each octave), by the algorithm of Stefan Stenzel.  For details of the algorithm look at http://stenzel.waldorfmusic.de/post/pink/.</p>"},{"location":"opcodes/pinker/#examples","title":"Examples","text":"<p>Here is an example of the pinker opcode. It uses the file pinker.csd.</p> Example of the pinker opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsInstruments&gt;\nksmps = 12\nnchnls = 1\n0dbfs = 1\n\ninstr 1\n  a1 pinker\n     out    a1\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pinker/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/pinker/#credits","title":"Credits","text":"<p>Authors: Stefan Stenzel and John ffitch University of Bath/Codemist Ltd. Bath, UK May 2014</p> <p>New in Csound Version 6.04</p>"},{"location":"opcodes/pinkish/","title":"Pinkish","text":""},{"location":"opcodes/pinkish/#pinkish","title":"pinkish","text":"<p>Generates approximate pink noise (-3dB/oct response) by one of two different methods:</p> <ul> <li>a multirate noise generator after Moore, coded by Martin Gardner</li> <li>a filter bank designed by Paul Kellet</li> </ul>"},{"location":"opcodes/pinkish/#syntax","title":"Syntax","text":"<pre><code>ares pinkish xin [, imethod] [, inumbands] [, iseed] [, iskip]\n</code></pre>"},{"location":"opcodes/pinkish/#initialization","title":"Initialization","text":"<p>imethod (optional, default=0) -- selects filter method:</p> <ul> <li>0 = Gardner method (default).</li> <li>1 = Kellet filter bank.</li> <li>2 = A somewhat faster filter bank by Kellet, with less accurate response.</li> </ul> <p>inumbands (optional) -- only effective with Gardner method. The number of noise bands to generate. Maximum is 32, minimum is 4. Higher levels give smoother spectrum, but above 20 bands there will be almost DC-like slow fluctuations.  Default value is 20.</p> <p>iseed (optional, default=0) -- only effective with Gardner method. If non-zero, seeds the random generator. If zero, the generator will be seeded from current time. Default is 0.</p> <p>iskip (optional, default=0) -- if non-zero, skip (re)initialization of internal state (useful for tied notes).  Default is 0.</p>"},{"location":"opcodes/pinkish/#performance","title":"Performance","text":"<p>xin -- for Gardner method: k- or a-rate amplitude. For Kellet filters: normally a-rate uniform random noise from rand (31-bit) or unirand, but can be any a-rate signal. The output peak value varies widely (\u00b115%) even over long runs, and will usually be well below the input amplitude. Peak values may also occasionally overshoot input amplitude or noise.</p> <p>pinkish attempts to generate pink noise (i.e., noise with equal energy in each octave), by one of two different methods.</p> <p>The first method, by Moore &amp; Gardner, adds several (up to 32) signals of white noise, generated at octave rates (sr, sr/2, sr/4 etc). It obtains pseudo-random values from an internal 32-bit generator. This random generator is local to each opcode instance and seedable (similar to rand).</p> <p>The second method is a lowpass filter with a response approximating -3dB/oct. If the input is uniform white noise, it outputs pink noise. Any signal may be used as input for this method.  The high quality filter is slower, but has less ripple and a slightly wider operating frequency range than less computationally intense versions. With the Kellet filters, seeding is not used.</p> <p>The Gardner method output has some frequency response anomalies in the low-mid and high-mid frequency ranges. More low-frequency energy can be generated by increasing the number of bands. It is also a bit faster.  The refined Kellet filter has very smooth spectrum, but a more limited effective range. The level increases slightly at the high end of the spectrum.</p>"},{"location":"opcodes/pinkish/#examples","title":"Examples","text":"<p>Here is an example of the pinkish opcode. It uses the file pinkish.csd.</p> Example of the pinkish opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o pinkish.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  awhite unirand 2.0\n\n  ; Normalize to +/-1.0\n  awhite = awhite - 1.0  \n\n  apink  pinkish awhite, 1, 0, 0, 1\n\n  out apink * 30000\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Kellet-filtered noise for a tied note (iskip is non-zero).</p>"},{"location":"opcodes/pinkish/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/pinkish/#credits","title":"Credits","text":"<p>Authors: Phil Burk and John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p> <p>Adapted for Csound by Rasmus Ekman</p> <p>The noise bands method is due to F. R. Moore (or R. F. Voss), and was presented by Martin Gardner in an oft-cited article in Scientific American. The present version was coded by Phil Burk as the result of discussion on the music-dsp mailing list, with significant optimizations suggested by James McCartney.</p> <p>The filter bank was designed by Paul Kellet, posted to the music-dsp mailing list.</p> <p>The whole pink noise discussion was collected on a HTML page by Robin Whittle, which is currently available at http://www.firstpr.com.au/dsp/pink-noise/.</p> <p>Added notes by Rasmus Ekman on September 2002.</p>"},{"location":"opcodes/pitch/","title":"Pitch","text":""},{"location":"opcodes/pitch/#pitch","title":"pitch","text":"<p>Tracks the pitch of a signal.</p> <p>Using the same techniques as spectrum and specptrk, pitch tracks the pitch of the signal in octave point decimal form, and amplitude in dB.</p>"},{"location":"opcodes/pitch/#syntax","title":"Syntax","text":"<pre><code>koct, kamp pitch asig, iupdte, ilo, ihi, idbthresh [, ifrqs] [, iconf] \\\n                 [, istrt] [, iocts] [, iq] [, inptls] [, irolloff] [, iskip]\n</code></pre>"},{"location":"opcodes/pitch/#initialization","title":"Initialization","text":"<p>iupdte -- length of period, in seconds, that outputs are updated</p> <p>ilo, ihi -- range in which pitch is detected, expressed in octave point decimal</p> <p>idbthresh -- amplitude, expressed in decibels, necessary for the pitch to be detected.  Once started it continues until it is 6 dB down.</p> <p>ifrqs (optional) -- number of divisons of an octave. Default is 12 and is limited to 120.</p> <p>iconf (optional) -- the number of conformations needed for an octave jump.  Default is 10.</p> <p>istrt (optional) -- starting pitch for tracker. Default value is (ilo + ihi)/2.</p> <p>iocts (optional) -- number of octave decimations in spectrum. Default is 6.</p> <p>iq (optional) -- Q of analysis filters. Default is 10.</p> <p>inptls (optional) -- number of harmonics, used in matching. Computation time increases with the number of harmonics. Default is 4.</p> <p>irolloff (optional) -- amplitude rolloff for the set of filters expressed as fraction per octave. Values must be positive. Default is 0.6.</p> <p>iskip (optional) -- if non-zero, skips initialization. Default is 0.</p>"},{"location":"opcodes/pitch/#performance","title":"Performance","text":"<p>koct -- The pitch output, given in the octave point decimal format.</p> <p>kamp -- The amplitude output.</p> <p>pitch analyzes the input signal, asig, to give a pitch/amplitude pair of outputs, for the strongest frequency in the signal. The value is updated every iupdte seconds.</p> <p>The number of partials and rolloff fraction can effect the pitch tracking, so some experimentation may be necessary. Suggested values are 4 or 5 harmonics, with rolloff 0.6, up to 10 or 12 harmonics with rolloff 0.75 for complex timbres, with a weak fundamental.</p>"},{"location":"opcodes/pitch/#examples","title":"Examples","text":"<p>Here is an example of the pitch opcode. It uses the file pitch.csd.</p> Example of the pitch opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pitch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2022\n\ninstr 1 ;clean audio\n\nasig soundin p4\n     outs asig, asig\nendin\n\ninstr 2 ;use pitch\n\niupdte = 0.001  ;high definition\nilo = 6\nihi = 10\nidbthresh = 10\nifrqs = 12\niconf = 10\nistrt = 8\n\nSfile = p4              \nasig soundin Sfile\n\nkoct, kamp pitch asig, iupdte, ilo, ihi, idbthresh, ifrqs, iconf, istrt\nkamp = kamp*.00004              ;lower volume\nkcps = cpsoct(koct)\nasig poscil kamp, kcps, 1       ;re-synthesize with sawtooth\nprintf  \"now %s is used...\\n\\n\", 1, Sfile\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ;sawtooth\n\ni 1 0   3 \"fox.wav\"\ni 2 3   3 \"fox.wav\"\ni 1 6   4 \"singFemale.aif\"\ni 2 10  4 \"singFemale.aif\"\ni 1 15  2 \"drumsMlp.wav\"\ni 2 17  2 \"drumsMlp.wav\"\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pitch/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/pitch/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK April 1999</p> <p>New in Csound version 3.54</p>"},{"location":"opcodes/pitchamdf/","title":"Pitchamdf","text":""},{"location":"opcodes/pitchamdf/#pitchamdf","title":"pitchamdf","text":"<p>Follows the pitch of a signal based on the AMDF method (Average Magnitude Difference Function).</p> <p>Outputs pitch and amplitude tracking signals. The method is quite fast and should run in realtime. This technique usually works best for monophonic signals.</p>"},{"location":"opcodes/pitchamdf/#syntax","title":"Syntax","text":"<pre><code>kcps, krms pitchamdf asig, imincps, imaxcps [, icps] [, imedi] \\\n                     [, idowns] [, iexcps] [, irmsmedi]\n</code></pre>"},{"location":"opcodes/pitchamdf/#initialization","title":"Initialization","text":"<p>imincps -- estimated minimum frequency (expressed in Hz) present in the signal</p> <p>imaxcps -- estimated maximum frequency present in the signal</p> <p>icps (optional, default=0) -- estimated initial frequency of the signal. If 0, icps = (imincps+imaxcps) / 2. The default is 0.</p> <p>imedi (optional, default=1) -- size of median filter applied to the output kcps. The size of the filter will be imedi*2+1. If 0, no median filtering will be applied. The default is 1.</p> <p>idowns (optional, default=1) -- downsampling factor for asig. Must be an integer. A factor of idowns &gt; 1 results in faster performance, but may result in worse pitch detection. Useful range is 1 - 4. The default is 1.</p> <p>iexcps (optional, default=0) -- how frequently pitch analysis is executed, expressed in Hz.  If 0, iexcps is set to imincps. This is usually reasonable, but experimentation with other values may lead to better results. Default is 0.</p> <p>irmsmedi (optional, default=0) -- size of median filter applied to the output krms. The size of the filter will be irmsmedi*2+1. If 0, no median filtering will be applied. The default is 0.</p>"},{"location":"opcodes/pitchamdf/#performance","title":"Performance","text":"<p>kcps -- pitch tracking output</p> <p>krms -- amplitude tracking output</p> <p>pitchamdf usually works best for monophonic signals, and is quite reliable if appropriate initial values are chosen. Setting imincps and imaxcps as narrow as possible to the range of the signal's pitch, results in better detection and performance.</p> <p>Because this process can only detect pitch after an initial delay, setting icps close to the signal's real initial pitch prevents spurious data at the beginning.</p> <p>The median filter prevents kcps from jumping. Experiment to determine the optimum value for imedi for a given signal.</p> <p>Other initial values can usually be left at the default settings. Lowpass filtering of asig before passing it to pitchamdf, can improve performance, especially with complex waveforms.</p>"},{"location":"opcodes/pitchamdf/#examples","title":"Examples","text":"<p>Here is an example of the pitchamdf opcode. It uses the file pitchamdf.csd.</p> Example of the pitchamdf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pitchamdf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;clean audio\n\nasig soundin p4\n     outs asig, asig\nendin\n\ninstr 2 ;use pitch\n\nSfile = p4              \nasig soundin Sfile\n\nasig tone asig, 1000            ;lowpass-filter\nkcps, krms pitchamdf asig, 100, 500, 200\nasig poscil krms, kcps, 1       ;re-synthesize with sawtooth\nprintf  \"now %s is used...\\n\\n\", 1, Sfile\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ;sawtooth\n\ni 1 0   3 \"fox.wav\"\ni 2 3   3 \"fox.wav\"\ni 1 6   4 \"singFemale.aif\"\ni 2 10  4 \"singFemale.aif\"\ni 1 15  2 \"drumsMlp.wav\"\ni 2 17  2 \"drumsMlp.wav\"\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pitchamdf/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/pitchamdf/#credits","title":"Credits","text":"<p>Author: Peter Neub\u00e4cker Munich, Germany August 1999</p> <p>New in Csound version 3.59</p>"},{"location":"opcodes/planet/","title":"Planet","text":""},{"location":"opcodes/planet/#planet","title":"planet","text":"<p>Simulates a planet orbiting in a binary star system.</p> <p>planet simulates a planet orbiting in a binary star system. The outputs are the x, y and z coordinates of the orbiting planet. It is possible for the planet to achieve escape velocity by a close encounter with a star. This makes this system somewhat unstable.</p>"},{"location":"opcodes/planet/#syntax","title":"Syntax","text":"<pre><code>ax, ay, az planet kmass1, kmass2, ksep, ix, iy, iz, ivx, ivy, ivz, idelta \\\n                  [, ifriction] [, iskip]\n</code></pre>"},{"location":"opcodes/planet/#initialization","title":"Initialization","text":"<p>ix, iy, iz -- the initial x, y and z coordinates of the planet</p> <p>ivx, ivy, ivz -- the initial velocity vector components for the planet.</p> <p>idelta -- the step size used to approximate the differential equation.</p> <p>ifriction (optional, default=0) -- a value for friction, which can be used to keep the system from blowing up</p> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/planet/#performance","title":"Performance","text":"<p>ax, ay, az -- the output x, y, and z coodinates of the planet</p> <p>ksep -- the separation between the two stars</p> <p>kmass1 -- the mass of the first star</p> <p>kmass2 -- the mass of the second star</p>"},{"location":"opcodes/planet/#examples","title":"Examples","text":"<p>Here is an example of the planet opcode. It uses the file planet.csd.</p> Example of the planet opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o planet.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 2\n\n; Instrument #1 - a planet oribiting in 3D space.\ninstr 1\n  ; Create a basic tone.\n  kamp init 5000\n  kcps init 440\n  ifn = 1\n  asnd oscil kamp, kcps, ifn\n\n  ; Figure out its X, Y, Z coordinates.\n  km1 init 0.5\n  km2 init 0.35\n  ksep init 2.2\n  ix = 0\n  iy = 0.1\n  iz = 0\n  ivx = 0.5\n  ivy = 0\n  ivz = 0\n  ih = 0.0003\n  ifric = -0.1\n  ax1, ay1, az1 planet km1, km2, ksep, ix, iy, iz, \\\n                       ivx, ivy, ivz, ih, ifric\n\n  ; Place the basic tone within 3D space.\n  kx downsamp ax1\n  ky downsamp ay1\n  kz downsamp az1\n  idist = 1\n  ift = 0\n  imode = 1\n  imdel = 1.018853416\n  iovr = 2\n  aw2, ax2, ay2, az2 spat3d asnd, kx, ky, kz, idist, \\\n                            ift, imode, imdel, iovr\n\n  ; Convert the 3D sound to stereo.\n  aleft = aw2 + ay2\n  aright = aw2 - ay2\n\n  outs aleft, aright\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1 a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for 10 seconds.\ni 1 0 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/planet/#see-also","title":"See Also","text":"<p>Models and Emulations</p> <p>More information on this opcode: http://www.csoundjournal.com/issue9/FlutesInOrbit.html  , written by Brian Redfern.</p>"},{"location":"opcodes/planet/#credits","title":"Credits","text":"<p>Author: Hans Mikelson December 1998</p> <p>New in Csound version 3.50</p>"},{"location":"opcodes/platerev/","title":"Platerev","text":""},{"location":"opcodes/platerev/#platerev","title":"platerev","text":"<p>Models the reverberation of a rectangular metal plate with settable physical characteristics when excited by audio signal(s).</p>"},{"location":"opcodes/platerev/#syntax","title":"Syntax","text":"<pre><code>a1[, a2, ...] platerev itabexcite. itabouts, kbndry, iaspect, istiff, idecay, \\\n                       iloss, aexcite1[, aexcite2, ...]\n</code></pre>"},{"location":"opcodes/platerev/#initialization","title":"Initialization","text":"<p>itabexcite -- number of a table that contains triplets for each excitation signal, (frequency, radius, initial phase in radians).  The radius should be less than 1. These control where the excitation happens.  The values in the table for frequency and radius may be changed in performance, with the proviso about clicking if the changes are too large.</p> <p>itabouts -- number of a table that contains triplets for each output signal, (frequency, radius, initial phase in radians).  See itabexcite description.</p> <p>kbndry -- boundary condition of the plate; 0 = free, 1 = clamped, 2 = pivoting.  Other values are undefined.  Thus parameter may be changed at k-rate but that might give rise to clicks.</p> <p>iaspect -- plate aspect ratio which should be less than or equal to 1.</p> <p>istiff -- plate stiffness parameter (set around 1 or less for plate reverb).</p> <p>idecay -- time taken for 30 dB decay</p> <p>iloss -- loss parameter for high-frequency damping (value about 0.001 suggested).</p>"},{"location":"opcodes/platerev/#performance","title":"Performance","text":"<p>A metal plate is excited by a stereo signal and the resulting reverberation captured.</p> <p>aexciten -- excitation signal to be inserted into the plate.</p>"},{"location":"opcodes/platerev/#examples","title":"Examples","text":"<p>Here is an example of the platerev opcode. It uses the file plate.csd.</p> Example of the platerev opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n;-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n -o plate.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; Note: this example is heavy on CPU\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nab    diskin2  \"drumsMlp.wav\", 1\nal,ar platerev 1, 2, p4, 0.73, 1.0, 5.0, 0.001, ab,ab\n      outs      al*.25,ar*.25\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8 -2   0.3   0.3875    0.39274  0.32   0.85714 0.78548\nf2 0 8 -2   0.2   0.666667  1.57097  0.24   0.75    0.78548\ni1 0 4 1\ni1 + 4 2\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/platerev/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/platerev/#credits","title":"Credits","text":"<p>Author: Stefan Bilbao  University of Edinburgh, UK Author: John ffitch  University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 5.17.12</p>"},{"location":"opcodes/plltrack/","title":"Plltrack","text":""},{"location":"opcodes/plltrack/#plltrack","title":"plltrack","text":"<p>Tracks the pitch of a signal.</p> <p>plltrack, a pitch tracker based on a phase-locked loop algorithm, described in Zolzer, U, Sankarababu, S.V. and Moller, S, \"PLL-based Pitch Detection and Tracking for Audio Signals. Proc. of IIH-MSP 2012\".</p>"},{"location":"opcodes/plltrack/#syntax","title":"Syntax","text":"<pre><code>acps, alock plltrack asig, kd [, kloopf, kloopq, klf, khf, kthresh]\n</code></pre>"},{"location":"opcodes/plltrack/#performance","title":"Performance","text":"<p>acps -- estimated pitch in Hz.</p> <p>alock -- phase lock indicator, a phase error indicating the quality of the tracking, with values between 0 and 1. Higher values indicate good tracking</p> <p>kd -- PLL feedback gain, controls frequency range of PLL (between 0 and 1). Higher values increase the range of the tracking.</p> <p>kloopf -- PLL LP filter cf, controls frequency range of PLL (opt, defaults to 20Hz).</p> <p>kloopq -- PLL LP filter Q, controls rise time of FO step (opt, defaults to 1/3)</p> <p>klf -- lowest tracking freq (opt, defaults to 20Hz)</p> <p>khf -- highest tracking freq (opt, defaults to 1500Hz)</p> <p>kthresh --  tracking signal level threshold (optional, defaults to 0.001, equiv to -60dBfs)</p> <p>plltrack analyzes the input signal, asig, estimating the fundamental of a monophonic signal. Its output is updated every sample.</p>"},{"location":"opcodes/plltrack/#examples","title":"Examples","text":"<p>Here is an example of the plltrack operator. It uses the file plltrack.csd.</p> Example of the plltrack operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o plltrack.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkd = p4\na1 diskin2 \"fox.wav\", 1,0,1\napitch, aloc plltrack a1, kd\nkrms rms a1\nkrms port krms, 0.01\nasig buzz krms, apitch, 10, 1\n     outs asig, asig            ;mix in some dry signal as well\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 65536 10 1 ;sine wave\n\ni 1 0 6 0.1\ni 1 7 6 0.3     ;more feedback\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/plltrack/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/plltrack/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI, Maynooth. Maynooth, Ireland September, 2012</p> <p>New in Csound version 5.18.031</p>"},{"location":"opcodes/pluck/","title":"Pluck","text":""},{"location":"opcodes/pluck/#pluck","title":"pluck","text":"<p>Produces a naturally decaying plucked string or drum sound.</p> <p>It is based on the Karplus-Strong algorithms.</p>"},{"location":"opcodes/pluck/#syntax","title":"Syntax","text":"<pre><code>ares pluck kamp, kcps, icps, ifn, imeth [, iparm1] [, iparm2]\n</code></pre>"},{"location":"opcodes/pluck/#initialization","title":"Initialization","text":"<p>icps -- intended pitch value in Hz, used to set up a buffer of 1 cycle of audio samples which will be smoothed over time by a chosen decay method. icps normally anticipates the value of kcps, but may be set artificially high or low to influence the size of the sample buffer.</p> <p>ifn -- table number of a stored function used to initialize the cyclic decay buffer. If ifn = 0, a random sequence will be used instead.</p> <p>imeth -- method of natural decay. There are six, some of which use parameters values that follow.</p> <ol> <li>simple averaging. A simple smoothing process, uninfluenced by parameter values.</li> <li>stretched averaging. As above, with smoothing time stretched by a factor of iparm1 (&gt;=1).</li> <li>simple drum. The range from pitch to noise is controlled by a 'roughness factor' in iparm1 (0 to 1). Zero gives the plucked string effect, while 1 reverses the polarity of every sample (octave down, odd harmonics). The setting .5 gives an optimum snare drum.</li> <li>stretched drum. Combines both roughness and stretch factors. iparm1 is roughness (0 to 1), and iparm2 the stretch factor (&gt;=1).</li> <li>weighted averaging. As method 1, with iparm1 weighting the current sample (the status quo) and iparm2 weighting the previous adjacent one. iparm1 + iparm2 must be &lt;= 1.</li> <li>1st order recursive filter, with coefs .5. Unaffected by parameter values.</li> </ol> <p>iparm1, iparm2 (optional) -- parameter values for use by the smoothing algorithms (above). The default values are both 0.</p>"},{"location":"opcodes/pluck/#performance","title":"Performance","text":"<p>kamp -- the output amplitude.</p> <p>kcps -- the resampling frequency in cycles-per-second.</p> <p>An internal audio buffer, filled at i-time according to ifn, is continually resampled with periodicity kcps and the resulting output is multiplied by kamp. Parallel with the sampling, the buffer is smoothed to simulate the effect of natural decay.</p> <p>Plucked strings (1, 2, 5, 6) are best realized by starting with a random noise source, which is rich in initial harmonics. Drum sounds (methods 3, 4) work best with a flat source (wide pulse), which produces a deep noise attack and sharp decay.</p> <p>The original Karplus-Strong algorithm used a fixed number of samples per cycle, which caused serious quantization of the pitches available and their intonation. This implementation resamples a buffer at the exact pitch given by kcps, which can be varied for vibrato and glissando effects. For low values of the orch sampling rate (e.g. sr = 10000), high frequencies will store only very few samples (sr / icps). Since this may cause noticeable noise in the resampling process, the internal buffer has a minimum size of 64 samples. This can be further enlarged by setting icps to some artificially lower pitch.</p>"},{"location":"opcodes/pluck/#examples","title":"Examples","text":"<p>Here is an example of the pluck opcode. It uses the file pluck.csd.</p> Example of the pluck opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pluck.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkcps = 220\nicps = 220\nifn  = 0\nimeth = p4\n\nasig pluck 0.7, 220, 220, ifn, imeth, .1, 10\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0  5 1\ni 1 5  5 4      ;needs 2 extra parameters (iparm1, iparm2)\ni 1 10 5 6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the pluck opcode: ResonPluck_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/pluck/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/poisson/","title":"Poisson","text":""},{"location":"opcodes/poisson/#poisson","title":"poisson","text":"<p>Poisson distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/poisson/#syntax","title":"Syntax","text":"<pre><code>ares poisson klambda\nires poisson klambda\nkres poisson klambda\n</code></pre>"},{"location":"opcodes/poisson/#performance","title":"Performance","text":"<p>ares, kres, ires - number of events occuring (always an integer).</p> <p>klambda - the expected number of occurrences that occur during the rate interval.</p>"},{"location":"opcodes/poisson/#adapted-from-wikipedia","title":"Adapted from Wikipedia:","text":"<p>In probability theory and statistics, the Poisson distribution is a discrete probability distribution. It expresses the probability of a number of events occurring in a fixed period of time if these events occur with a known average rate, and are independent of the time since the last event.</p> <p>The Poisson distribution describing the probability that there are exactly k occurrences (k being a non-negative integer, k = 0, 1, 2, ...) is:</p> <p>where:</p> <ul> <li>\u03bb is a positive real number, equal to the expected number of occurrences that occur during the given interval. For instance, if the events occur on average every 4 minutes, and you are interested in the number of events occurring in a 10 minute interval, you would use as model a Poisson distribution with \u03bb = 10/4 = 2.5. This parameter is called klambda on the poisson opcodes.</li> <li>k refers to the number of i- , k- or a- periods elapsed.</li> </ul> <p>The Poisson distribution arises in connection with Poisson processes. It applies to various phenomena of discrete nature (that is, those that may happen 0, 1, 2, 3, ... times during a given period of time or in a given area) whenever the probability of the phenomenon happening is constant in time or space. Examples of events that can be modelled as Poisson distributions include:</p> <ul> <li>The number of cars that pass through a certain point on a road (sufficiently distant from traffic lights) during a given period of time.</li> <li>The number of spelling mistakes one makes while typing a single page.</li> <li>The number of phone calls at a call center per minute.</li> <li>The number of times a web server is accessed per minute.</li> <li>The number of roadkill (animals killed) found per unit length of road.</li> <li>The number of mutations in a given stretch of DNA after a certain amount of radiation.</li> <li>The number of unstable nuclei that decayed within a given period of time in a piece of radioactive substance. The radioactivity of the substance will weaken with time, so the total time interval used in the model should be significantly less than the mean lifetime of the substance.</li> <li>The number of pine trees per unit area of mixed forest.</li> <li>The number of stars in a given volume of space.</li> <li>The distribution of visual receptor cells in the retina of the human eye.</li> <li>The number of viruses that can infect a cell in cell culture.</li> </ul> A diagram showing the Poisson distribution. <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/poisson/#examples","title":"Examples","text":"<p>Here is an example of the poisson opcode. It uses the file poisson.csd. It is written for *NIX systems, and will generate errors on Windows.</p> Example of the poisson opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n\n; For Non-realtime ouput leave only the line below:\n; -o poisson.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 441  ;ksmps set deliberately high to have few k-periods per second\nnchnls = 1\n\ninstr 1\n  ; Generates a random number in a poisson distribution.\n  ; klambda = 1\n  i1 poisson 1\n  print i1\nendin\n\ninstr 2\n  kres poisson p4\n  printk (ksmps/sr),kres ;prints every k-period\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n\ni 2 1 0.2 0.5\ni 2 2 0.2 4   ;average 4 events per k-period\ni 2 3 0.2 20  ;average 20 events per k-period\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the poisson opcode. It uses the file poisson2.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o poisson2.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi - 2024\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 1024\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkpitch poisson p4\nprintk (ksmps/sr),kpitch ;prints every k-period\n\na1 oscili 0.3, kpitch, 1\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 4096 10 1 0.1 0 0.2 0 0.3 0 0.1\n\ni 1 0 5 100\ni 1 + 5 200\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the poisson opcode: Poisson_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/poisson/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/poisson/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/polyaft/","title":"Polyaft","text":""},{"location":"opcodes/polyaft/#polyaft","title":"polyaft","text":"<p>Returns the polyphonic after-touch pressure of the selected note number, optionally mapped to an user-specified range.</p>"},{"location":"opcodes/polyaft/#syntax","title":"Syntax","text":"<pre><code>ires polyaft inote [, ilow] [, ihigh]\nkres polyaft inote [, ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/polyaft/#initialization","title":"Initialization","text":"<p>inote -- note number. Normally set to the value returned by notnum</p> <p>ilow (optional, default: 0) -- lowest output value</p> <p>ihigh (optional, default: 127) -- highest output value</p>"},{"location":"opcodes/polyaft/#performance","title":"Performance","text":"<p>kres -- polyphonic pressure (aftertouch).</p>"},{"location":"opcodes/polyaft/#examples","title":"Examples","text":"<p>Here is an example of the polyaft opcode. It uses the file polyaft.csd.</p> <p>Do not forget that you must include the -F flag when using an external MIDI file like \u201cpolyaft.mid\u201d.</p> Example of the polyaft opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in   No messages  MIDI in\n-odac           -iadc     -d         -M0  ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o polyaft.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =  44100\nksmps   =  10\nnchnls  =  1\n\n        massign 1, 1\nitmp    ftgen 1, 0, 1024, 10, 1         ; sine wave\n\n        instr 1\n\nkcps    cpsmidib 2              ; note frequency\ninote   notnum                  ; note number\nkaft    polyaft inote, 0, 127   ; aftertouch\n; interpolate aftertouch to eliminate clicks\nktmp    phasor 40\nktmp    trigger 1 - ktmp, 0.5, 0\nkaft    tlineto kaft, 0.025, ktmp\n; map to sine curve for crossfade\nkaft    =  sin(kaft * 3.14159 / 254) * 22000\n\nasnd    oscili kaft, kcps, 1\n\n        out asnd\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nt 0 120\nf 0 9 2 -2 0\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/polyaft/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/polyaft/#credits","title":"Credits","text":"<p>Added thanks to an email from Istvan Varga</p> <p>New in version 4.12</p>"},{"location":"opcodes/polynomial/","title":"Polynomial","text":""},{"location":"opcodes/polynomial/#polynomial","title":"polynomial","text":"<p>Efficiently evaluates a polynomial of arbitrary order.</p> <p>The polynomial opcode calculates a polynomial with a single a-rate input variable.  The polynomial is a sum of any number of terms in the form kn*x^n where kn is the nth coefficient of the expression.  These coefficients are k-rate values.</p>"},{"location":"opcodes/polynomial/#syntax","title":"Syntax","text":"<pre><code>aout polynomial ain, k0 [, k1 [, k2 [...]]]\n</code></pre>"},{"location":"opcodes/polynomial/#performance","title":"Performance","text":"<p>ain --  the input signal used as the independent variable of the polynomial (\"x\").</p> <p>aout --  the output signal (\"y\").</p> <p>k0, k1, k2, ... --  the coefficients for each term of the polynomial.</p> <p>If we consider the input parameter ain to be \"x\" and the output aout to be \"y\", then the polynomial opcode calculates the following equation:</p> <pre><code>y = k0 + k1*x + k2*x^2 + k3*x^3 + ...\n</code></pre>"},{"location":"opcodes/polynomial/#examples","title":"Examples","text":"<p>Here is an example of the polynomial opcode. It uses the file polynomial.csd.</p> Example of the polynomial opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o polynomial.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; The polynomial y=x^n where n is odd always produces a curve\n; that traverses the range [-1, 1] when the input is within\n; the same range.  Therefore, we can use one of these curves\n; to make a nonlinear phasor that repeatedly reads a table \n; from beginning to end like a linear phasor (maintaining \n; continuity) but that distorts the waveform in the table.\n\ninstr 4 ; This instrument demonstrates phase distortion with x^3\n\nidur   = p3\niamp   = p4\nifreq  = p5\nitable = p6\n\naenv linseg 0, .001, 1.0, idur - .051, 1.0, .05, 0      ; declicking envelope\naosc phasor ifreq                                       ; create a linear phasor\napd  polynomial aosc, 0, 0, 0, 1                        ; distort the phasor with x^3\naout tablei apd, itable, 1                              ; read a sine table with the nonlinear phasor\n     outs aenv*aout*iamp, aenv*aout*iamp\n\nendin\n\ninstr 5 ; This instrument demonstrates phase distortion with x^11\n\nidur   = p3\niamp   = p4\nifreq  = p5\nitable = p6\n\naenv linseg 0, .001, 1.0, idur - .051, 1.0, .05, 0      ; declicking envelope\naosc phasor ifreq                                       ; create a linear phasor\napd  polynomial aosc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ; distort the phasor with x^11\naout tablei apd, itable, 1                              ; read a sine table with the nonlinear phasor\n     outs aenv*aout*iamp, aenv*aout*iamp\n\nendin\n\ninstr 6 ; This instrument crossfades between a pure sine and one distorted with x^11\n\nidur   = p3\niamp   = p4\nifreq  = p5\nitable = p6\n\naenv    linseg  0, .001, 1.0, idur - .051, 1.0, .05, 0  ; declicking envelope\naosc    phasor  ifreq                                   ; create a linear phasor\naout3   tablei  aosc, itable, 1                         ; read a sine table without the linear phasor\napd11   polynomial aosc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ; distort the phasor with x^11\naout11  tablei  apd11, itable, 1                        ; read a sine table with the nonlinear phasor\nkamount linseg  1.0, 0.05, 0.9, 1.0, 0.0                ; crossfade between two outputs\naout    = aout3*kamount + aout11*(1.0 - kamount)\n        outs aenv*aout*iamp, aenv*aout*iamp     \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16385 10 1 ; sine wave\n\n; descending \"just blues\" scale\n\nt 0 100\ni4 0 .333 .7 512     1\ni. + .    .  448\ni. + .    .  384\ni. + .    .  360\ni. + .    .  341.33\ni. + .    .  298.67\ni. + 2    .  256\ns\n\nt 0 100\ni5 0 .333 .7 512     1\ni. + .    .  448\ni. + .    .  384\ni. + .    .  360\ni. + .    .  341.33\ni. + .    .  298.67\ni. + 2    .  256\ns\n\nt 0 100\ni6 0 .333 .7 512     1\ni. + .    .  448\ni. + .    .  384\ni. + .    .  360\ni. + .    .  341.33\ni. + .    .  298.67\ni. + 2    .  256\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/polynomial/#see-also","title":"See also","text":"<p>Waveshaping</p> <p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/polynomial/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/pop/","title":"Pop","text":""},{"location":"opcodes/pop/#pop","title":"pop","text":"<p>Pops values from the global stack.  Deprecated.</p> <p>Plugin opcode in stackops.</p>"},{"location":"opcodes/pop/#syntax","title":"Syntax","text":"<pre><code>xval1, [xval2, ... , xval31] pop\nival1, [ival2, ... , ival31] pop\n</code></pre>"},{"location":"opcodes/pop/#initialization","title":"Initialization","text":"<p>ival1 ... ival31  - values to be popped from the stack.</p>"},{"location":"opcodes/pop/#performance","title":"Performance","text":"<p>xval1 ... xval31  - values to be popped from the stack.</p> <p>The given values are poped from  the stack. The global stack works in LIFO order: after multiple push calls, pop should be used in reverse order.</p> <p>Each push or pop operation can work on a \"bundle\" of multiple variables. When using pop, the number, type, and order of items must match those used by the corresponding push. That is, after a 'push Sfoo, ibar', you must call something like 'Sbar, ifoo pop', and not e.g. two separate 'pop' statements.</p> <p>push and pop opcodes can take variables of any type (i-, k-, a- and strings). Use of any combination of i, k, a, and S types is allowed. Variables of type 'a' and 'k' are passed at performance time only, while 'i' and 'S' are passed at init time only.</p> <p>push/pop for a, k, i, and S types copy data by value. By contrast, push_f only pushes a \"reference\" to the f-signal, and then the corresponding pop_f will copy directly from the original variable to its output signal. For this reason, changing the source f-signal of push_f before pop_f is called is not recommended, and if the instrument instance owning the variable that was passed by push_f is deactivated before pop_f is called, undefined behavior may occur.</p> <p>Any stack errors (trying to push when there is no more space, or pop from an empty stack, inconsistent number or type of arguments, etc.) are fatal and terminate performance.</p>"},{"location":"opcodes/pop/#examples","title":"Examples","text":"<p>Here is an example of the pop opcode. It uses the file pop.csd.</p> Example of the pop opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pop.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\nstack 100000 \n\ninstr 1 \n\na1      oscils 0.7, 220, 0 \nk1      line 0, p3, 1 \n        push \"blah\", 123.45, a1, k1 \n        push rnd(k1) \n\nk_rnd   pop \nS01, i01, a01, k01 pop \n        printf_i \"S01 = '%s', i01 = %g\\n\", 1, S01, i01 \nktrig   metro 5.0 \n        printf \"k01 = %.3f, k_rnd = %.3f\\n\", ktrig, k01, k_rnd \n        outs a01, a01 \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 5 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/pop/#see-also","title":"See also","text":"<p>Stacks</p> <p>Using this opcode is somewhat hackish, as you can read here: http://csound.1045644.n5.nabble.com/passing-a-string-to-a-UDO-td1099284.html.</p>"},{"location":"opcodes/pop/#credits","title":"Credits","text":"<p>By: Istvan Varga. 2006</p> <p>Deprecated as of version 6.04.</p>"},{"location":"opcodes/pop_f/","title":"Pop f","text":""},{"location":"opcodes/pop_f/#pop_f","title":"pop_f","text":"<p>Pops an f-sig frame from the global stack.  Deprecated.</p> <p>Plugin opcode in stackops.</p>"},{"location":"opcodes/pop_f/#syntax","title":"Syntax","text":"<pre><code>fsig pop_f\n</code></pre>"},{"location":"opcodes/pop_f/#performance","title":"Performance","text":"<p>_fsig _  - f-signal to be popped from the stack.</p> <p>The values are popped the stack. The global stack must be initialized before used, and its size must be set. The global stack works in LIFO order: after multiple push_f calls, pop_f should be used in reverse order.</p> <p>push/pop for a, k, i, and S types copy data by value. By contrast, push_f only pushes a \"reference\" to the f-signal, and then the corresponding pop_f will copy directly from the original variable to its output signal. For this reason, changing the source f-signal of push_f before pop_f is called is not recommended, and if the instrument instance owning the variable that was passed by push_f is deactivated before pop_f is called, undefined behavior may occur.</p> <p>push_f and pop_f can only take a single argument, and the data is passed both at init and performance time.</p> <p>Any stack errors (trying to push when there is no more space, or pop from an empty stack, inconsistent number or type of arguments, etc.) are fatal and terminate performance.</p>"},{"location":"opcodes/pop_f/#see-also","title":"See also","text":"<p>Stacks</p>"},{"location":"opcodes/pop_f/#credits","title":"Credits","text":"<p>By: Istvan Varga. 2006</p> <p>Deprecated as of version 6.04.</p>"},{"location":"opcodes/port/","title":"Port","text":""},{"location":"opcodes/port/#port","title":"port","text":"<p>Applies portamento to a step-valued control signal.</p>"},{"location":"opcodes/port/#syntax","title":"Syntax","text":"<pre><code>kres port ksig, ihtim [, isig]\n</code></pre>"},{"location":"opcodes/port/#initialization","title":"Initialization","text":"<p>ihtim -- half-time of the function, in seconds.</p> <p>isig (optional, default=0) -- initial (i.e. previous) value for internal feedback. The default value is 0. Negative value will cause initialization to be skipped and last value from previous instance to be used as initial value for note.</p>"},{"location":"opcodes/port/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>port applies portamento to a step-valued control signal. At each new step value, ksig is low-pass filtered to move towards that value at a rate determined by ihtim. ihtim is the \u201chalf-time\u201d of the function (in seconds), during which the curve will traverse half the distance towards the new value, then half as much again, etc., theoretically never reaching its asymptote. With portk, the half-time can be varied at the control rate.</p>"},{"location":"opcodes/port/#examples","title":"Examples","text":"<p>Here is an example of the port opcode. It uses the file port.csd.</p> Example of the port opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o port.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\naout  diskin2 \"fox.wav\",1, 0, 1\nkf,ka ptrack aout, 512  ; pitch track with winsize=1024\nkcps  port kf, 0.01     ; smooth freq\nkamp  port ka, 0.01     ; smooth amp\n; drive an oscillator\nasig  poscil ampdb(kamp)*0dbfs, kcps, 1\n      outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; simple sine wave\nf 1 0 4096 10 1\n\ni 1 0  5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/port/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/portk/","title":"Portk","text":""},{"location":"opcodes/portk/#portk","title":"portk","text":"<p>Applies portamento to a step-valued control signal.</p>"},{"location":"opcodes/portk/#syntax","title":"Syntax","text":"<pre><code>kres portk ksig, khtim [, isig]\n</code></pre>"},{"location":"opcodes/portk/#initialization","title":"Initialization","text":"<p>isig (optional, default=0) -- initial (i.e. previous) value for internal feedback. The default value is 0.</p>"},{"location":"opcodes/portk/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>khtim -- half-time of the function in seconds.</p> <p>portk is like port except the half-time can be varied at the control rate.</p>"},{"location":"opcodes/portk/#examples","title":"Examples","text":"<p>Here is an example of the portk opcode. It uses the file portk.csd.</p> Example of the portk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o portk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Stefano Cucchi 2020\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nkFreq randomh 400, 1300, 4, 2, 550 ; random frequency to oscillators.\n\nkhtim linseg 0.001, p3*0.3, 0.001, p3*0.7, 0.125 ; portamento-function: start with NO portamento - then portamento.\nkPort portk kFreq, khtim ; pitch with portamento.\n\nasigL oscili 0.4, kFreq, 1 ; channel left - NO portamento.\nasigR oscili 0.4, kPort, 2 ; channel right - PORTAMENTO.\n\noutch 1, asigL   ; channel left\noutch 2, asigR   ; channel right\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 4096 10 1 0 1 0 1 0 1 0 1\nf 2 0 4096 10 1 1 0 1 0 1 0 1 0 1\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/portk/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/portk/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/poscil/","title":"Poscil","text":""},{"location":"opcodes/poscil/#poscil","title":"poscil","text":"<p>High precision oscillator.</p>"},{"location":"opcodes/poscil/#syntax","title":"Syntax","text":"<pre><code>ares poscil aamp, acps [, ifn, iphs]\nares poscil aamp, kcps [, ifn, iphs]\nares poscil kamp, acps [, ifn, iphs]\nares poscil kamp, kcps [, ifn, iphs]\nires poscil kamp, kcps [, ifn, iphs]\nkres poscil kamp, kcps [, ifn, iphs]\n</code></pre>"},{"location":"opcodes/poscil/#initialization","title":"Initialization","text":"<p>ifn -- (optional) function table number.  This defaults to -1 which indicates a sinewave.</p> <p>iphs (optional, default=0) -- initial phase (normalized table index 0-1).  If a negative value is given initialisation of the phase is skipped.</p>"},{"location":"opcodes/poscil/#performance","title":"Performance","text":"<p>ares -- output signal</p> <p>kamp, aamp -- the amplitude of the output signal.</p> <p>kcps, acps -- the frequency of the output signal in cycles per second.</p> <p>poscil (precise oscillator) is the same as oscili, but always employs floating-point table indexing, instead of integer math, like oscil and oscili (which can use either alternatively, depending on the table size).  It is only a bit slower than oscili when reading power-two size tables.</p> <p>The opcode poscil3 is the same as  poscil, but uses cubic interpolation.</p>"},{"location":"opcodes/poscil/#examples","title":"Examples","text":"<p>Here is an example of the poscil opcode. It uses the file poscil.csd.</p> Example of the poscil opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o poscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nipeak random 0, 1                ;where is the envelope peak\nasig  poscil .8, 220, gisine\naenv  transeg 0, p3*ipeak, 6, 1, p3-p3*ipeak, -6, 0\naL,aR pan2 asig*aenv, ipeak      ;pan according to random value\n      outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5\ni1 4 5\ni1 8 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/poscil/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/poscil/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>November 2002. Added a note about the changes to Csound version 4.22, thanks to Rasmus Ekman.</p> <p>New in Csound version 3.52</p> <p>Function table optional in Csound version 6.00</p> <p>Skip of initialisation new in version 6.06</p>"},{"location":"opcodes/poscil3/","title":"Poscil3","text":""},{"location":"opcodes/poscil3/#poscil3","title":"poscil3","text":"<p>High precision oscillator with cubic interpolation.</p> <p>poscil3 (precise oscillator) is the same as oscil3, but always employs floating-point table indexing, instead of integer math. It is only a bit slower than oscil3 when reading power-two size tables.</p>"},{"location":"opcodes/poscil3/#syntax","title":"Syntax","text":"<pre><code>ares poscil3 aamp, acps [, ifn, iphs]\nares poscil3 aamp, kcps [, ifn, iphs]\nares poscil3 kamp, acps [, ifn, iphs]\nares poscil3 kamp, kcps [, ifn, iphs]\nires poscil3 kamp, kcps [, ifn, iphs]\nkres poscil3 kamp, kcps [, ifn, iphs]\n</code></pre>"},{"location":"opcodes/poscil3/#initialization","title":"Initialization","text":"<p>ifn -- (optional) function table number.  This defaults to -1 which indicates a sinewave.</p> <p>iphs (optional, default=0) -- initial phase (normalized table index 0-1).  If a negative value is given initialisation of the phase is skipped.</p>"},{"location":"opcodes/poscil3/#performance","title":"Performance","text":"<p>ares -- output signal</p> <p>kamp, aamp -- the amplitude of the output signal.</p> <p>kcps, acps -- the frequency of the output signal in cycles per second.</p> <p>poscil3 works like poscil, but uses cubic interpolation.</p>"},{"location":"opcodes/poscil3/#examples","title":"Examples","text":"<p>Here is an example of the poscil3 opcode. It uses the file poscil3.csd.</p> Example of the poscil3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o poscil3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkrnd  randomh 40, 440, 1       ; produce random values\nain   poscil3 .6, krnd, giSine\nkline line    1, p3, 0         ; straight line\naL,aR pan2    ain, kline       ; sent across image\n      outs    aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the poscil3 opcode, which uses a table filled from a sound file. It uses the file poscil3-file.csd.</p> Another example of the poscil3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o poscil3-file.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example written by Joachim Heintz 07/2008\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; non-normalized function table with a sample 1\ngiFile  ftgen 1, 0, 0, -1, \"fox.wav\", 0, 0, 0\n\n; Instrument #1 - uses poscil3 for playing samples from a function table\ninstr 1\nkamp   = p4\nkspeed = p5\nifn    = 1\niskip  = p6\nkcps   = kspeed / (ftlen(ifn) / ftsr(ifn)) ; frequency of the oscillator\niphs   = iskip / (ftlen(ifn) / ftsr(ifn))  ; calculates skiptime to phase values (0-1)\n\n  a1 poscil3 kamp, kcps, ifn, iphs\n  out a1\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 2.756 1 1 0\ni1 3 2.756 1 -1 0\ni1 6 1.378 1 .5 2.067\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/poscil3/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/poscil3/#credits","title":"Credits","text":"<p>Authors: John ffitch, Gabriel Maldonado Italy</p> <p>New in Csound version 3.52</p> <p>variants with a-rate amplitude or frequency new in 5.16</p> <p>Function table optional in Csound version 6.00</p> <p>Skip of initialisation new in version 6.06</p>"},{"location":"opcodes/pow/","title":"Pow","text":""},{"location":"opcodes/pow/#pow","title":"pow","text":"<p>Computes one argument to the power of another argument and scales the result.</p>"},{"location":"opcodes/pow/#syntax","title":"Syntax","text":"<pre><code>ares pow aarg, kpow [, inorm]\nires pow iarg, ipow [, inorm]\nkres pow karg, kpow [, inorm]\n\nires[] pow iarg[], ipow[]\nkres[] pow karg[], kpow[]\nires[] pow iarg[], ipow\nkres[] pow karg[], kpow\n</code></pre>"},{"location":"opcodes/pow/#initialization","title":"Initialization","text":"<p>inorm (optional, default=1) -- The number to divide the result (default to 1). This is especially useful if you are doing powers of a- or k- signals where samples out of range are extremely common!</p>"},{"location":"opcodes/pow/#performance","title":"Performance","text":"<p>aarg, iarg, karg -- the base.</p> <p>ipow, kpow -- the exponent.</p> <p> Note</p> <p>Use \u02c6 with caution in arithmetical statements, as the precedence may not be correct. New in Csound version 3.493.</p>"},{"location":"opcodes/pow/#examples","title":"Examples","text":"<p>Here is an example of the pow opcode. It uses the file pow.csd.</p> Example of the pow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o pow.wav        ; output to audio file\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; Lo-Fi sound\n\nkpow      = 10                                          ;exponent\nkbase     line 1, p3, 1.4                               ;vary the base\nkQuantize pow kbase, kpow\nkQuantize = kQuantize*0.5                               ;half the number of steps for each side of a bipolar signal\nprintk2   kQuantize\nasig      diskin2 \"fox.wav\", 1, 0, 1                    ;loop the fox\nasig      = round(asig * kQuantize) / kQuantize         ;quantize and scale audio signal\n          outs asig, asig  \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 19.2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     0.50000\ni1     0.50007\ni1     0.50014\n.......\ni1    14.45986\ni1    14.46130\n</code></pre>"},{"location":"opcodes/pow/#see-also","title":"See also","text":"<p>Mathematical Functions</p> <p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/pow/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/powershape/","title":"Powershape","text":""},{"location":"opcodes/powershape/#powershape","title":"powershape","text":"<p>Waveshapes a signal by raising it to a variable exponent.</p> <p>The powershape opcode raises an input signal to a power with pre- and post-scaling of the signal so that the output will be in a predictable range.  It also processes negative inputs in a symmetrical way to positive inputs, calculating a dynamic transfer function that is useful for waveshaping.</p>"},{"location":"opcodes/powershape/#syntax","title":"Syntax","text":"<pre><code>aout powershape ain, kShapeAmount [, ifullscale]\n</code></pre>"},{"location":"opcodes/powershape/#initialization","title":"Initialization","text":"<p>ifullscale -- optional parameter specifying the range of input values from -ifullscale to ifullscale.  Defaults to 1.0 -- you should set this parameter to the maximum expected input value.</p>"},{"location":"opcodes/powershape/#performance","title":"Performance","text":"<p>ain --  the input signal to be shaped.</p> <p>aout --  the output signal.</p> <p>kShapeAmount --  the amount of the shaping effect applied to the input; equal to the power that the input signal is raised.</p> <p>The powershape opcode is very similar to the pow unit generators for calculating the mathematical \"power of\" operation.  However, it introduces a couple of twists that can make it much more useful for waveshaping audio-rate signals.  The kShapeAmount parameter is the exponent to which the input signal is raised.</p> <p>To avoid discontinuities, the powershape opcode treats all input values as positive (by taking their absolute value) but preserves their original sign in the output signal.  This allows for smooth shaping of any input signal while varying the exponent over any range.  (powershape also (hopefully) deals intelligently with  discontinuities that could arise when the exponent and input are both zero.  Note though that negative exponents will usually cause the signal to exceed the maximum amplitude specified by the ifullscale parameter and should normally be avoided).</p> <p>The other adaptation involves the ifullscale parameter.  The input signal is divided by ifullscale before being raised to kShapeAmount and then multiplied by ifullscale before being output.  This normalizes the input signal to the interval [-1,1], guaranteeing that the output (before final scaling) will also be within this range for positive shaping amounts and providing a smoothly evolving transfer function while varying the amount of shaping.  Values of kShapeAmount between (0,1) will make the signal more \"convex\" while values greater than 1 will make it more \"concave\". A value of exactly 1.0 will produce no change in the input signal.</p>"},{"location":"opcodes/powershape/#examples","title":"Examples","text":"<p>Here is an example of the powershape opcode. It uses the file powershape.csd.</p> Example of the powershape opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o abs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n        imaxamp    =           10000\n        kshapeamt  line        p5, p3, p6\n        aosc       oscili      1.0, cpspch(p4), 1\n        aout       powershape  aosc, kshapeamt\n        adeclick   linseg      0.0, 0.01, 1.0, p3 - 0.06, 1.0, 0.05, 0.0\n\n                     out         aout * adeclick * imaxamp\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32768 10 1\n\ni1 0 1    7.00  0.000001 0.8\ni1 + 0.5  7.02  0.01   1.0\ni1 + .    7.05  0.5    1.0\ni1 + .    7.07  4.0    1.0\ni1 + .    7.09  1.0    10.0\ni1 + 2    7.06  1.0    25.0\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/powershape/#see-also","title":"See also","text":"<p>pow, powoftwo</p> <p>Waveshaping</p> <p>Mathematical Functions</p>"},{"location":"opcodes/powershape/#credits","title":"Credits","text":"<p>Author: Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/powoftwo/","title":"Powoftwo","text":""},{"location":"opcodes/powoftwo/#powoftwo","title":"powoftwo","text":"<p>Performs a  power-of-two calculation.</p>"},{"location":"opcodes/powoftwo/#syntax","title":"Syntax","text":"<pre><code>powoftwo(x)  (init-rate or control-rate args only)\n</code></pre>"},{"location":"opcodes/powoftwo/#performance","title":"Performance","text":"<p>powoftwo() function returns 2<sup>x</sup> and allows positive and negatives numbers as argument. The range of values admitted in powoftwo() is -5 to +5 allowing a precision more fine than one cent in a range of ten octaves. If a greater range of values is required, use the slower opcode pow.</p> <p>These functions are fast, because they read values stored in tables. Also they are very useful when working with tuning ratios. They work at i- and k-rate.</p>"},{"location":"opcodes/powoftwo/#examples","title":"Examples","text":"<p>Here is an example of the powoftwo opcode. It uses the file powoftwo.csd.</p> Example of the powoftwo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o poweroftwo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; bit reduction for Lo-Fi sound\n\niBits     = p4                                          ;bit depth\niQuantize = powoftwo(iBits)                             ;find number of discrete steps for this bit depth\niQuantize = iQuantize*0.5                               ;half the number of steps for each side of a bipolar signal\nprint     iQuantize\nasig      soundin \"fox.wav\"\nasig      = round(asig * iQuantize) / iQuantize         ;quantize audio signal (bit reduce)\n          outs asig, asig         \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;        bits\ni1 0   3  16\ni1 ^+3 .  12\ni1 ^+3 .   8\ni1 ^+3 .   4\ni1 ^+3 .   2\ni1 ^+3 .   1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  iQuantize = 32768.000\ninstr 1:  iQuantize = 2048.000\ninstr 1:  iQuantize = 128.000\ninstr 1:  iQuantize = 8.000\ninstr 1:  iQuantize = 2.000\ninstr 1:  iQuantize = 1.000\n</code></pre>"},{"location":"opcodes/powoftwo/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/powoftwo/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy June 1998</p> <p>Author: John ffitch University of Bath, Codemist, Ltd. Bath, UK July 1999</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/prealloc/","title":"Prealloc","text":""},{"location":"opcodes/prealloc/#prealloc","title":"prealloc","text":"<p>Creates space for instruments but does not run them.</p>"},{"location":"opcodes/prealloc/#syntax","title":"Syntax","text":"<pre><code>prealloc insnum, icount\nprealloc \"insname\", icount\n</code></pre>"},{"location":"opcodes/prealloc/#initialization","title":"Initialization","text":"<p>insnum -- instrument number</p> <p>icount -- number of instrument allocations</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p>"},{"location":"opcodes/prealloc/#performance","title":"Performance","text":"<p>All instances of prealloc must be defined in the header section, not in the instrument body.</p>"},{"location":"opcodes/prealloc/#examples","title":"Examples","text":"<p>Here is an example of the prealloc opcode. It uses the file prealloc.csd.</p> Example of the prealloc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o prealloc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Pre-allocate memory for five instances of Instrument #1.\nprealloc 1, 5\n\n; Instrument #1\ninstr 1\n  ; Generate a waveform, get the cycles per second from the 4th p-field.\n  a1 oscil 6500, p4, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Just generate a nice, ordinary sine wave.\nf 1 0 32768 10 1\n\n; Play five instances of Instrument #1 for one second.\n; Note that 4th p-field contains cycles per second.\ni 1 0 1 220\ni 1 0 1 440\ni 1 0 1 880\ni 1 0 1 1320\ni 1 0 1 1760\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/prealloc/#see-also","title":"See also","text":"<p>Real-time Performance Control</p>"},{"location":"opcodes/prealloc/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy July 1999</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 3.57</p>"},{"location":"opcodes/prepiano/","title":"Prepiano","text":""},{"location":"opcodes/prepiano/#prepiano","title":"prepiano","text":"<p>Creates a tone similar to a piano string prepared in a Cageian fashion.</p> <p>Audio output is a tone similar to a piano string, prepared with a number of rubbers and rattles. The method uses a physical model developed from solving the partial differential equation.</p>"},{"location":"opcodes/prepiano/#syntax","title":"Syntax","text":"<pre><code>ares prepiano ifreq, iNS, iD, iK, iT30, iB, kbcl, kbcr, imass, ihvfreq, \\\n              iinit, ipos, ivel, isfreq, isspread[, irattles, irubbers]\nal, ar prepiano  ifreq, iNS, iD, iK, iT30, iB, kbcl, kbcr, imass, ihvfreq, \\\n                 iinit, ipos, ivel, isfreq, isspread[, irattles, irubbers]\n</code></pre>"},{"location":"opcodes/prepiano/#initialization","title":"Initialization","text":"<p>ifreq -- The base frequency of the string.</p> <p>iNS -- the number of strings involved.  In a real piano 1, 2 or 3 strings are found in different frequency regions.</p> <p>iD -- the amount each string other that the first is detuned from the main frequency, measured in cents.</p> <p>iK -- dimensionless stiffness parameter.</p> <p>iT30 -- 30 db decay time in seconds.</p> <p>ib -- high-frequency loss parameter (keep this small).</p> <p>imass -- the mass of the piano hammer.</p> <p>ihvfreq -- the frequency of the natural vibrations of the hammer.</p> <p>iinit -- the initial position of the hammer.</p> <p>ipos -- position along the string that the strike occurs.</p> <p>ivel -- normalized strike velocity.</p> <p>isfreq -- scanning frequency of the reading place.</p> <p>isspread -- scanning frequency spread.</p> <p>irattles -- table number giving locations of any rattle(s).</p> <p>irubbers -- table number giving locations of any rubbers(s).</p> <p>The rattles and rubbers tables are collections of four values, preceeded by a count. In the case of a rattle the four are position, mass density ratio of rattle/string, frequency of rattle and vertical length of the rattle.  For the rubber the fours are position, mass density ratio of rubber/string, frequency of rubber and the loss parameter.</p>"},{"location":"opcodes/prepiano/#performance","title":"Performance","text":"<p>A note is played on a piano string, with the arguments as below.</p> <p>kbcL -- Boundary condition at left end of string (1 is clamped, 2 pivoting and 3 free).</p> <p>kbcR -- Boundary condition at right end of string (1 is clamped, 2 pivoting and 3 free).</p> <p>Note that changing the boundary conditions during playing may lead to glitches and is made available as an experiment.</p>"},{"location":"opcodes/prepiano/#examples","title":"Examples","text":"<p>Here is an example of the prepiano opcode. It uses the file prepiano.csd.</p> Example of the prepiano opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if real audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o prepiano.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n;;          fund NS detune stiffness decay loss (bndry) (hammer) scan prep\naa,ab prepiano 60, 3, 10, p4, 3, 0.002, 2, 2, 1, 5000, -0.01, p5, p6, 0, 0.1, 1, 2\n      outs aa*.2, ab*.2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8 2 1 0.6 10 100 0.001 ;; 1 rattle\nf2 0 8 2 1 0.7 50 500 1000  ;; 1 rubber\ni1 0.0 1 1 0.09 20\ni1 1 .  -1 0.09 40        ;; 1 -&gt; skip initialisation\ni1 2 .  -1 0.09 60\ni1 3 .  -1 0.09 80\ni1 4 1.8  -1 0.09 100\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/prepiano/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/prepiano/#credits","title":"Credits","text":"<p>Author: Stefan Bilbao  University of Edinburgh, UK Author: John ffitch  University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 5.05</p>"},{"location":"opcodes/print/","title":"Print","text":""},{"location":"opcodes/print/#print","title":"print","text":"<p>Displays the values of init (i-rate) variables.</p>"},{"location":"opcodes/print/#syntax","title":"Syntax","text":"<pre><code>print iarg [, iarg1] [, iarg2] [...]\n</code></pre>"},{"location":"opcodes/print/#initialization","title":"Initialization","text":"<p>iarg, iarg2, ... -- i-rate arguments.</p>"},{"location":"opcodes/print/#performance","title":"Performance","text":"<p>print -- print the current value of the i-time arguments (or expressions) iarg at every i-pass through the instrument.</p> <p> Note</p> <p>The print opcode will truncate decimal places and may not show the complete value. Csound's precision depends on whether it is the floats (32-bit) or double (64-bit) version, since most internal calculations use one of these formats. If you need more resolution in the console output, you can try printf.</p>"},{"location":"opcodes/print/#examples","title":"Examples","text":"<p>Here is an example of the print opcode. It uses the file print.csd.</p> Example of the print opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o print.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nirand = rnd(3)                  ;generate a random number from 0 to 3\nprint irand                     ;print it\nasig  poscil .7, 440*irand, 1\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1 ;sine wave\n\ni 1 0 1\ni 1 2 1\ni 1 4 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>instr 1:  irand = 2.930\ninstr 1:  irand = 0.420\ninstr 1:  irand = 2.316\n</code></pre>"},{"location":"opcodes/print/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/printarray/","title":"Printarray","text":""},{"location":"opcodes/printarray/#printarray","title":"printarray","text":"<p>Print the contents of an array.</p> <p>Plugin opcode in emugens.</p>"},{"location":"opcodes/printarray/#syntax","title":"Syntax","text":"<pre><code>printarray ixs[] [, Smft, Slabel ]\nprintarray kxs[] [, ktrig, Sfmt, Slabel ]\n</code></pre>"},{"location":"opcodes/printarray/#initialization","title":"Initialization","text":"<p>Sfmt - If given, it is passed to printf for each element of the array. Otherwise a default format is used</p> <p>Slabel - If given, it is printed before the contents of the array, to easily identify the data</p>"},{"location":"opcodes/printarray/#performance","title":"Performance","text":"<p>ktrig - The array will be printed whenever this value changes from 0 to possitive. Can be used together with metro to print at a given time interval. A value of -1 indicates to print at each k-cycle (default = 1)</p>"},{"location":"opcodes/printarray/#examples","title":"Examples","text":"<p>Here is an example of the printarray opcode. It uses the file printarray.csd.</p> Example of the printarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n--nosound\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n  ; test i-time, 1D\n  ivalues[] fillarray 0, 1, 3, 5, 7, 9\n  printarray ivalues                      ; default fmt, no label\n  printarray ivalues, \"%.2f\"              ; with given fmt\n  printarray ivalues, \"\", \"ivalues = \"    ; uses default fmt\n\n  ; test i-time, long array\n  ilong[] genarray 0, 3, 0.01\n  printarray ilong\n  printarray ilong, \"%.2f\", \"long=\"\n\n  ; 2D\n  ivalues2[][] init 11, 4\n  ivalues2 fillarray 0,   1,  2, 3, \\\n                     10, 11, 12, 13, \\\n                     20, 21, 22, 23, \\\n                     30, 31, 32, 33, \\\n                     40, 41, 42, 43, \\\n                     50, 51, 52, 53, \\\n                     60, 61, 62, 63, \\\n                     70, 71, 72, 73, \\\n                     80, 81, 82, 83, \\\n                     90, 91, 92, 93, \\\n                    100,101,102,103\n  printarray ivalues2, \"%.2f\"\n  printarray ivalues2, \"%.1f\", \"ivalues2=\"\n  turnoff \nendin\n\ninstr 2\n  ; k-time, 1D, print every cycle\n  kxs[] fillarray 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n  printarray kxs, -1, \"\", \"instr 2\"\n  kxs += 1\nendin\n\ninstr 3\n  kxs[] fillarray 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n  printarray kxs, metro(20), \"%.0f\", \"kxs 1D=\"\n  kxs += 1\n  if kxs[0] &gt; 1000 then\n    turnoff\n  endif\n  endin\n\ninstr 4\n  ; k-time, 2D, print with a trigger\n  kxs[][] init 3, 4\n  kxs fillarray   0,  1,  2,  3, \\\n                 10, 11, 12, 13, \\\n                 20, 21, 22, 23\n  ktrig metro 20\n  printarray kxs, ktrig, \"\", \"kxs=\"\n  kxs[0][0] = kxs[0][0] + 1\n  if kxs[0][0] &gt; 1000 then\n    turnoff\n  endif\nendin\n\ninstr 5\n  ; test %d: it should work like printf(\"%d\", (int)myfloat)\n  ; this should print \"0 1 2 3 4\"\n  kxs[] fillarray 0, 1.1, 2, 3.3, 4\n  printarray kxs, 1, \"%d\"\n  turnoff \nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni 1 0 0.01\ni 2 1 0.05\ni 3 2 2\ni 4 2 2\ni 5 0 0.1\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/printarray/#see-also","title":"See also","text":"<p>Printing and Display</p> <p>Array opcodes</p>"},{"location":"opcodes/printarray/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/printf/","title":"Printf","text":""},{"location":"opcodes/printf/#printf","title":"printf","text":"<p>printf-style formatted output</p> <p>printf and printf_i write formatted output, similarly to the C function printf(). printf_i runs at i-time only, while printf runs both at initialization and performance time.</p>"},{"location":"opcodes/printf/#syntax","title":"Syntax","text":"<pre><code>printf_i Sfmt, itrig, [iarg1[, iarg2[, ... ]]]\nprintf Sfmt, ktrig, [xarg1[, xarg2[, ... ]]]\n</code></pre>"},{"location":"opcodes/printf/#initialization","title":"Initialization","text":"<p>Sfmt -- format string, has the same format as in printf() and other similar C functions, except length modifiers (l, ll, h, etc.) are not supported. The following conversion specifiers are allowed:</p> <ul> <li>d, i, o, u, x, X, e, E, f, F, g, G, c, s</li> </ul> <p>iarg1, iarg2, ... -- input arguments (max. 30) for format.  Integer formats like %d round the input values to the nearest integer.</p> <p>itrig -- if greater than zero the opcode performs the printing; otherwise it is an null operation.</p>"},{"location":"opcodes/printf/#performance","title":"Performance","text":"<p>ktrig -- if greater than zero and different from the value on the previous control cycle the opcode performs the requested printing.  Initially this previous value is taken as zero.</p> <p>xarg1, xarg2, ... -- input arguments (max. 30) for format.  Integer formats like %d round the input values to the nearest integer. Note that only k-rate and i-rate arguments are valid (no a-rate printing)</p>"},{"location":"opcodes/printf/#examples","title":"Examples","text":"<p>Here is an example of the printf opcode. It uses the file printf.csd.</p> Example of the printf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o printf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nSfile     strget    p4\nivld      filevalid Sfile\n\nif ivld=0 then\n          printf_i  \"Audiofile '%s' does not exist!\\n\", 1, Sfile\nelse\nasig      diskin2   Sfile, 1\n          outs      asig, asig\nendif\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 \"frox.wav\";file does not exist!!!\ni 1 + 3 \"fox.wav\";but this one certainly does...\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>Audiofile 'frox.wav' does not exist!\n</code></pre>"},{"location":"opcodes/printf/#see-also","title":"See also","text":"<p>Printing and Display</p> <p>More information about printf: http://www.cplusplus.com/reference/clibrary/cstdio/printf/</p>"},{"location":"opcodes/printf/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/printk/","title":"Printk","text":""},{"location":"opcodes/printk/#printk","title":"printk","text":"<p>Prints one k-rate value at specified intervals.</p>"},{"location":"opcodes/printk/#syntax","title":"Syntax","text":"<pre><code>printk itime, kval [, ispace] [, inamed]\n</code></pre>"},{"location":"opcodes/printk/#initialization","title":"Initialization","text":"<p>itime -- time in seconds between printings.</p> <p>ispace (optional, default=0) -- number of spaces to insert before printing. (default: 0, max: 130)</p> <p>inamed (optional, default=0) -- if non zero print the name of the kvar as well as the value.</p>"},{"location":"opcodes/printk/#performance","title":"Performance","text":"<p>kval -- The k-rate values to be printed.</p> <p>printk prints one k-rate value on every k-cycle, every second or at intervals specified. First the instrument number is printed, then the absolute time in seconds, then a specified number of spaces, then the kval value. The variable number of spaces enables different values to be spaced out across the screen - so they are easier to view.</p> <p>This opcode can be run on every k-cycle it is run in the instrument. To every accomplish this, set itime to 0.</p> <p>When itime is not 0, the opcode print on the first k-cycle it is called, and subsequently when every itime period has elapsed. The time cycles start from the time the opcode is initialized - typically the initialization of the instrument.</p>"},{"location":"opcodes/printk/#examples","title":"Examples","text":"<p>Here is an example of the printk opcode. It uses the file printk.csd.</p> Example of the printk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o printk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change a value linearly from 0 to 100,\n  ; over the period defined by p3.\n  kval line 0, p3, 100\n\n  ; Print the value of kval, once per second.\n  printk 1, kval\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 5 seconds.\ni 1 0 5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>i   1 time     0.00002:     0.00000\ni   1 time     1.00002:    20.01084\ni   1 time     2.00002:    40.02999\ni   1 time     3.00002:    60.04914\ni   1 time     4.00002:    79.93327\n</code></pre>"},{"location":"opcodes/printk/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/printk/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>named option new in 6.11</p> <p>Example written by Kevin Conder.</p> <p>Thanks goes to Luis Jure for pointing out a mistake with the itime parameter.</p>"},{"location":"opcodes/printk2/","title":"Printk2","text":""},{"location":"opcodes/printk2/#printk2","title":"printk2","text":"<p>Prints a new value every time a control variable changes.</p>"},{"location":"opcodes/printk2/#syntax","title":"Syntax","text":"<pre><code>printk2 kvar [, inumspaces] [, inamed]\n</code></pre>"},{"location":"opcodes/printk2/#initialization","title":"Initialization","text":"<p>inumspaces (optional, default=0) -- number of space characters printed before the value of kvar.</p> <p>inamed (optional, default=0) -- if non zero print the name of the kvar as well as the value.</p>"},{"location":"opcodes/printk2/#performance","title":"Performance","text":"<p>kvar -- signal to be printed</p> <p>Derived from Robin Whittle's printk, prints a new value of kvar each time kvar changes. Useful for monitoring MIDI control changes when using sliders.</p> <p> Warning</p> <p>WARNING! Do not use this opcode with normal, continuously variant k-signals, because it can hang the computer, as the rate of printing is too fast.</p>"},{"location":"opcodes/printk2/#examples","title":"Examples","text":"<p>Here is an example of the printk2 opcode. It uses the file printk2.csd.</p> Example of the printk2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o printk2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkval    randomh 0, 1.2, 20              ;choose between 0 and 1.2\nif kval &gt;0 &amp;&amp; kval&lt;=.5 then             ;3 possible outcomes\n        kval = 1                        \nelseif kval &gt;.5 &amp;&amp; kval&lt;=1 then\n        kval =2\nelseif kval &gt;1 then\n        kval =3\nendif\n\nprintk2 kval                            ;print value when it changes\nasig    poscil .7, 440*kval, 1\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     0.00000\ni1     3.00000\ni1     1.00000\ni1     3.00000\ni1     1.00000\ni1     2.00000\ni1     3.00000\n.....\n</code></pre>"},{"location":"opcodes/printk2/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/printk2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1998</p> <p>New in Csound version 3.48</p> <p>named option new in 6.11</p>"},{"location":"opcodes/printks/","title":"Printks","text":""},{"location":"opcodes/printks/#printks","title":"printks","text":"<p>Prints at k-rate using a printf() style syntax.</p>"},{"location":"opcodes/printks/#syntax","title":"Syntax","text":"<pre><code>printks \"string\", itime [, xval1] [, xval2] [...]\n</code></pre>"},{"location":"opcodes/printks/#initialization","title":"Initialization","text":"<p>\"string\" -- the text string to be printed. Can be up to 8192 characters and must be in double quotes.</p> <p>itime -- time in seconds between printings.</p>"},{"location":"opcodes/printks/#performance","title":"Performance","text":"<p>xval1, xval2, ... (optional) -- The k-rate values to be printed. These are specified in \u201cstring\u201d with the standard C value specifier (%f, %d, %s etc.) in the order given.</p> <p>In Csound version 4.23, you can use as many kval variables as you like. In versions prior to 4.23, you must specify 4 and only 4 kvals (using 0 for unused kvals).</p> <p>printks prints numbers and text which can be i-time or k-rate values. printks is highly flexible, and if used together with cursor positioning codes, could be used to write specific values to locations in the screen as the Csound processing proceeds.</p> <p>A special mode of operation allows this printks to convert kval1 input parameter into a 0 to 255 value and to use it as the first character to be printed. This enables a Csound program to send arbitrary characters to the console. To achieve this, make the first character of the string a # and then, if desired continue with normal text and format specifiers.</p> <p>This opcode can be run on every k-cycle it is run in the instrument. To every accomplish this, set itime to 0.</p> <p>When itime is not 0, the opcode print on the first k-cycle it is called, and subsequently when every itime period has elapsed. The time cycles start from the time the opcode is initialized - typically the initialization of the instrument.</p>"},{"location":"opcodes/printks/#print-output-formatting","title":"Print Output Formatting","text":"<p>All standard C language printf() control characters may be used. For example, if kval1 = 153.26789 then some common formatting options are:</p> <ol> <li>%f prints with full precision: 153.26789</li> <li>%5.2f prints: 153.26</li> <li>%d prints integers-only: 153</li> <li>%c treats kval1 as an ascii character code.</li> </ol> <p>In addition to all the printf() codes, printks supports these useful character codes:</p> printks Code Character Code \\\\r, \\\\R, %r, or %R return character (\\r) \\\\n, \\\\N, %n, %N newline character (\\n) \\\\t, \\\\T, %t, or %T tab character (\\t) %! semicolon character (;) This was needed because a \u201c;\u201d is interpreted as a comment. ^ escape character (0x1B) ^ ^ caret character (^) ~ ESC[ (escape+[ is the escape sequence for ANSI consoles) ~~ tilde (~) <p>For more information about printf() formatting, consult any C language documentation.</p> <p> Note</p> <p>Prior to version 4.23, only the %f format code was supported.</p>"},{"location":"opcodes/printks/#examples","title":"Examples","text":"<p>Here is an example of the printks opcode. It uses the file printks.csd.</p> Example of the printks opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o printks.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change a value linearly from 0 to 100,\n  ; over the period defined by p3.\n  kup line 0, p3, 100\n  ; Change a value linearly from 30 to 10, \n  ; over the period defined by p3.\n  kdown line 30, p3, 10\n\n  ; Print the value of kup and kdown, once per second.\n  printks \"kup = %f, kdown = %f\\\\n\", 1, kup, kdown\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 5 seconds.\ni 1 0 5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>kup = 0.000000, kdown = 30.000000\nkup = 20.010843, kdown = 25.962524\nkup = 40.029991, kdown = 21.925049\nkup = 60.049141, kdown = 17.887573\nkup = 79.933266, kdown = 13.872493\n</code></pre>"},{"location":"opcodes/printks/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/printks/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>Example written by Kevin Conder.</p> <p>Thanks goes to Luis Jure for pointing out a mistake with the itime parameter.</p> <p>Thanks to Matt Ingalls, updated the documentation for version 4.23.</p>"},{"location":"opcodes/printks2/","title":"Printks2","text":""},{"location":"opcodes/printks2/#printks2","title":"printks2","text":"<p>Prints a new value every time a control variable changes using a printf() style syntax.</p>"},{"location":"opcodes/printks2/#syntax","title":"Syntax","text":"<pre><code>printks2 \"string\", kval\n</code></pre>"},{"location":"opcodes/printks2/#initialization","title":"Initialization","text":"<p>\"string\" -- the text string to be used as a format.</p>"},{"location":"opcodes/printks2/#performance","title":"Performance","text":"<p>kval -- signal to be printed. The style of printing is specified in \u201cstring\u201d with the standard C value specifier (%f, %d, etc.).</p>"},{"location":"opcodes/printks2/#print-output-formatting","title":"Print Output Formatting","text":"<p>All standard C language printf() control characters may be used. For example, if kval1 = 153.26789 then some common formatting options are:</p> <ol> <li>%f prints with full precision: 153.26789</li> <li>%5.2f prints: 153.26</li> <li>%d prints integers-only: 153</li> <li>%c treats kval1 as an ascii character code.</li> </ol> <p>In addition to all the printf() codes, printks2 supports these useful character codes:</p> printks Code Character Code \\\\r, \\\\R, %r, or %R return character (\\r) \\\\n, \\\\N, %n, %N newline character (\\n) \\\\t, \\\\T, %t, or %T tab character (\\t) %! semicolon character (;) This was needed because a \u201c;\u201d is interpreted as a comment. ^ escape character (0x1B) ^ ^ caret character (^) ~ ESC[ (escape+[ is the escape sequence for ANSI consoles) ~~ tilde (~) <p>For more information about printf() formatting, consult any C language documentation.</p>"},{"location":"opcodes/printks2/#examples","title":"Examples","text":"<p>Here is an example of the printks2 opcode. It uses the file printks2.csd.</p> Example of the printks2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n; For Non-realtime ouput leave only the line below:\n; -o printk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Change a value linearly from 0 to 100,\n  ; over the period defined by p3.\n  kval line 0, p3, 100\n\n  ; Print the value of kval when it changes.\n  printks2 \"value now %f\\n\", int(kval)\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for 5 seconds.\ni 1 0 5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/printks2/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/printks2/#credits","title":"Credits","text":"<p>Author: John ffitch Bath, UK Mar 2014</p> <p>New in Csound version 6.03</p>"},{"location":"opcodes/println/","title":"Println","text":""},{"location":"opcodes/println/#println","title":"println","text":"<p>Prints at k-rate using a printf() style syntax like printks, appends a new line.</p>"},{"location":"opcodes/println/#syntax","title":"Syntax","text":"<pre><code>println \"string\", [, xval1] [, xval2] [...]\n</code></pre>"},{"location":"opcodes/println/#initialization","title":"Initialization","text":"<p>\"string\" -- the text string to be printed. Can be up to 8192 characters and must be in double quotes.</p>"},{"location":"opcodes/println/#performance","title":"Performance","text":"<p>xval1, xval2, ... (optional) -- The k-rate values to be printed. These are specified in \u201cstring\u201d with the standard C value specifier (%f, %d, %s etc.) in the order given.</p>"},{"location":"opcodes/println/#print-output-formatting","title":"Print Output Formatting","text":"<p>All standard C language printf() control characters may be used. For example, if kval1 = 153.26789 then some common formatting options are:</p> <ol> <li>%f prints with full precision: 153.26789</li> <li>%5.2f prints: 153.26</li> <li>%d prints integers-only: 153</li> <li>%c treats kval1 as an ascii character code.</li> </ol> <p>For more information about printf() formatting, consult any C language documentation.</p>"},{"location":"opcodes/println/#examples","title":"Examples","text":"<p>Here is an example of the println opcode. It uses the file println.csd.</p> Example of the println opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 64\nnchnls = 1\n\ninstr 1\n  ; printsk is executed at k-time, possibly multiples times per cycle.\n  k0 = 0\n  while k0 &lt; 20 do\n    if k0 % 2 == 0 then\n      printsk \"k0 = %d\\n\", k0\n    endif\n    k0 += 1\n  od\nendin\n\ninstr 2\n  ; println is similar to printsk but appends a new line\n  k0 = 0\n  while k0 &lt; 20 do\n    if k0 % 2 == 0 then\n      println \"k0 = %d\", k0\n    endif\n    k0 += 1\n  od\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0.1\ni 2 0.1 0.1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/println/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/println/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2020</p> <p>New plugin in version 6.15</p>"},{"location":"opcodes/prints/","title":"Prints","text":""},{"location":"opcodes/prints/#prints","title":"prints","text":"<p>Prints at init-time using a printf() style syntax.</p>"},{"location":"opcodes/prints/#syntax","title":"Syntax","text":"<pre><code>prints \"string\" [, xval1] [, xval2] [...]\n</code></pre>"},{"location":"opcodes/prints/#initialization","title":"Initialization","text":"<p>\"string\" -- the text string to be printed. Can be up to 8192 characters and must be in double quotes.</p>"},{"location":"opcodes/prints/#performance","title":"Performance","text":"<p>xval1, xval2, ... (optional) -- The k-rate values or strings to be printed. These are specified in \u201cstring\u201d with the standard C value specifier (%f, %d, %s etc.) in the order given.</p> <p>prints is similar to the printks opcode except it operates at init-time instead of k-rate. For more information about output formatting, please look at printks's documentation.</p>"},{"location":"opcodes/prints/#examples","title":"Examples","text":"<p>Here is an example of the prints opcode. It uses the file prints.csd.</p> Example of the prints opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o prints.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Matt Ingalls, edited by Kevin Conder. */\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Init-time print.\n  prints \"%2.3f\\\\t%!%!%!%!%!%!semicolons! %%\\\\n\", 1234.56789\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Matt Ingalls, edited by Kevin Conder. */\n; Play instrument #1.\ni 1 0 0.004\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>1234.568        ;;;;;;semicolons!\n</code></pre>"},{"location":"opcodes/prints/#see-also","title":"See also","text":"<p>Printing and Display</p>"},{"location":"opcodes/prints/#credits","title":"Credits","text":"<p>Author: Matt Ingalls January 2003</p>"},{"location":"opcodes/product/","title":"Product","text":""},{"location":"opcodes/product/#product","title":"product","text":"<p>Multiplies any number of a-rate signals.</p>"},{"location":"opcodes/product/#syntax","title":"Syntax","text":"<pre><code>ares product asig1, asig2 [, asig3] [...]\n</code></pre>"},{"location":"opcodes/product/#performance","title":"Performance","text":"<p>asig1, asig2, asig3, ... --  a-rate signals to be multiplied.</p>"},{"location":"opcodes/product/#examples","title":"Examples","text":"<p>Here is an example of the product opcode. It uses the file product.csd.</p> Example of the product opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o product.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\na1   oscili 1, 10.0, gisine             ;combine 3 sinusses\na2   oscili 1, 1.0, gisine              ;at different rates\na3   oscili 1, 3.0, gisine\nares product a1, a2, a3\n\nares = ares*10000                       ;scale result and\nasig poscil .5, ares+110, gisine        ;add to frequency                       \n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/product/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/product/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy April 1999</p> <p>New in Csound version 3.54</p>"},{"location":"opcodes/pset/","title":"Pset","text":""},{"location":"opcodes/pset/#pset","title":"pset","text":"<p>Defines and initializes numeric arrays at orchestra load time.</p>"},{"location":"opcodes/pset/#syntax","title":"Syntax","text":"<pre><code>pset icon1 [, icon2] [...]\n</code></pre>"},{"location":"opcodes/pset/#initialization","title":"Initialization","text":"<p>icon1, icon2, ... -- preset values for a MIDI instrument</p> <p>pset (optional) defines and initializes numeric arrays at orchestra load time. It may be used as an orchestra header statement (i.e. instrument 0) or within an instrument. When defined within an instrument, it is not part of its i-time or performance operation, and only one statement is allowed per instrument. These values are available as i-time defaults. When an instrument is triggered from MIDI it only gets p1 and p2 from the event, and p3, p4, etc. will receive the actual preset values.</p>"},{"location":"opcodes/pset/#examples","title":"Examples","text":"<p>Here is an example of the pset opcode. It uses the file pset.csd</p> Example of the pset opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pset.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2 \n\ninstr 1 ;this shows an example with non-midi use\n\npset 1, 0, 1, 220, 0.5 \nasig poscil p5, p4, 1 \n     outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \nf 1 0 1024 10 1 ;sine wave\n\ni 1 0 1 \ni 1 1 1 440 \ni 1 2 1 440 0.1 \ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Here is another example of the pset opcode, using pset with a midi file. It uses the files pset-midi.csd and midiChords.mid</p> Second example of the pset opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac    -m0d --midi-key-oct=4 --midi-velocity=5   -F midiChords.mid \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o pset-midi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\n; by Menno Knevel - 2021\n\nsr = 44100 \nksmps = 32\n0dbfs  = 1 \nnchnls = 2 \n\n; midiChords.mid can be found in examples folder\n\ninstr 1\n\n            pset 1, 0, .1\n\nistarttime  = p2\niattack     = 0.005\nisustain    = p3\nirelease    = 0.06\np3          = isustain + iattack + irelease\n\nifrequency cpsmidi\niamplitude  = p5*.2                     ;lower volume\n\nprint p1, p2, p3, p4, p5\nasig STKBandedWG ifrequency, iamplitude\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 60  ; runs for 1 minute, midifile time lasts for 35 seconds\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pset/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/ptrack/","title":"Ptrack","text":""},{"location":"opcodes/ptrack/#ptrack","title":"ptrack","text":"<p>Tracks the pitch of a signal.</p> <p>ptrack takes an input signal, splits it into ihopsize blocks and using a STFT method, extracts an estimated pitch for its fundamental frequency as well as estimating the total amplitude of the signal in dB, relative to full-scale (0dB). The method implies an analysis window size of 2*ihopsize samples (overlaping by 1/2 window), which has to be a power-of-two, between 128 and 8192 (hopsizes between 64 and 4096). Smaller windows will give better time precision, but worse frequency accuracy (esp. in low fundamentals).This opcode is based on an original algorithm by M. Puckette.</p>"},{"location":"opcodes/ptrack/#syntax","title":"Syntax","text":"<pre><code>kcps, kamp ptrack asig, ihopsize[,ipeaks]\n</code></pre>"},{"location":"opcodes/ptrack/#initialization","title":"Initialization","text":"<p>ihopsize -- size of the analysis 'hop', in samples, required to be power-of-two (min 64, max 4096). This is the period between measurements.</p> <p>ipeaks, ihi -- number of spectral peaks to use in the analysis, defaults to 20 (optional)</p>"},{"location":"opcodes/ptrack/#performance","title":"Performance","text":"<p>kcps -- estimated pitch in Hz.</p> <p>kamp -- estimated amplitude in dB relative to full-scale (0dB) (ie. always &lt;= 0).</p> <p>ptrack analyzes the input signal, asig, to give a pitch/amplitude pair of outputs, for the fundamental of a monophonic signal. The output is updated every sr/ihopsize seconds.</p>"},{"location":"opcodes/ptrack/#examples","title":"Examples","text":"<p>Here is an example of the ptrack opcode. This example uses the files ptrack.csd.</p> Example of the ptrack opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o ptrack.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nihop  = p4\naout  diskin2 \"fox.wav\",1, 0, 1\nkf,ka ptrack aout, ihop ; pitch track with different hopsizes\nkcps  port kf, 0.01     ; smooth freq\nkamp  port ka, 0.01     ; smooth amp\n; drive an oscillator\nasig  poscil ampdb(kamp)*0dbfs, kcps, 1\n      outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; simple sine wave\nf 1 0 4096 10 1\n\ni 1 0  5 128\ni 1 6  5 512\ni 1 12 5 1024\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/ptrack/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/ptrack/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI, Maynooth. Maynooth, Ireland March, 2007</p> <p>New in Csound version 5.05</p>"},{"location":"opcodes/push/","title":"Push","text":""},{"location":"opcodes/push/#push","title":"push","text":"<p>Pushes a value into the global stack.  Deprecated.</p> <p>Plugin opcode in stackops.</p>"},{"location":"opcodes/push/#syntax","title":"Syntax","text":"<pre><code>push  xval1, [xval2, ... , xval31]\npush  ival1, [ival2, ... , ival31]\n</code></pre>"},{"location":"opcodes/push/#initialization","title":"Initialization","text":"<p>_ival1 ... ival31 _  - values to be pushed into the stack.</p>"},{"location":"opcodes/push/#performance","title":"Performance","text":"<p>_xval1 ... xval31 _  - values to be pushed into the stack.</p> <p>The given values are pushed into the global stack as a bundle. The global stack works in LIFO order: after multiple push calls, pop should be used in reverse order.</p> <p>Each push or pop operation can work on a \"bundle\" of multiple variables. When using pop, the number, type, and order of items must match those used by the corresponding push. That is, after a 'push Sfoo, ibar', you must call something like 'Sbar, ifoo pop', and not e.g. two separate 'pop' statements.</p> <p>push and pop opcodes can take variables of any type (i-, k-, a- and strings). Use of any combination of i, k, a, and S types is allowed. Variables of type 'a' and 'k' are passed at performance time only, while 'i' and 'S' are passed at init time only.</p> <p>push/pop for a, k, i, and S types copy data by value. By contrast, push_f only pushes a \"reference\" to the f-signal, and then the corresponding pop_f will copy directly from the original variable to its output signal. For this reason, changing the source f-signal of push_f before pop_f is called is not recommended, and if the instrument instance owning the variable that was passed by push_f is deactivated before pop_f is called, undefined behavior may occur.</p> <p>Any stack errors (trying to push when there is no more space, or pop from an empty stack, inconsistent number or type of arguments, etc.) are fatal and terminate performance.</p>"},{"location":"opcodes/push/#examples","title":"Examples","text":"<p>Here is an example of the push opcode. It uses the file push.csd.</p> Example of the push opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o push.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\nstack 100000 \n\ninstr 1 \n\na1      oscils 0.7, 220, 0 \nk1      line 0, p3, 1 \n        push \"blah\", 123.45, a1, k1 \n        push rnd(k1) \n\nk_rnd   pop \nS01, i01, a01, k01 pop \n        printf_i \"S01 = '%s', i01 = %g\\n\", 1, S01, i01 \nktrig   metro 5.0 \n        printf \"k01 = %.3f, k_rnd = %.3f\\n\", ktrig, k01, k_rnd \n        outs a01, a01 \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 5 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/push/#see-also","title":"See also","text":"<p>Stacks</p> <p>Using this opcode is somewhat hackish, as you can read here: http://csound.1045644.n5.nabble.com/passing-a-string-to-a-UDO-td1099284.html.</p>"},{"location":"opcodes/push/#credits","title":"Credits","text":"<p>By: Istvan Varga. 2006</p> <p>Deprecated as of version 6.04.</p>"},{"location":"opcodes/push_f/","title":"Push f","text":""},{"location":"opcodes/push_f/#push_f","title":"push_f","text":"<p>Pushes an f-sig frame into the global stack.  Deprecated.</p> <p>Plugin opcode in stackops.</p>"},{"location":"opcodes/push_f/#syntax","title":"Syntax","text":"<pre><code>push_f  fsig\n</code></pre>"},{"location":"opcodes/push_f/#performance","title":"Performance","text":"<p>_fsig _  - f-signal to be pushed into the stack.</p> <p>The values are pushed into the global stack. The global stack works in LIFO order: after multiple push_f calls, pop_f should be used in reverse order.</p> <p>push/pop for a, k, i, and S types copy data by value. By contrast, push_f only pushes a \"reference\" to the f-signal, and then the corresponding pop_f will copy directly from the original variable to its output signal. For this reason, changing the source f-signal of push_f before pop_f is called is not recommended, and if the instrument instance owning the variable that was passed by push_f is deactivated before pop_f is called, undefined behavior may occur.</p> <p>pop_f and push_f can only take a single argument, and the data is passed both at init and performance time.</p> <p>Any stack errors (trying to push when there is no more space, or pop from an empty stack, inconsistent number or type of arguments, etc.) are fatal and terminate performance.</p>"},{"location":"opcodes/push_f/#see-also","title":"See also","text":"<p>Stacks</p>"},{"location":"opcodes/push_f/#credits","title":"Credits","text":"<p>By: Istvan Varga. 2006</p> <p>Deprecated as of version 6.04.</p>"},{"location":"opcodes/pvspitch/","title":"Pvspitch","text":""},{"location":"opcodes/pvspitch/#pvspitch","title":"pvspitch","text":"<p>Track the pitch and amplitude of a PVS signal as k-rate variables.</p>"},{"location":"opcodes/pvspitch/#syntax","title":"Syntax","text":"<pre><code>kfr, kamp pvspitch fsig, kthresh\n</code></pre>"},{"location":"opcodes/pvspitch/#performance","title":"Performance","text":"<p>kamp -- Amplitude of fundamental frequency</p> <p>kfr -- Fundamental frequency</p> <p>fsig -- an input pv stream</p> <p>kthresh -- analysis threshold (between 0 and 1). Higher values will eliminate low-amplitude components from the analysis.</p>"},{"location":"opcodes/pvspitch/#performance_1","title":"Performance","text":"<p>The pitch detection algorithm implemented by pvspitch is based upon  J. F. Schouten's hypothesis of the neural processes of the brain used to determine the pitch of a sound after the frequency analysis of the basilar membrane.  Except for some further considerations, pvspitch essentially seeks out the highest common factor of an incoming sound's spectral peaks to find the pitch that may be attributed to it.</p> <p>In general, input sounds that exhibit pitch will also exhibit peaks in their spectrum according to where their harmonics lie. There are some the exceptions, however.  Some sounds whose spectral representation is continuous can impart a sensation of pitch.  Such sounds are explained by the centroid or center of gravity of the spectrum and are beyond the scope of the method of pitch detection implemented by pvspitch (Using opcodes like pvscent might be more appriopriate in these cases).</p> <p>pvspitch is able (using a previous analysis fsig generated by pvsanal) to locate the spectral peaks of a signal. The threshold parameter (kthresh) is of utmost importance, as adjusting it can introduce weak yet significant harmonics into the calculation of the fundamental. However, bringing kthresh too low would allow harmonically unrelated partials into the analysis algorithm and this will compromise the method's accuracy.  These initial steps emulate the response of the basilar membrane by identifying physical characteristics of the input sound. The choice of kthresh depends on the actual level of the input signal, since its range (from 0 to 1) spans the whole dynamic range of an analysis bin (from -inf to 0dBFS).</p> <p>It is important to remember that the input to the pvspitch opcode is assumed to be characterised by strong partials within its spectrum.  If this is not the case, the results outputted by the opcode may not bear any relation to the pitch of the input signal.  If a spectral frame with many unrelated partials was analysed, the greatest common factor of these frequency values that allows for adjacent \u201charmonics\u201d would be chosen.  Thus, noisy frames can be characterised by low frequency outputs of pvspitch. This fact allows for a primitive type of instrumental transient detection, as the attack portion of some instrumental tones contain inharmonic components.  Should the lowest frequency of the analysed melody be known, then all frequencies detected below this threshold are inaccurate readings, due to the presence of unrelated partials.</p> <p>In order to facilitate efficient testing of the pvspitch algorithm, an amplitude value proportional to the one in the observed in the signal frame is also outputted (kamp).  The results of pvspitch can then be employed to drive an oscillator whose pitch can be audibly compared with that of the original signal (In the example below, an oscillator generates a signal which appears a fifth above the detected pitch).</p>"},{"location":"opcodes/pvspitch/#examples","title":"Examples","text":"<p>Here is an example of the pvspitch opcode. It uses the file pvspitch.csd. This example uses realtime audio input but can be used for audiofile input as well.</p> Example of the pvspitch opcode<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o pvspitch.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Richard Boulanger &amp; Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiwave ftgen 0, 0, 4096, 10, 1, 0.5, 0.333, 0.25, 0.2, 0.1666\n\ninstr 1\n\nifftsize = 1024\niwtype = 1                                              ; hanning window\na1 soundin \"flute.aiff\"\nfsig pvsanal a1, ifftsize, ifftsize/4, ifftsize, iwtype\nkfr, kamp pvspitch fsig, p4                             ; estimate pitch, use treshold settings\nadm poscil kamp, kfr, giwave                            ; sawtooth gets pitch from the flute\nouts adm, adm\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;       treshold\ni 1 0 3    .1\ni 1 3 3    .01\ni 1 6 3    .001\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/pvspitch/#see-also","title":"See also","text":"<p>Tools for Real-time Spectral Processing (pvs opcodes)</p> <p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/pvspitch/#credits","title":"Credits","text":"<p>Author: Alan OCinneide August 2005, added by Victor Lazzarini, August 2006 Part of the text has been adapted from the Csound Journal winter 2006 issue's article \"Introducing PVSPITCH: A pitch tracking opcode for Csound\" by Alan OCinneide. The article is available at: www.csoundjournal.com/2006winter/pvspitch.html</p>"},{"location":"opcodes/qinf/","title":"Qinf","text":""},{"location":"opcodes/qinf/#qinf","title":"qinf","text":"<p>Returns the number of times the argument is not a number, with the sign of the first infinity.</p>"},{"location":"opcodes/qinf/#syntax","title":"Syntax","text":"<pre><code>qinf(x) (no rate restriction)\n</code></pre>"},{"location":"opcodes/qinf/#examples","title":"Examples","text":"<p>Here is an example of the qinf opcode. It uses the file qinf.csd.</p> Example of the qinf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-+rtaudio=alsa -o dac:hw:0\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\nksmps = 400\n\n#define WII_B           #3#\n#define WII_A           #4#\n#define WII_R_A         #304#\n#define WII_PITCH       #20#\n#define WII_ROLL        #21#\n\ngkcnt init 1\n\ninstr 1  \n  i1  wiiconnect 3,1\n\n      wiirange   $WII_PITCH., -20, 0\n  kt  wiidata    $WII_B.\n  ka  wiidata    $WII_A.\n  kra wiidata    $WII_R_A.\n  gka wiidata    $WII_PITCH.\n  gkp wiidata    $WII_ROLL.\n; If the B (trigger) button is pressed then activate a note\n  if  (kt==0)    goto ee\n  if (qinf(gka)) goto ee\n  if (qinf(gkp)) goto ee\n  event \"i\", 2, 0, 5\n  gkcnt = gkcnt + 1\n  printk2  kb\nendin\n\ninstr 2\n  a1 oscil  ampdbfs(gka), 440+gkp, 1\n     outs   a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 4096 10 1\ni1 0 300\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/qinf/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/qinf/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in Csound 5.14</p>"},{"location":"opcodes/qnan/","title":"Qnan","text":""},{"location":"opcodes/qnan/#qnan","title":"qnan","text":"<p>Returns the number of times the argument is not a number.</p>"},{"location":"opcodes/qnan/#syntax","title":"Syntax","text":"<pre><code>qnan(x) (no rate restriction)\n</code></pre>"},{"location":"opcodes/qnan/#examples","title":"Examples","text":"<p>Here is an example of the qnan opcode. It uses the file qnan.csd.</p> Example of the qnan opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-+rtaudio=alsa -o dac:hw:0\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\nksmps = 400\n\n#define WII_B           #3#\n#define WII_A           #4#\n#define WII_R_A         #304#\n#define WII_PITCH       #20#\n#define WII_ROLL        #21#\n\ngkcnt init 1\n\ninstr 1  \n  i1  wiiconnect 3,1\n\n      wiirange   $WII_PITCH., -20, 0\n  kt  wiidata    $WII_B.\n  ka  wiidata    $WII_A.\n  kra wiidata    $WII_R_A.\n  gka wiidata    $WII_PITCH.\n  gkp wiidata    $WII_ROLL.\n; If the B (trigger) button is pressed then activate a note\n  if  (kt==0)    goto ee\n  if (qnan(gka)) goto ee\n  if (qnan(gkp)) goto ee\n  event \"i\", 2, 0, 5\n  gkcnt = gkcnt + 1\n  printk2  kb\nendin\n\ninstr 2\n  a1 oscil  ampdbfs(gka), 440+gkp, 1\n     outs   a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 4096 10 1\ni1 0 300\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/qnan/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/qnan/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in Csound 5.14</p>"},{"location":"opcodes/raises/","title":"Raises","text":""},{"location":"opcodes/raises/#_1","title":"\u02c6","text":"<p>\u201cPower of\u201d operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p> <p>The operator \u02c6 raises \\(a\\) to the \\(b\\) power. \\(b\\) may not be audio-rate. Use with caution as precedence may not work correctly. See pow.  (New in Csound version 3.493.)</p>"},{"location":"opcodes/raises/#syntax","title":"Syntax","text":"<pre><code>a ^ b  (b not audio-rate)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/raises/#examples","title":"Examples","text":"<p>Here is an example of the \u02c6 operator. It uses the file raises.csd.</p> Example of the \u02c6 operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o ^.wav        ; output to audio file\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; Lo-Fi sound\n\nkpow      = 10                                          ;exponent\nkbase     line 1, p3, 2.2                               ;vary the base\nkQuantize = kbase^kpow\nkQuantize = kQuantize*0.5                               ;half the number of steps for each side of a bipolar signal\nprintk2   kQuantize\nasig      diskin2 \"fox.wav\", 1, 0, 1                    ;loop the fox\nasig      = round(asig * kQuantize) / kQuantize         ;quantize and scale audio signal\n          outs asig, asig  \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 19.2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     0.50000\ni1     0.50021\ni1     0.50042\n......\ni1  1327.49320\ni1  1327.74465\n</code></pre>"},{"location":"opcodes/raises/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/rand/","title":"Rand","text":""},{"location":"opcodes/rand/#rand","title":"rand","text":"<p>Output is a controlled random number series between -amp and +amp</p>"},{"location":"opcodes/rand/#syntax","title":"Syntax","text":"<pre><code>ares rand xamp [, iseed] [, isel] [, ioffset]\nkres rand xamp [, iseed] [, isel] [, ioffset]\n</code></pre>"},{"location":"opcodes/rand/#initialization","title":"Initialization","text":"<p>iseed (optional, default=0.5) -- a seed value for the recursive pseudo-random formula. A value between 0 and 1 will produce an initial output of kamp * iseed. A value greater than 1 will be seeded from the system clock. A negative value will cause seed re-initialization to be skipped. The default seed value is .5.</p> <p>isel (optional, default=0) -- if zero, a 16-bit number is generated. If non-zero, a 31-bit random number is generated. Default is 0.</p> <p>ioffset (optional, default=0) -- a base value added to the random result. New in Csound version 4.03.</p>"},{"location":"opcodes/rand/#performance","title":"Performance","text":"<p>kamp, xamp -- range over which random numbers are distributed.</p> <p>ares, kres -- Random number produced.</p> <p>The internal pseudo-random formula produces values which are uniformly distributed over the range kamp to -kamp. rand will thus generate uniform white noise with an R.M.S value of kamp / root 2.</p> <p>The value ares or kres is within is a half-closed interval which contains -xamp, but never contains +xamp.</p>"},{"location":"opcodes/rand/#examples","title":"Examples","text":"<p>Here is an example of the rand opcode. It uses the file rand.csd.</p> Example of the rand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;same values every time\n\nkrnd rand 100\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time\n\nkrnd rand 100, 10                       ; seed from system clock\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ni 1 0 1\ni 2 2 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>i   1 time     0.00067:    50.00305\ni   1 time     0.50000:    62.71362\ni   1 time     1.00000:   -89.31885\n\nWARNING: Seeding from current time 472230558\n\ni   2 time     2.00067:   -70.65735\ni   2 time     2.50000:    69.15283\ni   2 time     3.00000:   -48.79761\n</code></pre>"},{"location":"opcodes/rand/#see-also","title":"See also","text":"<p>Random (Noise) Generators, randh, randi</p>"},{"location":"opcodes/rand/#credits","title":"Credits","text":"<p>Thanks to a note from John ffitch, I changed the names of the parameters.</p>"},{"location":"opcodes/randc/","title":"Randc","text":""},{"location":"opcodes/randc/#randc","title":"randc","text":"<p>Generates a controlled random number series with cubic interpolation between each new number.</p>"},{"location":"opcodes/randc/#syntax","title":"Syntax","text":"<pre><code>ares randc xamp, xcps [, iseed] [, isize] [, ioffset]\nkres randc kamp, kcps [, iseed] [, isize] [, ioffset]\n</code></pre>"},{"location":"opcodes/randc/#initialization","title":"Initialization","text":"<p>iseed (optional, default=0.5) -- seed value for the recursive pseudo-random formula. A value between 0 and +1 will produce an initial output of kamp * iseed. A negative value will cause seed re-initialization to be skipped. A value greater than 1 will seed from system time, this is the best option to generate a different random sequence for each run.</p> <p>isize (optional, default=0) -- if zero, a 16 bit number is generated. If non-zero, a 31-bit random number is generated. Default is 0.</p> <p>ioffset (optional, default=0) -- a base value added to the random result.</p>"},{"location":"opcodes/randc/#performance","title":"Performance","text":"<p>kamp, xamp -- range over which random numbers are distributed.</p> <p>kcps, xcps -- the frequency which new random numbers are generated.</p> <p>The internal pseudo-random formula produces values which are uniformly distributed over the range kamp to -kamp. rand will thus generate uniform white noise with an R.M.S value of kamp / root 2.</p> <p>The remaining units produce band-limited noise: the kcps and xcps parameters permit the user to specify that new random numbers are to be generated at a rate less than the sampling or control frequencies. randi will produce straight-line interpolation between each new number and the next.</p>"},{"location":"opcodes/randc/#examples","title":"Examples","text":"<p>Here is an example of the randc opcode. It uses the file randc.csd.</p> Example of the randc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o randc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel - 2024\n\ninstr 1 ;same values every time\n\nkrnd randc 100, 10\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd               ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time\n\nkrnd randc 100, 10, 10                  ; seed from system clock\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd               ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3\ni 2 4 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>i   1 time     0.00000:    50.00305\ni   1 time     0.50068:    68.16267\ni   1 time     1.00136:   -94.61682\ni   1 time     1.50204:   -74.38840\n....\n\nWARNING: Seeding from current time 67726716\n\ni   2 time     4.00036:    79.19006\ni   2 time     4.50104:   -47.46559\ni   2 time     5.00172:    74.73582\ni   2 time     5.50240:    65.35726\n....\n</code></pre>"},{"location":"opcodes/randc/#see-also","title":"See also","text":"<p>Random (Noise) Generators, randh, rand</p>"},{"location":"opcodes/randh/","title":"Randh","text":""},{"location":"opcodes/randh/#randh","title":"randh","text":"<p>Generates random numbers and holds them for a period of time.</p>"},{"location":"opcodes/randh/#syntax","title":"Syntax","text":"<pre><code>ares randh xamp, xcps [, iseed] [, isize] [, ioffset]\nkres randh kamp, kcps [, iseed] [, isize] [, ioffset]\n</code></pre>"},{"location":"opcodes/randh/#initialization","title":"Initialization","text":"<p>iseed (optional, default=0.5) -- seed value for the recursive pseudo-random formula. A value between 0 and +1 will produce an initial output of kamp * iseed. A negative value will cause seed re-initialization to be skipped. A value greater than 1 will seed from system time, this is the best option to generate a different random sequence for each run.</p> <p>isize (optional, default=0) -- if zero, a 16 bit number is generated. If non-zero, a 31-bit random number is generated. Default is 0.</p> <p>ioffset (optional, default=0) -- a base value added to the random result. New in Csound version 4.03.</p>"},{"location":"opcodes/randh/#performance","title":"Performance","text":"<p>kamp, xamp -- range over which random numbers are distributed.</p> <p>kcps, xcps -- the frequency which new random numbers are generated.</p> <p>The internal pseudo-random formula produces values which are uniformly distributed over the range -kamp to +kamp. rand will thus generate uniform white noise with an R.M.S value of kamp / root 2.</p> <p>The remaining units produce band-limited noise: the kcps and xcps parameters permit the user to specify that new random numbers are to be generated at a rate less than the sampling or control frequencies. randh will hold each new number for the period of the specified cycle.</p>"},{"location":"opcodes/randh/#examples","title":"Examples","text":"<p>Here is an example of the randh opcode. It uses the file randh.csd.</p> Example of the randh opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o randh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;same values every time\n\nkrnd randh 100, 10\n     printk2 krnd                       ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time\n\nkrnd randh 100, 10, 10                  ; seed from system clock\n     printk2 krnd                       ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ni 1 0 1\ni 2 2 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>i1    50.00000\ni1    50.00305\ni1    97.68677\ni1   -44.25354\ni1   -61.56006\ni1   -75.91248\ni1    67.57202\ni1    12.83875\ni1     5.39551\ni1   -95.18738\n\nWARNING: Seeding from current time 684387922\n\ni2   -13.81226\ni2   -16.49475\ni2    69.51904\ni2    35.04944\ni2    47.47925\ni2    63.25378\ni2   -59.61914\ni2    50.93079\ni2    -6.46362\ni2     5.89294\n</code></pre>"},{"location":"opcodes/randh/#see-also","title":"See also","text":"<p>Random (Noise) Generators, rand, randi</p>"},{"location":"opcodes/randi/","title":"Randi","text":""},{"location":"opcodes/randi/#randi","title":"randi","text":"<p>Generates a controlled random number series with interpolation between each new number.</p>"},{"location":"opcodes/randi/#syntax","title":"Syntax","text":"<pre><code>ares randi xamp, xcps [, iseed] [, isize] [, ioffset]\nkres randi kamp, kcps [, iseed] [, isize] [, ioffset]\n</code></pre>"},{"location":"opcodes/randi/#initialization","title":"Initialization","text":"<p>iseed (optional, default=0.5) -- seed value for the recursive pseudo-random formula. A value between 0 and +1 will produce an initial output of kamp * iseed. A negative value will cause seed re-initialization to be skipped. A value greater than 1 will seed from system time, this is the best option to generate a different random sequence for each run.</p> <p>isize (optional, default=0) -- if zero, a 16 bit number is generated. If non-zero, a 31-bit random number is generated. Default is 0.</p> <p>ioffset (optional, default=0) -- a base value added to the random result. New in Csound version 4.03.</p>"},{"location":"opcodes/randi/#performance","title":"Performance","text":"<p>kamp, xamp -- range over which random numbers are distributed.</p> <p>kcps, xcps -- the frequency which new random numbers are generated.</p> <p>The internal pseudo-random formula produces values which are uniformly distributed over the range kamp to -kamp. rand will thus generate uniform white noise with an R.M.S value of kamp / root 2.</p> <p>The remaining units produce band-limited noise: the kcps and xcps parameters permit the user to specify that new random numbers are to be generated at a rate less than the sampling or control frequencies. randi will produce straight-line interpolation between each new number and the next.</p>"},{"location":"opcodes/randi/#examples","title":"Examples","text":"<p>Here is an example of the randi opcode. It uses the file randi.csd.</p> Example of the randi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o randi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;same values every time\n\nkrnd randi 100, 10\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time\n\nkrnd randi 100, 10, 10                  ; seed from system clock\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ni 1 0 1\ni 2 2 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example will produce the following output:</p> <pre><code>i   1 time     0.00067:    50.00000\ni   1 time     0.50000:   -75.81672\ni   1 time     1.00000:    95.93833\n\nWARNING: Seeding from current time 1482746120\n\ni   2 time     2.00067:   -17.94434\ni   2 time     2.50000:   -14.11875\ni   2 time     3.00000:   -72.41545\n</code></pre>"},{"location":"opcodes/randi/#see-also","title":"See also","text":"<p>Random (Noise) Generators, randh, rand</p>"},{"location":"opcodes/random/","title":"Random","text":""},{"location":"opcodes/random/#random","title":"random","text":"<p>Generates a controlled pseudo-random number series between min and max values.</p>"},{"location":"opcodes/random/#syntax","title":"Syntax","text":"<pre><code>ares random kmin, kmax\nires random imin, imax\nkres random kmin, kmax\n</code></pre>"},{"location":"opcodes/random/#initialization","title":"Initialization","text":"<p>imin -- minimum range limit</p> <p>imax -- maximum range limit</p>"},{"location":"opcodes/random/#performance","title":"Performance","text":"<p>kmin -- minimum range limit</p> <p>kmax -- maximum range limit</p> <p>The random opcode is similar to linrand and trirand but sometimes I [Gabriel Maldonado] find it more convenient because allows the user to set arbitrary minimum and maximum values.</p>"},{"location":"opcodes/random/#examples","title":"Examples","text":"<p>Here is an example of the random opcode. It uses the file random.csd.</p> Example of the random opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o random.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;same values every time\n\nkrnd random 100, 1000\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time\n\nseed 0\nkrnd random 100, 1000                   ; seed from system clock\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ni 1 0 1\ni 2 2 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i   1 time     0.00067:   894.58566\ni   1 time     0.50000:   748.44281\ni   1 time     1.00000:   328.29916\n\nWARNING: Seeding from current time 1656666052\n\ni   2 time     2.00067:   690.71466\ni   2 time     2.50000:   459.42445\ni   2 time     3.00000:   100.85594\n</code></pre>"},{"location":"opcodes/random/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/random/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"opcodes/randomh/","title":"Randomh","text":""},{"location":"opcodes/randomh/#randomh","title":"randomh","text":"<p>Generates random numbers with a user-defined limit and holds them for a period of time.</p>"},{"location":"opcodes/randomh/#syntax","title":"Syntax","text":"<pre><code>ares randomh kmin, kmax, xcps [,imode] [,ifirstval]\nkres randomh kmin, kmax, kcps [,imode] [,ifirstval]\n</code></pre>"},{"location":"opcodes/randomh/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- generation mode of the first output value (see below)</p> <p>ifirstval (optional, default=0) -- first output value</p>"},{"location":"opcodes/randomh/#performance","title":"Performance","text":"<p>kmin -- minimum range limit</p> <p>kmax -- maximum range limit</p> <p>kcps, xcps -- rate of random break-point generation</p> <p>The randomh opcode is similar to randh but allows the user to set arbitrary minimum and maximum values.</p> <p>When imode = 0 (the default), the kmin argument value is outputted during 1/kcps (resp. 1/xcps) seconds at the beginning of the note. Then, the normal process takes place with a new random number generated and held every 1/kcps (resp. 1/xcps) seconds.</p> <p>When imode = 2, the ifirstval argument value is outputted during 1/kcps (resp. 1/xcps) seconds at the beginning of the note. Then, the normal process takes place with a new random number generated and held every 1/kcps (resp. 1/xcps) seconds.</p> <p>When imode = 3, the generation process begins with a random value from the initialization time.</p>"},{"location":"opcodes/randomh/#examples","title":"Examples","text":"<p>Here is an example of the randomh opcode. It uses the file randomh.csd.</p> Example of the randomh opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac    ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o randomh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder &amp; Menno Knevel, adapted for new args by Francois Pinot.\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\n\ninstr 1\n\nkmin    init 220; Choose a random frequency between 220 and 440 Hz.\nkmax    init 440\nkcps    init 10; Generate new random numbers at 10 Hz.\nimode   =    p4\nifstval =    p5\n\nprintf_i \"\\nMode: %d\\n\", 1, imode\nk1 randomh kmin, kmax, kcps, imode, ifstval\nprintk2 k1\nasig    poscil  1, k1\nouts    asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; each time with a different mode.\ni 1 0 1\ni 1 2 1 2 330\ni 1 4 1 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>Mode: 0\ni1   220.00000\ni1   396.26079\ni1   240.75446\ni1   364.24577\n...\n\nMode: 2\ni1   330.00000\ni1   416.50935\ni1   356.11619\ni1   433.59324\n...\n\nMode: 3\ni1   261.17741\ni1   402.00891\ni1   393.86592\ni1   307.19839\n...\n</code></pre> <p>Two musical examples featuring the randomh opcode: FtmorfRandomh_Cucchi.csd and Ftmorf_Cucchi.csd, both by Stefano Cucchi.</p>"},{"location":"opcodes/randomh/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/randomh/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>Arguments imode and ifirstval added by Fran\u00e7ois Pinot, Jan. 2011, after a discussion with Peiman Khosravi on the csnd list.</p>"},{"location":"opcodes/randomi/","title":"Randomi","text":""},{"location":"opcodes/randomi/#randomi","title":"randomi","text":"<p>Generates a user-controlled random number series with interpolation between each new number.</p>"},{"location":"opcodes/randomi/#syntax","title":"Syntax","text":"<pre><code>ares randomi kmin, kmax, xcps [,imode] [,ifirstval]\nkres randomi kmin, kmax, kcps [,imode] [,ifirstval]\n</code></pre>"},{"location":"opcodes/randomi/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- first interpolation cycle mode (see below)</p> <p>ifirstval (optional, default=0) -- first output value</p>"},{"location":"opcodes/randomi/#performance","title":"Performance","text":"<p>kmin -- minimum range limit</p> <p>kmax -- maximum range limit</p> <p>kcps, xcps -- rate of random break-point generation</p> <p>The randomi opcode is similar to randi but allows the user to set arbitrary minimum and maximum values.</p> <p>When imode = 0 (the default), the kmin argument value is outputted during 1/kcps (resp. 1/xcps) seconds at the beginning of the note, before the first random number is generated. Then the normal interpolation process takes place, first between kmin and the first random number generated, and then between successive generated random numbers, each interpolation cycle having a duration of 1/kcps (resp. 1/xcps) seconds.</p> <p>When imode = 1, a random number is generated at initialization and interpolation begins immediately between the kmin argument value and that random number.</p> <p>When imode = 2, a random number is generated at initialization and interpolation begins immediately between the ifirstval argument value and that random number.</p> <p>When imode = 3, two random numbers are generated at initialization as breakpoints for the first interpolation cycle.</p>"},{"location":"opcodes/randomi/#examples","title":"Examples","text":"<p>Here is an example of the randomi opcode. It uses the file randomi.csd.</p> Example of the randomi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o randomi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n     seed 0\n\n; Instrument #1.\ninstr 1\n  ; Choose a random frequency between 220 and 440.\n  ; Generate new random numbers at 10 Hz.\n  kmin    init 220\n  kmax    init 440\n  kcps    init 10\n  imode   =    p4\n  ifstval =    p5\n\n     printf_i \"\\nMode: %d\\n\", 1, imode\n  k1 randomi kmin, kmax, kcps, imode, ifstval\n     printks \"k1 = %f\\n\", 0.1, k1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\n; each time with a different mode.\ni 1 0 1\ni 1 1 1 1\ni 1 2 1 2 330\ni 1 3 1 3\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>Mode: 0\nk1 = 220.000000\nk1 = 220.000000\nk1 = 220.146093\nk1 = 246.827703\nk1 = 395.595775\n...\n\nMode: 1\nk1 = 220.000000\nk1 = 224.325329\nk1 = 274.370074\nk1 = 343.216049\nk1 = 414.324347\n...\n\nMode: 2\nk1 = 330.000000\nk1 = 292.628171\nk1 = 334.519777\nk1 = 290.610602\nk1 = 394.905366\n...\n\nMode: 3\nk1 = 360.727674\nk1 = 431.680412\nk1 = 380.625254\nk1 = 289.267139\nk1 = 303.038109\n...\n</code></pre>"},{"location":"opcodes/randomi/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/randomi/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>Arguments imode and ifirstval added by Fran\u00e7ois Pinot, Jan. 2011, after a discussion with Peiman Khosravi on the csnd list.</p> <p>Example written by Kevin Conder, adapted for new args by Fran\u00e7ois Pinot.</p>"},{"location":"opcodes/rbjeq/","title":"Rbjeq","text":""},{"location":"opcodes/rbjeq/#rbjeq","title":"rbjeq","text":"<p>Parametric equalizer and filter opcode with 7 filter types, based on algorithm by Robert Bristow-Johnson.</p>"},{"location":"opcodes/rbjeq/#syntax","title":"Syntax","text":"<pre><code>ar rbjeq asig, kfco, klvl, kQ, kS[, imode]\n</code></pre>"},{"location":"opcodes/rbjeq/#initialization","title":"Initialization","text":"<p>imode (optional, defaults to zero) - sum of:</p> <ul> <li>1: skip initialization (should be used in tied, or re-initialized notes only)</li> </ul> <p>and exactly one of the following values to select filter type:</p> <ul> <li>0: resonant lowpass filter. kQ controls the resonance: at the cutoff frequency (kfco), the amplitude gain is kQ (e.g. 20 dB for kQ = 10), and higher kQ values result in a narrower resonance peak. If kQ is set to sqrt(0.5) (about 0.7071), there is no resonance, and the filter has a response that is very similar to that of butterlp. If kQ is less than sqrt(0.5), there is no resonance, and the filter has a -6 dB / octave response from about kfco * kQ to kfco. Above kfco, there is always a -12 dB / octave cutoff.</li> </ul> <p> NOTE</p> <p>The rbjeq lowpass filter is basically the same as ar pareq asig, kfco, 0, kQ, 2 but is faster to calculate.</p> <ul> <li>2: resonant highpass filter. The parameters are the same as for the lowpass filter, but the equivalent filter is butterhp if kQ is 0.7071, and \"ar pareq asig, kfco, 0, kQ, 1\" in other cases.</li> <li>4: bandpass filter. kQ controls the bandwidth, which is kfco / kQ, and must be always less than sr / 2. The bandwidth is measured between -3 dB points (i.e. amplitude gain = 0.7071), beyond which there is a +/- 6 dB / octave slope. This filter type is very similar to ar butterbp asig, kfco, kfco / kQ.</li> <li>6: band-reject filter, with the same parameters as the bandpass filter, and a response similar to that of butterbr.</li> <li>8: peaking EQ. It has an amplitude gain of 1 (0 dB) at 0 Hz and sr / 2, and klvl at the center frequency (kfco). Thus, klvl controls the amount of boost (if it is greater than 1), or cut (if it is less than 1). Setting klvl to 1 results in a flat response. Similarly to the bandpass and band-reject filters, the bandwidth is determined by kfco / kQ (which must be less than sr / 2 again); however, this time it is between sqrt(klvl) points (or, in other words, half the boost or cut in decibels). NOTE: excessively low or high values of klvl should be avoided (especially with 32-bit floats), though the opcode was tested with klvl = 0.01 and klvl = 100. klvl = 0 is always an error, unlike in the case of pareq, which does allow a zero level.</li> <li>10: low shelf EQ, controlled by klvl and kS (kQ is ignored by this filter type). There is an amplitude gain of klvl at zero frequency, while the level of high frequencies (around sr / 2) is not changed. At the corner frequency (kfco), the gain is sqrt(klvl) (half the boost or cut in decibels). The kS parameter controls the steepness of the slope of the frequency response (see below).</li> <li>12: high shelf EQ. Very similar to the low shelf EQ, but affects the high frequency range.</li> </ul> <p>The default value for imode is zero (lowpass filter, initialization not skipped).</p>"},{"location":"opcodes/rbjeq/#performance","title":"Performance","text":"<p>ar -- the output signal.</p> <p>asig -- the input signal</p> <p> NOTE</p> <p>If the input contains silent sections, on Intel CPUs a significant slowdown can occur due to denormals. In such cases, it is recommended to process the input signal with \"denorm\" opcode before filtering it with rbjeq (and actually many other filters).</p> <p>kfco -- cutoff, corner, or center frequency, depending on filter type, in Hz. It must be greater than zero, and less than sr / 2 (the range of about sr * 0.0002 to sr * 0.49 should be safe).</p> <p>klvl -- level (amount of boost or cut), as amplitude gain (e.g. 1: flat response, 4: 12 dB boost, 0.1: 20 dB cut); zero or negative values are not allowed. It is recognized by the peaking and shelving EQ types (8, 10, 12) only, and is ignored by other filters.</p> <p>kQ -- resonance (also kfco / bandwidth in many filter types). Not used by the shelving EQs (imode = 10 and 12). The exact meaning of this parameter depends on the filter type (see above), but it should be always greater than zero, and usually (kfco / kQ) less than sr / 2.</p> <p>kS -- shelf slope parameter for shelving filters. Must be greater than zero; a higher value means a steeper slope, with resonance if kS &gt; 1 (however, a too high kS value may make the filter unstable). If kS is set to exactly 1, the shelf slope is as steep as possible without a resonance. Note that the effect of kS - especially if it is greater than 1 - also depends on klvl, and it does not have any well defined unit.</p>"},{"location":"opcodes/rbjeq/#examples","title":"Examples","text":"<p>Here is an example of the rbjeq opcode. It uses the file rbjeq.csd.</p> An example of the rbjeq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rbjeq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nimode = p4\na1    vco2    .3, 155.6                 ; sawtooth wave\nkfco  expon   8000, p3, 200             ; filter frequency\nasig  rbjeq   a1, kfco, 1, kfco * 0.005, 1, imode\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0  5 0      ;lowpass\ni 1 6  5 2      ;highpass\ni 1 12 5 4      ;bandpass\ni 1 18 5 8      ;equalizer\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rbjeq/#see-also","title":"See also","text":"<p>Specialized Filters: Parametric EQ</p>"},{"location":"opcodes/rbjeq/#credits","title":"Credits","text":"<p>Original algorithm by Robert Bristow-Johnson Csound orchestra version by Josep M Comajuncosas, Aug 1999 Converted to C (with optimizations and bug fixes) by Istvan Varga, Dec 2002</p>"},{"location":"opcodes/readclock/","title":"Readclock","text":""},{"location":"opcodes/readclock/#readclock","title":"readclock","text":"<p>Reads the value of an internal clock.</p>"},{"location":"opcodes/readclock/#syntax","title":"Syntax","text":"<pre><code>ir readclock inum\n</code></pre>"},{"location":"opcodes/readclock/#initialization","title":"Initialization","text":"<p>inum -- the number of a clock.  There are 32 clocks numbered 0 through 31. All other values are mapped to clock number 32.</p> <p>ir -- value at i-time, of the clock specified by inum</p>"},{"location":"opcodes/readclock/#performance","title":"Performance","text":"<p>Between a clockon and a clockoff opcode, the CPU time used is accumulated in the clock. The precision is machine dependent but is the millisecond range on UNIX and Windows systems. The readclock opcde reads the current value of a clock at initialization time.</p>"},{"location":"opcodes/readclock/#examples","title":"Examples","text":"<p>Here is an example of the readclock opcode. It uses the file readclock.csd.</p> Example of the readclock opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o readclock.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Start clock #1.\n  clockon 1\n  ; Do something that keeps Csound busy.\n  a1 oscili 10000, 440, 1\n  out a1\n  ; Stop clock #1.\n  clockoff 1\n  ; Print the time accumulated in clock #1.\n  i1 readclock 1\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Initialize the function tables.\n; Table 1: an ordinary sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for one second starting at 0:00.\ni 1 0 1\n; Play Instrument #1 for one second starting at 0:01.\ni 1 1 1\n; Play Instrument #1 for one second starting at 0:02.\ni 1 2 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = 0.000\ninstr 1:  i1 = 90.000\ninstr 1:  i1 = 180.000\n</code></pre>"},{"location":"opcodes/readclock/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/readclock/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK July, 1999</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/readf/","title":"Readf","text":""},{"location":"opcodes/readf/#readf","title":"readf","text":"<p>Read a line of text from an external file once each k-cycle.</p> <p>Plugin opcode in cs_date.</p>"},{"location":"opcodes/readf/#syntax","title":"Syntax","text":"<pre><code>Sres, kline readf ifilname\n</code></pre>"},{"location":"opcodes/readf/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"input.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p>"},{"location":"opcodes/readf/#performance","title":"Performance","text":"<p>Sres -- output of the line read from ifilname.</p> <p>kline -- line number, or -1 when end of file has been reached.</p> <p>This opcode allows a line of text to be read from a named external file.  There may be any number of readf opcodes in an instrument or orchestra but they read separately from the same or different files.</p>"},{"location":"opcodes/readf/#examples","title":"Examples","text":"<p>Here is an example of the readf opcode. It uses the file readf.csd.</p> Example of the readf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\ninstr 1\n  Swd           pwd\n                printf_i      \"Working directory is '%s'\\n\", 1, Swd\n                prints        \"Reading myself =):\\n\"\nread:\n  Sline, kLinNum readf \"readf.csd\"\n                printf \"Line %d: %s\", kLinNum, kLinNum, Sline\n  if kLinNum != -1 then\n                kgoto read\n  else \n                turnoff\n  endif\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 1\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/readf/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readf/#credits","title":"Credits","text":"<p>John ffitch and Joachim Heintz</p> <p>2012; new in 5.17.12</p>"},{"location":"opcodes/readfi/","title":"Readfi","text":""},{"location":"opcodes/readfi/#readfi","title":"readfi","text":"<p>Read a line of text from an external file once on initialisation.</p> <p>Plugin opcode in cs_date.</p>"},{"location":"opcodes/readfi/#syntax","title":"Syntax","text":"<pre><code>Sres, iline readfi ifilname\n</code></pre>"},{"location":"opcodes/readfi/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"input.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p> <p>iline -- line number, or -1 when end of file has been reached.</p> <p>Sres -- output of the line read from ifilname.</p> <p>This opcode allows a line of text to be read from a named external file.  There may be any number of readfi opcodes in an instrument or orchestra but they read separately from the same or different files.</p>"},{"location":"opcodes/readfi/#examples","title":"Examples","text":"<p>Here is an example of the readfi opcode. It uses the file readfi.csd.</p> Example of the readfi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\ninstr 1\n    Swd pwd\n        printf_i \"Working directory is '%s'\\n\", 1, Swd\n        prints \"Reading myself =):\\n\"\nread:\nSline, iLineNum readfi \"readfi.csd\"\n        printf_i  \"Line %d: %s\", iLineNum, iLineNum, Sline\n        if iLineNum != -1 igoto read\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 0.1\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/readfi/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readfi/#credits","title":"Credits","text":"<p>John ffitch and Joachim Heintz</p> <p>2012; new in 5.17.12</p>"},{"location":"opcodes/readk/","title":"Readk","text":""},{"location":"opcodes/readk/#readk","title":"readk","text":"<p>Periodically reads an orchestra control-signal value from a named external file in a specific format.</p>"},{"location":"opcodes/readk/#syntax","title":"Syntax","text":"<pre><code>kres readk ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/readk/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"readk.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p> <p>iformat -- specifies the input data format:</p> <ul> <li>1 = 8-bit signed integers (char)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers (plain text)</li> <li>8 = ASCII floats (plain text)</li> </ul> <p>Note that A-law and U-law formats are not available, and that all formats except the last two are binary. The input file should be a \"raw\", headerless data file.</p> <p>iprd -- the rate (period) in seconds, rounded to the nearest orchestra control period, at which the signal is read from the input file.  A value of 0 implies one control period (the enforced minimum), which will read new values at the orchestra control rate.  Longer periods will cause the same values to repeat for more than one control period.</p>"},{"location":"opcodes/readk/#performance","title":"Performance","text":"<p>kres -- output of the signal read from ifilname.</p> <p>This opcode allows a generated control signal value to be read from a named external file. The file should contain no header information but it should contain a regularly sampled time series of control values. For ASCII text formats, the values are assumed to be separated by at least one whitespace character. There may be any number of readk opcodes in an instrument or orchestra and they may read from the same or different files.</p>"},{"location":"opcodes/readk/#examples","title":"Examples","text":"<p>Here is an example of the readk opcode. It uses the file readk.csd.</p> Example of the readk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o readk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n0dbfs = 1\n; By Andres Cabrera 2008\n\ninstr 1\n; Read a number from the file every 0.5 seconds\n  kfibo readk \"fibonacci.txt\", 7, 0.5\n  kpitchclass = 8 +  ((kfibo % 12)/100)\n  printk2 kpitchclass\n  kcps = cpspch( kpitchclass )\n  printk2 kcps\n  a1 oscil 0.5, kcps, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 10 1\ni 1 0 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the readk opcode. It uses the file readk-2.csd.</p> Example 2 of the readk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o readk-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes a control signal to a file\nkfreq randh  100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\n      dumpk  kfreq, \"dumpk.txt\", 8, 1 ;writes the control signal\n      printk 1, kfreq                            ;prints it\nendin\n\ninstr 2 ;reads the file written by instr 1\nkfreq readk  \"dumpk.txt\", 8, 1\n      printk 1, kfreq ;prints it\naout  poscil .2, kfreq, giSine\n      outs   aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>WARNING: Seeding from current time 683384022\n\ni   1 time     1.00033:   463.64510\ni   1 time     2.00000:   463.64510\ni   1 time     3.00000:   483.14200\ni   1 time     4.00000:   567.55973\ni   1 time     5.00000:   576.37060\ni   1 time     6.00000:   460.66550\n\ni   2 time     6.00033:   463.64510\ni   2 time     7.00000:   463.64510\ni   2 time     8.00000:   483.14200\ni   2 time     9.00000:   567.55970\ni   2 time    10.00000:   576.37060\ni   2 time    11.00000:   460.66550\n</code></pre>"},{"location":"opcodes/readk/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readk/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/readk2/","title":"Readk2","text":""},{"location":"opcodes/readk2/#readk2","title":"readk2","text":"<p>Periodically reads two orchestra control-signal values from an external file.</p>"},{"location":"opcodes/readk2/#syntax","title":"Syntax","text":"<pre><code>kr1, kr2 readk2 ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/readk2/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"readk.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p> <p>iformat -- specifies the input data format:</p> <ul> <li>1 = 8-bit signed integers (char)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers (plain text)</li> <li>8 = ASCII floats (plain text)</li> </ul> <p>Note that A-law and U-law formats are not available, and that all formats except the last two are binary. The input file should be a \"raw\", headerless data file.</p> <p>iprd -- the rate (period) in seconds, rounded to the nearest orchestra control period, at which the signals are read from the input file.  A value of 0 implies one control period (the enforced minimum), which will read new values at the orchestra control rate.  Longer periods will cause the same values to repeat for more than one control period.</p>"},{"location":"opcodes/readk2/#performance","title":"Performance","text":"<p>kr1, kr2 -- output of the signals read from ifilname.</p> <p>This opcode allows two generated control signal values to be read from a named external file. The file should contain no header information but it should contain a regularly sampled time series of control values. For binary formats, the individual samples of each signal are interleaved. For ASCII text formats, the values are assumed to be separated by at least one whitespace character.  The two \"channels\" in a sample frame may be on the same line or separated by newline characters, it does not matter. There may be any number of readk2 opcodes in an instrument or orchestra and they may read from the same or different files.</p>"},{"location":"opcodes/readk2/#examples","title":"Examples","text":"<p>Here is an example of the readk2 opcode. It uses the file readk2.csd.</p> Example of the readk2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o readk2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes two control signals to a file\nkfreq     randh     100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\nkdb       randh     12, 1, 2, 1, -12 ;amplitudes in dB between -24 and 0\n          dumpk2    kfreq, kdb, \"dumpk2.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kfreq = %f, kdb = %f\\n\", 1, kfreq, kdb  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkf,kdb    readk2    \"dumpk2.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kfreq = %f, kdb = %f\\n\", 1, kf, kdb  ;prints again\nkdb       lineto    kdb, .1 ;smoothing amp transition\naout      poscil    ampdb(kdb), kf, giSine\n          outs      aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>kfreq = 429.202551, kdb = -20.495694\nkfreq = 429.202551, kdb = -20.495694\nkfreq = 407.275258, kdb = -23.123776\nkfreq = 475.264472, kdb = -9.300846\nkfreq = 569.979181, kdb = -7.315527\nkfreq = 440.103457, kdb = -0.058331\n\nkfreq = 429.202600, kdb = -20.495700\nkfreq = 429.202600, kdb = -20.495700\nkfreq = 407.275300, kdb = -23.123800\nkfreq = 475.264500, kdb = -9.300800\nkfreq = 569.979200, kdb = -7.315500\nkfreq = 440.103500, kdb = -0.058300\n</code></pre>"},{"location":"opcodes/readk2/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readk2/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/readk3/","title":"Readk3","text":""},{"location":"opcodes/readk3/#readk3","title":"readk3","text":"<p>Periodically reads three orchestra control-signal values from an external file.</p>"},{"location":"opcodes/readk3/#syntax","title":"Syntax","text":"<pre><code>kr1, kr2, kr3 readk3 ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/readk3/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"readk.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p> <p>iformat -- specifies the input data format:</p> <ul> <li>1 = 8-bit signed integers (char)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers (plain text)</li> <li>8 = ASCII floats (plain text)</li> </ul> <p>Note that A-law and U-law formats are not available, and that all formats except the last two are binary. The input file should be a \"raw\", headerless data file.</p> <p>iprd -- the rate (period) in seconds, rounded to the nearest orchestra control period, at which the signals are read from the input file.  A value of 0 implies one control period (the enforced minimum), which will read new values at the orchestra control rate.  Longer periods will cause the same values to repeat for more than one control period.</p>"},{"location":"opcodes/readk3/#performance","title":"Performance","text":"<p>kr1, kr2, kr3 -- output of the signals read from ifilname.</p> <p>This opcode allows three generated control signal values to be read from a named external file. The file should contain no header information but it should contain a regularly sampled time series of control values. For binary formats, the individual samples of each signal are interleaved. For ASCII text formats, the values are assumed to be separated by at least one whitespace character.  The three \"channels\" in a sample frame may be on the same line or separated by newline characters, it does not matter. There may be any number of readk3 opcodes in an instrument or orchestra and they may read from the same or different files.</p>"},{"location":"opcodes/readk3/#examples","title":"Examples","text":"<p>Here is an example of the readk3 opcode. It uses the file readk3.csd.</p> Example of the readk3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o readk3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes three control signals to a file\nkfreq     randh     100, 1, 2, 1, 500 ;generates one random number between 400 and 600 per second\nkdb       randh     12, 1, 2, 1, -12 ;amplitudes in dB between -24 and 0\nkpan      randh     .5, 1, 2, 1, .5 ;panning between 0 and 1\n          dumpk3    kfreq, kdb, kpan, \"dumpk3.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kfreq = %f, kdb = %f, kpan = %f\\n\", 1, kfreq, kdb, kpan  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkf,kdb,kp readk3    \"dumpk3.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kfreq = %f, kdb = %f, kpan = %f\\n\", 1, kf, kdb, kp  ;prints again\nkdb       lineto    kdb, .1 ;smoothing amp transition\nkp        lineto    kp, .1 ;smoothing pan transition\naout      poscil    ampdb(kdb), kf, giSine\naL, aR    pan2      aout, kp\n          outs      aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>WRITING:\nkfreq = 473.352855, kdb = -15.197657, kpan = 0.366764\nkfreq = 473.352855, kdb = -15.197657, kpan = 0.366764\nkfreq = 441.426368, kdb = -19.026206, kpan = 0.207327\nkfreq = 452.965140, kdb = -21.447486, kpan = 0.553270\nkfreq = 585.106328, kdb = -11.903852, kpan = 0.815665\nkfreq = 482.056760, kdb = -4.046744, kpan = 0.876537\n\nREADING:\nkfreq = 473.352900, kdb = -15.197700, kpan = 0.366800\nkfreq = 473.352900, kdb = -15.197700, kpan = 0.366800\nkfreq = 441.426400, kdb = -19.026200, kpan = 0.207300\nkfreq = 452.965100, kdb = -21.447500, kpan = 0.553300\nkfreq = 585.106300, kdb = -11.903900, kpan = 0.815700\nkfreq = 482.056800, kdb = -4.046700, kpan = 0.876500\n</code></pre>"},{"location":"opcodes/readk3/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readk3/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/readk4/","title":"Readk4","text":""},{"location":"opcodes/readk4/#readk4","title":"readk4","text":"<p>Periodically reads four orchestra control-signal values from an external file.</p>"},{"location":"opcodes/readk4/#syntax","title":"Syntax","text":"<pre><code>kr1, kr2, kr3, kr4 readk4 ifilname, iformat, iprd\n</code></pre>"},{"location":"opcodes/readk4/#initialization","title":"Initialization","text":"<p>ifilname -- an integer N denoting a file named \"readk.N\" or a character string (in double quotes, spaces permitted) denoting the external file name. For a string, it may either be a full path name with directory specified or a simple filename.  In the later case, the file is sought first in the current directory, then in SSDIR, and finally in SFDIR.</p> <p>iformat -- specifies the input data format:</p> <ul> <li>1 = 8-bit signed integers (char)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = ASCII long integers (plain text)</li> <li>8 = ASCII floats (plain text)</li> </ul> <p>Note that A-law and U-law formats are not available, and that all formats except the last two are binary. The input file should be a \"raw\", headerless data file.</p> <p>iprd -- the rate (period) in seconds, rounded to the nearest orchestra control period, at which the signals are read from the input file.  A value of 0 implies one control period (the enforced minimum), which will read new values at the orchestra control rate. Longer periods will cause the same values to repeat for more than one control period.</p>"},{"location":"opcodes/readk4/#performance","title":"Performance","text":"<p>kr1, kr2, kr3, kr4 -- output of the signals read from ifilname.</p> <p>This opcode allows four generated control signal values to be read from a named external file. The file should contain no header information but it should contain a regularly sampled time series of control values. For binary formats, the individual samples of each signal are interleaved. For ASCII text formats, the values are assumed to be separated by at least one whitespace character.  The four \"channels\" in a sample frame may be on the same line or separated by newline characters, it does not matter. There may be any number of readk4 opcodes in an instrument or orchestra and they may read from the same or different files.</p>"},{"location":"opcodes/readk4/#examples","title":"Examples","text":"<p>Here is an example of the readk4 opcode. It uses the file readk4.csd.</p> Example of the readk4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o readk4.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1 ;writes four control signals to a file\nkcf       randh     950, 1, 2, 1, 1050 ;generates one random number between 100 and 2000 per second\nkq        randh     10, 1, 2, 1, 11 ;generates another random number between 1 and 21 per second\nkdb       randh     9, 1, 2, 1, -15 ;amplitudes in dB between -24 and -6\nkpan      randh     .5, 1, 2, 1, .5 ;panning between 0 and 1\n          dumpk4    kcf, kq, kdb, kpan, \"dumpk4.txt\", 8, 1 ;writes the control signals\n          prints    \"WRITING:\\n\"\n          printks   \"kcf = %f, kq = %f, kdb = %f, kpan = %f\\n\", 1, kcf, kq, kdb, kpan  ;prints them\nendin\n\ninstr 2 ;reads the file written by instr 1\nkcf,kq,kdb,kp readk4 \"dumpk4.txt\", 8, 1\n          prints    \"READING:\\n\"\n          printks   \"kcf = %f, kq = %f, kdb = %f, kpan = %f\\n\", 1, kcf, kq, kdb, kp  ;prints values\nkdb       lineto    kdb, .1 ;smoothing amp transition\nkp        lineto    kp, .1 ;smoothing pan transition\nanoise    rand      ampdb(kdb), 2, 1\nkbw       =         kcf/kq ;bandwidth of resonant filter\nabp       reson     anoise, kcf, kbw\naout      balance   abp, anoise\naL, aR    pan2      aout, kp\n          outs      aL, aR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The output should include lines like these:</p> <pre><code>WRITING:\nkcf = 1122.469723, kq = 11.762839, kdb = -14.313445, kpan = 0.538142\nkcf = 1122.469723, kq = 11.762839, kdb = -14.313445, kpan = 0.538142\nkcf = 1148.638412, kq = 12.040490, kdb = -14.061868, kpan = 0.552205\nkcf = 165.796855, kq = 18.523179, kdb = -15.816977, kpan = 0.901528\nkcf = 147.729960, kq = 13.071911, kdb = -11.924531, kpan = 0.982518\nkcf = 497.430113, kq = 13.605512, kdb = -21.586611, kpan = 0.179229\n\nREADING:\nWARNING: Seeding from current time 3308160476\n\nkcf = 1122.469700, kq = 11.762800, kdb = -14.313400, kpan = 0.538100\nkcf = 1122.469700, kq = 11.762800, kdb = -14.313400, kpan = 0.538100\nkcf = 1148.638400, kq = 12.040500, kdb = -14.061900, kpan = 0.552200\nkcf = 165.796900, kq = 18.523200, kdb = -15.817000, kpan = 0.901500\nkcf = 147.730000, kq = 13.071900, kdb = -11.924500, kpan = 0.982500\nkcf = 497.430100, kq = 13.605500, kdb = -21.586600, kpan = 0.179200\n</code></pre>"},{"location":"opcodes/readk4/#see-also","title":"See also","text":"<p>File Input and Output</p>"},{"location":"opcodes/readk4/#credits","title":"Credits","text":"<p>By: John ffitch and Barry L. Vercoe</p> <p>1999 or earlier</p>"},{"location":"opcodes/readscore/","title":"Readscore","text":""},{"location":"opcodes/readscore/#readscore","title":"readscore","text":"<p>Read, preprocess and schedule a score from an input string.</p> <p>Readscore will issue one or more score events. It can handle strings in the same conditions as the standard score, including preprocessing (carry, sort, ramp, etc). Multi-line strings are accepted, using {{  }} to enclose the string.</p>"},{"location":"opcodes/readscore/#syntax","title":"Syntax","text":"<pre><code>readscore Sin\n</code></pre>"},{"location":"opcodes/readscore/#initialization","title":"Initialization","text":"<p>\u201cSin\u201d --  a string (in double-quotes or enclosed by {{ }}) containing one or more score events.</p>"},{"location":"opcodes/readscore/#examples","title":"Examples","text":"<p>Here is an example of the readscore opcode. It uses the file readscore.csd.</p> Example of the readscore opcode.<pre><code>&lt;CsoundSynthesizer&gt;  \n&lt;CsOptions&gt;\n-d -o dac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;   \n\ninstr 1\na1 flooper2 1000,p4,2,5,0.1,1 \n   out a1\nendin\n\ninstr 2\nires readscore {{\n{12  COUNT \ni1 $COUNT 1 [1 + $COUNT/12]\n}\n}}\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf0 12\nf 1 0 0 1 \"fox.wav\" 0 0 1\n\ni2 0 1\n\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>You can use string opcodes like sprintfk to produce strings to be passed to readscore like this:</p> <pre><code>Sfil    = \"/Volumes/Bla/file.aif\"\nString  sprintfk {{i 2 0 %f \"%s\" %f %f %f %f}}, idur, Sfil, p5, p6, knorm, iskip\n        readscore String\n</code></pre>"},{"location":"opcodes/readscore/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/readscore/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2013</p>"},{"location":"opcodes/reinit/","title":"Reinit","text":""},{"location":"opcodes/reinit/#reinit","title":"reinit","text":"<p>Suspends a performance while a special initialization pass is executed.</p> <p>Whenever this statement is encountered during a p-time pass, performance is temporarily suspended while a special Initialization pass, beginning at label and continuing to rireturn or endin, is executed. Performance will then be resumed from where it left off.</p>"},{"location":"opcodes/reinit/#syntax","title":"Syntax","text":"<pre><code>reinit label\n</code></pre>"},{"location":"opcodes/reinit/#examples","title":"Examples","text":"<p>The following statements will generate an exponential control signal whose value moves from 440 to 880 exactly ten times over the duration p3. They use the file reinit.csd.</p> Example of the reinit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o reinit.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nreset:\n        timout 0, p3/p4, contin         \n        reinit reset\n\ncontin:\n        kLine expon 440, p3/p4, 880\n        aSig poscil 1, kLine\n        outs aSig, aSig\n        rireturn\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10 10\ni1 + 10 50      \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the reinit opcode: Reinit_Giordani.csd by Eugenio Giordani.</p>"},{"location":"opcodes/reinit/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p>"},{"location":"opcodes/release/","title":"Release","text":""},{"location":"opcodes/release/#release","title":"release","text":"<p>Indicates whether a note is in its release stage.</p> <p>Provides a way of knowing when a note off message for the current note is received. Only a noteoff message with the same MIDI note number as the one which triggered the note will be reported by release.</p>"},{"location":"opcodes/release/#syntax","title":"Syntax","text":"<pre><code>kflag release\n</code></pre>"},{"location":"opcodes/release/#performance","title":"Performance","text":"<p>kflag -- indicates whether the note is in its release stage. (1 if a note off is received, otherwise 0)</p> <p>release outputs current note state. If current note is in the release stage (i.e. if its duration has been extended with xtratim opcode and if it has only just deactivated), then the kflag output argument is set to 1. Otherwise (in sustain stage of current note), kflag is set to 0.</p> <p>This opcode is useful for implementing complex release-oriented envelopes. When used in conjunction with xtratim it can provide an alternative to the hard-coded behaviour of the \"r\" opcodes (linsegr, expsegr et al), where release time is set to the longest time specified in the active instrument.</p>"},{"location":"opcodes/release/#examples","title":"Examples","text":"<p>See the examples for xtratim.</p>"},{"location":"opcodes/release/#see-also","title":"See also","text":"<p>Event Extenders</p>"},{"location":"opcodes/release/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/remove/","title":"Remove","text":""},{"location":"opcodes/remove/#remove","title":"remove","text":"<p>Removes the definition of an instrument as long as it is not in use.</p>"},{"location":"opcodes/remove/#syntax","title":"Syntax","text":"<pre><code>remove insnum\n</code></pre>"},{"location":"opcodes/remove/#initialization","title":"Initialization","text":"<p>insnum -- number or name of the instrument to be deleted</p>"},{"location":"opcodes/remove/#performance","title":"Performance","text":"<p>As long as the indicated instrument is not active, remove deletes the instrument and memory associated with it.  It should be treated with care as it is possible that in some cases its use may lead to a crash.</p>"},{"location":"opcodes/remove/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/remove/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK June, 2006</p> <p>New in Csound version 5.04</p>"},{"location":"opcodes/repluck/","title":"Repluck","text":""},{"location":"opcodes/repluck/#repluck","title":"repluck","text":"<p>Physical model of the plucked string.</p> <p>A user can control the pluck point, the pickup point, the filter, and an additional audio signal, axcite. axcite is used to excite the 'string'. Based on the Karplus-Strong algorithm.</p>"},{"location":"opcodes/repluck/#syntax","title":"Syntax","text":"<pre><code>ares repluck iplk, kamp, icps, kpick, krefl, axcite\n</code></pre>"},{"location":"opcodes/repluck/#initialization","title":"Initialization","text":"<p>iplk -- The point of pluck is iplk, which is a fraction of the way up the string (0 to 1). A pluck point of zero means no initial pluck.</p> <p>icps  -- The string plays at icps pitch.</p>"},{"location":"opcodes/repluck/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kpick -- Proportion of the way along the string to sample the output.</p> <p>krefl -- the coefficient of reflection, indicating the lossiness and the rate of decay. It must be strictly between 0 and 1 (it will complain about both 0 and 1).</p>"},{"location":"opcodes/repluck/#performance_1","title":"Performance","text":"<p>axcite -- A signal which excites the string.</p>"},{"location":"opcodes/repluck/#examples","title":"Examples","text":"<p>Here is an example of the repluck opcode. It uses the file repluck.csd.</p> Example of the repluck opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o repluck.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\niplk  = 0.75\nkamp  = .8\nicps  = 110\nkrefl = p4\nkpick = p5\n\n\naxcite oscil 1, 1, 1\nasig repluck iplk, kamp, icps, kpick, krefl, axcite\nasig dcblock2 asig              ;get rid of DC offset\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ns\ni 1 0 1 0.95 0.75       ;sounds heavier (=p5)\ni 1 + 1  &lt;\ni 1 + 1  &lt;\ni 1 + 1  &lt;\ni 1 + 10 0.6\n\ns\ni 1 0 1 0.95 0.15       ;sounds softer (=p5)\ni 1 + 1  &lt;\ni 1 + 1  &lt;\ni 1 + 1  &lt;\ni 1 + 10 0.6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the repluck opcode. It uses the file repluck-advanced.csd.</p> Advanced example of the repluck opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o repluck_advanced.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2020\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1  \nnchnls = 2\n\ninstr 1\n\n\niplk  = p4\nkamp  = p5\nicps  = p6\n\nkrefll randomi 0.52, 0.99, 0.61\nkpickl randomi 0.1, 0.9, 13\n\nkreflr = p7\nkpickr = p8\n\nain1 diskin \"fox.wav\", 1, 0\n\nasigl repluck iplk, kamp, icps, kpickl, krefll, ain1\nasigl dcblock2 asigl    \n\nasigr repluck iplk, kamp, icps, kpickr, kreflr, ain1\nasigr dcblock2 asigr\n\nkdeclick linseg 0, 0.05, 1, p3-0.1, 1, 0.05, 0\n\noutch 1, asigl * kdeclick\noutch 2, asigr * kdeclick\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\ni 1 0 4 0.11 0.5 69 0.9 0.11\ni 1 3 4 0.11 0.5 12 0.9 0.11\ni 1 6 4 0.41 0.5 1 0.2 0.11\ni 1 9 4 0.11 0.5 300 0.9 0.99\ni 1 12 4 0.11 0.5 182 0.9 0.99\ni 1 15 15 0.99 0.5 12.039 0.9 0.11\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/repluck/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/repluck/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/reshapearray/","title":"Reshapearray","text":""},{"location":"opcodes/reshapearray/#reshapearray","title":"reshapearray","text":"<p>Reshape an array, maintaining its capacity</p> <p>Plugin opcode in emugens.</p> <p>The reshapearray opcode changes the shape of an array, as long as this does not modify its capacity. It can be used to convert a 1D to a 2D array, or viceversa, or simply to modify the size of its dimensions, as long as the product remains constant.</p>"},{"location":"opcodes/reshapearray/#syntax","title":"Syntax","text":"<pre><code>reshapearray array[], isize0 [, isize1 ]\n</code></pre>"},{"location":"opcodes/reshapearray/#initialization","title":"Initialization","text":"<p>array[] - The array to be reshaped (this is done inplace)</p> <p>isize0 - The size of the first dimension</p> <p>isize1 - The size of the second dimension (0 for 1D arrays). Defaults to 0</p>"},{"location":"opcodes/reshapearray/#examples","title":"Examples","text":"<p>Here is an example of the reshapearray opcode. It uses the file reshapearray.csd.</p> Example of the reshapearray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n;-odac     ;;;realtime audio out\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 64\nnchnls = 2\n0dbfs  = 1\n\n; This is the example file for reshapearray\n\n/*\n\nreshapearray \n\n  Reshape an array, maintaining the capacity of the array\n  (it does NOT resize the array).\n\n  You can reshape a 2D array to another array of equal capacity\n  of reshape a 1D array to a 2D array, or a 2D array to a 1D\n  array\n\n  reshapearray array[], inumrows, inumcols=0\n\n  works with i and k arrays, at i-time and k-time\n\n*/\n\n\ninstr 1\n  ivalues[] fillarray 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\n  printarray ivalues\n  reshapearray ivalues, 3, 4\n  printarray ivalues\n  turnoff\nendin\n\ninstr 2\n  kxs[][] init 3, 4\n  kxs fillarray   0,  1,  2,  3, \\\n                 10, 11, 12, 13, \\\n                 20, 21, 22, 23\n  reshapearray kxs, 4, 3\n  printarray kxs, 1, \"\", \"kxs after\"\n  turnoff\nendin\n\ninstr 3\n  kxs[][] init 3, 4\n  kxs fillarray   0,  1,  2,  3, \\\n                 10, 11, 12, 13, \\\n                 20, 21, 22, 23\n  reshapearray kxs, 12\n  printarray kxs, 1, \"\", \"kxs after\"\n  turnoff\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni 1 0 0.01\ni 2 1 0.01\ni 3 2 0.01\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/reshapearray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/reshapearray/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/reson/","title":"Reson","text":""},{"location":"opcodes/reson/#reson","title":"reson","text":"<p>A second-order resonant filter.</p>"},{"location":"opcodes/reson/#syntax","title":"Syntax","text":"<pre><code>ares reson asig, xcf, xbw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/reson/#initialization","title":"Initialization","text":"<p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/reson/#performance","title":"Performance","text":"<p>ares -- the output signal at audio rate.</p> <p>asig -- the input signal at audio rate.</p> <p>xcf -- the center frequency of the filter, or frequency position of the peak response.</p> <p>xbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points).</p> <p>reson is a second-order filter in which kcf controls the center frequency, or frequency position of the peak response, and kbw controls its bandwidth (the frequency difference between the upper and lower half-power points).</p>"},{"location":"opcodes/reson/#examples","title":"Examples","text":"<p>Here is an example of the reson opcode. It uses the file reson.csd.</p> Example of the reson opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o reson.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nasaw vco2 .2, 220       ;sawtooth\nkcf  line 220, p3, 1760 ;vary cut-off frequency from 220 to 1280 Hz\nkbw  = p4               ;vary bandwidth of filter too           \nares reson asaw, kcf, kbw\nasig balance ares, asaw\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 10      ;bandwidth of filter = 10 Hz\ni 1 + 4 50      ;50 Hz and\ni 1 + 4 200     ;200 Hz\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the reson opcode: ResonPluck_Cucchi.csd by Stefano Cucchi.</p>"},{"location":"opcodes/reson/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/reson/#credits","title":"Credits","text":"<p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/resonk/","title":"Resonk","text":""},{"location":"opcodes/resonk/#resonk","title":"resonk","text":"<p>A second-order resonant filter.</p>"},{"location":"opcodes/resonk/#syntax","title":"Syntax","text":"<pre><code>kres resonk ksig, kcf, kbw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/resonk/#initialization","title":"Initialization","text":"<p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/resonk/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>kcf -- the center frequency of the filter, or frequency position of the peak response.</p> <p>kbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points).</p> <p>resonk is like reson except its output is at control-rate rather than audio rate.</p>"},{"location":"opcodes/resonk/#examples","title":"Examples","text":"<p>Here is an example of the resonk opcode. It uses the file resonk.csd.</p> Example of the resonk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o resonk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nksig    randomh 400, 1800, 150\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\ninstr 2\n\nksig    randomh 400, 1800, 150\nkhp     line    1, p3, 400      ;vary high-pass\nksig    resonk  ksig, khp, 50\naout    poscil  .2, 1000+ksig, gisin\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 5\ni 2 5.5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resonk/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/resonk/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/resonr/","title":"Resonr","text":""},{"location":"opcodes/resonr/#resonr","title":"resonr","text":"<p>A second-order, two-pole two-zero bandpass filter with variable frequency response.</p>"},{"location":"opcodes/resonr/#syntax","title":"Syntax","text":"<pre><code>ares resonr asig, xcf, xbw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/resonr/#initialization","title":"Initialization","text":"<p>The optional initialization variables for resonr are identical to the i-time variables for reson.</p> <p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e.  all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise. A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/resonr/#performance","title":"Performance","text":"<p>asig -- input signal to be filtered</p> <p>xcf -- cutoff or resonant frequency of the filter, measured in Hz</p> <p>xbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points)</p> <p>resonr and resonz are variations of the classic two-pole bandpass resonator (reson). Both filters have two zeroes in their transfer functions, in addition to the two poles. resonz has its zeroes located at z = 1 and z = -1. resonr has its zeroes located at +sqrt(R) and -sqrt(R), where R is the radius of the poles in the complex z-plane. The addition of zeroes to resonr and resonz results in the improved selectivity of the magnitude response of these filters at cutoff frequencies close to 0, at the expense of less selectivity of frequencies above the cutoff peak.</p> <p>resonr and resonz are very close to constant-gain as the center frequency is swept, resulting in a more efficient control of the magnitude response than with traditional two-pole resonators such as reson.</p> <p>resonr and resonz produce a sound that is considerably different from reson, especially for lower center frequencies; trial and error is the best way of determining which resonator is best suited for a particular application.</p>"},{"location":"opcodes/resonr/#examples","title":"Examples","text":"<p>Here is an example of the resonr and resonz opcodes. It uses the file resonr.csd.</p> Example of the resonr and resonz opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o resonr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Sean Costello */\n ; Orchestra file for resonant filter sweep of a sawtooth-like waveform. \n  ; The outputs of reson, resonr, and resonz are scaled by coefficients\n  ; specified in the score, so that each filter can be heard on its own\n  ; from the same instrument.\n\n  sr = 44100\n  kr = 4410\n  ksmps = 10\n  nchnls = 1\n\ninstr 1\n\n  idur     =        p3\n  ibegfreq =        p4                              ; beginning of sweep frequency\n  iendfreq =        p5                              ; ending of sweep frequency\n  ibw      =        p6                              ; bandwidth of filters in Hz\n  ifreq    =        p7                              ; frequency of gbuzz that is to be filtered\n  iamp     =        p8                              ; amplitude to scale output by\n  ires     =        p9                              ; coefficient to scale amount of reson in output\n  iresr    =        p10                             ; coefficient to scale amount of resonr in output\n  iresz    =        p11                             ; coefficient to scale amount of resonz in output\n\n ; Frequency envelope for reson cutoff\n  kfreq    linseg ibegfreq, idur * .5, iendfreq, idur * .5, ibegfreq\n\n ; Amplitude envelope to prevent clicking\n  kenv     linseg 0, .1, iamp, idur - .2, iamp, .1, 0\n\n ; Number of harmonics for gbuzz scaled to avoid aliasing\n  iharms   =        (sr*.4)/ifreq\n\n  asig     gbuzz 1, ifreq, iharms, 1, .9, 1      ; \"Sawtooth\" waveform\n  ain      =        kenv * asig                     ; output scaled by amp envelope\n  ares     reson ain, kfreq, ibw, 1\n  aresr    resonr ain, kfreq, ibw, 1\n  aresz    resonz ain, kfreq, ibw, 1\n\n           out ares * ires + aresr * iresr + aresz * iresz\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Sean Costello */\nf1 0 8192 9 1 1 .25                               ; cosine table for gbuzz generator\n\ni1  0 10 1 3000 200 100 4000 1 0 0                ; reson  output with bw = 200\ni1 10 10 1 3000 200 100 4000 0 1 0                ; resonr output with bw = 200\ni1 20 10 1 3000 200 100 4000 0 0 1                ; resonz output with bw = 200\ni1 30 10 1 3000  50 200 8000 1 0 0                ; reson  output with bw = 50\ni1 40 10 1 3000  50 200 8000 0 1 0                ; resonr output with bw = 50\ni1 50 10 1 3000  50 200 8000 0 0 1                ; resonz output with bw = 50\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resonr/#technical-history","title":"Technical History","text":"<p>resonr and resonz were originally described in an article by Julius O. Smith and James B. Angell.<sup>1</sup> Smith and Angell recommended the resonz form (zeros at +1 and -1) when computational efficiency was the main concern, as it has one less multiply per sample, while resonr (zeroes at + and - the square root of the pole radius R) was recommended for situations when a perfectly constant-gain center peak was required.</p> <p>Ken Steiglitz, in a later article <sup>2</sup>, demonstrated that resonz had constant gain at the true peak of the filter, as opposed to resonr, which displayed constant gain at the pole angle. Steiglitz also recommended resonz for its sharper notches in the gain curve at zero and Nyquist frequency. Steiglitz's recent book <sup>3</sup> features a thorough technical discussion of reson and resonz, while Dodge and Jerse's textbook <sup>4</sup> illustrates the differences in the response curves of reson and resonz.</p>"},{"location":"opcodes/resonr/#references","title":"References","text":"<ol> <li>Smith, Julius O. and Angell, James B., \"A Constant-Gain Resonator Tuned by a Single Coefficient,\" Computer Music Journal, vol. 6, no. 4, pp. 36-39, Winter 1982.</li> <li>Steiglitz, Ken, \"A Note on Constant-Gain Digital Resonators,\" Computer Music Journal, vol. 18, no. 4, pp. 8-10, Winter 1994.</li> <li>Ken Steiglitz, A Digital Signal Processing Primer, with Applications to Digital Audio and Computer Music. Addison-Wesley Publishing Company, Menlo Park, CA, 1996.</li> <li>Dodge, Charles and Jerse, Thomas A., Computer Music: Synthesis, Composition, and Performance. New York: Schirmer Books, 1997, 2nd edition, pp. 211-214.</li> </ol>"},{"location":"opcodes/resonr/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/resonr/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>New in Csound version 3.55</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/resonx/","title":"Resonx","text":""},{"location":"opcodes/resonx/#resonx","title":"resonx","text":"<p>Emulates a stack of filters using the reson opcode.</p> <p>resonx is equivalent to a filters consisting of more layers of reson with the same arguments, serially connected. Using a stack of a larger number of filters allows a sharper cutoff. They are faster than using a larger number instances in a Csound orchestra of the old opcodes, because only one initialization and k- cycle are needed at time and the audio loop falls entirely inside the cache memory of processor.</p>"},{"location":"opcodes/resonx/#syntax","title":"Syntax","text":"<pre><code>ares resonx asig, xcf, xbw [, inumlayer] [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/resonx/#initialization","title":"Initialization","text":"<p>inumlayer (optional) -- number of elements in the filter stack. Default value is 4.</p> <p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/resonx/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xcf -- the center frequency of the filter, or frequency position of the peak response.</p> <p>xbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points)</p>"},{"location":"opcodes/resonx/#examples","title":"Examples","text":"<p>Here is an example of the resonx opcodes. It uses the file resonx.csd.</p> Example of the resonx opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o resonx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; unfiltered noise\n\nkenv    linseg  0, p3*.5, 1, p3*.5, 0   ;envelope\nasig    rand    0.7                     ;white noise\n        outs    asig*kenv, asig*kenv\n\nendin\n\ninstr 2 ; filtered noise\n\nkenv    linseg  0, p3*.5, 1, p3*.5, 0   ;envelope\nasig    rand    0.7\nkcf     line    300, p3, 2000\nafilt   resonx  asig, kcf, 300, 4\nasig    balance afilt, asig\n        outs    asig*kenv, asig*kenv\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 3 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resonx/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/resonx/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado (adapted by John ffitch) Italy</p> <p>New in Csound version 3.49</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/resonxk/","title":"Resonxk","text":""},{"location":"opcodes/resonxk/#resonxk","title":"resonxk","text":"<p>Control signal resonant filter stack.</p> <p>resonxk is equivalent to a group of resonk filters, with the same arguments, serially connected. Using a stack of a larger number of filters allows a sharper cutoff.</p>"},{"location":"opcodes/resonxk/#syntax","title":"Syntax","text":"<pre><code>kres resonxk ksig, kcf, kbw[, inumlayer, iscl, istor]\n</code></pre>"},{"location":"opcodes/resonxk/#initialization","title":"Initialization","text":"<p>inumlayer - number of elements of filter stack. Default value is 4. Maximum value is 10</p> <p>iscl (optional, default=0) - coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>istor (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/resonxk/#performance","title":"Performance","text":"<p>kres - output signal</p> <p>ksig - input signal</p> <p>kcf -  the center frequency of the filter, or frequency position of the peak response.</p> <p>kbw - bandwidth of the filter (the Hz difference between the upper and lower half-power points)</p> <p>resonxk is a lot faster than using individual instances in Csound orchestra of the old opcodes, because only one initialization and 'k' cycle are needed at a time, and the audio loop falls enterely inside the cache memory of processor.</p>"},{"location":"opcodes/resonxk/#examples","title":"Examples","text":"<p>Here is an example of the resonxk opcode. It uses the file resonxk.csd.</p> Example of the resonxk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o resonxk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nksig randomh  400, 1800, 150\naout poscil   .2, 1000+ksig, gisin\n     outs     aout, aout\nendin\n\ninstr 2\n\nksig randomh  400, 1800, 150\nkcf  line     1, p3, 1000               ;vary high-pass\nilay = p4\nksig resonxk  ksig, kcf, 100, ilay\naout poscil   .2, 1000+ksig, gisin\nasig interp   ksig                      ;convert k-rate to a-rate\naout balance  asig, aout                ;avoid getting asig out of range\n     outs     aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0  5\ni 2 6  5 1      ;number of filter stack = 1\ni 2 12 5 5      ;number of filter stack = 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resonxk/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/resonxk/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/resony/","title":"Resony","text":""},{"location":"opcodes/resony/#resony","title":"resony","text":"<p>A bank of second-order bandpass filters, connected in parallel.</p>"},{"location":"opcodes/resony/#syntax","title":"Syntax","text":"<pre><code>ares resony asig, kbf, kbw, inum, ksep [, isepmode] [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/resony/#initialization","title":"Initialization","text":"<p>inum -- number of filters</p> <p>isepmode (optional, default=0) -- if isepmode = 0, the separation of center frequencies of each filter is generated logarithmically (using octave as unit of measure). If isepmode not equal to 0, the separation of center frequencies of each filter is generated linearly (using Hertz). Default value is 0.</p> <p>iscl (optional, default=0) -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. (This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise.) A zero value signifies no scaling of the signal, leaving that to some later adjustment (e.g. balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/resony/#performance","title":"Performance","text":"<p>asig -- audio input signal</p> <p>kbf -- base frequency, i.e. center frequency of lowest filter in Hz</p> <p>kbw -- bandwidth in Hz</p> <p>ksep -- separation of the center frequency of filters in octaves</p> <p>resony is a bank of second-order bandpass filters, with k-rate variant frequency separation, base frequency and bandwidth, connected in parallel (i.e. the resulting signal is a mix of the output of each filter). The center frequency of each filter depends of kbf and ksep variables. The maximum number of filters is set to 100.</p>"},{"location":"opcodes/resony/#examples","title":"Examples","text":"<p>Here is an example of the resony opcode. It uses the file resony.csd.</p> Example of the resony opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o resonx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; unfiltered noise\n\nkenv    linseg  0, p3*.5, 1, p3*.5, 0   ;envelope\nasig    rand    0.7                     ;white noise\n        outs    asig*kenv, asig*kenv\n\nendin\n\ninstr 2 ; filtered noise\n\nksep    = p4                            ;vary seperation of center frequency of filters in octaves\nkenv    linseg  0, p3*.5, 1, p3*.5, 0   ;envelope\nasig    rand    0.7\nkbf     line    300, p3, 2000           ;vary base frequency\nafilt   resony  asig, kbf, 300, 4, ksep\nasig    balance afilt, asig\n        outs    asig*kenv, asig*kenv\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 3 2 1\ni 2 6 2 3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resony/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/resony/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/resonz/","title":"Resonz","text":""},{"location":"opcodes/resonz/#resonz","title":"resonz","text":"<p>A second-order, two-pole two-zero bandpass filter with variable frequency response.</p>"},{"location":"opcodes/resonz/#syntax","title":"Syntax","text":"<pre><code>ares resonz asig, xcf, xbw [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/resonz/#initialization","title":"Initialization","text":"<p>The optional initialization variables for resonr and resonz are identical to the i-time variables for reson.</p> <p>iskip -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p> <p>iscl -- coded scaling factor for resonators. A value of 1 signifies a peak response factor of 1, i.e.  all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A value of 2 raises the response factor so that its overall RMS value equals 1. This intended equalization of input and output power assumes all frequencies are physically present; hence it is most applicable to white noise. A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p>"},{"location":"opcodes/resonz/#performance","title":"Performance","text":"<p>resonr and resonz are variations of the classic two-pole bandpass resonator (reson). Both filters have two zeroes in their transfer functions, in addition to the two poles. resonz has its zeroes located at z = 1 and z = -1. resonr has its zeroes located at +sqrt(R) and -sqrt(R), where R is the radius of the poles in the complex z-plane. The addition of zeroes to resonr and resonz results in the improved selectivity of the magnitude response of these filters at cutoff frequencies close to 0, at the expense of less selectivity of frequencies above the cutoff peak.</p> <p>resonr and resonz are very close to constant-gain as the center frequency is swept, resulting in a more efficient control of the magnitude response than with traditional two-pole resonators such as reson.</p> <p>resonr and resonz produce a sound that is considerably different from reson, especially for lower center frequencies; trial and error is the best way of determining which resonator is best suited for a particular application.</p> <p>asig -- input signal to be filtered</p> <p>xcf -- cutoff or resonant frequency of the filter, measured in Hz</p> <p>xbw -- bandwidth of the filter (the Hz difference between the upper and lower half-power points)</p>"},{"location":"opcodes/resonz/#examples","title":"Examples","text":"<p>Here is an example of the resonr and resonz opcodes. It uses the file resonz.csd.</p> Example of the resonr and resonz opcodes.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o resonr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Sean Costello */\n ; Orchestra file for resonant filter sweep of a sawtooth-like waveform. \n  ; The outputs of reson, resonr, and resonz are scaled by coefficients\n  ; specified in the score, so that each filter can be heard on its own\n  ; from the same instrument.\n\n  sr = 44100\n  kr = 4410\n  ksmps = 10\n  nchnls = 1\n\ninstr 1\n\n  idur     =        p3\n  ibegfreq =        p4                              ; beginning of sweep frequency\n  iendfreq =        p5                              ; ending of sweep frequency\n  ibw      =        p6                              ; bandwidth of filters in Hz\n  ifreq    =        p7                              ; frequency of gbuzz that is to be filtered\n  iamp     =        p8                              ; amplitude to scale output by\n  ires     =        p9                              ; coefficient to scale amount of reson in output\n  iresr    =        p10                             ; coefficient to scale amount of resonr in output\n  iresz    =        p11                             ; coefficient to scale amount of resonz in output\n\n ; Frequency envelope for reson cutoff\n  kfreq    linseg ibegfreq, idur * .5, iendfreq, idur * .5, ibegfreq\n\n ; Amplitude envelope to prevent clicking\n  kenv     linseg 0, .1, iamp, idur - .2, iamp, .1, 0\n\n ; Number of harmonics for gbuzz scaled to avoid aliasing\n  iharms   =        (sr*.4)/ifreq\n\n  asig     gbuzz 1, ifreq, iharms, 1, .9, 1      ; \"Sawtooth\" waveform\n  ain      =        kenv * asig                     ; output scaled by amp envelope\n  ares     reson ain, kfreq, ibw, 1\n  aresr    resonr ain, kfreq, ibw, 1\n  aresz    resonz ain, kfreq, ibw, 1\n\n           out ares * ires + aresr * iresr + aresz * iresz\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Sean Costello */\nf1 0 8192 9 1 1 .25                               ; cosine table for gbuzz generator\n\ni1  0 10 1 3000 200 100 4000 1 0 0                ; reson  output with bw = 200\ni1 10 10 1 3000 200 100 4000 0 1 0                ; resonr output with bw = 200\ni1 20 10 1 3000 200 100 4000 0 0 1                ; resonz output with bw = 200\ni1 30 10 1 3000  50 200 8000 1 0 0                ; reson  output with bw = 50\ni1 40 10 1 3000  50 200 8000 0 1 0                ; resonr output with bw = 50\ni1 50 10 1 3000  50 200 8000 0 0 1                ; resonz output with bw = 50\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/resonz/#technical-history","title":"Technical History","text":"<p>resonr and resonz were originally described in an article by Julius O. Smith and James B. Angell.<sup>1</sup> Smith and Angell recommended the resonz form (zeros at +1 and -1) when computational efficiency was the main concern, as it has one less multiply per sample, while resonr (zeroes at + and - the square root of the pole radius R) was recommended for situations when a perfectly constant-gain center peak was required.</p> <p>Ken Steiglitz, in a later article <sup>2</sup>, demonstrated that resonz had constant gain at the true peak of the filter, as opposed to resonr, which displayed constant gain at the pole angle. Steiglitz also recommended resonz for its sharper notches in the gain curve at zero and Nyquist frequency. Steiglitz's recent book <sup>3</sup> features a thorough technical discussion of reson and resonz, while Dodge and Jerse's textbook <sup>4</sup> illustrates the differences in the response curves of reson and resonz.</p>"},{"location":"opcodes/resonz/#references","title":"References","text":"<ol> <li>Smith, Julius O. and Angell, James B., \"A Constant-Gain Resonator Tuned by a Single Coefficient,\" Computer Music Journal, vol. 6, no. 4, pp. 36-39, Winter 1982.</li> <li>Steiglitz, Ken, \"A Note on Constant-Gain Digital Resonators,\" Computer Music Journal, vol. 18, no. 4, pp. 8-10, Winter 1994.</li> <li>Ken Steiglitz, A Digital Signal Processing Primer, with Applications to Digital Audio and Computer Music. Addison-Wesley Publishing Company, Menlo Park, CA, 1996.</li> <li>Dodge, Charles and Jerse, Thomas A., Computer Music: Synthesis, Composition, and Performance. New York: Schirmer Books, 1997, 2nd edition, pp. 211-214.</li> </ol>"},{"location":"opcodes/resonz/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/resonz/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>New in Csound version 3.55</p> <p>Audio rate parameters introduced in version 6.02</p> <p>November 2013.</p>"},{"location":"opcodes/reverb/","title":"Reverb","text":""},{"location":"opcodes/reverb/#reverb","title":"reverb","text":"<p>Reverberates an input signal with a \u201cnatural room\u201d frequency response.</p>"},{"location":"opcodes/reverb/#syntax","title":"Syntax","text":"<pre><code>ares reverb asig, krvt [, iskip]\n</code></pre>"},{"location":"opcodes/reverb/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p>"},{"location":"opcodes/reverb/#performance","title":"Performance","text":"<p>krvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>A standard reverb unit is composed of four comb filters in parallel followed by two alpass units in series. Loop times are set for optimal \u201cnatural room response.\u201d Core storage requirements for this unit are proportional only to the sampling rate, each unit requiring approximately 3K words for every 10KC. The comb, alpass, delay, tone and other Csound units provide the means for experimenting with alternate reverberator designs.</p> <p>Since output from the standard reverb will begin to appear only after 1/20 second or so of delay, and often with less than three-fourths of the original power, it is normal to output both the source and the reverberated signal. If krvt is inadvertently set to a non-positive number, krvt will be reset automatically to 0.01. (New in Csound version 4.07.) Also, since the reverberated sound will persist long after the cessation of source events, it is normal to put reverb in a separate instrument to which sound is passed via a global variable, and to leave that instrument running throughout the performance.</p>"},{"location":"opcodes/reverb/#examples","title":"Examples","text":"<p>Here is an example of the reverb opcode. It uses the file reverb.csd.</p> Example of the reverb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o reverb.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\nga1 init 0 \n\ninstr 1 \n\nasig poscil .2, cpspch(p4), 1 \n     outs asig, asig \n\nga1  += asig     ;add direct signal to global reverb\n\nendin\n\ninstr 99        ;(highest instr number executed last)\n\narev reverb ga1, 1.5\n     outs arev, arev \n\nga1  = 0        ;clear\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 128 10 1  ;sine\n\ni 1 0 0.1 7.00  ;short sounds\ni 1 1 0.1 8.02\ni 1 2 0.1 8.04\ni 1 3 0.1 8.06\n\ni 99 0 6        ;reverb runs for 6 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/reverb/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/reverb/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss University of Texas at Austin Austin, Texas USA January 2002</p>"},{"location":"opcodes/reverb2/","title":"Reverb2","text":""},{"location":"opcodes/reverb2/#reverb2","title":"reverb2","text":"<p>Same as the nreverb opcode.</p>"},{"location":"opcodes/reverb2/#syntax","title":"Syntax","text":"<pre><code>ares reverb2 asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] \\\n             [, inumAlpas] [, ifnAlpas]\n</code></pre>"},{"location":"opcodes/reverbsc/","title":"Reverbsc","text":""},{"location":"opcodes/reverbsc/#reverbsc","title":"reverbsc","text":"<p>8 delay line stereo FDN reverb.</p> <p>It has a feedback matrix based upon physical modeling scattering junction of 8 lossless waveguides of equal characteristic impedance. Based on Csound orchestra version by Sean Costello.</p>"},{"location":"opcodes/reverbsc/#syntax","title":"Syntax","text":"<pre><code>aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]]\n</code></pre>"},{"location":"opcodes/reverbsc/#initialization","title":"Initialization","text":"<p>israte (optional, defaults to the orchestra sample rate) -- assume a sample rate of israte. This is normally set to sr, but a different setting can be useful for special effects.</p> <p>ipitchm (optional, defaults to 1) -- depth of random variation added to delay times, in the range 0 to 10. The default is 1, but this may be too high and may need to be reduced for held pitches such as piano tones.</p> <p>iskip (optional, defaults to zero) -- if non-zero, initialization of the opcode is skipped, whenever possible.</p>"},{"location":"opcodes/reverbsc/#performance","title":"Performance","text":"<p>aoutL, aoutR -- output signals for left and right channel</p> <p>ainL, ainR -- left and right channel input. Note that having an input signal on either the left or right channel only will still result in having reverb output on both channels, making this unit more suitable for reverberating stereo input than the freeverb opcode.</p> <p>kfblvl -- feedback level, in the range 0 to 1. 0.6 gives a good small \"live\" room sound, 0.8 a small hall, and 0.9 a large hall. A setting of exactly 1 means infinite length, while higher values will make the opcode unstable.</p> <p>kfco -- cutoff frequency of simple first order lowpass filters in the feedback loop of delay lines, in Hz. Should be in the range 0 to israte/2 (not sr/2). A lower value means faster decay in the high frequency range.</p>"},{"location":"opcodes/reverbsc/#examples","title":"Examples","text":"<p>Here is an example of the reverbsc opcode. It uses the file reverbsc.csd.</p> An example of the reverbsc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o reverbsc.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr      =  48000\nksmps   =  32\nnchnls  =  2\n0dbfs   =  1\n\n        instr 1\na1      vco2 0.85, 440, 10\nkfrq    port 100, 0.004, 20000\na1      butterlp a1, kfrq\na2      linseg 0, 0.003, 1, 0.01, 0.7, 0.005, 0, 1, 0\na1      =  a1 * a2\na2      =  a1 * p5\na1      =  a1 * p4\n        denorm a1, a2\naL, aR  reverbsc a1, a2, 0.85, 12000, sr, 0.5, 1\n        outs a1 + aL, a2 + aR\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1 0.71 0.71\ni 1 1 1 0 1\ni 1 2 1 -0.71 0.71\ni 1 3 1 1 0\ni 1 4 4 0.71 0.71\ne \n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/reverbsc/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/reverbsc/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p>"},{"location":"opcodes/rewindscore/","title":"Rewindscore","text":""},{"location":"opcodes/rewindscore/#rewindscore","title":"rewindscore","text":"<p>Rewinds the playback position of the current score performance.</p>"},{"location":"opcodes/rewindscore/#syntax","title":"Syntax","text":"<pre><code>rewindscore\n</code></pre>"},{"location":"opcodes/rewindscore/#examples","title":"Examples","text":"<p>Here is an example of the rewindscore opcode. It uses the file rewindscore.csd.</p> An example of the rewindscore opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rewindscore.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkenv expon  1, p3, 0.0001\naout poscil .5*kenv, cpspch(p4), 1\n     outs   aout, aout\nendin\n\ninstr 100\n\nrewindscore\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1  ;sine wave\n\ni1 0 1 8.00\ni1 + 1 8.03\ni1 + 1 8.04\ni1 + 1 8.07 \ni1 + 1 8.09\ni1 + 1 8.10\ni1 + 1 8.09\ni1 + 1 8.07\ni1 + 1 8.03\n\ni100 9 1        ;rewind from 9th second\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rewindscore/#see-also","title":"See also","text":"<p>Sensing and Control: Score control</p>"},{"location":"opcodes/rewindscore/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2008</p> <p>New in Csound version 5.09</p>"},{"location":"opcodes/rezzy/","title":"Rezzy","text":""},{"location":"opcodes/rezzy/#rezzy","title":"rezzy","text":"<p>A resonant low-pass filter.</p>"},{"location":"opcodes/rezzy/#syntax","title":"Syntax","text":"<pre><code>ares rezzy asig, xfco, xres [, imode, iskip]\n</code></pre>"},{"location":"opcodes/rezzy/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- high-pass or low-pass mode. If zero, rezzy is low-pass. If not zero, rezzy is high-pass. Default value is 0. (New in Csound version 3.50)</p> <p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/rezzy/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>xfco -- filter cut-off frequency in Hz. As of version 3.50, may i-,k-, or a-rate.</p> <p>xres -- amount of resonance. Values of 1 to 100 are typical. Resonance should be one or greater. As of version 3.50, may a-rate, i-rate, or k-rate.</p> <p>rezzy is a resonant low-pass filter created empirically by Hans Mikelson.</p>"},{"location":"opcodes/rezzy/#examples","title":"Examples","text":"<p>Here is an example of the rezzy opcode. It uses the file rezzy.csd.</p> Example of the rezzy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rezzy.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n0dbfs  = 1\nnchnls = 2\n\ninstr 1\n\nasaw vco2 .3, 110       ;sawtooth\nkcf  line 1760, p3, 220 ;vary cut-off frequency from 220 to 1280 Hz\nkres = p4               ;vary resonance too\nares rezzy asaw, kcf, kres\nasig balance ares, asaw\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4 10\ni 1 + 4 30\ni 1 + 4 120     ;lots of resonance\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rezzy/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/rezzy/#credits","title":"Credits","text":"<p>Author: Hans Mikelson October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/rigoto/","title":"Rigoto","text":""},{"location":"opcodes/rigoto/#rigoto","title":"rigoto","text":"<p>Transfers control during a reinit pass.</p> <p>Similar to igoto, but effective only during a reinit pass (i.e., no-op at standard i-time). This statement is useful for bypassing units that are not to be reinitialized.</p>"},{"location":"opcodes/rigoto/#syntax","title":"Syntax","text":"<pre><code>rigoto label\n</code></pre>"},{"location":"opcodes/rigoto/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p>"},{"location":"opcodes/rireturn/","title":"Rireturn","text":""},{"location":"opcodes/rireturn/#rireturn","title":"rireturn","text":"<p>Terminates a reinit pass (i.e., no-op at standard i-time).</p> <p>This statement, or an endin, will cause normal performance to be resumed.</p>"},{"location":"opcodes/rireturn/#syntax","title":"Syntax","text":"<pre><code>rireturn\n</code></pre>"},{"location":"opcodes/rireturn/#examples","title":"Examples","text":"<p>The following statements will generate an exponential control signal whose value moves from 440 to 880 exactly ten times over the duration p3. They use the file reinit.csd.</p> Example of the rireturn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o reinit.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nreset:\n        timout 0, p3/p4, contin         \n        reinit reset\n\ncontin:\n        kLine expon 440, p3/p4, 880\n        aSig poscil 1, kLine\n        outs aSig, aSig\n        rireturn\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10 10\ni1 + 10 50      \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rireturn/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p>"},{"location":"opcodes/rms/","title":"Rms","text":""},{"location":"opcodes/rms/#rms","title":"rms","text":"<p>Determines the root-mean-square amplitude of an audio signal.</p> <p>It low-pass filters the actual value, to average in the manner of a VU meter.</p>"},{"location":"opcodes/rms/#syntax","title":"Syntax","text":"<pre><code>kres rms asig [, ihp] [, iskip]\n</code></pre>"},{"location":"opcodes/rms/#initialization","title":"Initialization","text":"<p>ihp (optional, default=10) -- half-power point (in Hz) of a special internal low-pass filter. The default value is 10.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space (see reson). The default value is 0.</p>"},{"location":"opcodes/rms/#performance","title":"Performance","text":"<p>asig -- input audio signal</p> <p>kres -- low-pass filtered rms value of the input signal</p> <p>rms output values kres will trace the root-mean-square value of the audio input asig. This unit is not a signal modifier, but functions rather as a signal power-gauge. It uses an internal low-pass filter to make the response smoother. ihp can be used to control this smoothing. The higher the value, the \"snappier\" the measurement.</p> <p>This opcode can also be used as an evelope follower.</p> <p>The kres output from this opcode is given in amplitude and depends on 0dbfs. If you want the output in decibels, you can use dbamp</p>"},{"location":"opcodes/rms/#examples","title":"Examples","text":"<p>Here is an example of the rms opcode. It uses the file rms.csd.</p> Example of the rms opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rms.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nareference diskin \"fox.wav\"\nkrms rms  areference       ; take the RMS of \"fox.wav\"\nasound oscili krms, 440 ; use RMS as amplitude of sine wave     \noutch 1, areference\noutch 2, asound\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the rms opcode. It uses the file rms-FLTK.csd.</p> Advanced example of the rms opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d  -m0   ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o rms.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 128\nnchnls = 1\n\n;Example by Andres Cabrera 2007\n\n0dbfs = 1\n\nFLpanel \"rms\", 400, 100, 50, 50\n    gkrmstext, gihrmstext FLtext \"Rms\", -100, 0, 0.1, 3, 110, 30, 60, 50\n    gkihp, gihandle FLtext \"ihp\", 0, 10, 0.05, 1, 100, 30, 220, 50\n    gkrmsslider, gihrmsslider FLslider \"\", -60, -0.5, -1, 5, -1, 380, 20, 10, 10\n\nFLpanelEnd\nFLrun\n\n\nFLsetVal_i 5, gihandle\n; Instrument #1.\ninstr 1\n  a1 inch 1   \n\nlabel:\n  kval rms a1, i(gkihp)  ;measures rms of input channel 1\nrireturn\n\n  kval = dbamp(kval) ; convert to db full scale\n  printk 0.5, kval\n  FLsetVal 1, kval, gihrmsslider   ;update the slider and text values\n  FLsetVal 1, kval, gihrmstext\n  knewihp changed gkihp   ; reinit when ihp text has changed\n  if (knewihp == 1) then\n    reinit label  ;needed because ihp is an i-rate parameter\n  endif\nendin\n\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one minute\ni 1 0 60\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rms/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/rnd/","title":"Rnd","text":""},{"location":"opcodes/rnd/#rnd","title":"rnd","text":"<p>Returns a random number in a unipolar range at the rate given by the input argument.</p>"},{"location":"opcodes/rnd/#syntax","title":"Syntax","text":"<pre><code>rnd(x) (init- or control-rate only)\n</code></pre> <p>Where the argument within the parentheses may be an expression. These value converters sample a global random sequence, but do not reference seed. The result can be a term in a further expression.</p>"},{"location":"opcodes/rnd/#performance","title":"Performance","text":"<p>Returns a random number in the unipolar range 0 to x.</p>"},{"location":"opcodes/rnd/#examples","title":"Examples","text":"<p>Here is an example of the rnd opcode. It uses the file rnd.csd.</p> Example of the rnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o rnd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Andres Cabrera 2010\n\nsr = 44100\nksmps = 4410\nnchnls = 1\n0dbfs = 1\n\ninstr 1\n        ; Generate a random number from 0 to 10.\n        irand = rnd(10)\n        print irand\nendin\n\ninstr 2\n        klimit init 10\n        krand = rnd(klimit)\n        printk 0, krand\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1  ; Generate 1 number\ni 1 0 1  ; Generate another number\ni 1 0 1  ; yet another number\n\ni 2 2 1  ; 1 second prints 9 values (kr = 10)\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should be:</p> <pre><code>SECTION 1:\nnew alloc for instr 1:\ninstr 1:  irand = 9.735\nnew alloc for instr 1:\ninstr 1:  irand = 1.394\nnew alloc for instr 1:\ninstr 1:  irand = 7.695\nmidi channel 1 now using instr 1\nB  0.000 ..  2.000 T  2.000 TT  2.000 M:  0.00000\nnew alloc for instr 2:\ni   2 time     2.10000:     5.25005\ni   2 time     2.20000:     6.22665\ni   2 time     2.30000:     9.69511\ni   2 time     2.40000:     7.16822\ni   2 time     2.50000:     9.45134\ni   2 time     2.60000:     1.34123\ni   2 time     2.70000:     2.09879\ni   2 time     2.80000:     2.36001\ni   2 time     2.90000:     0.03553\n</code></pre> <p>Here is another example of the rnd opcode. It uses the file rnd-advanced.csd.</p> Advanced example of the rnd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o rnd.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n; Generate a random number from 0 to 5\nirand1 = rnd(5)\n; Generate a random number from 0 to 13\nirand2 = rnd(13)\n\nprint irand1\nprint irand2\n\na1, a2 crossfm 200, 250, irand1, irand2, 1, 1, 1\nkdeclick linseg 0, 0.2, 0.5, p3-0.4, 0.5, 0.2, 0\n\noutch 1, a1*kdeclick\noutch 2, a2*kdeclick\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 4096 10 1 0 1 0 0.5 0 0.2\n\ni 1 0 1  \ni 1 + 1  \ni 1 + 1 \ni 1 + 1 \n\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rnd/#see-also","title":"See also","text":"<p>Random Functions</p>"},{"location":"opcodes/rnd/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe MIT Cambridge, Massachussetts 1997</p>"},{"location":"opcodes/rnd31/","title":"Rnd31","text":""},{"location":"opcodes/rnd31/#rnd31","title":"rnd31","text":"<p>31-bit bipolar random opcodes with controllable distribution.</p> <p>These units are portable, i.e. using the same seed value will generate the same random sequence on all systems. The distribution of generated random numbers can be varied at k-rate.</p>"},{"location":"opcodes/rnd31/#syntax","title":"Syntax","text":"<pre><code>ax rnd31 kscl, krpow [, iseed]\nix rnd31 iscl, irpow [, iseed]\nkx rnd31 kscl, krpow [, iseed]\n</code></pre>"},{"location":"opcodes/rnd31/#initialization","title":"Initialization","text":"<p>ix -- i-rate output value.</p> <p>iscl -- output scale. The generated random numbers are in the range -iscl to iscl.</p> <p>irpow -- controls the distribution of random numbers. If irpow is positive, the random distribution (x is in the range -1 to 1) is abs(x) \u02c6 ((1 / irpow) - 1); for negative irpow values, it is (1 - abs(x)) \u02c6 ((-1 / irpow) - 1). Setting irpow to -1, 0, or 1 will result in uniform distribution (this is also faster to calculate).</p> A graph of distributions for different values of irpow. <p>iseed (optional, default=0) -- seed value for random number generator (positive integer in the range 1 to 2147483646 (2 \u02c6 31 - 2)). Zero or negative value seeds from current time (this is also the default). Seeding from current time is guaranteed to generate different random sequences, even if multiple random opcodes are called in a very short time.</p> <p>In the a- and k-rate version the seed is set at opcode initialization. With i-rate output, if iseed is zero or negative, it will seed from current time in the first call, and return the next value from the random sequence in successive calls; positive seed values are set at all i-rate calls.  The seed is local for a- and k-rate, and global for i-rate units.</p> <p> Notes</p> <ul> <li>although seed values up to 2147483646 are allowed, it is recommended to use smaller numbers (&lt; 1000000) for portability, as large integers may be rounded to a different value if 32-bit floats are used.</li> <li>i-rate rnd31 with a positive seed will always produce the same output value (this is not a bug). To get different values, set seed to 0 in successive calls, which will return the next value from the random sequence.</li> </ul>"},{"location":"opcodes/rnd31/#performance","title":"Performance","text":"<p>ax -- a-rate output value.</p> <p>kx -- k-rate output value.</p> <p>kscl -- output scale. The generated random numbers are in the range -kscl to kscl. It is the same as iscl, but can be varied at k-rate.</p> <p>krpow -- controls the distribution of random numbers. It is the same as irpow, but can be varied at k-rate.</p>"},{"location":"opcodes/rnd31/#examples","title":"Examples","text":"<p>Here is an example of the rnd31 opcode at a-rate. It uses the file rnd31.csd.</p> An example of the rnd31 opcode at a-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o rnd31.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n                            ; Create random numbers at a-rate in the range -2 to 2 with\na31 rnd31 2, -0.5           ; a triangular distribution, seed from the current time.\nafreq = a31 * 500 + 100     ; Use the random numbers to choose a frequency.\na1 oscili .5, afreq         ; uses sine\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the rnd31 opcode at k-rate. It uses the file rnd31_krate.csd.</p> An example of the rnd31 opcode at k-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n      ; no sound   \n; For Non-realtime ouput leave only the line below:\n; -o rnd31_krate.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nk1 rnd31 1, 0, 10           ; Create random numbers at k-rate in the range -1 to 1 \nprintks \"k1=%f\\\\n\", 0.1, k1 ; with a uniform distribution, seed=10.\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 .3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1=0.112106\nk1=-0.274665\nk1=0.403933\n</code></pre> <p>Here is an example of the rnd31 opcode that uses the number 7 as a seed value. It uses the file rnd31_seed7.csd.</p> An example of the rnd31 opcode that uses the number 7 as a seed value.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n      ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o rnd31_seed7.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\ni1 rnd31 1, 0.5, 7      ; i-rate random numbers with linear distribution, seed=7.\ni2 rnd31 1, 0.5         ; (Note that the seed was used only in the first call.)\ni3 rnd31 1, 0.5\n\nprint i1\nprint i2\nprint i3\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = -0.649\ninstr 1:  i2 = -0.761\ninstr 1:  i3 = 0.677\n</code></pre> <p>Here is an example of the rnd31 opcode that uses the current time as a seed value. It uses the file rnd31_time.csd.</p> An example of the rnd31 opcode that uses the current time as a seed value.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n      ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o rnd31_time.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1\n\ni1 rnd31 1, 0.5, 0      ; i-rate random numbers with linear distribution,\ni2 rnd31 1, 0.5         ; seeding from the current time. (Note that the seed\ni3 rnd31 1, 0.5         ; was used only in the first call.)\n\nprint i1\nprint i2\nprint i3\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr 1:  i1 = -0.691\ninstr 1:  i2 = -0.686\ninstr 1:  i3 = -0.358\n</code></pre>"},{"location":"opcodes/rnd31/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/rnd31/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.16</p>"},{"location":"opcodes/rndseed/","title":"Rndseed","text":""},{"location":"opcodes/rndseed/#rndseed","title":"rndseed","text":"<p>Sets the global seed value for rnd and birnd.</p>"},{"location":"opcodes/rndseed/#syntax","title":"Syntax","text":"<pre><code>rndseed ival\n</code></pre>"},{"location":"opcodes/rndseed/#initialization","title":"Initialization","text":"<p>ival (default=0.5) -- should be between 0 and 1.</p> <p>Use of rndseed will provide alternative results from the rnd and birnd opcodes to the default (= 0.5).</p>"},{"location":"opcodes/rndseed/#examples","title":"Examples","text":"<p>Here is an example of the rndseed opcode. It uses the file rndseed.csd.</p> Example of the rndseed opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rndseed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nrndseed .15 ; change value for a different sequence\n; Generate a random number sequence from -1000 to 1000 according to rndseed\ninstr 1 \n\nkbin    =       birnd(1000)\nprintk2 kbin\nasig    vco2    .5, 100\nares    rezzy   asig, 1500+kbin, 20\n        outs ares, ares\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 .3\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ni 1 + .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rndseed/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/rndseed/#credits","title":"Credits","text":"<p>Author: John ffitch April 2020</p> <p>New in Csound version 6.15</p>"},{"location":"opcodes/round/","title":"Round","text":""},{"location":"opcodes/round/#round","title":"round","text":"<p>Returns the integer value nearest to x.</p> <p>If the fractional part of x is exactly 0.5, the direction of rounding is undefined and may depend on the host operating system and Csound version.</p>"},{"location":"opcodes/round/#syntax","title":"Syntax","text":"<pre><code>round(x)      (init-, control-, or audio-rate arg allowed)\nround(k/i[])  (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/round/#examples","title":"Examples","text":"<p>Here is an example of the round opcode. It uses the file round.csd.</p> Example of the round opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o round.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidiv init 1\n\nloop:\ninumber = 9\ni1  = inumber / idiv\niro =  round(i1)\nprint inumber, idiv, iro ;print number / idiv = result using round\nidiv = idiv + 1\nif (idiv &lt;= 10) igoto loop\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like these:</p> <pre><code>instr 1:  inumber = 9.000  idiv = 1.000  ifl = 9.000\ninstr 1:  inumber = 9.000  idiv = 2.000  ifl = 5.000\ninstr 1:  inumber = 9.000  idiv = 3.000  ifl = 3.000\ninstr 1:  inumber = 9.000  idiv = 4.000  ifl = 2.000\ninstr 1:  inumber = 9.000  idiv = 5.000  ifl = 2.000\ninstr 1:  inumber = 9.000  idiv = 6.000  ifl = 2.000\ninstr 1:  inumber = 9.000  idiv = 7.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 8.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 9.000  ifl = 1.000\ninstr 1:  inumber = 9.000  idiv = 10.000  ifl = 1.000\n</code></pre> <p>Here is an example for the rounding-group, comparing the different rounding opcodes. It uses the file rounding-group.csd.</p> Example of the rounding group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac       ;   \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\n\n; by tgrey 2020\ninstr 1\n\niLoopStart = p4\niLoopEnd   = p5\niOffset    = p6\n\niCount init iLoopStart\n\n\nif(iLoopStart&lt;iLoopEnd) then            ; loop going up\n        while iCount &lt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount + 1             \n        od\n\nelseif(iLoopEnd&lt;iLoopStart) then        ; loop going down\n        while iCount &gt;= iLoopEnd do\n                iVal = iCount+iOffset\n                iRound = round(iVal)\n                iInt = int(iVal)\n                iFloor = floor(iVal)\n                iCeil = ceil(iVal)\n                print iVal, iRound, iInt, iFloor, iCeil\n                iCount = iCount - 1             \n        od\nendif\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 .1 0 10 .5\ni1 .2 .1 0 -10 .5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/round/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/round/#credits","title":"Credits","text":"<p>Author: Istvan Varga New in Csound 5 2005</p>"},{"location":"opcodes/rspline/","title":"Rspline","text":""},{"location":"opcodes/rspline/#rspline","title":"rspline","text":"<p>Generate random spline curves.</p>"},{"location":"opcodes/rspline/#syntax","title":"Syntax","text":"<pre><code>ares rspline xrangeMin, xrangeMax, kcpsMin, kcpsMax\nkres rspline krangeMin, krangeMax, kcpsMin, kcpsMax\n</code></pre>"},{"location":"opcodes/rspline/#performance","title":"Performance","text":"<p>kres, ares -- Output signal</p> <p>xrangeMin, xrangeMax -- Range of values of random-generated points</p> <p>kcpsMin, kcpsMax -- Range of point-generation rate. Min and max limits are expressed in cps.</p> <p>rspline (random-spline-curve generator) is similar to jspline but output range is defined by means of two limit values. Also in this case, real output range could be a bit greater of range values, because of interpolating curves beetween each pair of random-points.</p> <p>At present time generated curves are quite smooth when cpsMin is not too different from cpsMax. When cpsMin-cpsMax interval is big, some little discontinuity could occurr, but it should not be a problem, in most cases. Maybe the algorithm will be improved in next versions.</p> <p>These opcodes are often better than jitter when user wants to \u201cnaturalize\u201d or \u201canalogize\u201d digital sounds. They could be used also in algorithmic composition, to generate smooth random melodic lines when used together with samphold opcode.</p> <p>Note that the result is quite different from the one obtained by filtering white noise, and they allow the user to obtain a much more precise control.</p>"},{"location":"opcodes/rspline/#examples","title":"Examples","text":"<p>Here is an example of the rspline opcode. It uses the file rspline.csd.</p> Example of the rspline opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o jspline.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkrangeMin init p4\nkrangeMax init p5\nkcpsmin init 2\nkcpsmax init 3\n\nksp  rspline krangeMin, krangeMax, kcpsmin, kcpsmax\naout pluck 1, 200+ksp, 1000, 0, 1\naout dcblock aout       ;remove DC\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0  10  2  5 ;a bit jitter\ni 1 8  10 10 20 ;some more\ni 1 16 10 20 50 ;lots more\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rspline/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/rspline/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 4.15</p>"},{"location":"opcodes/rtclock/","title":"Rtclock","text":""},{"location":"opcodes/rtclock/#rtclock","title":"rtclock","text":"<p>Read the real time clock from the operating system.</p>"},{"location":"opcodes/rtclock/#syntax","title":"Syntax","text":"<pre><code>ires rtclock\nkres rtclock\n</code></pre>"},{"location":"opcodes/rtclock/#performance","title":"Performance","text":"<p>Read the real-time clock from operating system. Under Windows, this changes only once per second. Under GNU/Linux, it ticks every microsecond. Performance under other systems varies.</p>"},{"location":"opcodes/rtclock/#examples","title":"Examples","text":"<p>Here is an example of the rtclock opcode. It uses the file rtclock.csd.</p> Example of the rtclock opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n     ;;;no sound\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o rtclock.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n;after an example by Iain McCurdy\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nFLcolor 200, 200, 200, 0, 0, 0\n;       LABEL     | WIDTH | HEIGHT | X | Y\nFLpanel \"rtclock\",   500,    130,    0,  0\n;                                  ON,OFF,TYPE,WIDTH, HEIGHT, X, Y, OPCODE, INS,START,IDUR\ngkOnOff,ihOnOff FLbutton \"On/Off\", 1,  0,  22,  150,   25,    5, 5,    0,   1,   0,   3600\ngkExit,ihExit   FLbutton \"exitnow\",1,  0,  21,  150,   25,  345, 5,    0,  999,  0,   0.001\nFLsetColor2 255, 0, 50, ihOnOff ;reddish color\n\n;VALUE DISPLAY BOXES     WIDTH,HEIGHT,X, Y\ngidclock FLvalue \"clock\", 100, 25, 200, 60\nFLsetVal_i 1, ihOnOff   \nFLpanel_end\nFLrun\n\ninstr 1 \n\nif gkOnOff !=0 kgoto CONTINUE ;sense if FLTK on/off switch is not off (in which case skip the next line)  \nturnoff                       ;turn this instr. off now\nCONTINUE:\nktime rtclock                 ;clock continues to run even \nFLprintk2 ktime, gidclock     ;after the on/off button was used to stop\n\nendin\n\ninstr 999\n\nexitnow                       ;exit Csound as fast as possible\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 0 60  ;runs 60 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/rtclock/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/rtclock/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 4.10</p>"},{"location":"opcodes/s16b14/","title":"S16b14","text":""},{"location":"opcodes/s16b14/#s16b14","title":"s16b14","text":"<p>Creates a bank of 16 different 14-bit MIDI control message numbers.</p>"},{"location":"opcodes/s16b14/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i16 s16b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n                    initvalue1, ifn1, ..., ictlno_msb16, ictlno_lsb16, \\\n                    imin16, imax16, initvalue16, ifn16\nk1, ..., k16 s16b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n                    initvalue1, ifn1, ..., ictlno_msb16, ictlno_lsb16, \\\n                    imin16, imax16, initvalue16, ifn16\n</code></pre>"},{"location":"opcodes/s16b14/#initialization","title":"Initialization","text":"<p>i1 ... i64 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlno_msb1 .... ictlno_msb32 -- MIDI control number, most significant byte (0-127)</p> <p>ictlno_lsb1 .... ictlno_lsb32 -- MIDI control number, least significant byte (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p>"},{"location":"opcodes/s16b14/#performance","title":"Performance","text":"<p>k1 ... k64 -- output values</p> <p>s16b14 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>s16b14 allows a bank of 16 different MIDI control message numbers. It uses 14-bit values instead of MIDI's normal 7-bit values.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of s16b14, there is not an initial value input argument. The output is taken directly from the current status of internal controller array of Csound.</p>"},{"location":"opcodes/s16b14/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/s16b14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/s32b14/","title":"S32b14","text":""},{"location":"opcodes/s32b14/#s32b14","title":"s32b14","text":"<p>Creates a bank of 32 different 14-bit MIDI control message numbers.</p>"},{"location":"opcodes/s32b14/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i32 s32b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n                    initvalue1, ifn1, ..., ictlno_msb32, ictlno_lsb32, \\\n                    imin32, imax32, initvalue32, ifn32\nk1, ..., k32 s32b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \\\n                    initvalue1, ifn1, ..., ictlno_msb32, ictlno_lsb32, \\\n                    imin32, imax32, initvalue32, ifn32\n</code></pre>"},{"location":"opcodes/s32b14/#initialization","title":"Initialization","text":"<p>i1 ... i64 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlno_msb1 .... ictlno_msb32 -- MIDI control number, most significant byte (0-127)</p> <p>ictlno_lsb1 .... ictlno_lsb32 -- MIDI control number, least significant byte (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p>"},{"location":"opcodes/s32b14/#performance","title":"Performance","text":"<p>k1 ... k64 -- output values</p> <p>s32b14 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>s32b14 allows a bank of 32 different MIDI control message numbers. It uses 14-bit values instead of MIDI's normal 7-bit values.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of s32b14, there is not an initial value input argument. The output is taken directly from the current status of internal controller array of Csound.</p>"},{"location":"opcodes/s32b14/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/s32b14/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/samphold/","title":"Samphold","text":""},{"location":"opcodes/samphold/#samphold","title":"samphold","text":"<p>Performs a sample-and-hold operation on its input.</p>"},{"location":"opcodes/samphold/#syntax","title":"Syntax","text":"<pre><code>ares samphold asig, agate [, ival] [, ivstor]\nkres samphold ksig, kgate [, ival] [, ivstor]\n</code></pre>"},{"location":"opcodes/samphold/#initialization","title":"Initialization","text":"<p>ival, ivstor (optional) -- controls initial disposition of internal save space. If ivstor is zero the internal \u201chold\u201d value is set to ival ; else it retains its previous value. Defaults are 0,0 (i.e. init to zero)</p>"},{"location":"opcodes/samphold/#performance","title":"Performance","text":"<p>kgate, xgate -- controls whether to hold the signal.</p> <p>samphold performs a sample-and-hold operation on its input according to the value of gate. If gate != 0, the input samples are passed to the output; if gate = 0, the last output value is repeated. The controlling gate can be a constant, a control signal, or an audio signal.</p>"},{"location":"opcodes/samphold/#examples","title":"Examples","text":"<pre><code>asrc  buzz      10000, 440, 20, 1     ; band-limited pulse train\nadif  diff      asrc                  ; emphasize the highs\nanew  balance   adif, asrc            ;   but retain the power\nagate reson     asrc, 0, 440          ; use a lowpass of the original\nasamp samphold  anew, agate           ;   to gate the new audiosig\naout  tone      asamp, 100            ; smooth out the rough edges\n</code></pre> <p>Here is another example of the samphold opcode. It uses the file samphold.csd.</p> Example of the samphold opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o samphold.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkx      line -1, p3, 1          ; between -1 and +1 \nktrig   metro 1                 ; triggers 1 time per second \nkval    samphold kx, ktrig      ; change value whenever ktrig = 1 \n        printk2 kval            ; will print every time kval changes \nasig    diskin2 \"flute.aiff\", 1+kval, 0, 1\n        outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 11 \ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/samphold/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/sandpaper/","title":"Sandpaper","text":""},{"location":"opcodes/sandpaper/#sandpaper","title":"sandpaper","text":"<p>Semi-physical model of a sandpaper sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/sandpaper/#syntax","title":"Syntax","text":"<pre><code>ares sandpaper iamp, idettack [, inum] [, idamp] [, imaxshake]\n</code></pre>"},{"location":"opcodes/sandpaper/#initialization","title":"Initialization","text":"<p>iamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only a approximation.</p> <p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 128.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.998 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.999 which means that the default value of idamp is 0.5. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 1.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p>"},{"location":"opcodes/sandpaper/#examples","title":"Examples","text":"<p>Here is an example of the sandpaper opcode. It uses the file sandpaper.csd.</p> Example of the sandpaper opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sandpaper.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidmp = p4\na1   line 2, p3, 2                      ;preset amplitude increase\na2   sandpaper 1, 0.01, 128, idmp       ;sandpaper needs a little amp help at these settings\nasig product a1, a2                     ;increase amplitude\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1 0.5\ni1 + 1 0.95\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sandpaper/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/sandpaper/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhOLIES (Physically-Oriented Library of Imitated Environmental Sounds) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/scale/","title":"Scale","text":""},{"location":"opcodes/scale/#scale","title":"scale","text":"<p>Arbitrary signal scaling.</p> <p>Scales incoming value to user-definable range. Similar to scale object found in popular dataflow languages.</p>"},{"location":"opcodes/scale/#syntax","title":"Syntax","text":"<pre><code>kscl scale kinput, kmax, kmin[, kimax, kimin]\n</code></pre>"},{"location":"opcodes/scale/#performance","title":"Performance","text":"<p>kin -- Input value. Can originate from any k-rate source as long as that source's output is in range kimin to kimax.</p> <p>kmin -- Minimum value of the resultant scale operation.</p> <p>kmax -- Maximum value of the resultant scale operation.</p> <p>kimin -- Optional; Minimum of the incoming value range, defaulting to zero.</p> <p>kimax -- Optional; Maximum of the incoming value range, defaulting to one.</p> <p> Warning</p> <p>Take care with the order of the arguments which has maximum before minimum</p>"},{"location":"opcodes/scale/#examples","title":"Examples","text":"<p>Here is an example of the scale opcode. It uses the file scale.csd.</p> Example of the scale opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent\n-odac           -iadc     -d    ;;;realtime output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       44100\nksmps   =       10\nnchnls  =       2\n\n/*--- ---*/\n\n        instr   1       ; scale test\n\nkmod    ctrl7   1, 1, 0, 1\n        printk2 kmod\n\nkout    scale   kmod, 0, -127\n        printk2 kout\n\n        endin\n\n/*--- ---*/\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1      0       8888\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scale/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/scale/#credits","title":"Credits","text":"<p>Author: David Akbari October 2006 John ffitch Modified to add input range values in 2020</p>"},{"location":"opcodes/scale2/","title":"Scale2","text":""},{"location":"opcodes/scale2/#scale2","title":"scale2","text":"<p>Arbitrary signal scaling with optional smoothing.</p> <p>Scales incoming value to user-definable range. Similar to scale object found in popular dataflow languages.</p>"},{"location":"opcodes/scale2/#syntax","title":"Syntax","text":"<pre><code>kscl scale2 kinput, kmin, kmax[, kimin, kimax][ihtime]\n</code></pre> <p>Initialisation</p> <p>ihtime -- Optional; Half time value for internal port filter for smoothing.  Default is no smoothing.</p>"},{"location":"opcodes/scale2/#performance","title":"Performance","text":"<p>kin -- Input value. Can originate from any k-rate source and should be in the range kimin to kimax.  If it is larger than kimax it is treated as kimax, and if less than kimin then it is treated as kimin.</p> <p>kmin -- Minimum value of the resultant scale operation.</p> <p>kmax -- Maximum value of the resultant scale operation.</p> <p>kimin -- Optional; Minimum of the incoming value range, defaulting to zero.</p> <p>kimax -- Optional; Maximum of the incoming value range, defaulting to one.</p> <p> Warning</p> <p>The argument order is minimum before maximum, which differs from scale but it consistent with other opcodes that use a range.</p>"},{"location":"opcodes/scale2/#examples","title":"Examples","text":"<p>Here is an example of the scale2 opcode. It uses the file scale2.csd.</p> Example of the scale2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent\n-odac           -iadc     -d    ;;;realtime output\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       44100\nksmps   =       10\nnchnls  =       2\n\n/*--- ---*/\n\n        instr   1       ; scale test\n\nkmod    ctrl7   1, 1, 0, 1\n        printk2 kmod\n\nkout    scale2  kmod, -127, 0\n        printk2 kout\n\n        endin\n\n/*--- ---*/\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1      0       8888\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scale2/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/scale2/#credits","title":"Credits","text":"<p>Author: John ffitch after David Akbari December 2020</p>"},{"location":"opcodes/scalearray/","title":"Scalearray","text":""},{"location":"opcodes/scalearray/#scalearray","title":"scalearray","text":"<p>The scalearray opcode scales a subregion of a vector to a given minimum/maximum.</p>"},{"location":"opcodes/scalearray/#syntax","title":"Syntax","text":"<pre><code>scalearray tarray, kmin, kmax[, kleft, kright]\n</code></pre>"},{"location":"opcodes/scalearray/#performance","title":"Performance","text":"<p>karray --  array for operation.</p> <p>kmin, kmax --  target minimum and maximum values.</p> <p>kleft, kright --  range of table to use, defaulting to 0 and size of the vector.</p>"},{"location":"opcodes/scalearray/#examples","title":"Examples","text":"<p>Here is an example of the scalearray opcode. It uses the file scalearray.csd.</p> Example of the scalearray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example by joachim heintz\n\n           seed       0\n\ninstr 1\n;create an array with 10 elements\nkArr[]     init       10\n;fill in random numbers and print them out\n           printks    \"kArr in maximum range 0..100:\\n\", 0\nkIndx      =          0\n  until kIndx == 10 do\nkNum       random     0, 100\nkArr[kIndx] =         kNum\n           printf     \"kArr[%d] = %10f\\n\", kIndx+1, kIndx, kNum\nkIndx      +=         1\n  od\n;scale numbers 0...1 and print them out again\n           scalearray kArr, 0, 1\nkIndx      =          0\n           printks    \"kArr in range 0..1\\n\", 0\n  until kIndx == 10 do\n           printf     \"kArr[%d] = %10f\\n\", kIndx+1, kIndx, kArr[kIndx]\nkIndx      +=         1\n  od\n           turnoff\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scalearray/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/scalearray/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.14</p> <p>Renamed in Csound version 6.00</p>"},{"location":"opcodes/scanhammer/","title":"Scanhammer","text":""},{"location":"opcodes/scanhammer/#scanhammer","title":"scanhammer","text":"<p>Copies from one table to another with a gain control.</p> <p>This is is a variant of tablecopy, copying from one table to another, starting at ipos, and with a gain control. The number of points copied is determined by the length of the source. Other points are not changed. This opcode can be used to \u201chit\u201d a string in the scanned synthesis code.</p>"},{"location":"opcodes/scanhammer/#syntax","title":"Syntax","text":"<pre><code>scanhammer isrc, idst, ipos, imult\n</code></pre>"},{"location":"opcodes/scanhammer/#initialization","title":"Initialization","text":"<p>isrc -- source function table.</p> <p>idst -- destination function table.</p> <p>ipos -- starting position (in points).</p> <p>imult -- gain multiplier. A value of 0 will leave values unchanged.</p>"},{"location":"opcodes/scanhammer/#examples","title":"Examples","text":"<p>Here is an example of the scanhammer opcode. It uses the file scanhammer.csd.</p> Example of the scanhammer opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac --limiter=0.9 ;;;realtime audio out and limiter\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanhammer.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2021\n\ninstr 1 \n\ninitial ftgen 1, 0, p5, 10, 1                         ; initial position = sine wave\nimass   ftgen 2, 0, p5, -7, .1, p5, 1                 ; masses\nistiff  ftgen 3, 0, p5, -7, 0, p5*.3, 0.8*p5, p5*.7, 0   ; stiffness\nidamp   ftgen 4, 0, p5, -7, 1, p5, 1                  ; damping\nivelo   ftgen 5, 0, p5, -7, 0, p5, 0.5                ; initial velocity\n\niamp = .20\nipch  = cpsmidinn(p4) \nscanhammer 1, 1, 0, p6                                ; scale initial position wave \nasig3 scantable iamp, ipch, 1, 2, 3, 4, 5             ; set ftables in motion\nasig  foscili iamp, ipch, 1.414, .03, 1, 1            ; but use FM sound, with slow vibrato\nasig  butlp  asig, 2000                               ; lowpass filter\nasig dcblock asig\nouts asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns   ;                  note    size    hit\ni1      0       10      50      128     2   ; hit very hard\ni1      11      10      50      .       1   ; hit normally\ni1      22      10      50      .       .3  ; hit soft\ns\ni1      1       10      50      32      2   ; different table size \ni1      12      10      50      .       1\ni1      23      20      50      .       .3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scanhammer/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scanhammer/#credits","title":"Credits","text":"<p>Author: Matt Gilliard April 2002</p> <p>New in version 4.20</p>"},{"location":"opcodes/scanmap/","title":"Scanmap","text":""},{"location":"opcodes/scanmap/#scanmap","title":"scanmap","text":"<p>Allows the position and velocity of a node in a scanned process to be read.</p> <p>Plugin opcode in scansyn.</p>"},{"location":"opcodes/scanmap/#syntax","title":"Syntax","text":"<pre><code>kpos, kvel scanmap iscan, kamp, kvamp [, iwhich]\n</code></pre>"},{"location":"opcodes/scanmap/#initialization","title":"Initialization","text":"<p>iscan -- which scan process to read</p> <p>iwhich (optional) -- which node to sense. The default is 0.</p>"},{"location":"opcodes/scanmap/#performance","title":"Performance","text":"<p>kamp -- amount to amplify the kpos value.</p> <p>kvamp -- amount to amplify the kvel value.</p> <p>The internal state of a node is read. This includes its position and velocity. They are amplified by the kamp and kvamp values.</p>"},{"location":"opcodes/scanmap/#examples","title":"Examples","text":"<p>Here is an example of the scanmap opcode. It uses the file scanmap.csd.</p> Example of the scanmap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc for RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanmap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr scannode\n\na0 init 0\nirate = .001\n; scanu2 init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass,\n;       kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2 1, irate, 6, 2, 3, p5, 5, 2, 9, .01, .01, .1, .9, 0, 0, a0, 0, 2\nkpos,kvel scanmap 2, 100,1, p4     ; amplify the kpos value 100 times\ndisplay  kpos, .25                  ; display is updated every .25 of a second\nasig poscil .5+kvel, 150+kpos       ; use moving velocity and position of the node \nouts asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 10 1                       ; Initial displacement condition: sine\nf2 0 128 -7 1 128 1                 ; Masses\nf3 0 16384 -23 \"string-128.matrxB\"  ; Spring matrices\n\n;-------------------------------------\n; 2 different Centering forces\nf44 0 128 -7 1 128 1                ; uniform initial centering\nf4 0 128 -7 .001 128 1              ; ramped centering\n;-------------------------------------\nf5 0 128 -7 1 128 1                 ; uniform damping\nf6 0 128 -7 .01 128 .01             ; uniform initial velocity\nf7 0 128 -5 .001 128 128            ; Trajectory\n\ns;                node\ni\"scannode\" 0 10   0    4           ; uniform initial centering ramped centering\ni\"scannode\" 11 10  64   4           ; reading 3 nodes\ni\"scannode\" 22 10 127   4           ; 0 - 64 - 127\ns;                node\ni\"scannode\" 0 10   0    44          ; uniform initial centering          \ni\"scannode\" 11 10  64   44          ; reading 3 nodes\ni\"scannode\" 22 10 127   44          ; 0 - 64 - 127\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the scanmap opcode. It uses the file scanmap_matrxT.csd.</p> Second example of the scanma opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac         ;  -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o scanmap_matrxT.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr scanmap_Additive\n\na0 init 0\nkp[] init 16\nkv[] init 16\ngiTableKP ftgen 100, 0, -16, 2, 0\ngiTableKV ftgen 101, 0, -16, 2, 0\nscanu2 -1, .1, 6, 2, 3, 4, 5, 2, 10, .001, .01, .1, .9, 0, 0, a0, 1, 2\nkp,kv scanmap 2, 1000, 2\ncopya2ftab kp, giTableKP\ncopya2ftab kv, giTableKV\na1 poscil ampdbfs(p4)*kv[8], cpsmidinn(p5)+kp[8]\na2 poscil ampdbfs(p4)*kv[13], cpsmidinn(p5)+kp[13]\na3 poscil ampdbfs(p4)*kv[5], cpsmidinn(p5)+kp[5]\na4 poscil ampdbfs(p4)*kv[1], cpsmidinn(p5)+kp[1]\nkamp    line    3, p3, 0.01\nouts (a1+a4)*kamp, (a2+a3) * kamp\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16 10 1 ; initial displacement condition (sine shape)\nf2 0 16 -7 1 16 1 ; uniform masses\nf3 0 0 -44 \"string_with_extras-16.matrxT\"\nf4 0 16 -7 .001 16 1 ; ramped centering\nf5 0 16 -7 .1 16 1 ; ramped damping\nf6 0 16 -7 .01 16 .01 ; uniform initial velocity\n\ni \"scanmap_Additive\" 0 15 -1 72\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scanmap/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scanmap/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 6.17</p>"},{"location":"opcodes/scans/","title":"Scans","text":""},{"location":"opcodes/scans/#scans","title":"scans","text":"<p>Generate audio output using scanned synthesis.</p> <p>Plugin opcode in scansyn.</p>"},{"location":"opcodes/scans/#syntax","title":"Syntax","text":"<pre><code>ares scans kamp, kfreq, ifn, id [, iorder]\n</code></pre>"},{"location":"opcodes/scans/#initialization","title":"Initialization","text":"<p>ifn -- ftable containing the scanning trajectory.  This is a series of numbers that contains addresses of masses.  The order of these addresses is used as the scan path.  It should not contain values greater than the number of masses, or negative numbers. See the introduction to the scanned synthesis section.</p> <p>id -- ID number of the scanu opcode's waveform to use</p> <p>iorder (optional, default=0) -- order of interpolation used internally.  It can take any value in the range 1 to 4, and defaults to 4 if outside that range, which is quartic interpolation.  The setting of 3 is cubic, 2 is quadratic and 1 is linear.  The higher numbers are slower, but not necessarily better.</p>"},{"location":"opcodes/scans/#performance","title":"Performance","text":"<p>kamp -- output amplitude.  Note that the resulting amplitude is also dependent on instantaneous value in the wavetable.  This number is effectively the scaling factor of the wavetable.</p> <p>kfreq -- frequency of the scan rate</p>"},{"location":"opcodes/scans/#examples","title":"Examples","text":"<p>Here is an example of the scanned synthesis. It uses the file scans.csd.</p> Example of the scans opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scans.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\nnchnls=2\n0dbfs=1\n\n; example by Menno Knevel 2024\n\ninstr 1 \n\na0  = 0                                              ; no audio input\n;scanu init, irate, ifnvel, ifnmass, ifnstif, ifncentr, ifndamp, kmass, kstif, kcentr, kdamp, ileft, iright, kpos, kstrngth, ain, idisp, id\nscanu 1,     .01,    6,       2,       3,     4,        5,       2,     .1,    .1,     -.01,  .1,    .5,     0,    0,        a0,  1,     2\n\nif (p6 == 0) then\n    asig  scans ampdb(p4), cpspch(p5), 7, 2          ; exponential trajectory\nelseif (p6 == 1) then\n    asig  scans ampdb(p4), cpspch(p5), 77, 2         ; linear trajectory\nelse\n    asig  scans ampdb(p4), cpspch(p5), 777, 2        ; linear trajectory but only a small portion\nendif\n\nasig    *=  .000025                                  ; compensate volume due to 0dbfs = 1\nouts asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 7 0 64 1 64 0\nf2 0 128 -7 1 128 1\nf3 0 16384 -23 \"string-128.matrxB\"   ; binary matrix, can be found in the examples folder of the manual\nf4  0 128 -7 0 128 2\nf5 0 128 -7 1 128 1\nf6 0 128 -7 0 128 0\nf7 0 128 -5 .001 128 128             ; exponential trajectory\nf77 0 128 -7 0 128 128               ; linear trajectory\nf777 0 128 -7 10 128 20              ; linear trajectory but only a small portion\n\ni1      0       9       90      6.00    0\ni1      9       12      90      7.00    0\ni1      13      17      90      5.00    0\ni1      31      9       90      6.00    1\ni1      40      12      90      7.00    1\ni1      44      17      90      5.00    1\ni1      62      9       90      6.00    2\ni1      71      12      90      7.00    2\ni1      74      17      90      5.00    2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the scanned synthesis. It uses the file scans-2.csd.</p> Second example of the scans opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n; For Non-realtime ouput leave only the line below:\n; -o scans-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; example by Menno Knevel 2024\n\nsr=44100\nksmps=32\nnchnls=2\n0dbfs=1\n\ninstr 1 \ninitial ftgenonce 1, 0, 128, 10, 1                                               ; initial position = sine wave\nidispl  ftgenonce 2, 0, 128, -7, .01, 128, .04                                   ; displace\nimass   ftgenonce 3, 0, 128, -7, 5, 128, 15                                      ; masses\nicent   ftgenonce 4, 0, 128, -7, 2.01, 128, .09                                  ; centering\nidamp   ftgenonce 5, 0, 128, -7, -.1, 128, -.01                                  ; damping\nitraj1  ftgenonce 6, 0, 128, -7, 0, 128, 128                                                    ; trajectory 1\nitraj2  ftgenonce 66, 0, 128, -23, \"straightline_max128_128.traj\"              ; trajectory 2\nitraj3  ftgenonce 666, 0, 128, -23, \"128-spiral-8,16,128,2,1over2.traj\"        ; trajectory 3\n\na0 = 0                                                                          ; no audio \nkline line .7, p3, 0                                                            ; simple envelope\n\nitrajectory =   p6\nif (p6 == 6) then                                                               \n    prints \"\\nlinear trajectory, reading through all of the masses\\n\"\nelseif (p6 == 66) then                                                          \n    prints \"\\nthe same linear trajectory but written as an ASCII file\\n\"\nelse\n    prints \"\\na spiral trajectory - see images below\\n\"\nendif\n\n;scanu2 init, irate, ifndisplace, ifnmass, imatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2   1,   .02,     2,          3,      100,       4,       5,      10,      0.6,       0.1,    .9,     .5,    .1,     0,      0,     a0,    0,   20\nasigL  scans kline, p4, itrajectory, 20\nasigR  scans kline, p4*1.01, itrajectory, 20        ; stereo\nasigL  dcblock asigL\nasigR  dcblock asigR \nouts asigL, asigR\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf100 0  0   -44  \"string_128.matrxT\"    ; text matrix\n\ni1      0.0     4       130.8127825             1.0     6\ni1      5.0     4       109.99999987361387      1.0     66\ni1      10.0    5       146.8323837899985       1.0     666\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A plot of the table <code>itraj1  ftgenonce 6, 0, 128, -7, 0, 128, 128</code> and <code>itraj2  ftgenonce 66, 0, 128, -23, \"straightline_max128_128.traj\"</code>:</p> <p>and this is what the table <code>itraj3  ftgenonce 666, 0, 128, -23, \"128-spiral-8,16,128,2,1over2.traj</code> looks like:</p>"},{"location":"opcodes/scans/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scans/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT Media Lab Boston, Massachussetts USA</p> <p>New in Csound version 4.05</p>"},{"location":"opcodes/scansmap/","title":"Scansmap","text":""},{"location":"opcodes/scansmap/#scansmap","title":"scansmap","text":"<p>Allows the position and velocity of a node in a scanned process to be written.</p> <p>Plugin opcode in scansyn.</p>"},{"location":"opcodes/scansmap/#syntax","title":"Syntax","text":"<pre><code>scansmap kpos, kvel, iscan, kamp, kvamp [, iwhich]\n</code></pre>"},{"location":"opcodes/scansmap/#initialization","title":"Initialization","text":"<p>iscan -- which scan process to write</p> <p>iwhich (optional) -- which node to sense. The default is 0.</p>"},{"location":"opcodes/scansmap/#performance","title":"Performance","text":"<p>kpos -- the node's position.</p> <p>kvel -- the node's velocity.</p> <p>kamp -- amount to amplify the kpos value.</p> <p>kvamp -- amount to amplify the kvel value.</p> <p>The internal state of a node to write. This includes its position and velocity. They are amplified by the kamp and kvamp values.</p>"},{"location":"opcodes/scansmap/#examples","title":"Examples","text":"<p>Here is an example of the scansmap opcode. It uses the file scansmap.csd.</p> Example of the scansmap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n; For Non-realtime ouput leave only the line below:\n; -o scansmao.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=32\nnchnls=2\n0dbfs = 1\n\n; by Menno Knevel - 2024\n; listen carefully: changes are subtle as only one node of the 128 is replaced each time!\n\ninstr 1 ;replace 2 nodes- first 5 then 89\n\na0 init 0\nirate = .002                              ; rather fast scanning rate\n; scanu2 init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass,\nscanu2     1,  irate,      6,         2,         3,        4,        5,     2,\\\n           9,      .01,    .01,   .1,    .9,    0,     0,     a0,    0,   1\n ;    kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nkpos,kvel   scanmap     1, 1, 1, p4              ; just read what is going on with node \n            scansmap    p5, p6, 1, 1, 1, p4      ; set new parameters for this node     \n\nprints \"\\nnode %d: set position to %0.1f, set velocity to %0.1f \\n\", p4, p5, p6\nprintks \"         present  amplitude = %f, position = %f\\n\", .2, kvel, kpos\n\na1  scans ampdb(87), cpspch(7.00), 7,    1\na1  butlp   a1, 1500                             ; low pass filter   \nasig  dcblock a1\nouts asig*.00002, asig*.00002                   \n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 128 -7 0 28 0 2 1 2 0 96 0     ; a pluck that is 10 points wide on the surface\nf2 0 128 -7 1 128 1                 ; Masses\nf3 0 16384 -23 \"string-128.matrxB\"  ; Spring matrix\nf4 0 128 -7 1 128 1 ; uniform initial centering\nf5 0 128 -7 1 128 1                 ; uniform damping\nf6 0 128 -7 .01 128 .01             ; uniform initial velocity\nf7 0 128 -7 1 128 128              ; trajectory\n\ni1      0.0     5       5       0       0\ni1      5.0     5       89      0       0\ni1      11.0    5       5       0       1\ni1      16.0    5       89      0       1\ni1      22.0    5       5       1       0\ni1      27.0    5       89      1       0\ni1      33.0    5       5       1       1\ni1      38.0    5       89      1       1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scansmap/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scansmap/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 6.17</p>"},{"location":"opcodes/scantable/","title":"Scantable","text":""},{"location":"opcodes/scantable/#scantable","title":"scantable","text":"<p>A simpler scanned synthesis implementation.</p> <p>This is an implementation of a circular string scanned using external tables. This opcode will allow direct modification and reading of values with the table opcodes.</p>"},{"location":"opcodes/scantable/#syntax","title":"Syntax","text":"<pre><code>aout scantable kamp, kpch, ipos, imass, istiff, idamp, ivel\n</code></pre>"},{"location":"opcodes/scantable/#initialization","title":"Initialization","text":"<p>ipos -- table containing position array.</p> <p>imass -- table containing the mass of the string.</p> <p>istiff -- table containing the stiffness of the string.</p> <p>idamp -- table containing the damping factors of the string.</p> <p>ivel -- table containing the velocities.</p>"},{"location":"opcodes/scantable/#performance","title":"Performance","text":"<p>kamp -- amplitude (gain) of the string.</p> <p>kpch -- the string's scanned frequency.</p>"},{"location":"opcodes/scantable/#examples","title":"Examples","text":"<p>Here is an example of the scantable opcode. It uses the file scantable.csd.</p> Example of the scantable opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac --limiter=0.95 ;;;realtime audio out &amp; limiter\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scantable.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2021\n\ninstr 1 \n\ninitial ftgen 1, 0, p5, 10, 1                         ; initial position = sine wave\nimass   ftgen 2, 0, p5, -7, .1, p5, 1                 ; masses\nistiff  ftgen 3, 0, p5, -7, 0, p5*.3, 0.8*p5, p5*.7, 0   ; stiffness\nidamp   ftgen 4, 0, p5, -7, 1, p5, 1                  ; damping\nivelo   ftgen 5, 0, p5, -7, 0, p5, 0.5                ; initial velocity\n\niamp = .15\nipch  = cpsmidinn(p4) \nasig scantable iamp, ipch, 1, 2, 3, 4, 5\nasig dcblock asig\nasig   butlp  asig, 5000                              ; lowpass filter\nouts asig, asig;\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1      0       20      50  128\ni1      10      10      70  .\ni1      15      3       40  .\ns\ni1      0       20      50  4096    ; f-tables now bigger tables\ni1      10      10      70  .       ; sounds different \ni1      15      3       40  .\ns\ni1      0       20      50  1000    ; still big tables\ni1      10      10      70  .       ; but non-power of 2\ni1      15      3       40  .\ns\ni1      0       20      50  20      ; small tables\ni1      10      10      70  .       ; &amp; non-power of 2\ni1      15      3       40  .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scantable/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scantable/#credits","title":"Credits","text":"<p>Author: Matt Gilliard April 2002</p> <p>New in version 4.20</p>"},{"location":"opcodes/scanu/","title":"Scanu","text":""},{"location":"opcodes/scanu/#scanu","title":"scanu","text":"<p>Compute the waveform and the wavetable for use in scanned synthesis.</p> <p>Plugin opcode in scansyn.</p>"},{"location":"opcodes/scanu/#syntax","title":"Syntax","text":"<pre><code>scanu init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, \\\n      kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, \\\n      ain, idisp, id\n</code></pre>"},{"location":"opcodes/scanu/#initialization","title":"Initialization","text":"<p>init -- the initial position of the masses.  If this is a negative number, then the absolute of init signifies the table to use as a hammer shape.  If init &gt; 0, the length of it should be the same as the intended mass number, otherwise it can be anything.</p> <p>irate -- the amount of time between successive updates of the mass state. Kind of like the sample period of the system. If the number is big, the string will update at a slow rate showing little timbral variability; otherwise it will change rapidly resulting in a more dynamic sound.</p> <p>ifndisplace -- the ftable that contains the initial velocity for each mass.  It should have the same size as the intended mass number.</p> <p>ifnmass -- ftable that contains the mass of each mass.  It should have the same size as the intended mass number.</p> <p>ifnmatrix -- ftable that contains the spring stiffness of each connection. It should have the same size as the square of the intended mass number.  The data ordering is a row after row dump of the connection matrix of the system.</p> <p>ifncentr -- ftable that contains the centering force of each mass. It should have the same size as the intended mass number.</p> <p>ifndamp -- the ftable that contains the damping factor of each mass. It should have the same size as the intended mass number.</p> <p>ileft -- If init &lt; 0, the position of the left hammer (ileft = 0 is hit at leftmost, ileft = 1 is hit at rightmost). Ignored when init &gt; 0.</p> <p>iright -- If init &lt; 0, the position of the right hammer (iright = 0 is hit at leftmost, iright = 1 is hit at rightmost). Ignored when init &gt; 0.</p> <p>idisp -- If 0, no display of the masses is provided.</p> <p>id --  If positive, the ID of the opcode.  This will be used to point the scanning opcode to the proper waveform maker.  If this value is negative, the absolute of this value is the wavetable on which to write the waveshape. That wavetable can be used later from an other opcode to generate sound.  The initial contents of this table will be destroyed.</p>"},{"location":"opcodes/scanu/#performance","title":"Performance","text":"<p>kmass -- scales the masses</p> <p>kmtrxstiff -- scales the spring stiffness.</p> <p>kcentr -- scales the centering force</p> <p>kdamp -- scales the damping</p> <p>kpos -- position of an active hammer along the string (kpos = 0 is leftmost, kpos = 1 is rightmost).  The shape of the hammer is determined by init and the power it pushes with is kdisplace.</p> <p>kdisplace -- power that the active hammer uses.</p> <p>ain -- audio input that adds to the velocity of the masses. Amplitude should not be too great.</p> <p> Note</p> <p>Both scanu and scanu2 are capable of reading the binary (.matrxB) and text (.matrxT) matrix format. However, using scanu2 is to be preferred because of its accuracy and better sound quality.</p>"},{"location":"opcodes/scanu/#examples","title":"Examples","text":"<p>Here is an example of the scanu opcode. It uses the file scanu.csd.</p> Example of the scanu opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanu.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2024\n\ninstr 1 \n\na0  = 0     ; no external input\n;   scanu init, irate, ifnvel, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kstif, kcentr, kdamp, ileft, iright, kpos, kstrngth, ain, idisp, id\n    scanu p7,     p6,    6,       2,       3,        4,        5,       2,     .1,    .1,     -.02,  .1,    .5,     0,     0,     a0,  0,     2\n\nif (p7 == -1) then\n    prints \"\\nthe hammer option!\\n\"\nelse\n    prints  \"\\ninitial position of the masses...\\n\"\nendif\n;ar scans kamp,      kfreq,      ifntraj, id\na1  scans ampdb(p4), cpspch(p5),    7,    2\na2  scans ampdb(p4), cpspch(p5)*1.01, 7,  2           ; slightly out of tune\na1  *= 0.00006                                        ; lower amplitude due to 0dbfs  = 1\na2  *= 0.00006                                      \na1  dcblock2  a1                                      ; remove DC offset\na2  dcblock2  a2                                     \nouts a1, a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 128 7 0 64 1 64 0     ; Initial condition\nf2 0 128 -7 1 64 .45 64 1  ; Masses\nf3 0 16384 -23 \"string-128.matrxB\" ; Matrix, a binary one. Can be found in manual/examples\nf4 0 128 -7 0 64 1 64 0    ; Centering force\nf5 0 128 -7 0 64 1 64 0    ; Damping\nf6 0 128 -7 0 128 0        ; Initial velocity\nf7 0 128 -7 0 64 127 64 0  ; Trajectory\n\ni1      0.0     8       86      6.00    0.001   1\ni1      8.0     8       89      6.01    0.001   -1 \ni1      17.0    10      86      6.00    0.005   1\ni1      27.0    10      89      6.01    0.005   -1\ni1      38.0    120     86      6.00    0.1     1\ni1      159.0   120     89      6.01    0.1     -1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the scanu opcode. It uses the file scanu-2.csd.</p> Second example of the scanu opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanu-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2024\n\ninstr 1 ; play sample\n\na0      loscil   .8, p4, 200                                                    ; audio sample with loop points\nprints \"\\nthe drum sample has an frequency of %d\\n\", p4\nouts a0, a0\nendin\n\ninstr 2 ; inject sample\n\na0      loscil   .5, p6, 200                                                    ; audio injection \nprints \"...and is injected into the system...\"\nif (p6 == 0) then\n    prints  \"sample injection has no effect!\"\nendif\n\nkenv    linseg    1, p3*.8, .1, p3*.2, 0                                        ; simple envelope\n;scanu init, irate, ifnvel, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass, kstif, kcentr, kdamp, ileft, iright, kpos, kstrngth, ain, idisp, id\n scanu  1,   .01,    6,       2,       3,          4,        5,     2,     .1,    .1,     -.02,   .1,    .5,     0,      0,    a0,  0,     2\n;ar scans kamp,      kfreq,      ifntraj, id\na1  scans ampdb(p4)*kenv, cpspch(p5), 7,       2\na2  scans ampdb(p4)*kenv, cpspch(p5)*1.01, 7,       2                           ; slightly out of tune (stereo)\na1  *= 0.00005                                                                  ; lower amplitude due to 0dbfs  = 1\na2  *= 0.00005                                      \na1  dcblock2  a1                                                                ; remove DC offset\na2  dcblock2  a2                                     \nouts a1, a2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 128 7 0 64 1 64 0                               ; Initial condition\nf2 0 128 -7 1 64 .45 64 1                            ; Masses\nf3 0 16384 -23 \"string-128.matrxB\"                   ; Spring matrix\nf4 0 128 -7 0 64 1 64 0                              ; Centering force\nf5 0 128 -7 0 64 1 64 -0.01                          ; Damping\nf6 0 128 -7 0 128 0                                  ; Initial velocity\nf7 0 128 -7 0 64 127 64 0                            ; Trajectory\nf200 0 0 1 \"drumsMlp.wav\" 0 0 0  \n\ni1      0.0     4       0\ni1      34.0    4       4\ni1      68.0    4       18\ni2      4.0     30      88      6.00    0\ni2      38.0    30      70      6.00    4\ni2      72.0    30      65      6.00    18\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the scanu opcode: Scanu_Shengzheng_Zhang.csd by Shengzheng Zhang. This musical example also needs MIDIpad.mid.</p>"},{"location":"opcodes/scanu/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scanu/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT Media Lab Boston, Massachussetts USA March 2000</p> <p>New in Csound version 4.05</p>"},{"location":"opcodes/scanu2/","title":"Scanu2","text":""},{"location":"opcodes/scanu2/#scanu2","title":"scanu2","text":"<p>Compute the waveform and the wavetable for use in scanned synthesis.</p> <p>Plugin opcode in scansyn.</p>"},{"location":"opcodes/scanu2/#syntax","title":"Syntax","text":"<pre><code>scanu2 init, irate, ifndisplace,ifnmass, ifnmatrix, ifncentr, ifndamp, \\\n       kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, \\\n       ain, idisp, id\n</code></pre>"},{"location":"opcodes/scanu2/#initialization","title":"Initialization","text":"<p>init -- the initial position of the masses. If this is a negative number, then the absolute of init signifies the table to use as a hammer shape.  If init &gt; 0, the length of it should be the same as the intended mass number, otherwise it can be anything.  If init is not an integer the initial state is white noise with the fractional part being a scaling..</p> <p>irate -- the amount of time between successive updates of the mass state. Kind of like the sample period of the system. If the number is big, the string will update at a slow rate showing little timbral variability; otherwise it will change rapidly resulting in a more dynamic sound.</p> <p>ifndisplace -- the ftable that contains the initial velocity for each mass.  It should have the same size as the intended mass number.</p> <p>ifnmass -- ftable that contains the mass of each mass.  It should have the same size as the intended mass number.</p> <p>ifnmatrix -- ftable that contains the spring stiffness of each connection. It should have the same size as the square of the intended mass number.  The data ordering is a row after row dump of the connection matrix of the system.</p> <p>ifncentr -- ftable that contains the centering force of each mass. It should have the same size as the intended mass number.</p> <p>ifndamp -- the ftable that contains the damping factor of each mass. It should have the same size as the intended mass number.</p> <p>ileft -- If init &lt; 0, the position of the positive pluck in the range 0 to 1. Ignored when init &gt; 0.</p> <p>iright -- If init &lt; 0, the position of the negative pluck in the range 0 to 1. Ignored when init &gt; 0.</p> <p>If ileft is the same as iright a single positive pluck is used as initial state.</p> <p>idisp -- If 0, no display of the masses is provided.</p> <p>id --  If positive, the ID of the opcode. This will be used to point the scanning opcode to the proper waveform maker.  If this value is negative, the absolute of this value is the wavetable on which to write the waveshape. That wavetable can be used later from an other opcode to generate sound.  The initial contents of this table will be destroyed.</p>"},{"location":"opcodes/scanu2/#performance","title":"Performance","text":"<p>kmass -- scales the masses</p> <p>kmtrxstiff -- scales the spring stiffness.  Note that larger numbers slow the evolution of the vibration, which is the reciprocal of the coresponding parameter in scanu.</p> <p>kcentr -- scales the centering force</p> <p>kdamp -- scales the damping</p> <p>kpos -- position of an active hammer along the string (kpos = 0 is leftmost, kpos = 1 is rightmost).  The shape of the hammer is determined by init and the power it pushes with is kdisplace.</p> <p>kdisplace -- power that the active hammer uses.</p> <p>ain -- audio input that adds to the velocity of the masses. Amplitude should not be too great.</p> <p> Note</p> <p>Both scanu and scanu2 are capable of reading the binary (.matrxB) and text (.matrxT) matrix format. However, using scanu2 is to be preferred because of its accuracy and better sound quality.</p>"},{"location":"opcodes/scanu2/#examples","title":"Examples","text":"<p>Here is an example of the scanu2 opcode. It uses the file scanu2.csd.</p> Example of the scanu2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanu2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2024\n\ninstr 1 \n\na0 init 0                                                                       ; no audio injection\nirate = .01\nkenv adsr  .0001,  1,  .7,  .1                                                  ; envelope\n\nif (p6 == 1) then\n    prints  \"\\ninitial displacement condition = ramp\"\nelseif (p6 == 11) then\n    prints  \"\\ninitial displacement condition = sine (hammer???)\"\nelse\n    prints  \"\\ninitial displacement condition = a pluck that is 10 points wide on the surface\"\nendif\n\nif (p7 == 3) then\n    prints  \"\\n                                 (binary matrix)\\n\\n\"\nelse\n    prints  \"\\n                                 (text matrix)\\n\\n\"\nendif\n\n; scanu init, irate, ifndisplace, ifnmass, ifnmatrix, ifncentr, ifndamp, kmass,\n;       kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2 p6, irate, 6, 2, p7, 4, 5, 2, 9, .01, .01, .1, .9, 0, 0, a0, 1, 2\n\n;ar scans kamp, kfreq, ifntraj, id\nasig scans ampdb(p4)*kenv, cpspch(p5), 7, 2\nouts asig*.00004, asig*.00004                                                   ; lower volume due to 0dbfs=1\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Initial displacement condition\nf1 0 128 -7 0 64 1 64 0 ; ramp\nf11 0 128 10 1 ; sine hammer\nf111 0 128 -7 0 28 0 2 1 2 0 96 0 ; a pluck that is 10 points wide on the surface\n\n; Masses\nf2 0 128 -7 1 128 1\n\n; Spring matrices\nf3 0 16384 -23 \"string-128.matrxB\"\nf33 0 16384 -44 \"cylinder_128.matrxT\"\n\n; Centering force\nf4 0 128 -7 1 128 1 ; uniform initial centering\n; 0 128 -7 .001 128 1 ; ramped centering\n\n; Damping\nf5 0 128 -7 1 128 1 ; uniform damping\n\n; Initial velocity - (displacement, vel, and acceleration\n; Acceleration is from stiffness matrix pos effect - increases acceleration\nf6 0 128 -7 .01 128 .01 ; uniform initial velocity\n\n; exponential Trajectory\nf7 0 128 -5 .001 128 128\n\ni1 0  6 88      7.00    1       3\ni1 7  2 88      5.00    1       3\ni1 9  2 88      6.00    1       3\n\ni1 12 6 86      7.00    11      3\ni1 19 2 86      5.00    11      3\ni1 21 2 86      6.00    11      3\n\ni1 24 6 90      7.00    111     3\ni1 31 2 90      5.00    111     3\ni1 33 2 90      6.00    111     3\n\ni1 37 6 88      7.00    1       33\ni1 44 2 88      5.00    1       33\ni1 46 2 88      6.00    1       33\n\ni1 49 6 85      7.00    11      33\ni 156 2 85      5.00    11      33\ni1 58 2 85      6.00    11      33\n\ni1 61 6 92      7.00    111     33\ni1 68 2 92      5.00    111     33\ni1 70 2 92      6.00    111     33\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the scanu2 opcode. It uses the file scanu2-2.csd.</p> Second example of the scanu2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanu2-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2024\n\ninstr 1 ; play with k-rate parameters\n\na0 init 0\nirate = .2\n\nkmass   line    10,  p3, 1\nkstiff  line    .30, p3, .7\nkcenter line    .3,  p3, .01\nkdamp   line    -.01, p3, -.1\nkdisplace line   0,  p3,  1\n\nscanu2 1, irate, 6, 2, 3, 4, 5, kmass, kstiff, kcenter, kdamp, .1, .7, 1, kdisplace, a0, 1, 5\nasig scans ampdbfs(p4), cpspch(p5), 7, 5\nasig dcblock2 asig\nasigL, asigR    reverbsc asig, asig, .6, 10000, sr, .5, 1  ; add some reverb\nouts asigL+asig, asigR+asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Initial displacement condition\nf1 0 1024 10 1                  ; sine\nf2 0 1024 -7 1 1024 1           ; Masses\n; Spring text matrix\nf3 0  0   -44  \"circularstring_1024.matrxT\"    ; text matrix, to be found in manual/examples\nf4 0 1024 -7 1 1024 1 ; uniform initial centering\nf5 0 1024 -7 1 1024 1 ; uniform damping\n; Initial displacement - (displacement, vel, and acceleration\n; Acceleration is from stiffness matrix pos effect - increases acceleration\nf6 0 1024 -7 .01 1024 .01 ; uniform initial velocity-displacement\nf7 0 1024 -5 .001 1024 1024     ; Trajectory\n\ni1      0.0     6.5     -6      7.00\ni1      6.5     6.5     -9      7.07    ; 2 notes\ni1      6.5     6.5     -9      7.04\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Yet another example of the scanu2 opcode. It uses the file scanu2-3.csd.</p> Third example of the scanu2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scanu2-3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Richard Boulanger 2024\n\ninstr scan      ; show the pluck options\n\na0 init 0\nirate = .04\n\nkmass line 2,p3,1\nkstiff line 10,p3,10\nkcenter line 5,p3,6\nkdamp line 1,p3,2\nkpos line .4,p3,.5\n\n;scanu2 init,irate,ifndisplace,ifnmass,ifnmatrix,ifncentr,ifndamp,kmass,kmtrxstiff,\n; kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2 p6, irate, 6, 2, 3, 4, 5, kmass, kstiff, kcenter, kdamp, p7, p8, kpos, .02, a0, 1, 2\na1 scans ampdbfs(p4), cpspch(p5), 7, 2\na1 dcblock2 a1\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16 10 1 ; Sine Hammer\nf11 0 16 10 1 .5 .3 .2 .1 .01 ; Sawlike hammer\nf111 0 16 10 1 0 .73 0 .53 0 .45 0 .17 0 .02 0 .002 ; Pulselike hammer\nf2 0 16 -7 8 16 8 ; Masses\nf3 0 0 -44 \"string_with_extras-16.matrxT\" ; Spring matrix, to be found in the examples folder of the manual\nf4 0 16 -7 .07 16 .07 ; Centering force, uniform initial centering\nf5 0 16 -7 .04 16 .04 ; Damping, uniform damping\nf6 0 16 -7 .01 16 .01 ; uniform initial velocity-displacement\nf7 0 16 -5 15 16 1 ; Trajectory\n\n\ni\"scan\" 0 3 6 7.00 -1 .5 .5 ; pluck in middle\ns\ni\"scan\" 0 3 2 7.00 -1 .1 .1 ; pluck at left\ns\ni\"scan\" 0 3 0 7.00 -1 .2 -.8 ; 2 plucks up left and down right\ns\ni\"scan\" 0 3 -6 7.00 1 .2 .8 ; sine hammer - ignore pluck position\ns\ni\"scan\" 0 3 -6 7.00 11 .8 .2 ; sawlike hammer - ignore pluck position\ns\ni\"scan\" 0 3 -6 7.00 111 .1 .6 ; pulselike hammer - ignore pluck position\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scanu2/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"opcodes/scanu2/#credits","title":"Credits","text":"<p>Author: John ffitch May 2021</p> <p>New in Csound version 6.16</p>"},{"location":"opcodes/schedkwhen/","title":"Schedkwhen","text":""},{"location":"opcodes/schedkwhen/#schedkwhen","title":"schedkwhen","text":"<p>Adds a new score event generated by a k-rate trigger.</p>"},{"location":"opcodes/schedkwhen/#syntax","title":"Syntax","text":"<pre><code>schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur \n           [, ip4] [, ip5] [...]\nschedkwhen ktrigger, kmintim, kmaxnum, \"insname\", kwhen, kdur \\\n           [, ip4] [, ip5] [...]\n</code></pre>"},{"location":"opcodes/schedkwhen/#initialization","title":"Initialization","text":"<p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>ip4, ip5, ... -- Equivalent to p4, p5, etc., in a score i statement</p>"},{"location":"opcodes/schedkwhen/#performance","title":"Performance","text":"<p>ktrigger -- triggers a new score event. If ktrigger = 0, no new event is triggered.</p> <p>kmintim -- minimum time between generated events, in seconds. If kmintim &lt;= 0, no time limit exists. If the kinsnum is negative (to turn off an instrument), this test is bypassed.</p> <p>kmaxnum -- maximum number of simultaneous instances of instrument kinsnum allowed. If the number of existant instances of kinsnum is &gt;= kmaxnum, no new event is generated. If kmaxnum is &lt;= 0, it is not used to limit event generation. If the kinsnum is negative (to turn off an instrument), this test is bypassed.</p> <p>kinsnum -- instrument number. Equivalent to p1 in a score i statement.</p> <p>kwhen -- start time of the new event. Equivalent to p2 in a score i statement. Measured from the time of the triggering event. kwhen must be &gt;= 0. If kwhen &gt; 0, the instrument will not be initialized until the actual time when it should start performing.</p> <p>kdur -- duration of event. Equivalent to p3 in a score i statement. If kdur = 0, the instrument will only do an initialization pass, with no performance. If kdur is negative, a held note is initiated. (See ihold and i statement.)</p> <p> Note</p> <p>While waiting for events to be triggered by schedkwhen, the performance must be kept going, or Csound may quit if no score events are expected. To guarantee continued performance, an f0 statement may be used in the score.</p> <p> Note</p> <p>Note that the schedkwhen opcode cannot accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/schedkwhen/#examples","title":"Examples","text":"<p>Here is an example of the schedkwhen opcode. It uses the file schedkwhen.csd.</p> Example of the schedkwhen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o schedkwhen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 44100\nksmps = 1\nnchnls = 1\n\n; Instrument #1 - oscillator with a high note.\ninstr 1\n  ; Use the fourth p-field as the trigger.\n  ktrigger = p4\n  kmintim = 0\n  kmaxnum = 2\n  kinsnum = 2\n  kwhen = 0\n  kdur = 0.5\n\n  ; Play Instrument #2 at the same time, if the trigger is set.\n  schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur\n\n  ; Play a high note.\n  a1 oscils 10000, 880, 1\n  out a1\nendin\n\n; Instrument #2 - oscillator with a low note.\ninstr 2\n  ; Play a low note.\n  a1 oscils 10000, 220, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; p4 = trigger for Instrument #2 (when p4 &gt; 0).\n; Play Instrument #1 for half a second, no trigger.\ni 1 0 0.5 0\n; Play Instrument #1 for half a second, trigger Instrument #2.\ni 1 1 0.5 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the schedkwhen opcode: schedkwhen_Daughtrey.csd by Scott Daughtrey.</p>"},{"location":"opcodes/schedkwhen/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/schedkwhen/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman EMS, Stockholm, Sweden</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 3.59</p>"},{"location":"opcodes/schedkwhennamed/","title":"Schedkwhennamed","text":""},{"location":"opcodes/schedkwhennamed/#schedkwhennamed","title":"schedkwhennamed","text":"<p>Similar to schedkwhen but uses a named instrument at init-time.</p>"},{"location":"opcodes/schedkwhennamed/#syntax","title":"Syntax","text":"<pre><code>schedkwhennamed ktrigger, kmintim, kmaxnum, \"name\", kwhen, kdur \\\n                [, ip4] [, ip5] [...]\n</code></pre>"},{"location":"opcodes/schedkwhennamed/#initialization","title":"Initialization","text":"<p>ip4, ip5, ... -- Equivalent to p4, p5, etc., in a score i statement</p>"},{"location":"opcodes/schedkwhennamed/#performance","title":"Performance","text":"<p>ktrigger -- triggers a new score event. If ktrigger is 0, no new event is triggered.</p> <p>kmintim -- minimum time between generated events, in seconds. If kmintim is less than or equal to 0, no time limit exists.</p> <p>kmaxnum -- maximum number of simultaneous instances of named instrument allowed. If the number of existant instances of the named instrument is greater than or equal to kmaxnum, no new event is generated. If kmaxnum is less than or equal to 0, it is not used to limit event generation.</p> <p>\"name\" -- the named instrument's name.</p> <p>kwhen -- start time of the new event. Equivalent to p2 in a score i statement. Measured from the time of the triggering event. kwhen must be greater than or equal to 0. If kwhen greater than 0, the instrument will not be initialized until the actual time when it should start performing.</p> <p>kdur -- duration of event. Equivalent to p3 in a score i statement. If kdur is 0, the instrument will only do an initialization pass, with no performance. If kdur is negative, a held note is initiated. (See ihold and i statement.)</p> <p> Note</p> <p>While waiting for events to be triggered by schedkwhennamed, the performance must be kept going, or Csound may quit if no score events are expected. To guarantee continued performance, an f0 statement may be used in the score.</p> <p> Note</p> <p>Note that the schedkwhennamed opcode cannot accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/schedkwhennamed/#examples","title":"Examples","text":"<p>Here is an example of the schedkwhennamed opcode. It uses the file schedkwhennamed.csd.</p> Example of the schedkwhennamed opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d\n; For Non-realtime ouput leave only the line below:\n; -o schedkwhennamed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  sr        =  48000\n  ksmps     =  16\n  nchnls    =  2\n  0dbfs     =  1\n\n; Example by Jonathan Murphy 2007\n\n  gSinstr2  =  \"printer\"\n\n    instr 1\n\n  ktrig     metro     1\nif (ktrig == 1) then\n  ;Call instrument \"printer\" once per second\n            schedkwhennamed   ktrig, 0, 1, gSinstr2, 0, 1\n\nendif\n\n    endin\n\n    instr printer\n\n  ktime     timeinsts\n            printk2   ktime\n\n    endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/schedkwhennamed/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/schedkwhennamed/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman EMS, Stockholm, Sweden</p> <p>New in Csound version 4.23</p>"},{"location":"opcodes/schedule/","title":"Schedule","text":""},{"location":"opcodes/schedule/#schedule","title":"schedule","text":"<p>Adds a new score event.</p>"},{"location":"opcodes/schedule/#syntax","title":"Syntax","text":"<pre><code>schedule insnum, iwhen, idur [, ip4] [, ip5] [...]\nschedule \"insname\", iwhen, idur [, ip4] [, ip5] [...]\nschedule iPar[]\n</code></pre>"},{"location":"opcodes/schedule/#initialization","title":"Initialization","text":"<p>insnum -- instrument number. Equivalent to p1 in a score i statement. insnum must be a number greater than the number of the calling instrument.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>iwhen -- start time of the new event. Equivalent to p2 in a score i statement. iwhen must be nonnegative. If iwhen is zero, insum must be greater than or equal to the p1 of the current instrument.</p> <p>idur -- duration of event. Equivalent to p3 in a score i statement.</p> <p>iPar[] -- event parameters as an i-time array.</p> <p>ip4, ip5, ... -- Equivalent to p4, p5, etc., in a score i statement. The opcode also accepts strings as arguments for p4-pN.</p>"},{"location":"opcodes/schedule/#performance","title":"Performance","text":"<p>schedule adds a new score event. The arguments, including options, are the same as in a score. The iwhen time (p2) is measured from the time of this event.</p> <p>If the duration is zero or negative the new event is of MIDI type, and inherits the release sub-event from the scheduling instruction.</p>"},{"location":"opcodes/schedule/#examples","title":"Examples","text":"<p>Here is an example of the schedule opcode. It uses the file schedule.csd.</p> Example of the schedule opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o schedule.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - oscillator with a high note.\ninstr 1\n  ; Play Instrument #2 at the same time.\n  schedule 2, 0, p3\n\n  ; Play a high note.\n  a1 oscils 10000, 880, 1\n  out a1\nendin\n\n; Instrument #2 - oscillator with a low note.\ninstr 2\n  ; Play a low note.\n  a1 oscils 10000, 220, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for half a second.\ni 1 0 0.5\n; Play Instrument #1 for half a second.\ni 1 1 0.5\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/schedule/#see-also","title":"See also","text":"<p>Instrument Invocation</p> <p>More information on this opcode: http://www.csoundjournal.com/issue15/phrase_loops.html  , written by Jim Aikin</p>"},{"location":"opcodes/schedule/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK November 1998</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 3.491</p> <p>Based on work by Gabriel Maldonado</p> <p>Thanks goes to David Gladstein, for clarifying the iwhen parameter.</p>"},{"location":"opcodes/schedulek/","title":"Schedulek","text":""},{"location":"opcodes/schedulek/#schedulek","title":"schedulek","text":"<p>Adds a new score event.</p>"},{"location":"opcodes/schedulek/#syntax","title":"Syntax","text":"<pre><code>schedulek knsnum, kwhen, kdur [, kp4] [, kp5] [...]\nschedulek \"insname\", kwhen, kdur [, kp4] [, kp5] [...]\nschedule kPar[]\n</code></pre>"},{"location":"opcodes/schedulek/#performance","title":"Performance","text":"<p>knsnum -- instrument number. Equivalent to p1 in a score i statement. knsnum must be a number greater than the number of the calling instrument.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>kwhen -- start time of the new event. Equivalent to p2 in a score i statement. kwhen must be nonnegative. If kwhen is zero, insum must be greater than or equal to the p1 of the current instrument.</p> <p>kdur -- duration of event. Equivalent to p3 in a score i statement.</p> <p>kPar[] -- event parameters as a k-rate array.</p> <p>kp4, kp5, ... -- Equivalent to p4, p5, etc., in a score i statement. The opcode also accepts strings as arguments for p4-pN.</p> <p>schedulek adds a new score event. The arguments, including options, are the same as in a score. The kwhen time (p2) is measured from the time of this event.</p> <p>If the duration is zero or negative the new event is of MIDI type, and inherits the release sub-event from the scheduling instruction.</p>"},{"location":"opcodes/schedulek/#examples","title":"Examples","text":"<p>Here is an example of the schedulek opcode. It uses the file schedulek.csd.</p> Example of the schedule opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o schedulek.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2024\nsr = 44100      \nksmps = 32      \nnchnls = 2              \n0dbfs  = 1              \n\ninstr 1\n\nkfreqnote randomh 0.1, 6.3, 2\nkTrigger  metro   kfreqnote \nif kTrigger == 1 then ;\n\nschedulek 10, 0, 0.1 ;call the instrument\nendif\n\nendin\n\ninstr 10\n\na1 oscili 0.2, 440, 2\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 2 0 4096 10 1 0.9 0.8 0.7 0.6\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>A musical example featuring the schedulek opcode: Schedulek_Heintz.csd by Joachim Heintz.</p>"},{"location":"opcodes/schedulek/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/schedulek/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK January 2020</p>"},{"location":"opcodes/schedwhen/","title":"Schedwhen","text":""},{"location":"opcodes/schedwhen/#schedwhen","title":"schedwhen","text":"<p>Adds a new score event.</p>"},{"location":"opcodes/schedwhen/#syntax","title":"Syntax","text":"<pre><code>schedwhen ktrigger, kinsnum, kwhen, kdur [, ip4] [, ip5] [...]\nschedwhen ktrigger, \"insname\", kwhen, kdur [, ip4] [, ip5] [...]\n</code></pre>"},{"location":"opcodes/schedwhen/#initialization","title":"Initialization","text":"<p>ip4, ip5, ... -- Equivalent to p4, p5, etc., in a score i statement.</p>"},{"location":"opcodes/schedwhen/#performance","title":"Performance","text":"<p>kinsnum -- instrument number. Equivalent to p1 in a score i statement.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>ktrigger -- trigger value for new event</p> <p>kwhen -- start time of the new event. Equivalent to p2 in a score i statement.</p> <p>kdur -- duration of event. Equivalent to p3 in a score i statement.</p> <p>schedwhen adds a new score event. The event is only scheduled when the k-rate value ktrigger is first non-zero. The arguments, including options, are the same as in a score. The kwhen time (p2) is measured from the time of this event.</p> <p>If the duration is zero or negative the new event is of MIDI type, and inherits the release sub-event from the scheduling instruction.</p> <p> Note</p> <p>Note that the schedwhen opcode can't accept string p-fields. If you need to pass strings when instantiating an instrument, use the scoreline or scoreline_i opcode.</p>"},{"location":"opcodes/schedwhen/#examples","title":"Examples","text":"<p>Here is an example of the schedwhen opcode. It uses the file schedwhen.csd.</p> Example of the schedwhen opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o schedwhen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkmtr metro 100                          ;produce 100 triggers per second\n     schedwhen kmtr, 2, 1, .3           ;but schedwhen plays instr. 2 only once         \n\nendin\n\ninstr 2                                            \n\naenv linseg 0, p3*.1, 1, p3*.3, 1, p3*.6, 0 ;envelope\na1   poscil .3*aenv, 1000, 1\n     outs a1, a1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine \n\ni 1 0 3\ni 1 3 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/schedwhen/#see-also","title":"See also","text":"<p>Instrument Invocation</p>"},{"location":"opcodes/schedwhen/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK November 1998</p> <p>New in Csound version 3.491</p> <p>Based on work by Gabriel Maldonado</p>"},{"location":"opcodes/scoreline/","title":"Scoreline","text":""},{"location":"opcodes/scoreline/#scoreline","title":"scoreline","text":"<p>Issues one or more score line events from an instrument.</p> <p>If ktrig is 1 every k-period. It can handle strings in the same conditions as the standard score. Multi-line strings are accepted, using {{  }} to enclose the string.</p>"},{"location":"opcodes/scoreline/#syntax","title":"Syntax","text":"<pre><code>scoreline Sin, ktrig\n</code></pre>"},{"location":"opcodes/scoreline/#initialization","title":"Initialization","text":"<p>\u201cSin\u201d --  a string (in double-quotes or enclosed by {{ }}) containing one or more score events.</p>"},{"location":"opcodes/scoreline/#performance","title":"Performance","text":"<p>ktrig -- event trigger, 1 issues the score event, 0 bypasses it.</p>"},{"location":"opcodes/scoreline/#examples","title":"Examples","text":"<p>Here is an example of the scoreline opcode. It uses the file scoreline.csd.</p> Example of the scoreline opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scoreline.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nktrig metro 3                           ;trigger 3 times a second\nscoreline {{                            ;so it sounds like an echo\n            i 2  0  3  \"flute.aiff\"\n            i 2  1  3  \"drumsMlp.wav\"\n            }}, ktrig\nktrig = 0\n\nendin\n\ninstr 2\n\nasig soundin p4\n     outs asig*.3, asig*.3\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2  ;play for 2 seconds, so the samples are played 6 times \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>You can use string opcodes like sprintfk to produce strings to be passed to scoreline like this:</p> <pre><code>Sfil    = \"/Volumes/Bla/file.aif\"\nString  sprintfk {{i 2 0 %f \"%s\" %f %f %f %f}}, idur, Sfil, p5, p6, knorm, iskip\n        scoreline String, ktrig\n</code></pre>"},{"location":"opcodes/scoreline/#see-also","title":"See also","text":"<p>Instrument Invocation</p> <p>More information on this opcode: http://www.csoundjournal.com/issue15/phrase_loops.html written by Jim Aikin, and in the Floss Manuals: https://flossmanual.csound.com/csound-language/live-events.</p>"},{"location":"opcodes/scoreline/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2007</p>"},{"location":"opcodes/scoreline_i/","title":"Scoreline i","text":""},{"location":"opcodes/scoreline_i/#scoreline_i","title":"scoreline_i","text":"<p>Issues one or more score line events from an instrument at i-time.</p> <p>It can handle strings in the same conditions as the standard score. Multi-line strings are accepted, using {{  }} to enclose the string.</p>"},{"location":"opcodes/scoreline_i/#syntax","title":"Syntax","text":"<pre><code>scoreline_i Sin\n</code></pre>"},{"location":"opcodes/scoreline_i/#initialization","title":"Initialization","text":"<p>\u201cSin\u201d --  a string (in double-quotes or enclosed by {{ }}) containing one or more score events.</p>"},{"location":"opcodes/scoreline_i/#examples","title":"Examples","text":"<p>Here is an example of the scoreline_i opcode. It uses the file scoreline_i.csd.</p> Example of the scoreline_i opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac --old-parser   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o scoreline.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nscoreline_i {{\n            i 2  0  3  \"flute.aiff\"\n            i 2  1  3  \"drumsMlp.wav\"\n            }}\n\nendin\n\ninstr 2\n\nasig soundin p4\n     outs asig*.8, asig*.8\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/scoreline_i/#see-also","title":"See also","text":"<p>Instrument Invocation</p> <p>More information on this opcode: http://www.csoundjournal.com/issue15/phrase_loops.html written by Jim Aikin, and in the Floss Manuals: https://flossmanual.csound.com/csound-language/live-events.</p>"},{"location":"opcodes/scoreline_i/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini, 2007</p>"},{"location":"opcodes/seed/","title":"Seed","text":""},{"location":"opcodes/seed/#seed","title":"seed","text":"<p>Sets the global seed value for all x-class noise generators, as well as other opcodes that use a random call, such as grain.</p> <p> Please Note</p> <p>rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.</p>"},{"location":"opcodes/seed/#syntax","title":"Syntax","text":"<pre><code>seed ival\n</code></pre>"},{"location":"opcodes/seed/#performance","title":"Performance","text":"<p>Use of seed will provide predictable results from an orchestra using with random generators, when required from multiple performances.</p> <p>When specifying a seed value, ival should be an integer between 0 and 2<sup>32</sup>. If ival = 0, the value of ival will be derived from the system clock.</p>"},{"location":"opcodes/seed/#examples","title":"Examples","text":"<p>Here is an example of the seed opcode. It uses the file seed.csd.</p> Example of the seed opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o seed.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ;same values every time\n\nseed 10\nkrnd randomh 100, 200, 5\n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n\ninstr 2 ;different values every time - value is derived from system clock\n\nseed 0                                  ; seed from system clock\nkrnd randomh 100, 200, 5                \n     printk .5, krnd                    ; look \naout oscili 0.8, 440+krnd, 1            ; &amp; listen\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\n\ni 1 0 1\ni 2 2 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i   1 time     0.00067:   100.00000\ni   1 time     0.50000:   175.78677\ni   1 time     1.00000:   170.89579\n\nWARNING: Seeding from current time 834128659\n\ni   2 time     2.00067:   100.00000\ni   2 time     2.50000:   197.58517\ni   2 time     3.00000:   188.69525\n</code></pre>"},{"location":"opcodes/seed/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p> <p>Orchestra Header Statements</p>"},{"location":"opcodes/sekere/","title":"Sekere","text":""},{"location":"opcodes/sekere/#sekere","title":"sekere","text":"<p>Semi-physical model of a sekere sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/sekere/#syntax","title":"Syntax","text":"<pre><code>ares sekere iamp, idettack [, inum] [, idamp] [, imaxshake]\n</code></pre>"},{"location":"opcodes/sekere/#initialization","title":"Initialization","text":"<p>iamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only a approximation.</p> <p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 64.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.998 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.999 which means that the default value of idamp is 0.5. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 1.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p>"},{"location":"opcodes/sekere/#examples","title":"Examples","text":"<p>Here is an example of the sekere opcode. It uses the file sekere.csd.</p> Example of the sekere opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sekere.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidamp = p4                      ;vary damping amount\nasig  sekere 1, 0.01, 64, idamp\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 .1\ni1 + 1 .9\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sekere/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/sekere/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/semitone/","title":"Semitone","text":""},{"location":"opcodes/semitone/#semitone","title":"semitone","text":"<p>Calculates a factor to raise/lower a frequency by a given amount of semitones.</p>"},{"location":"opcodes/semitone/#syntax","title":"Syntax","text":"<pre><code>semitone(x)\n</code></pre> <p>This function works at a-rate, i-rate, and k-rate.</p>"},{"location":"opcodes/semitone/#initialization","title":"Initialization","text":"<p>x -- a value expressed in semitones.</p>"},{"location":"opcodes/semitone/#performance","title":"Performance","text":"<p>The value returned by the semitone function is a factor. You can multiply a frequency by this factor to raise/lower it by the given amount of semitones.</p>"},{"location":"opcodes/semitone/#examples","title":"Examples","text":"<p>Here is an example of the semitone opcode. It uses the file semitone.csd.</p> Example of the semitone opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o semitone.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niroot = 440             ; root note is A above middle-C (440 Hz)\nksem  lfo 12, .5, 5     ; generate sawtooth, go from 5 octaves higher to root\nksm = int(ksem)         ; produce only whole numbers\nkfactor = semitone(ksm) ; for semitones\nknew = iroot * kfactor\nprintk2 knew\nprintk2 kfactor\nasig pluck 1, knew, 1000, 0, 1 \nasig dcblock asig       ;remove DC\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like:</p> <pre><code>i1   880.00000\ni1     2.00000\ni1   830.65625\ni1     1.88786\ni1   783.94665\ni1     1.78170\ni1   739.98885\ni1     1.68179\ni1   698.49586\ni1     1.58749\ni1   659.21793\ni1     1.49822\ni1   622.25397\ni1     1.41421\ni1   587.36267\ni1     1.33492\ni1   554.33399\ni1     1.25985\ni1   523.25113\ni1     1.18921\ni1   493.91116\ni1     1.12253\ni1   466.13747\ni1     1.05940\ni1   440.00000\ni1     1.00000\n.......\n</code></pre>"},{"location":"opcodes/semitone/#see-also","title":"See also","text":"<p>Pitch Converters: Functions</p>"},{"location":"opcodes/semitone/#credits","title":"Credits","text":"<p>New in version 4.16</p>"},{"location":"opcodes/sense/","title":"Sense","text":""},{"location":"opcodes/sense/#sense","title":"sense","text":"<p>Same as the sensekey opcode.</p>"},{"location":"opcodes/sensekey/","title":"Sensekey","text":""},{"location":"opcodes/sensekey/#sensekey","title":"sensekey","text":"<p>Returns the ASCII code of a key that has been pressed, or -1 if no key has been pressed.</p>"},{"location":"opcodes/sensekey/#syntax","title":"Syntax","text":"<pre><code>kres[, kkeydown] sensekey\n</code></pre>"},{"location":"opcodes/sensekey/#performance","title":"Performance","text":"<p>kres - returns the ASCII value of a key which is pressed or released.</p> <p>kkeydown - returns 1 if the key was pressed, 0 if it was released or if there is no key event.</p> <p>kres can be used to read keyboard events from stdin and returns the ASCII value of any key that is pressed or released, or it returns -1 when there is no keyboard activity. The value of kkeydown is 1 when a key was pressed, or 0 otherwise. This behavior is emulated by default, so a key release is generated immediately after every key press. To have full functionality, FLTK can be used to capture keyboard events. FLpanel can be used to capture keyboard events and send them to the sensekey opcode, by adding an additional optional argument. See FLpanel for more information.</p> <p> Note</p> <p>This opcode can also be written as sense.</p>"},{"location":"opcodes/sensekey/#examples","title":"Examples","text":"<p>Here is an example of the sensekey opcode. It uses the file sensekey.csd.</p> Example of the sensekey opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac -d   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi - 2020\n\n; Initialize the global variables.\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\n\ninstr 1\n\n; Instr 1 trigger instr 2: every time you press any key, instr 2 produce a note.\n; The pitch of the tone produced by instr 2 is equal to the ASCII code of the key pressed.\n\ngkNumber, gkPress sensekey \n\nif changed(gkPress) == 1 then\n      if (gkPress == 1) then\n          event \"i\", 2, 0, 0.3\n      endif \nendif      \nendin\n\ninstr 2\n\niCps init i(gkNumber)\nprint iCps\nasig oscili 0.2, iCps, 1 \nkenvelope linseg 0, 0.1, 1, 0.1, 1, 0.1, 0\nouts asig*kenvelope, asig*kenvelope\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 1 0.3 0 0.2 0.3 0.5\n\ni 1 0 2000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sensekey/#see-also","title":"See also","text":"<p>Sensing and Control: Keyboard and mouse sensing</p>"},{"location":"opcodes/sensekey/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK October 2000</p> <p>New in Csound version 4.09. Renamed in Csound version 4.10.</p>"},{"location":"opcodes/seqtime/","title":"Seqtime","text":""},{"location":"opcodes/seqtime/#seqtime","title":"seqtime","text":"<p>Generates a trigger signal according to the values stored in a table.</p>"},{"location":"opcodes/seqtime/#syntax","title":"Syntax","text":"<pre><code>ktrig_out seqtime ktime_unit, kstart, kloop, kinitndx, kfn_times\n</code></pre>"},{"location":"opcodes/seqtime/#performance","title":"Performance","text":"<p>ktrig_out -- output trigger signal</p> <p>ktime_unit -- unit of measure of time, related to seconds.</p> <p>kstart -- start index of looped section</p> <p>kloop -- end index of looped section</p> <p>kinitndx -- initial index</p> <p> Note</p> <p>Although kinitndx is listed as k-rate, it is in fact accessed only at init-time. So if you are using a k-rate argument, it must be assigned with init.</p> <p>kfn_times -- number of table containing a sequence of times</p> <p>This opcode handles timed-sequences of groups of values stored into a table.</p> <p>seqtime generates a trigger signal (a sequence of impulses, see also trigger opcode), according to the values stored in the kfn_times table. This table should contain a series of delta-times (i.e. times beetween to adjacent events). The time units stored into table are expressed in seconds, but can be rescaled by means of ktime_unit argument. The table can be filled with GEN02 or by means of an external text-file containing numbers, with GEN23.</p> <p> Note</p> <p>Note that the kloop index marks the loop boundary and is NOT included in the looped elements. If you want to loop the first four elements, you would set kstart to 0 and kloop to 4.</p> <p>It is possible to start the sequence from a value different than the first, by assigning to kinitndx an index different than zero (which corresponds to the first value of the table). Normally the sequence is looped, and the start and end of loop can be adjusted by modifying kstart and kloop arguments. User must be sure that values of these arguments (as well as kinitndx) correspond to valid table numbers, otherwise Csound will crash (because no range-checking is implementeted).</p> <p>It is possible to disable loop (one-shot mode) by assigning the same value both to kstart and kloop arguments. In this case, the last read element will be the one corresponding to the value of such arguments.  Table can be read backward by assigning a negative kloop value. It is possible to trigger two events almost at the same time (actually separated by a k-cycle) by giving a zero value to the corresponding delta-time.  First element contained in the table should be zero, if the user intends to send a trigger impulse, it should come immediately after the orchestra instrument containing seqtime opcode.</p>"},{"location":"opcodes/seqtime/#examples","title":"Examples","text":"<p>Here is an example of the seqtime opcode. It uses the file seqtime.csd.</p> Example of the seqtime opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o seqtime.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n\n sr = 44100\n ksmps = 64\n nchnls = 1\n\n; By Tim Mortimer and Andres Cabrera 2007\n\n0dbfs = 1\n\ngisine         ftgen    0, 0, 8192, 10,    1\n;;; table defining an integer pitch set\ngipset    ftgen     0, 0, 4, -2, 8.00, 8.04, 8.07, 8.10\n;;;DELTA times for seqtime\ngidelta    ftgen    0, 0, 4, -2, .5, 1, .25, 1.25\n\n\n  instr 1\n\nkndx init 0\nktrigger init 0\n\nktime_unit init 1\nkstart init p4\nkloop init p5\nkinitndx init 0\nkfn_times init gidelta\n\nktrigger seqtime ktime_unit, kstart, kloop, kinitndx, kfn_times\n\nprintk2 ktrigger\n\n\nif (ktrigger &gt; 0) then\n   kpitch table kndx, gipset\n   event \"i\", 2, 0, 1, kpitch\n   kndx = kndx + 1\n   kndx = kndx % kloop\nendif\n\n  endin\n\n\n  instr 2\nicps = cpspch (p4)\na1    buzz    1, icps, 7, gisine\naamp expseg    0.00003,.02,1,p3-.02,0.00003\n\na1 = a1 * aamp * 0.5\n\nout a1\n  endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n;      start    dur   kstart  kloop\ni 1     0       7       0       4\ni 1     8       10      0       3\ni 1     19      10      4       4\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/seqtime/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/seqtime/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>November 2002. Added a note about the kinitndx parameter, thanks to Rasmus Ekman.</p> <p>New in version 4.06</p> <p>Example by: Tim Mortimer and Andres Cabrera 2007</p>"},{"location":"opcodes/seqtime2/","title":"Seqtime2","text":""},{"location":"opcodes/seqtime2/#seqtime2","title":"seqtime2","text":"<p>Generates a trigger signal according to the values stored in a table.</p>"},{"location":"opcodes/seqtime2/#syntax","title":"Syntax","text":"<pre><code>ktrig_out seqtime2 ktrig_in, ktime_unit, kstart, kloop, kinitndx, kfn_times\n</code></pre>"},{"location":"opcodes/seqtime2/#performance","title":"Performance","text":"<p>ktrig_out -- output trigger signal</p> <p>ktime_unit -- unit of measure of time, related to seconds.</p> <p>ktrig_in -- input trigger signal.</p> <p>kstart -- start index of looped section</p> <p>kloop -- end index of looped section</p> <p>kinitndx -- initial index</p> <p> Note</p> <p>Although kinitndx is listed as k-rate, it is in fact accessed only at init-time. So if you are using a k-rate argument, it must be assigned with init.</p> <p>kfn_times -- number of table containing a sequence of times</p> <p>This opcode handles timed-sequences of groups of values stored into a table.</p> <p>seqtime2 generates a trigger signal (a sequence of impulses, see also trigger opcode), according to the values stored in the kfn_times table. This table should contain a series of delta-times (i.e. times beetween to adjacent events). The time units stored into table are expressed in seconds, but can be rescaled by means of ktime_unit argument. The table can be filled with GEN02 or by means of an external text-file containing numbers, with GEN23.</p> <p>It is possible to start the sequence from a value different than the first, by assigning to initndx an index different than zero (which corresponds to the first value of the table). Normally the sequence is looped, and the start and end of loop can be adjusted by modifying kstart and kloop arguments. User must be sure that values of these arguments (as well as initndx) correspond to valid table numbers, otherwise Csound will crash (because no range-checking is implementeted).</p> <p>It is possible to disable loop (one-shot mode) by assigning the same value both to kstart and kloop arguments. In this case, the last read element will be the one corresponding to the value of such arguments.  Table can be read backward by assigning a negative kloop value. It is possible to trigger two events almost at the same time (actually separated by a k-cycle) by giving a zero value to the corresponding delta-time.  First element contained in the table should be zero, if the user intends to send a trigger impulse, it should come immediately after the orchestra instrument containing seqtime2 opcode.</p> <p>seqtime2 is similar to seqtime, the difference is that when ktrig_in contains a non-zero value, current index is reset to kinitndx value.  kinitndx can be varied at performance time.</p>"},{"location":"opcodes/seqtime2/#examples","title":"Examples","text":"<p>Here is an example of the seqtime2 opcode. It uses the file seqtime2.csd.</p> Example of the seqtime2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o seqtime2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngitabMap2 ftgen 57,0,512,-2, 1,1/4,1/4,1/8,1/8,1/8,1/8,1/4,1/4,.5,1/4,1/4,1/16,1/16,1/16,1/16,1/16,1/16,1/16,1/16\ngisine    ftgen 1,0,512,10, 1\n\ninstr 1\n\nktrigin metro   .333333333333\nktrig2  metro   1\n        schedkwhen ktrig2, 0,0, 2, 0, .1                        ; just to set the metronome!\nkspeed  init    1\n;                ktime_unit, kstart, kloop, initndx, kfn_times \nktrig   seqtime2 ktrigin, kspeed, 0, 20, 2, gitabMap2\n;ktrig  seqtime  kspeed, 0, 20, 0, gitabMap2                    ; try with seqtime too...               \n        schedkwhen ktrig, 0, 0, 3, 0, ktrig                     ; the duration is got from seqtime2 output!\nendin\n\ninstr 2\n\na1      line    1,p3,0\naout    oscili  0.7*a1,500,gisine\n        outs1   aout\nendin   \n\n\ninstr 3\n\na1      line    1,p3,0\naout    oscili  0.7*a1,1000,gisine\n        outs2   aout\nendin   \n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 20\n\n;f0 3600\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/seqtime2/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/seqtime2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"opcodes/sequencer/","title":"Sequencer","text":""},{"location":"opcodes/sequencer/#sequ","title":"sequ","text":"<p>Emulate a hardware sequencer</p> <p>Uses a collection of arrays to generate a sequence of events with variable tempo that can be played in forward, reverse, back and forth, and random directions. The max length of the arrays is 128, and it can be scaled dynamically. Permutational playback modes feature randomisation, probability and other algorithms.</p>"},{"location":"opcodes/sequencer/#syntax","title":"Syntax","text":"<pre><code>kres sequ irhythm[], iinstr[], idata[], kbpm, klen [, kmode] [, kstep] \\\n           [, kreset] [, kverbose]\nkres sequ irhythm[], iinstr[], idata[][], kbpm, klen [, kmode] [, kstep] \\\n          [, kreset] [, kverbose]\n</code></pre>"},{"location":"opcodes/sequencer/#initialization","title":"Initialization","text":"<p>irhythm  - array of durations in beats.  The actual duration is determined by these values divided by the current BPM.</p> <p>iinstr  -  array of instrument numbers scheduled per step. An instrument number zero does nothing. It skips the note associated with the step and produces a silence for that note's duration.</p> <p>idata  -  Either a vector of p4 values to the associated iinstr step or a two dimensional array of p4, p5, p6...values.  Typically, one would specify pitch information in cps, or MIDI note number; but the arbitrary list of p4 data values could have other uses in the called iinstr.</p>"},{"location":"opcodes/sequencer/#performance","title":"Performance","text":"<p>kbpm - speed of looping in beats per minute.</p> <p>klen - length of the active part of the sequence (starting from step 0).</p> <p>kmode - control the sequencer playback. A value of 0 (default) loops forward through the sequence, calling the associated instrument on each step. Other modes are supported. (See below).</p> <p>Current playback options for kmode are:</p> <ul> <li>0 - forward loop</li> <li>n&gt;0 - forward loop with a mutation every n events</li> <li>-1 - backward loop</li> <li>-2 - back and forth</li> <li>-3 - random events</li> <li>-4 - play the entire sequence forward one time and stop</li> <li>-5 - play the entire sequence backward one time and stop</li> <li>-6 - shuffle the events</li> <li>-7 - reset to the initial state</li> </ul> <p>kstep - if non zero replace the irhythm array with k-rate triggers. These could be from a MIDI keyboard or any other krate controller.  An event is scheduled if this argument is positive, and just waits if it is negative.  Default is zero.</p> <p>kreset - if non zero resets the sequencer (like mode -7). Default is zero.</p> <p>kverbose - if non zero prints messages about the internal state changes.  Default is zero.</p> <p>kres - gives the index of the event created for the current k-cycle, or -1 if no event happened.</p> <p> Note</p> <p>While the irhythm, iinstr, and idata, arrays are i-time, the values of the entries are read at k-rate when used.  This means that by using global i-rate vectors, it is possible (with care) to change the specific values and other details at performance time.</p>"},{"location":"opcodes/sequencer/#examples","title":"Examples","text":"<p>Here is an example of the sequ opcode. It uses the file sequ1.csd</p> Example of the sequ opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nksmps = 32\n0dbfs = 1.0\nnchnls = 2\n\ninstr 1\n;; rhythm array - these steps values multiplied by tempo (ticks) in BPM\nirhythm[] fillarray 1, 1.5, 0.5, 0.5, 0.5, 0.5, 1.5, 1\n\n;; instrument array - instrument number to render for each step\ninst0[] fillarray 11, 12, 13, 14, 15, 16, 17, 18\ninst1[] fillarray 19, 20, 21, 22, 23, 24, 25, 26\n\n;; note array - here in cpsmidinn - esentially the 'p4' output from opcode\n;;               can be any sequence of values\ninotes[] fillarray 60, 61, 62, 63, 64, 65, 66, 67\n\n;; variable tempo\nkspeed line 60, p3, 180\n\n;; rhythm, inst, notes, bpm, length, mode, verbose\nkSeq0 sequ irhythm, inst0, inotes, kspeed, 8\nkSeq1 sequ irhythm, inst1, inotes, kspeed * 1.2, 8\nendin\n\ninstr 11, 12, 13, 14, 15, 16, 17, 18\nkl linseg 0, p3*0.01, 1, p3*.99, 0\na1 oscil 0.9, cpsmidinn(p4)\nouts1 a1*kl\nendin\n\ninstr 19, 20, 21, 22, 23, 24, 25, 26\nkl linseg 0, p3*0.01, 1,p3*.99, 0\na1 oscil 0.9, cpsmidinn(p4)\nouts2 a1*kl\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 60\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the sequ opcode showing the various modes. It uses the file sequ2.csd</p> Example of the sequ opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nksmps = 32\n0dbfs = 1.0\nnchnls = 2\n\ninstr 1\n;; rhythm array - these values are multiplied by tempo (ticks) in BPM\nirhythm0[] fillarray 1, 1.5, 0.5, 0.5, 0.5, 0.5, 1.5, 1\n;; instrument array - instrument number to render for each step\niinsts0[] fillarray 11, 12, 13, 14, 15, 16, 17, 18\n;; note array - here cpsmidinn(p4), amps(p5), mod ratios(p6), mod indices(p7)\n;; - esentially the 'p4', 'p5', 'p6' and 'p7' are output from sequ\ninotes[][] init 4,8 ;initialize 4 rows with 8 columns - p4=pitch, p5=amp, p6=modratio, p7=modindex\ninotes fillarray 60, 61, 62, 63, 64, 65, 66, 67, \\\n                 0.8, 0.3, 0.6, 0.2, 0.7, 0.4, 0.5, 0.6, \\\n                 1, 2, 3, 4, 5, 6, 7, 8, \\\n                 1, 11, 2, 12, 3, 21, 4, 22\n;; NOTE: this can be any sequence of values\n;; variable tempo\nkspeed linseg 85, p3*.7, 85, p3*.3, 240\n;; rhythms, insts, notes, bpm, length, mode, step, reset, verbose\nkSeq sequ irhythm0, iinsts0, inotes, kspeed, 8, p4\nendin\n\ninstr 11, 12, 13, 14, 15, 16, 17, 18\nkenv linseg 0, p3*0.01, 1, p3*.99, 0\nasig foscil p5, cpsmidinn(p4), 1, p6, p7\noutall asig * kenv\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 15 0 ;; forward mode\ns\nf0 1\ns\ni1 0 15 -1 ;; backward mode\ns\nf0 1\ns\ni1 0 15 -2 ;; forward and backward mode\ns\nf0 1\ns\ni1 0 15 -3 ;; random\ns\nf0 1\ns\ni1 0 6 -4 ;; play forward once and stop\ns\nf0 1\ns\ni1 0 6 -5 ;; play backward once and stop\ns\nf0 1\ns\ni1 0 15 -6 ;; shuffle mode\ns\nf0 1\ns\ni1 0 30 1 ;; mutate after each step\ns\nf0 1\ns\ni1 0 30 2 ;; mutate each second step\ns\nf0 1\ns\ni1 0 30 4 ;; mutate every four steps\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sequencer/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/sequencer/#credits","title":"Credits","text":"<p>Written by John ffitch</p> <p>New in Csound 6.17</p>"},{"location":"opcodes/setcol/","title":"Setcol","text":""},{"location":"opcodes/setcol/#setcol","title":"setcol","text":"<p>Sets a given column of a 2-dimensional array from a vector.</p> <p>The output is an 2-d array with the contents of the requested column set to values of the input array (1-d; if 2-d the first row of the input array is used).</p>"},{"location":"opcodes/setcol/#syntax","title":"Syntax","text":"<pre><code>i/kout[] setcol i/kin[], i/kcol\n</code></pre>"},{"location":"opcodes/setcol/#initialization","title":"Initialization","text":"<p>iout[] -- output array containing the extracted column. It will be created if it does not exist.</p> <p>iin[] -- input array.</p> <p>icol -- column to be extracted.</p>"},{"location":"opcodes/setcol/#performance","title":"Performance","text":"<p>kout[] -- output array containing the set column. It will be created if it does not exist.</p> <p>kin[] -- input array.</p> <p>kcol -- column to be set.</p>"},{"location":"opcodes/setcol/#examples","title":"Examples","text":"<p>Here is an example of the setcol opcode. It uses the file setcol.csd.</p> Example of the setcol opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n kcnt init 0\n kArr[] init 3,3\n kVec[] fillarray  0,1,2\n while kcnt &lt; 3 do\n  kArr setcol kVec,kcnt\n  printf \"column %d: %d %d %d\\n\",kcnt+1,kcnt,kArr[0][kcnt],kArr[1][kcnt],kArr[2][kcnt] \n  kcnt += 1\n od\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/setcol/#see-also","title":"See Also","text":"<p>Vectorial Opcodes</p> <p>Array Opcodes</p>"},{"location":"opcodes/setcol/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2014</p> <p>New in version 6.04</p>"},{"location":"opcodes/setctrl/","title":"Setctrl","text":""},{"location":"opcodes/setctrl/#setctrl","title":"setctrl","text":"<p>Configurable slider controls for realtime user input.</p> <p>Plugin opcode in control.</p> <p>Requires Winsound or TCL/TK. setctrl sets a slider to a specific value, or sets a minimum or maximum range.</p>"},{"location":"opcodes/setctrl/#syntax","title":"Syntax","text":"<pre><code>setctrl inum, ival, itype\n</code></pre>"},{"location":"opcodes/setctrl/#initialization","title":"Initialization","text":"<p>Note that this opcode is not available on Windows due to the implimentation of pipes on that system.</p> <p>inum -- number of the slider to set</p> <p>ival -- value to be sent to the slider</p> <p>itype -- type of value sent to the slider as follows:</p> <ul> <li>1 -- set the current value. Initial value is 0.</li> <li>2 -- set the minimum value. Default is 0.</li> <li>3 -- set the maximum value. Default is 127.</li> <li>4 -- set the label. (New in Csound version 4.09)</li> </ul>"},{"location":"opcodes/setctrl/#performance","title":"Performance","text":"<p>Calling setctrl will create a new slider on the screen. There is no theoretical limit to the number of sliders. Windows and TCL/TK use only integers for slider values, so the values may need rescaling. GUIs usually pass values at a fairly slow rate, so it may be advisable to pass the output of control through port.</p>"},{"location":"opcodes/setctrl/#examples","title":"Examples","text":"<p>Here is an example of the setctrl opcode. It uses the file setctrl.csd.</p> Example of the setctrl opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o setctrl.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Display the label \"Volume\" on Slider #1.\n  setctrl 1, \"Volume\", 4\n  ; Set Slider #1's initial value to 20.\n  setctrl 1, 20, 1\n\n  ; Capture and display the values for Slider #1.\n  k1 control 1\n  printk2 k1\n\n  ; Play a simple oscillator.\n  ; Use the values from Slider #1 for amplitude.\n  kamp = k1 * 128\n  a1 oscil kamp, 440, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for thirty seconds.\ni 1 0 30\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>i1    38.00000\ni1    40.00000\ni1    43.00000\n</code></pre>"},{"location":"opcodes/setctrl/#see-also","title":"See also","text":"<p>Sensing and Control: TCL/TK widgets</p>"},{"location":"opcodes/setctrl/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK May 2000</p> <p>Example written by Kevin Conder.</p> <p>New in Csound version 4.06</p>"},{"location":"opcodes/setrow/","title":"Setrow","text":""},{"location":"opcodes/setrow/#setrow","title":"setrow","text":"<p>Sets a given row of a 2-dimensional array from a vector.</p> <p>The output is an 2-d array with the contents of the requested row set to values of the input array (1-d; if 2-d the first row of the input array is used).</p>"},{"location":"opcodes/setrow/#syntax","title":"Syntax","text":"<pre><code>i/kout[] setrow i/kin[], i/krow\n</code></pre>"},{"location":"opcodes/setrow/#initialization","title":"Initialization","text":"<p>iout[] -- output array containing the set row. It will be created if it does not exist.</p> <p>iin[] -- input array.</p> <p>irow -- row to be set.</p>"},{"location":"opcodes/setrow/#performance","title":"Performance","text":"<p>kout[] -- output array containing the set row. It will be created if it does not exist.</p> <p>kin[] -- input array.</p> <p>krow -- row to be set.</p>"},{"location":"opcodes/setrow/#examples","title":"Examples","text":"<p>Here is an example of the setrow opcode. It uses the file rfft.csd.</p> Example of the setrow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n-d -o dac\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n;ksmps needs to be an integer div of hopsize\nksmps = 64\n0dbfs=1\n\ninstr 1\n\n ihopsize = 256   ; hopsize\n ifftsize = 1024  ; FFT size\n iolaps = ifftsize/ihopsize ; overlaps\n ibw = sr/ifftsize ; bin bandwidth\n kcnt init 0    ; counting vars\n krow init 0\n\n kOla[] init ifftsize ; overlap-add buffer\n kIn[] init ifftsize  ; input buffer\n kSw[] init ifftsize\n kOut[][] init iolaps, ifftsize ; output buffers\n\n a1 diskin2 \"fox.wav\",1,0,1 ; audio input\n ks  expon  100, p3, 1000\n asw vco2  0.15, ks\n\n /* every hopsize samples */\n if kcnt == ihopsize then\n   /* window and take FFT */\n   kWin[] window kIn,krow*ihopsize\n   kSpec[] rfft kWin\n   kWin window kSw,krow*ihopsize\n   kSpec2[] rfft kWin\n   kProd[] cmplxprod kSpec, kSpec2\n\n   /* IFFT + window */\n   kRow[] rifft kProd + kSpec\n   kWin window kRow, krow*ihopsize\n   /* place it on out buffer */\n   kOut setrow kWin, krow\n\n   /* zero the ola buffer */\n   kOla = 0\n   /* overlap-add */\n   ki = 0\n   until ki == iolaps do\n     kRow getrow kOut, ki\n     kOla = kOla + kRow\n     ki += 1\n   od\n\n  /* update counters */\n  krow = (krow+1)%iolaps\n  kcnt = 0\n endif\n\n /* shift audio in/out of buffers */\n kIn shiftin a1\n kSw shiftin asw\n a2 shiftout kOla\n    out a2/iolaps\n\n /* increment counter */\n kcnt += ksmps\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 10\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/setrow/#see-also","title":"See Also","text":"<p>Vectorial Opcodes</p> <p>Array Opcodes</p>"},{"location":"opcodes/setrow/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini NUI Maynooth 2014</p> <p>New in version 6.04</p>"},{"location":"opcodes/setscorepos/","title":"Setscorepos","text":""},{"location":"opcodes/setscorepos/#setscorepos","title":"setscorepos","text":"<p>Sets the playback position of the current score performance to a given position.</p>"},{"location":"opcodes/setscorepos/#syntax","title":"Syntax","text":"<pre><code>setscorepos ipos\n</code></pre>"},{"location":"opcodes/setscorepos/#initialization","title":"Initialization","text":"<p>ipos -- playback position in seconds.</p>"},{"location":"opcodes/setscorepos/#examples","title":"Examples","text":"<p>Here is an example of the setscorepos opcode. It uses the file setscorepos.csd.</p> Example of the setscorepos opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o setscorepos.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 8192, 10, 1\n\ninstr 1\n\nasig poscil 0.5, p4, giSine             ;play something\n     outs asig, asig\nendin\n\ninstr 11\n\nsetscorepos 8.5                         \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 2 220      ;this one will be played\ni11 2.5 1       ;start setscorepos now\ni1 3 2 330      ;skip this note\ni1 6 2 440      ;and this one\ni1 9 2 550      ;play this one        \n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/setscorepos/#see-also","title":"See also","text":"<p>Sensing and Control: Score control</p>"},{"location":"opcodes/setscorepos/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini 2008</p> <p>New in Csound version 5.09</p>"},{"location":"opcodes/sfilist/","title":"Sfilist","text":""},{"location":"opcodes/sfilist/#sfilist","title":"sfilist","text":"<p>Prints a list of all instruments of a previously loaded SoundFont2 (SF2) sample file.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfilist/#syntax","title":"Syntax","text":"<pre><code>sfilist ifilhandle [, Sprintprefix]\n</code></pre>"},{"location":"opcodes/sfilist/#initialization","title":"Initialization","text":"<p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>Sprintprefix -- A string prefix to prepend to each instrument row printed</p>"},{"location":"opcodes/sfilist/#performance","title":"Performance","text":"<p>sfilist prints a list of all instruments of a previously loaded SF2 file to the console.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfilist/#examples","title":"Examples","text":"<p>Here is an example of the sfilist opcode. It uses the file sfilist.csd.</p> Example of the sfilist opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfilist.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisf    sfload  \"sf_GMbank.sf2\"\n        sfilist gisf                                            ;lists all instruments of Soundfont\n\ninstr 1 \n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/250000                                           ;scale amplitude, small value due to 0dbfs = 1\nkfreq   =       1                                               ;do not change freq from sf\na1, a2  sfinstr3 ivel, inum, kamp*ivel, kfreq, p6, gisf        ;p6 chooses instrument, make amp velocity dependent\n        outs    a1, a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127 100       ;Halo Pad\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\n\ni1 5 1 60 127 1         ;Piano 2\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>Instrument list of \"sf_GMbank.sf2\"\n0) Piano 1\n1) Piano 2\n2) CP 70\n3) EP 1 layer 1\n4) EP 1 layer 2\n5) E.Piano 2\n6) Harpsichord\n.......\n100) Halo Pad\n.......\n</code></pre>"},{"location":"opcodes/sfilist/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfilist/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfinstr/","title":"Sfinstr","text":""},{"location":"opcodes/sfinstr/#sfinstr","title":"sfinstr","text":"<p>Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfinstr/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 sfinstr ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n                 [, iflag] [, ioffset]\n</code></pre>"},{"location":"opcodes/sfinstr/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>instrnum -- number of an instrument of a SF2 file.</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p>"},{"location":"opcodes/sfinstr/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>sfinstr plays an SF2 instrument instead of a preset (an SF2 instrument is the base of a preset layer). instrnum specifies the instrument number, and the user must be sure that the specified number belongs to an existing instrument of a determinate soundfont bank. Notice that both xamp and xfreq can operate at k-rate as well as a-rate, but both arguments must work at the same rate.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfinstr/#examples","title":"Examples","text":"<p>Here is an example of the sfinstr opcode. It uses the file sfinstr.csd.</p> Example of the sfinstr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfinstr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32\nnchnls = 2\n0dbfs  = 1 \n\n; By  Menno Knevel - 2020\n\ngisf    sfload  \"sf_GMbank.sf2\"\n        sfilist gisf\n\ninstr 1 \n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/500000                                           ;scale amplitude\nkfreq   =       1                                               ;do not change freq from sf\na1,a2   sfinstr ivel, inum, kamp*ivel, kfreq, 194, gisf         ;= Strings 2 tighter, make amp velocity dependent\n        outs    a1, a2  \n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127\ni1 + 1 62 &lt;\ni1 + 1 65 &lt;\ni1 + 1 69 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfinstr/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfinstr/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfinstr3/","title":"Sfinstr3","text":""},{"location":"opcodes/sfinstr3/#sfinstr3","title":"sfinstr3","text":"<p>Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound with cubic interpolation.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfinstr3/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 sfinstr3 ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n                  [, iflag] [, ioffset]\n</code></pre>"},{"location":"opcodes/sfinstr3/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>instrnum -- number of an instrument of a SF2 file.</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p>"},{"location":"opcodes/sfinstr3/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>sfinstr3 is a cubic-interpolation version of sfinstr. Difference of sound-quality is noticeable specially in bass-frequency-transposed samples. In high-freq-transposed samples the difference is less noticeable, and I suggest to use linear-interpolation versions, because they are faster.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfinstr3/#examples","title":"Examples","text":"<p>Here is an example of the sfinstr3 opcode. It uses the file sfinstr3.csd.</p> Example of the sfinstr3 opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfinstr3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\n; By  Menno Knevel - 2020\n\nsr = 44100 \nksmps = 32\nnchnls = 2\n0dbfs  = 1 \n\ngi24   ftgen 1, 0, 32, -2, 24, 2, 261.626, 60, 1, 1.0293022, 1.059463, 1.0905076, 1.1224619, 1.1553525, 1.1892069, \\\n             1.2240532, 1.2599207, 1.2968391, 1.33483924, 1.3739531, 1.414213, 1.4556525, 1.4983063, 1.54221, 1.5874001, \\\n             1.6339145, 1.6817917, 1.73107, 1.7817962, 1.8340067, 1.8877471, 1.9430623,  2 ;table for microtuning, a 24 tone equal temperament\n\ngiSF    sfload  \"sf_GMbank.sf2\" \n        sfilist giSF \n\ninstr 1 \n\nikey    = p4\nivel    = p5\naenv    linsegr 1, 1, 1, 1, 0                   ;envelope\nicps    cpstuni ikey, 1                         ;24 tones per octave\niamp    = 0.0002                                ;scale amplitude\niamp    = iamp * ivel * 1/128                   ;make velocity-dependent, small value due to 0dbfs = 1\naL, aR  sfinstr3 ivel, ikey, iamp, icps, 180, giSF, 1 ;= Slap Bass 3\naL      = aL * aenv \naR      = aR * aenv \n        outs aL, aR \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni1 0 1 60 100 1 ;using ftable 1\ni1 + 1 62 &lt;   .\ni1 + 1 65 &lt;   .\ni1 + 1 69 20  .\n\ni1 5 1 60 100 1 ;using ftable 1\ni1 + 1 61 &lt;   .\ni1 + 1 62 &lt;   .\ni1 + 1 63 20  .\n\ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/sfinstr3/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfinstr3/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfinstr3m/","title":"Sfinstr3m","text":""},{"location":"opcodes/sfinstr3m/#sfinstr3m","title":"sfinstr3m","text":"<p>Plays a SoundFont2 (SF2) sample instrument, generating a mono sound with cubic interpolation.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfinstr3m/#syntax","title":"Syntax","text":"<pre><code>ares sfinstr3m ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n               [, iflag] [, ioffset]\n</code></pre>"},{"location":"opcodes/sfinstr3m/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>instrnum -- number of an instrument of a SF2 file.</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p>"},{"location":"opcodes/sfinstr3m/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>sfinstr3m is a cubic-interpolation version of sfinstrm. Difference of sound-quality is noticeable specially in bass-frequency-transposed samples. In high-freq-transposed samples the difference is less noticeable, and I suggest to use linear-interpolation versions, because they are faster.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfinstr3m/#examples","title":"Examples","text":"<p>Here is an example of the sfinstr3m opcode. It uses the file sfinstr3m.csd.</p> Example of the sfinstr3m opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfinstr3m.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32\nnchnls = 2\n0dbfs  = 1 \n\n; By  Menno Knevel - 2020\n\ngisf    sfload  \"07AcousticGuitar.sf2\"\n        sfilist gisf\n\ninstr 1 \n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/900000                                           ;scale amplitude, small value because of 0dbfs  = 1 \nkfreq   =       1                                               ;do not change freq from sf\naout    sfinstr3m ivel, inum, kamp*ivel, kfreq, 0, gisf\n        outs    aout, aout\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127\ni1 + 1 62 &lt;\ni1 + 1 65 &lt;\ni1 + 1 69 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfinstr3m/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfinstr3m/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfinstrm/","title":"Sfinstrm","text":""},{"location":"opcodes/sfinstrm/#sfinstrm","title":"sfinstrm","text":"<p>Plays a SoundFont2 (SF2) sample instrument, generating a mono sound.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfinstrm/#syntax","title":"Syntax","text":"<pre><code>ares sfinstrm ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \\\n              [, iflag] [, ioffset]\n</code></pre>"},{"location":"opcodes/sfinstrm/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>instrnum -- number of an instrument of a SF2 file.</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p>"},{"location":"opcodes/sfinstrm/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>sfinstrm is a mono version of sfinstr. This is the fastest opcode of the SF2 family.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfinstrm/#examples","title":"Examples","text":"<p>See the example for sfinstr.</p>"},{"location":"opcodes/sfinstrm/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfinstrm/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfload/","title":"Sfload","text":""},{"location":"opcodes/sfload/#sfload","title":"sfload","text":"<p>Loads an entire SoundFont2 (SF2) sample file into memory.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p> <p>sfload should be placed in the header section of a Csound orchestra.</p>"},{"location":"opcodes/sfload/#syntax","title":"Syntax","text":"<pre><code>ir sfload \"filename\"\n</code></pre>"},{"location":"opcodes/sfload/#initialization","title":"Initialization","text":"<p>ir -- output to be used by other SF2 opcodes. For sfload, ir is ifilhandle.</p> <p>\u201cfilename\u201d -- name of the SF2 file, with its complete path. It must be a string typed within double-quotes with \u201c/\u201d to separate directories (this applies to DOS and Windows as well, where using a backslash will generate an error), or an integer that has been the subject of a strset operation</p>"},{"location":"opcodes/sfload/#performance","title":"Performance","text":"<p>sfload loads an entire SF2 file into memory. It returns a file handle to be used by other opcodes. Several instances of sfload can placed in the header section of an orchestra, allowing use of more than one SF2 file in a single orchestra.</p> <p>If there is an attempt to load the same file twice the existing load is used with a warning message (from version 6.14).</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p> <p>It should be noted that before version 5.12 a maximum of 10 sound fonts could be loaded, a restriction since relaxed.</p>"},{"location":"opcodes/sfload/#examples","title":"Examples","text":"<p>Here is an example of the sfload opcode. It uses the file sfload.csd.</p> Example of the sfload opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out, virtual midi in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfload.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; load in two soundfonts\nisf     sfload  \"sf_GMbank.sf2\"\nir      sfload  \"07AcousticGuitar.sf2\"\n        sfplist isf\n        sfplist ir\n; first sf_GMbank.sf2 is loaded and assigned to start at 0 and counting up to 328\n; as there are 329 presets in sf_GMbank.sf2 (0-328).\n; then 07AcousticGuitar.sf2 is loaded and assigned to replace the 10th preset of already loaded sf_GMbank.sf2\n        sfpassign       0, isf  \n        sfpassign       10, ir\n\ninstr 1 ; play French Horn, bank 0 program 60\n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/500000                                           ;scale amplitude\nkfreq   =       1                                               ;do not change freq from sf\na1,a2   sfplay3 ivel, inum, kamp*ivel, kfreq, 60                        ;preset index = 60\n        outs    a1, a2  \nendin\n\ninstr 2 ; play Guitar replaces sf_GMbank.sf2 at preset index 10\n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/700000                                           ;scale amplitude\nkfreq   =       1                                               ;do not change freq from sf\na1,a2   sfplay3 ivel, inum, kamp*ivel, kfreq, 10                        ;preset index = 10\n        outs    a1, a2  \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 100\ni1 + 1 62 &lt;\ni1 + 1 65 &lt;\ni1 + 1 69 10\n\ni2 5 1 60 100\ni2 + 1 62 &lt;\ni2 7 1 65 &lt;\ni2 7 1 69 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfload/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfload/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sflooper/","title":"Sflooper","text":""},{"location":"opcodes/sflooper/#sflooper","title":"sflooper","text":"<p>Plays a SoundFont2 (SF2) sample preset, generating a stereo sound, with user-defined time-varying crossfade looping.</p> <p>Similar to sfplay. Unlike that opcode, though, it ignores the looping points set in the SF2 file and substitutes them for a user-defined crossfade loop. It is a cross between sfplay and flooper2. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2  format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sflooper/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 sflooper ivel, inotenum, kamp, kpitch, ipreindex, kloopstart, \\\n                  kloopend, kcrossfade [, istart, imode, ifenv, iskip, iflag]\n</code></pre>"},{"location":"opcodes/sflooper/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>ipreindex -- preset index</p> <p>_istart _ -- playback start pos in seconds</p> <p>_imode _ -- loop modes: 0 forward, 1 backward, 2 back-and-forth [def: 0]</p> <p>_ifenv _ -- if non-zero, crossfade envelope shape table number. The default, 0, sets the crossfade to linear.</p> <p>_iskip _ -- if 1, the opcode initialisation is skipped, for tied notes, performance continues from the position in the loop where the previous note stopped. The default, 0, does not skip initialisation</p> <p>iflag -- flag regarding the behavior of kpitch and inotenum</p>"},{"location":"opcodes/sflooper/#performance","title":"Performance","text":"<p>kamp -- amplitude scaling</p> <p>kpitch -- pitch control (transposition ratio, negative values are not allowed) or frequency multiplier, depending by iflag. When iflag = 0, kpitch is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, kpitch is the absolute frequency of the output sound, in Hz. Default is 0. When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and kpitch is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by kpitch. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>kloopstart -- loop start point (secs). Note that although k-rate, loop parameters such as this are only updated once per loop cycle. If loop start is set beyond the end of the sample, no looping will result.</p> <p>kloopend -- loop end point (secs), updated once per loop cycle.</p> <p>_kcrossfade _ -- crossfade length (secs), updated once per loop cycle and limited to loop length.</p> <p>sflooper plays a preset, generating a stereo sound.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p> <p>Note: The looping points are set on the root key of every sample that is part of the preset of the soundfont. For instance, a soundfont can have a single sample for the whole keyboard. In that case, sflooper will work like flooper and flooper2, because as the sample is transposed, played back at different rates, the loop will get short or longer. If however the soundfont has a sample for each key, than there will be no transposition and the loop will stay the same length (unless you change kpitch).</p>"},{"location":"opcodes/sflooper/#examples","title":"Examples","text":"<p>Here is an example of the sflooper opcode. It uses the file sflooper.csd.</p> Example of the sflooper opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac   ;;;realtime audio in\n; For Non-realtime ouput leave only the line below:\n; -o sflooper.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by  Menno Knevel - 2021\n\nisf   sfload \"07AcousticGuitar.sf2\"\n      sfpassign 0, isf\n\ninstr 1 \n\ninum  = p4\nivel  = p5\nkamp  linsegr 1,1,1,.1,0        ; declick envelope\nkamp  = kamp * .0000015         ;scale amplitude\nifreq = 1                       ;do not change freq from sf\n;\"07AcousticGuitar.sf2\" contains 2 samples, on notes E1 and C#4\n;start loop from beginning, loop .2 seconds - on the root key of these samples\naL,aR sflooper ivel, inum, kamp*ivel, ifreq, 0, 0, .2, .05  ; make amp velocity dependent\n      outs aL, aR\nendin\n\ninstr 2 \n\nifreq  = p4\nivel  = p5\nkamp  linsegr 1,1,1,.1,0        ; declick envelope\nkamp  = kamp * .0000015         ;scale amplitude\ninum = 60                       ;take soundfont samples belonging to midi index 60\n\n;nearly identical instr, but now takes midi note sound 60 as reference, set iflag to 1\naL,aR sflooper ivel, inum, kamp*ivel, ifreq, 0, 0, .2, .05, 0, 0, 0, 0, 1  ; &amp; use ifreq for frequency\n      outs aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 120   ; p4 = midi note\ni1 + 1 62 &lt;\ni1 + 1 65 &lt;\ni1 + 1 69 10\n\n\ni2 5 1 200 120  ; p4 = frequency\ni2 + 1 261 &lt;\ni2 + 1 300 &lt;\ni2 + 1 1000 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sflooper/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sflooper/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini August 2007</p> <p>New in Csound Version 5.07</p>"},{"location":"opcodes/sfpassign/","title":"Sfpassign","text":""},{"location":"opcodes/sfpassign/#sfpassign","title":"sfpassign","text":"<p>Assigns all presets of a SoundFont2 (SF2) sample file to a sequence of progressive index numbers.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p> <p>sfpassign should be placed in the header section of a Csound orchestra.</p>"},{"location":"opcodes/sfpassign/#syntax","title":"Syntax","text":"<pre><code>sfpassign istartindex, ifilhandle[, imsgs]\n</code></pre>"},{"location":"opcodes/sfpassign/#initialization","title":"Initialization","text":"<p>istartindex -- starting index preset by the user in bulk preset assignments.</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>imsgs -- if non-zero messages are suppressed.</p>"},{"location":"opcodes/sfpassign/#performance","title":"Performance","text":"<p>sfpassign assigns all presets of a previously loaded SF2 file to a sequence of progressive index numbers, to be used later with the opcodes sfplay and sfplaym. istartindex specifies the starting index number. Any number of sfpassign instances can be placed in the header section of an orchestra, each one assigning presets belonging to different SF2 files.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfpassign/#examples","title":"Examples","text":"<p>Here is an example of the sfpassign opcode. It uses the file sfpassign.csd.</p> Example of the sfpassign opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out, virtual midi in\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfpassign.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n;load three soundfonts\ngisf    sfload  \"sf_GMbank.sf2\"\ngir     sfload  \"01hpschd.sf2\"\ngiv     sfload  \"07AcousticGuitar.sf2\"\n        sfplist gisf\n        sfplist gir\n        sfplist giv\n\n; first, sf_GMbank.sf2 is loaded and assigned to start at 0 and counting up to 328\n; as there are 329 presets in sf_GMbank.sf2.\n; then 01hpschd.sf2 is loaded and assigned to replace the 100th preset of sf_GMbank.sf2\n; then 07AcousticGuitar.sf2 is loaded and assigned to replace the 20th preset of sf_GMbank.sf2\n\n        sfpassign       0, gisf \n        sfpassign       100, gir\n        sfpassign       20, giv\n\ninstr 1 \n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/600000 * ivel                                    ;scale amplitude and velocity dependent\nkfreq   =       1                                               ;do not change freq from sf\na1,a2   sfplay3 ivel, inum, kamp, kfreq, p6                     ;preset index starts at 0, counting up\n        outs    a1, a2\n\n        endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 100   0   ; Piano 1 from sf_GMbank.sf2\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\n\ni1 5 1 60 100   100 ; harpsichord from 01hpschd.sf2\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\n\ni1 10 1 60 100   20 ; guitar from 07AcousticGuitar.sf2\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\n\ni1 15 1 60 100   101 ; Goblin from sf_GMbank.sf2\ni1 + 1 62 &lt;     .\ni1 + 1 65 &lt;     .\ni1 + 1 69 10    .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfpassign/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfpassign/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfplay/","title":"Sfplay","text":""},{"location":"opcodes/sfplay/#sfplay","title":"sfplay","text":"<p>Plays a SoundFont2 (SF2) sample preset, generating a stereo sound.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfplay/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 sfplay ivel, inotenum, xamp, xfreq, ipreindex [, iflag] \\\n                [, ioffset] [, ienv]\n</code></pre>"},{"location":"opcodes/sfplay/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>ipreindex -- preset index</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p> <p>ienv (optional) -- enables and determines amplitude envelope. 0 = no envelope, 1 = linear attack and decay, 2 = linear attack, exponential decay (see below). Default = 0.</p>"},{"location":"opcodes/sfplay/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>Notice that both xamp and xfreq can use k-rate as well as a-rate signals. Both arguments must use variables of the same rate, or sfplay will not work correctly. ipreindex must contain the number of a previously assigned preset, or Csound will crash.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>The ienv parameter enables and determines the type of amplitude envelope used. The default value is 0, or no envelope. If ienv is set to 1, the attack and decay portions are linear. If set to 2, the attack is linear and the decay is exponential. The release portion of the envelope has not yet been implemented.</p> <p>sfplay plays a preset, generating a stereo sound. ivel does not directly affect the amplitude of the output, but informs sfplay about which sample should be chosen in multi-sample, velocity-split presets.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfplay/#examples","title":"Examples","text":"<p>See the example for sfplay3.</p>"},{"location":"opcodes/sfplay/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfplay/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p> <p>New optional parameter ienv in version 5.09</p>"},{"location":"opcodes/sfplay3/","title":"Sfplay3","text":""},{"location":"opcodes/sfplay3/#sfplay3","title":"sfplay3","text":"<p>Plays a SoundFont2 (SF2) sample preset, generating a stereo sound with cubic interpolation.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfplay3/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 sfplay3 ivel, inotenum, xamp, xfreq, ipreindex [, iflag] \\\n                 [, ioffset] [, ienv]\n</code></pre>"},{"location":"opcodes/sfplay3/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>ipreindex -- preset index</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p> <p>ienv (optional) -- enables and determines amplitude envelope. 0 = no envelope, 1 = linear attack and decay, 2 = linear attack, exponential decay (see below). Default = 0.</p>"},{"location":"opcodes/sfplay3/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>Notice that both xamp and xfreq can use k-rate as well as a-rate signals. Both arguments must use variables of the same rate, or sfplay3 will not work correctly. ipreindex must contain the number of a previously assigned preset, or Csound will crash.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>The ienv parameter enables and determines the type of amplitude envelope used. The default value is 0, or no envelope. If ienv is set to 1, the attack and decay portions are linear. If set to 2, the attack is linear and the decay is exponential. The release portion of the envelope has not yet been implemented.</p> <p>sfplay3 plays a preset, generating a stereo sound with cubic interpolation. ivel does not directly affect the amplitude of the output, but informs sfplay3 about which sample should be chosen in multi-sample, velocity-split presets.</p> <p>sfplay3 is a cubic-interpolation version of sfplay. Difference of sound-quality is noticeable specially in bass-frequency-transposed samples. In high-freq-transposed samples the difference is less noticeable, and I suggest to use linear-interpolation versions, because they are faster.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfplay3/#examples","title":"Examples","text":"<p>Here is an example of the sfplay3 opcode. It uses the file sfplay3.csd.</p> Example of the sfplay3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfplay3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr  =   44100\nksmps   =   32\nnchnls  =   2\n0dbfs   =   1 \n\ngitwelve ftgen 1, 0, 16, -2, 12, 2, 440, 69, 1, 16/15, 9/8, 6/5, 5/4, 4/3, 7/5, 3/2, 8/5, 5/3, 9/5, 15/8, 2 \ngivife   ftgen 2, 0, 16, -2, 5, 2, 261.659, 60, 1, 1.1486, 1.3195, 1.5157, 1.7411, 2.00\n\ngiSF    sfload  \"01hpschd.sf2\" \n        sfplist giSF \ngipre   sfpreset 0, 0, giSF, 0 \n\n\ninstr 1\n\nikey    = p4\nivel    = p5\naenv    linsegr 1, 1, 1, 1, 0                   ;envelope\nicps    cpstuni ikey, gitwelve                  ;12 tones per octave\niamp    = 0.00001                                ;scale amplitude down a lot, due to 0dbfs  = 1 \niamp    *= ivel                                  ;make velocity-dependent\n\naL, aR  sfplay3 ivel, ikey, iamp, icps, gipre, 1 \naL      = aL * aenv \naR      = aR * aenv \n        outs aL, aR \n\n        endin\n\ninstr 2 \n\nikey    = p4\nivel    = p5\naenv    linsegr 1, 1, 1, 1, 0                   ;envelope\nicps    cpstuni ikey, givife                    ;5 tones per octave\niamp    = 0.00001                                 ;scale amplitude down a lot, due to 0dbfs  = 1 \niamp    *= ivel                                  ;make velocity-dependent\n\naL, aR  sfplay3 ivel, ikey, iamp, icps, gipre, 1 \naL      = aL * aenv \naR      = aR * aenv \n        outs aL, aR \n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;instr.1 using ftable 1\ni1 0 1 60 100 \ni1 + 1 62 &lt;  \ni1 + 1 65 &lt;   \ni1 + 1 69 40  \n\n;instr.2 using ftable 2\ni2 5 1 60 100 \ni2 + 1 62 &lt;   \ni2 + 1 65 &lt;   \ni2 + 1 69 40  \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfplay3/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfplay3/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p> <p>New optional parameter ienv in version 5.09</p>"},{"location":"opcodes/sfplay3m/","title":"Sfplay3m","text":""},{"location":"opcodes/sfplay3m/#sfplay3m","title":"sfplay3m","text":"<p>Plays a SoundFont2 (SF2) sample preset, generating a mono sound with cubic interpolation.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfplay3m/#syntax","title":"Syntax","text":"<pre><code>ares sfplay3m ivel, inotenum, xamp, xfreq, ipreindex [, iflag] \\\n              [, ioffset] [, ienv]\n</code></pre>"},{"location":"opcodes/sfplay3m/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>ipreindex -- preset index</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p> <p>ienv (optional) -- enables and determines amplitude envelope. 0 = no envelope, 1 = linear attack and decay, 2 = linear attack, exponential decay (see below). Default = 0.</p>"},{"location":"opcodes/sfplay3m/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>Notice that both xamp and xfreq can use k-rate as well as a-rate signals. Both arguments must use variables of the same rate, or sfplay3m will not work correctly. ipreindex must contain the number of a previously assigned preset, or Csound will crash.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>The ienv parameter enables and determines the type of amplitude envelope used. The default value is 0, or no envelope. If ienv is set to 1, the attack and decay portions are linear. If set to 2, the attack is linear and the decay is exponential. The release portion of the envelope has not yet been implemented.</p> <p>sfplay3m is a mono version of sfplay3. It should be used with mono preset, or with the stereo presets in which stereo output is not required. It is faster than sfplay3.</p> <p>sfplay3m is also a cubic-interpolation version of sfplaym. Difference of sound-quality is noticeable specially in bass-frequency-transposed samples. In high-freq-transposed samples the difference is less noticeable, and I suggest to use linear-interpolation versions, because they are faster.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfplay3m/#examples","title":"Examples","text":"<p>Here is an example of the sfplay3m opcode. It uses the file sfplay3m.csd.</p> Example of the sfplay3m opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfplay3m.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100 \nksmps = 32\nnchnls = 2\n0dbfs  = 1 \n\n\ngisf    sfload  \"07AcousticGuitar.sf2\"\n        sfplist gisf\n        sfpassign 0, gisf    ; assign the preset to number 00 \n\ninstr 1 \n\ninum    =   p4\nivel    =   p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/900000 * ivel                    ;scale amplitude and make velocity dependent\nkfreq   =       1                                               ;do not change freq from sf\naout    sfplay3m ivel, inum, kamp, p6, 0, 1        ;preset index = 0, set flag to frequency instead of midi pitch\n        outs    aout, aout\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127 400   ; take the samples from key 60 and set new frequency\ni1 + 1 60 90   &lt;\ni1 + 1 60 60   &lt;\ni1 + 1 60 10  200\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfplay3m/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfplay3m/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p> <p>New optional parameter ienv in version 5.09</p>"},{"location":"opcodes/sfplaym/","title":"Sfplaym","text":""},{"location":"opcodes/sfplaym/#sfplaym","title":"sfplaym","text":"<p>Plays a SoundFont2 (SF2) sample preset, generating a mono sound.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfplaym/#syntax","title":"Syntax","text":"<pre><code>ares sfplaym ivel, inotenum, xamp, xfreq, ipreindex [, iflag] \\\n             [, ioffset] [, ienv]\n</code></pre>"},{"location":"opcodes/sfplaym/#initialization","title":"Initialization","text":"<p>ivel -- velocity value</p> <p>inotenum -- MIDI note number value</p> <p>ipreindex -- preset index</p> <p>iflag (optional) -- flag regarding the behavior of xfreq and inotenum</p> <p>ioffset (optional) -- start playing at offset, in samples.</p> <p>ienv (optional) -- enables and determines amplitude envelope. 0 = no envelope, 1 = linear attack and decay, 2 = linear attack, exponential decay (see below). Default = 0.</p>"},{"location":"opcodes/sfplaym/#performance","title":"Performance","text":"<p>xamp -- amplitude correction factor</p> <p>xfreq -- frequency value or frequency multiplier, depending by iflag. When iflag = 0, xfreq is a multiplier of a the default frequency, assigned by SF2 preset to the inotenum value. When iflag = 1, xfreq is the absolute frequency of the output sound, in Hz. Default is 0.</p> <p>When iflag = 0, inotenum sets the frequency of the output according to the MIDI note number used, and xfreq is used as a multiplier. When iflag = 1, the frequency of the output, is set directly by xfreq. This allows the user to use any kind of micro-tuning based scales. However, this method is designed to work correctly only with presets tuned to the default equal temperament. Attempts to use this method with a preset already having non-standard tunings, or with drum-kit-based presets, could give unexpected results.</p> <p>Adjustment of the amplitude can be done by varying the xamp argument, which acts as a multiplier.</p> <p>Notice that both xamp and xfreq can use k-rate as well as a-rate signals. Both arguments must use variables of the same rate, or sfplay will not work correctly. ipreindex must contain the number of a previously assigned preset, or Csound will crash.</p> <p>The ioffset parameter allows the sound to start from a sample different than the first one. The user should make sure that its value is within the length of the specific sound. Otherwise, Csound will probably crash.</p> <p>The ienv parameter enables and determines the type of amplitude envelope used. The default value is 0, or no envelope. If ienv is set to 1, the attack and decay portions are linear. If set to 2, the attack is linear and the decay is exponential. The release portion of the envelope has not yet been implemented.</p> <p>sfplaym is a mono version of sfplay. It should be used with mono preset, or with the stereo presets in which stereo output is not required. It is faster than sfplay.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfplaym/#examples","title":"Examples","text":"<p>Here is an example of the sfplaym opcode. It uses the file sfplaym.csd.</p> Example of the sfplaym opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfplaym.wav -W ;;; for file output any platform\n\n; By  Menno Knevel - 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32\nnchnls = 2\n0dbfs  = 1 \n\n\ngisf    sfload  \"07AcousticGuitar.sf2\"\n        sfplist gisf\n        sfpassign 100, gisf         ;in this case, the number 100 is assigned to the preset\n\ninstr 1 \n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp  = kamp * .000001                  ;scale amplitude- small value due to 0dbfs = 0\na1      sfplaym ivel, inum, kamp * ivel, p6, 100, 1  ; flag = 1 so frequencies is used intead of midi pitch\n        outs    a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127 100  ; use sample of this key and set new frequency\ni1 + 1 62 &lt;    &lt;\ni1 + 1 65 &lt;    &lt;\ni1 + 1 69 10   70\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfplaym/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfplaym/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p> <p>New optional parameter ienv in version 5.09</p>"},{"location":"opcodes/sfplist/","title":"Sfplist","text":""},{"location":"opcodes/sfplist/#sfplist","title":"sfplist","text":"<p>Prints a list of all presets of a previously loaded SoundFont2 (SF2) sample file.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p>"},{"location":"opcodes/sfplist/#syntax","title":"Syntax","text":"<pre><code>sfplist ifilhandle\n</code></pre>"},{"location":"opcodes/sfplist/#initialization","title":"Initialization","text":"<p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p>"},{"location":"opcodes/sfplist/#performance","title":"Performance","text":"<p>sfplist prints a list of all presets of a previously loaded SF2 file to the console.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfplist/#examples","title":"Examples","text":"<p>Here is an example of the sfplist opcode. It uses the file sfplist.csd.</p> Example of the sfplist opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfplist.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisf    sfload   \"sf_GMbank.sf2\"\n        sfplist  gisf                                   ;list all 329 presets of Soundfont\ngir     sfpreset 125, 3, gisf, 0                        ;choose preset 125 = Car Pass\n\ninstr 1\n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/700000                                   ;scale amplitude\nkfreq   =       1                                       ;do not change freq from sf\na1,a2   sfplay3 ivel, inum, kamp*ivel, kfreq, gir       ; make amp velocity dependent\n        outs    a1, a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127\ni1 + 1 62 &lt;\ni1 + 1 65 &lt;\ni1 + 1 69 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>Preset list of \"sf_GMbank.sf2\"\n0) Piano 1              prog:0   bank:0\n1) Piano 2              prog:1   bank:0\n2) Piano 3              prog:2   bank:0\n3) Honky Tonk           prog:3   bank:0\n4) E.Piano 1            prog:4   bank:0\n5) E.Piano 2            prog:5   bank:0\n6) Harpsichord          prog:6   bank:0\n........\n146) Car-Pass               prog:125 bank:3\n........\n</code></pre>"},{"location":"opcodes/sfplist/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfplist/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/sfpreset/","title":"Sfpreset","text":""},{"location":"opcodes/sfpreset/#sfpreset","title":"sfpreset","text":"<p>Assigns an existing preset of a previously loaded SoundFont2 (SF2) sample file to an index number.</p> <p>These opcodes allow management the sample-structure of SF2 files. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format can be found in the SoundFont2 File Format section.</p> <p>sfpreset should be placed in the header section of a Csound orchestra.</p>"},{"location":"opcodes/sfpreset/#syntax","title":"Syntax","text":"<pre><code>ir sfpreset iprog, ibank, ifilhandle, ipreindex\n</code></pre>"},{"location":"opcodes/sfpreset/#initialization","title":"Initialization","text":"<p>ir -- output to be used by other SF2 opcodes. For sfpreset, ir is ipreindex.</p> <p>iprog -- program number of a bank of presets in a SF2 file</p> <p>ibank -- number of a specific bank of a SF2 file</p> <p>ifilhandle -- unique number generated by sfload opcode to be used as an identifier for a SF2 file. Several SF2 files can be loaded and activated at the same time.</p> <p>ipreindex -- preset index</p>"},{"location":"opcodes/sfpreset/#performance","title":"Performance","text":"<p>sfpreset assigns an existing preset of a previously loaded SF2 file to an index number, to be used later with the opcodes sfplay and sfplaym. The user must previously know the program and the bank numbers of the preset in order to fill the corresponding arguments. Any number of sfpreset instances can be placed in the header section of an orchestra, each one assigning a different preset belonging to the same (or different) SF2 file to different index numbers.</p> <p>These opcodes only support the sample structure of SF2 files. The modulator structure of the SoundFont2 format is not supported in Csound. Any modulation or processing to the sample data is left to the Csound user, bypassing all restrictions forced by the SF2 standard.</p>"},{"location":"opcodes/sfpreset/#examples","title":"Examples","text":"<p>Here is an example of the sfpreset opcode. It uses the file sfpreset.csd.</p> Example of the sfpreset opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sfpreset.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By  Menno Knevel - 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisf1   sfload   \"sf_GMbank.sf2\"\n        sfplist  gisf1                                          ;list presets of first soundfont\ngisf2   sfload   \"07AcousticGuitar.sf2\"\n        sfplist  gisf2                                          ;list presets of second soundfont\ngir     sfpreset 51, 0, gisf1, 0                                ;assign Synth Strings2 (#51)to index 0\ngiv     sfpreset 0, 0, gisf2, 1                                 ;assign AcousticGuitar (#0) to index 1\nprint gir\nprint giv\n\ninstr 1\n\ninum    =       p4\nivel    =       p5\nkamp    linsegr 1, 1, 1, .1, 0\nkamp    = kamp/600000                                           ;scale amplitude, small value due to 0dbfs = 1\nkfreq   =       1                                               ;do not change freq \na1,a2   sfplay3 ivel, inum, kamp*ivel, kfreq, p6\n        outs    a1, a2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 60 127 0 ;= Synth Strings I from first soundfont\ni1 + 1 62 &lt;   .\ni1 + 1 65 &lt;   .\ni1 + 1 69 10  .\n\ni1 5 1 60 127 1 ;= AcousticGuitar from second soundfont\ni1 + 1 62 &lt;   .\ni1 + 1 65 &lt;   .\ni1 + 1 69 10  .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sfpreset/#see-also","title":"See also","text":"<p>Soundfonts</p> <p>More information on soundfonts is in the Floss Manuals: https://flossmanual.csound.com/midi/reading-midi-files</p> <p>For other information on soundfonts look in the Wikipedia: http://en.wikipedia.org/wiki/Soundfont</p>"},{"location":"opcodes/sfpreset/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/shaker/","title":"Shaker","text":""},{"location":"opcodes/shaker/#shaker","title":"shaker","text":"<p>Sounds like the shaking of a maraca or similar gourd instrument.</p> <p>The method is a physically inspired model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/shaker/#syntax","title":"Syntax","text":"<pre><code>ares shaker kamp, kfreq, kbeans, kdamp, ktimes [, idecay]\n</code></pre>"},{"location":"opcodes/shaker/#initialization","title":"Initialization","text":"<p>idecay -- If present indicates for how long at the end of the note the shaker is to be damped. The default value is zero.</p>"},{"location":"opcodes/shaker/#performance","title":"Performance","text":"<p>A note is played on a maraca-like instrument, with the arguments as below.</p> <p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kbeans -- The number of beans in the gourd. A value of 8 seems suitable.</p> <p>kdamp -- The damping value of the shaker. Values of 0.98 to 1 seems suitable, with 0.99 a reasonable default.</p> <p>ktimes -- Number of times shaken.</p> <p> Note</p> <p>The argument knum was redundant, so it was removed in version 3.49.</p>"},{"location":"opcodes/shaker/#examples","title":"Examples","text":"<p>Here is an example of the shaker opcode. It uses the file shaker.csd.</p> Example of the shaker opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o shaker.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nknum  =   p5\nkfreq   line p4, p3, 440\na1 shaker .5, kfreq, 8, 0.999, knum\nouts a1, a1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;       frq     #\ni 1 0 1 440     3\ni 1 2 1 440    300\ni 1 4 1 440    3000\ni 1 6 2 4000    100\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/shaker/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/shaker/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/signum/","title":"Signum","text":""},{"location":"opcodes/signum/#signum","title":"signum","text":"<p>Returns the signum of x returning -1, 0 or 1.</p>"},{"location":"opcodes/signum/#syntax","title":"Syntax","text":"<pre><code>signum(x) (no rate restriction)\n</code></pre>"},{"location":"opcodes/signum/#examples","title":"Examples","text":"<p>Here is an example of the signum opcode. It uses the file signum.csd.</p> Example of the signum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o signum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by tgrey - 2020\n\nsr     =    44100\nksmps  =    10\nnchnls =    2\n0dbfs  =    1\n\ninstr 1\n        iinput = p4\n        isignum = signum(iinput)\n        print iinput\n        print isignum\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 .1 100\ni1 + . 50\ni1 + . .25\ni1 + . 0\ni1 + . -.25\ni1 + . -50\ni1 + . -100\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the signum opcode. It uses the file signum2.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o signum2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nkr     =    4410\nksmps  =    10\nnchnls =    2\n0dbfs  =    1\n\ngaArr[]  init  2\n\ninstr 1\nkEnv transeg    1, p3, -3, 0\n\na_pi = 4 * taninv(1.0);\na1   phasor 440;\na2   = sin(2 * a_pi * 1/ksmps * a1);\na3   dcblock2 a2\nasig = signum(a3)\n\ngaArr[0] = a2   * 0.6 * kEnv \ngaArr[1] = asig * 0.6 * kEnv \n\nouts  gaArr[0], gaArr[1]\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the signum opcode: Signum_Welsh.csd by Kevin Welsh.</p>"},{"location":"opcodes/signum/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/signum/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist Ltd. Bath, UK July 2013</p> <p>New in Csound version 6.01</p>"},{"location":"opcodes/sin/","title":"Sin","text":""},{"location":"opcodes/sin/#sin","title":"sin","text":"<p>Returns the sine of x (x in radians).</p>"},{"location":"opcodes/sin/#syntax","title":"Syntax","text":"<pre><code>sin(x)     (no rate restriction)\nsin(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/sin/#examples","title":"Examples","text":"<p>Here is an example of the sin opcode. It uses the file sin.csd.</p> Example of the sin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nisin1     =          sin(0)                                     ;sine of 0 is 0\nisin2     =          sin($M_PI_2)                               ;sine of pi/2 (1.5707...) is 1\nisin3     =          sin($M_PI)                                 ;sine of pi (3.1415...) is 0\nisin4     =          sin($M_PI_2 * 3)                           ;sine of 3/2pi (4.7123...) is -1\nisin5     =          sin($M_PI * 2)                             ;sine of 2pi (6.2831...) is 0\nisin6     =          sin($M_PI * 4)                             ;sine of 4pi is also 0\n          print      isin1, isin2, isin3, isin4, isin5, isin6\nendin\n\ninstr 2 ;sin used in panning, after an example from Hans Mikelson\n\naout      vco2       0.8, 220                                   ; sawtooth\nkpan      linseg     p4, p3, p5 ;0 = left, 1 = right\nkpan      =          kpan*$M_PI_2                               ;range 0-1 becomes 0-pi/2\nkpanl     =          cos(kpan)\nkpanr     =          sin(kpan)\n          outs       aout*kpanl, aout*kpanr\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0\ni 2 0 5 0 1 ;move left to right\ni 2 5 5 1 0 ;move right to left\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  isin1 = 0.000  isin2 = 1.000  isin3 = 0.000  isin4 = -1.000  isin5 = -0.000  isin6 = 0.000\n</code></pre>"},{"location":"opcodes/sin/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/sinh/","title":"Sinh","text":""},{"location":"opcodes/sinh/#sinh","title":"sinh","text":"<p>Returns the hyperbolic sine of x (x in radians).</p>"},{"location":"opcodes/sinh/#syntax","title":"Syntax","text":"<pre><code>sinh(x)     (no rate restriction)\nsinh(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/sinh/#examples","title":"Examples","text":"<p>Here is an example of the sinh opcode. It uses the file sinh.csd.</p> Example of the sinh opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o sinh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  irad = 1\n  i1 = sinh(irad)\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should a line like this:</p> <pre><code>instr 1:  i1 = 1.175\n</code></pre>"},{"location":"opcodes/sinh/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/sinh/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p> <p>New in version 3.47</p>"},{"location":"opcodes/sininv/","title":"Sininv","text":""},{"location":"opcodes/sininv/#sininv","title":"sininv","text":"<p>Returns the arcsine of x (x in radians).</p>"},{"location":"opcodes/sininv/#syntax","title":"Syntax","text":"<pre><code>sininv(x)     (no rate restriction)\nsininv(k/i[]) (k- or i-arrays)\n</code></pre>"},{"location":"opcodes/sininv/#examples","title":"Examples","text":"<p>Here is an example of the sininv opcode. It uses the file sininv.csd.</p> Example of the sininv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o sininv.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  irad = 0.5\n  i1 = sininv(irad)\n\n  print i1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 0.524\n</code></pre>"},{"location":"opcodes/sininv/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/sininv/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.48</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/skf/","title":"Skf","text":""},{"location":"opcodes/skf/#skf","title":"skf","text":"<p>Sallen-Key filter.</p> <p>skf is an digital implementation of a linear Sallen-Key analogue filter, which is a second-order filter with either lowpass or highpass responses.</p>"},{"location":"opcodes/skf/#syntax","title":"Syntax","text":"<pre><code>asig skf asig, xcf, xK[, ihp, istor]\n</code></pre>"},{"location":"opcodes/skf/#initialization","title":"Initialization","text":"<p>ihp -- if non-zero, select highpass response. Defaults to 0 (lowpass).</p> <p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/skf/#performance","title":"Performance","text":"<p>asig -- input</p> <p>xcf -- filter cutoff frequency (a- or k-rate)</p> <p>xK -- Sallen-Key opamp gain, in the range 1 to 3. At 3 the filter self-oscillates. K=1. 586 gives a Butterworth response,  higher values are equivalent to Chebyshev responses (with peaking). At K=1 the filter is critically damped and the poles are real-valued.</p>"},{"location":"opcodes/skf/#examples","title":"Examples","text":"<p>Here is an example of the skf opcode. It uses the file skf.csd.</p> Example of the skf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n0dbfs = 1\n\ninstr 1\n alp = diskin:a(\"fox.wav\",1,0,1)/3\n af expon 100,p3,10000\n a3 skf alp,af,1.516,p5\n out a3\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10 0.2 0  ; lowpass\ni1 10 10 0.2 1 ; highpass\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/skf/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/skf/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Feb 2021</p>"},{"location":"opcodes/sleighbells/","title":"Sleighbells","text":""},{"location":"opcodes/sleighbells/#sleighbells","title":"sleighbells","text":"<p>Semi-physical model of a sleighbell sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/sleighbells/#syntax","title":"Syntax","text":"<pre><code>ares sleighbells kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n                 [, ifreq1] [, ifreq2]\n</code></pre>"},{"location":"opcodes/sleighbells/#initialization","title":"Initialization","text":"<p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 32.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.9994 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.9994 which means that the default value of idamp is 0. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 0.03.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional, default=0) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p> <p>ifreq (optional) -- the main resonant frequency. The default value is 2500.</p> <p>ifreq1 (optional) -- the first resonant frequency. The default value is 5300.</p> <p>ifreq2 (optional) -- the second resonant frequency. The default value is 6500.</p>"},{"location":"opcodes/sleighbells/#performance","title":"Performance","text":"<p>kamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only an approximation.</p>"},{"location":"opcodes/sleighbells/#examples","title":"Examples","text":"<p>Here is an example of the sleighbells opcode. It uses the file sleighbells.csd.</p> Example of the sleighbells opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sleighbells.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1\n\nidamp = p4\nasig  sleighbells .7, 0.01, 32, idamp, 0.55\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0.00 0.25 0 ;short sound\ni 1 0.30 0.25\ni 1 0.60 0.25\ni 1 0.90 0.25\ni 1 1.20 0.25\ni 1 1.50 1   .3 ;longer sound\ni 1 1.80 0.25 0 ;short sound again\ni 1 2.10 0.25\ni 1 2.40 0.25\ni 1 2.70 0.25\ni 1 3.00 0.25\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sleighbells/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/sleighbells/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/slicearray/","title":"Slicearray","text":""},{"location":"opcodes/slicearray/#slicearray","title":"slicearray","text":"<p>Take a slice of a vector (one-dimensional k-rate array).</p>"},{"location":"opcodes/slicearray/#syntax","title":"Syntax","text":"<pre><code>karray slicearray kinarray, istart, iend [,istride]\n</code></pre>"},{"location":"opcodes/slicearray/#initialization","title":"Initialization","text":"<p>istart -- index of the first part of the answer.</p> <p>iend -- index of the last element of the answer.</p> <p>istride -- increment for source elements (optional), defaults to 1.</p>"},{"location":"opcodes/slicearray/#examples","title":"Examples","text":"<p>Here is an example of the slicearray opcode. It uses the file slicearray.csd.</p> Example of the slicearray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n;create and fill an array\nkArr[]  genarray_i 1, 9\n\n;print the content\n        printf  \"%s\", 1, \"kArr = whole array\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr) do\n        printf  \"kArr[%d] = %f\\n\", kndx+1, kndx, kArr[kndx]\nkndx    +=      1\n  od\n\n;build new arrays for the slices\nkArr1[] init    5\nkArr2[] init    4\nkArr3[] init    3\n\n;put in first five and last four elements\nkArr1   slicearray kArr, 0, 4\nkArr2   slicearray kArr, 5, 8\n; and three values from 1, 1+2 and 1+2+3\nkArr3   slicearray kArr, 1, 5, 2\n\n;print the content\n        printf  \"%s\", 1, \"\\nkArr1 = slice from index 0 to index 4\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr1) do\n        printf  \"kArr1[%d] = %f\\n\", kndx+1, kndx, kArr1[kndx]\nkndx    +=      1\n  od\n        printf  \"%s\", 1, \"\\nkArr2 = slice from index 5 to index 8\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr2) do\n        printf  \"kArr2[%d] = %f\\n\", kndx+1, kndx, kArr2[kndx]\nkndx    +=      1\n  od\n        printf  \"%s\", 1, \"\\nkArr3 = slice from index 1 to index 5 inc2\\n\"\nkndx    =       0\n  until kndx == lenarray(kArr3) do\n        printf  \"kArr3[%d] = %f\\n\", kndx+1, kndx, kArr3[kndx]\nkndx    +=      1\n  od\n\n        turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/slicearray/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/slicearray/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2013</p> <p>New in version 6.00</p> <p>istride argument new in 6.10</p>"},{"location":"opcodes/slider16/","title":"Slider16","text":""},{"location":"opcodes/slider16/#slider16","title":"slider16","text":"<p>Creates a bank of 16 different MIDI control message numbers.</p>"},{"location":"opcodes/slider16/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i16 slider16 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum16, imin16, imax16, init16, ifn16\nk1, ..., k16 slider16 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum16, imin16, imax16, init16, ifn16\n</code></pre>"},{"location":"opcodes/slider16/#initialization","title":"Initialization","text":"<p>i1 ... i16 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum16 -- MIDI control number (0-127)</p> <p>imin1 ... imin16 -- minimum values for each controller</p> <p>imax1 ... imax16 -- maximum values for each controller</p> <p>init1 ... init16 -- initial value for each controller</p> <p>ifn1 ... ifn16 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider16/#performance","title":"Performance","text":"<p>k1 ... k16 -- output values</p> <p>slider16 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider16 allows a bank of 16 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of slider16, there is not an initial value input argument, because the output is gotten directly from current status of internal controller array of Csound.</p>"},{"location":"opcodes/slider16/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider16/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider16f/","title":"Slider16f","text":""},{"location":"opcodes/slider16f/#slider16f","title":"slider16f","text":"<p>Creates a bank of 16 different MIDI control message numbers, filtered before output.</p>"},{"location":"opcodes/slider16f/#syntax","title":"Syntax","text":"<pre><code>k1, ..., k16 slider16f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n                       ..., ictlnum16, imin16, imax16, init16, ifn16, icutoff16\n</code></pre>"},{"location":"opcodes/slider16f/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum16 -- MIDI control number (0-127)</p> <p>imin1 ... imin16 -- minimum values for each controller</p> <p>imax1 ... imax16 -- maximum values for each controller</p> <p>init1 ... init16 -- initial value for each controller</p> <p>ifn1 ... ifn16 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff16 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider16f/#performance","title":"Performance","text":"<p>k1 ... k16 -- output values</p> <p>slider16f is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider16f allows a bank of 16 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p> Warning</p> <p>slider16f does not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider16f/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider16f/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider16table/","title":"Slider16table","text":""},{"location":"opcodes/slider16table/#slider16table","title":"slider16table","text":"<p>Stores a bank of 16 different MIDI control messages to a table.</p>"},{"location":"opcodes/slider16table/#syntax","title":"Syntax","text":"<pre><code>kflag slider16table ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                    init1, ifn1, ...., \\\n                    ictlnum16, imin16, imax16, init16, ifn16\n</code></pre>"},{"location":"opcodes/slider16table/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum16 -- MIDI control number (0-127)</p> <p>imin1 ... imin16 -- minimum values for each controller</p> <p>imax1 ... imax16 -- maximum values for each controller</p> <p>init1 ... init16 -- initial value for each controller</p> <p>ifn1 ... ifn16 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider16table/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider16table is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider16table allows a bank of 16 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider16table is very similar to  slider16 and sliderN family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p>"},{"location":"opcodes/slider16table/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider16table/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider16tablef/","title":"Slider16tablef","text":""},{"location":"opcodes/slider16tablef/#slider16tablef","title":"slider16tablef","text":"<p>Stores a bank of 16 different MIDI control messages to a table, filtered before output.</p>"},{"location":"opcodes/slider16tablef/#syntax","title":"Syntax","text":"<pre><code>kflag slider16tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                     init1, ifn1, icutoff1, ...., \\\n                     ictlnum16, imin16, imax16, init16, ifn16, icutoff16\n</code></pre>"},{"location":"opcodes/slider16tablef/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum16 -- MIDI control number (0-127)</p> <p>imin1 ... imin16 -- minimum values for each controller</p> <p>imax1 ... imax16 -- maximum values for each controller</p> <p>init1 ... init16 -- initial value for each controller</p> <p>ifn1 ... ifn16 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff16 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider16tablef/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider16tablef is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider16tablef allows a bank of 16 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider16tablef is very similar to  slider16f and sliderNf family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p> <p> Warning</p> <p>slider16tablef does not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider16tablef/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider16tablef/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider32/","title":"Slider32","text":""},{"location":"opcodes/slider32/#slider32","title":"slider32","text":"<p>Creates a bank of 32 different MIDI control message numbers.</p>"},{"location":"opcodes/slider32/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i32 slider32 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum32, imin32, imax32, init32, ifn32\nk1, ..., k32 slider32 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum32, imin32, imax32, init32, ifn32\n</code></pre>"},{"location":"opcodes/slider32/#initialization","title":"Initialization","text":"<p>i1 ... i32 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum32 -- MIDI control number (0-127)</p> <p>imin1 ... imin32 -- minimum values for each controller</p> <p>imax1 ... imax32 -- maximum values for each controller</p> <p>init1 ... init32 -- initial value for each controller</p> <p>ifn1 ... ifn32 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider32/#performance","title":"Performance","text":"<p>k1 ... k32 -- output values</p> <p>slider32 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider32 allows a bank of 32 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of slider32, there is not an initial value input argument, because the output is gotten directly from current status of internal controller array of Csound.</p>"},{"location":"opcodes/slider32/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider32/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider32f/","title":"Slider32f","text":""},{"location":"opcodes/slider32f/#slider32f","title":"slider32f","text":"<p>Creates a bank of 32 different MIDI control message numbers, filtered before output.</p>"},{"location":"opcodes/slider32f/#syntax","title":"Syntax","text":"<pre><code>k1, ..., k32 slider32f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n                       ..., ictlnum32, imin32, imax32, init32, ifn32, icutoff32\n</code></pre>"},{"location":"opcodes/slider32f/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum32 -- MIDI control number (0-127)</p> <p>imin1 ... imin32 -- minimum values for each controller</p> <p>imax1 ... imax32 -- maximum values for each controller</p> <p>init1 ... init32 -- initial value for each controller</p> <p>ifn1 ... ifn32 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff32 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider32f/#performance","title":"Performance","text":"<p>k1 ... k32 -- output values</p> <p>slider32f is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider32f allows a bank of 32 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p> Warning</p> <p>slider32f opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider32f/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider32f/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider32table/","title":"Slider32table","text":""},{"location":"opcodes/slider32table/#slider32table","title":"slider32table","text":"<p>Stores a bank of 32 different MIDI control messages to a table.</p>"},{"location":"opcodes/slider32table/#syntax","title":"Syntax","text":"<pre><code>kflag slider32table ichan, ioutTable, ioffset, ictlnum1, imin1, \\\n                    imax1, init1, ifn1, ...., \\\n                    ictlnum32, imin32, imax32, init32, ifn32\n</code></pre>"},{"location":"opcodes/slider32table/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum32 -- MIDI control number (0-127)</p> <p>imin1 ... imin32 -- minimum values for each controller</p> <p>imax1 ... imax32 -- maximum values for each controller</p> <p>init1 ... init32 -- initial value for each controller</p> <p>ifn1 ... ifn32 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider32table/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider32table is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider32table allows a bank of 32 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider32table is very similar to  slider32 and sliderN family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p>"},{"location":"opcodes/slider32table/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider32table/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider32tablef/","title":"Slider32tablef","text":""},{"location":"opcodes/slider32tablef/#slider32tablef","title":"slider32tablef","text":"<p>Stores a bank of 32 different MIDI control messages to a table, filtered before output.</p>"},{"location":"opcodes/slider32tablef/#syntax","title":"Syntax","text":"<pre><code>kflag slider32tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                     init1, ifn1, icutoff1, ...., \\\n                     ictlnum32, imin32, imax32, init32, ifn32, icutoff32\n</code></pre>"},{"location":"opcodes/slider32tablef/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum32 -- MIDI control number (0-127)</p> <p>imin1 ... imin32 -- minimum values for each controller</p> <p>imax1 ... imax32 -- maximum values for each controller</p> <p>init1 ... init32 -- initial value for each controller</p> <p>ifn1 ... ifn32 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff32 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider32tablef/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider32tablef is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider32tablef allows a bank of 32 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider32tablef is very similar to  slider32f and sliderNf family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p> <p> Warning</p> <p>slider32tablef opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider32tablef/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider32tablef/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider64/","title":"Slider64","text":""},{"location":"opcodes/slider64/#slider64","title":"slider64","text":"<p>Creates a bank of 64 different MIDI control message numbers.</p>"},{"location":"opcodes/slider64/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i64 slider64 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum64, imin64, imax64, init64, ifn64\nk1, ..., k64 slider64 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                      ictlnum64, imin64, imax64, init64, ifn64\n</code></pre>"},{"location":"opcodes/slider64/#initialization","title":"Initialization","text":"<p>i1 ... i64 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum64 -- MIDI control number (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider64/#performance","title":"Performance","text":"<p>k1 ... k64 -- output values</p> <p>slider64 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider64 allows a bank of 64 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of slider64, there is not an initial value input argument, because the output is gotten directly from current status of internal controller array of Csound.</p>"},{"location":"opcodes/slider64/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider64/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider64f/","title":"Slider64f","text":""},{"location":"opcodes/slider64f/#slider64f","title":"slider64f","text":"<p>Creates a bank of 64 different MIDI control message numbers, filtered before output.</p>"},{"location":"opcodes/slider64f/#syntax","title":"Syntax","text":"<pre><code>k1, ..., k64 slider64f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n                       ..., ictlnum64, imin64, imax64, init64, ifn64, icutoff64\n</code></pre>"},{"location":"opcodes/slider64f/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum64 -- MIDI control number (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff64 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider64f/#performance","title":"Performance","text":"<p>k1 ... k64 -- output values</p> <p>slider64f is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider64f allows a bank of 64 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p> Warning</p> <p>slider64f opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider64f/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider64f/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider64table/","title":"Slider64table","text":""},{"location":"opcodes/slider64table/#slider64table","title":"slider64table","text":"<p>Stores a bank of 64 different MIDI control messages to a table.</p>"},{"location":"opcodes/slider64table/#syntax","title":"Syntax","text":"<pre><code>kflag slider64table ichan, ioutTable, ioffset, ictlnum1, imin1, \\\n                    imax1, init1, ifn1, ...., \\\n                    ictlnum64, imin64, imax64, init64, ifn64\n</code></pre>"},{"location":"opcodes/slider64table/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum64 -- MIDI control number (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider64table/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider64table is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider64table allows a bank of 64 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider64table is very similar to  slider64 and sliderN family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p>"},{"location":"opcodes/slider64table/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider64table/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider64tablef/","title":"Slider64tablef","text":""},{"location":"opcodes/slider64tablef/#slider64tablef","title":"slider64tablef","text":"<p>Stores a bank of 64 different MIDI control messages to a table, filtered before output.</p>"},{"location":"opcodes/slider64tablef/#syntax","title":"Syntax","text":"<pre><code>kflag slider64tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                     init1, ifn1, icutoff1, ...., \\\n                     ictlnum64, imin64, imax64, init64, ifn64, icutoff64\n</code></pre>"},{"location":"opcodes/slider64tablef/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum64 -- MIDI control number (0-127)</p> <p>imin1 ... imin64 -- minimum values for each controller</p> <p>imax1 ... imax64 -- maximum values for each controller</p> <p>init1 ... init64 -- initial value for each controller</p> <p>ifn1 ... ifn64 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff64 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider64tablef/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider64tablef is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider64tablef allows a bank of 64 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider64tablef is very similar to  slider64f and sliderN family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p> <p> Warning</p> <p>slider64tablef opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider64tablef/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider64tablef/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider8/","title":"Slider8","text":""},{"location":"opcodes/slider8/#slider8","title":"slider8","text":"<p>Creates a bank of 8 different MIDI control message numbers.</p>"},{"location":"opcodes/slider8/#syntax","title":"Syntax","text":"<pre><code>i1, ..., i8 slider8 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                    ictlnum8, imin8, imax8, init8, ifn8\nk1, ..., k8 slider8 ichan, ictlnum1, imin1, imax1, init1, ifn1, ..., \\\n                    ictlnum8, imin8, imax8, init8, ifn8\n</code></pre>"},{"location":"opcodes/slider8/#initialization","title":"Initialization","text":"<p>i1 ... i8 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum8 -- MIDI control number (0-127)</p> <p>imin1 ... imin8 -- minimum values for each controller</p> <p>imax1 ... imax8 -- maximum values for each controller</p> <p>init1 ... init8 -- initial value for each controller</p> <p>ifn1 ... ifn8 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider8/#performance","title":"Performance","text":"<p>k1 ... k8 -- output values</p> <p>slider8 is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider8 allows a bank of 8 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>In the i-rate version of slider8, there is not an initial value input argument, because the output is gotten directly from current status of internal controller array of Csound.</p>"},{"location":"opcodes/slider8/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider8/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider8f/","title":"Slider8f","text":""},{"location":"opcodes/slider8f/#slider8f","title":"slider8f","text":"<p>Creates a bank of 8 different MIDI control message numbers, filtered before output.</p>"},{"location":"opcodes/slider8f/#syntax","title":"Syntax","text":"<pre><code>k1, ..., k8 slider8f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \\\n                     ..., ictlnum8, imin8, imax8, init8, ifn8, icutoff8\n</code></pre>"},{"location":"opcodes/slider8f/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ictlnum1 ... ictlnum8 -- MIDI control number (0-127)</p> <p>imin1 ... imin8 -- minimum values for each controller</p> <p>imax1 ... imax8 -- maximum values for each controller</p> <p>init1 ... init8 -- initial value for each controller</p> <p>ifn1 ... ifn8 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff8 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider8f/#performance","title":"Performance","text":"<p>k1 ... k8 -- output values</p> <p>slider8f is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider8f allows a bank of 8 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p> Warning</p> <p>slider8f opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider8f/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider8f/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy December 1998</p> <p>New in Csound version 3.50</p> <p>Thanks goes to Rasmus Ekman for pointing out the correct MIDI channel and controller number ranges.</p>"},{"location":"opcodes/slider8table/","title":"Slider8table","text":""},{"location":"opcodes/slider8table/#slider8table","title":"slider8table","text":"<p>Stores a bank of 8 different MIDI control messages to a table.</p>"},{"location":"opcodes/slider8table/#syntax","title":"Syntax","text":"<pre><code>kflag slider8table ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                   init1, ifn1, ..., ictlnum8, imin8, imax8, init8, ifn8\n</code></pre>"},{"location":"opcodes/slider8table/#initialization","title":"Initialization","text":"<p>i1 ... i8 -- output values</p> <p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum8 -- MIDI control number (0-127)</p> <p>imin1 ... imin8 -- minimum values for each controller</p> <p>imax1 ... imax8 -- maximum values for each controller</p> <p>init1 ... init8 -- initial value for each controller</p> <p>ifn1 ... ifn8 -- function table for conversion for each controller</p>"},{"location":"opcodes/slider8table/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider8table handles a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider8table allows a bank of 8 different MIDI control message numbers.</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider8table is very similar to  slider8 and sliderN family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p>"},{"location":"opcodes/slider8table/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider8table/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/slider8tablef/","title":"Slider8tablef","text":""},{"location":"opcodes/slider8tablef/#slider8tablef","title":"slider8tablef","text":"<p>Stores a bank of 8 different MIDI control messages to a table, filtered before output.</p>"},{"location":"opcodes/slider8tablef/#syntax","title":"Syntax","text":"<pre><code>kflag slider8tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \\\n                    init1, ifn1, icutoff1, ...., \\\n                    ictlnum8, imin8, imax8, init8, ifn8, icutoff8\n</code></pre>"},{"location":"opcodes/slider8tablef/#initialization","title":"Initialization","text":"<p>ichan -- MIDI channel (1-16)</p> <p>ioutTable -- number of the table that will contain the output</p> <p>ioffset -- output table offset. A zero means that the output of the first slider will affect the first table element. A 10 means that the output of the first slider will affect the 11th table element.</p> <p>ictlnum1 ... ictlnum8 -- MIDI control number (0-127)</p> <p>imin1 ... imin8 -- minimum values for each controller</p> <p>imax1 ... imax8 -- maximum values for each controller</p> <p>init1 ... init8 -- initial value for each controller</p> <p>ifn1 ... ifn8 -- function table for conversion for each controller</p> <p>icutoff1 ... icutoff8 -- low-pass filter cutoff frequency for each controller</p>"},{"location":"opcodes/slider8tablef/#performance","title":"Performance","text":"<p>kflag -- a flag that informs if any control-change message in the bank has been received. In this case kflag is set to 1. Otherwise is set to zero.</p> <p>slider8tablef is a bank of MIDI controllers, useful when using MIDI mixer such as Kawai MM-16 or others for changing whatever sound parameter in real-time. The raw MIDI control messages at the input port are converted to agree with iminN and imaxN,  and an initial value can be set. Also, an optional non-interpolated function table with a custom translation curve is allowed, useful for enabling exponential response curves.</p> <p>When no function table translation is required, set the ifnN value to 0, else set ifnN to a valid function table number.  When table translation is enabled (i.e. setting ifnN value to a non-zero number referring to an already allocated function table), initN value should be set equal to iminN or imaxN value, else the initial output value will not be the same as specified in initN argument.</p> <p>slider8tablef allows a bank of 8 different MIDI control message numbers. It filters the signal before output. This eliminates discontinuities due to the low resolution of the MIDI (7 bit). The cutoff frequency can be set separately for each controller (suggested range: .1 to 5 Hz).</p> <p>As the input and output arguments are many, you can split the line using '\\' (backslash) character (new in 3.47 version) to improve the readability. Using these opcodes is considerably more efficient than using the separate ones (ctrl7 and tonek) when more controllers are required.</p> <p>slider8tablef is very similar to  slider8f and sliderNf family of opcodes (see their manual for more information). The actual difference is that the output is not stored to k-rate variables, but to a table, denoted by the ioutTable argument. It is possible to define a starting index in order to use the same table for more than one slider bank (or other purposes).</p> <p>It is possible to use this opcode together with FLslidBnk2Setk and FLslidBnk2, so you can synchronize the position of the MIDI values to the position of the FLTK valuator widgets of FLslidBnk2. Notice that you have to specify the same min/max values as well the linear/exponential responses in both sliderNtable(f) and FLslidBnk2. The exception is when using table-indexed response instead of a lin/exp response. In this case, in order to achieve a useful result, the table-indexed response and actual min/max values must be set only in FLslidBnk2, whereas, in sliderNtable(f), you have to set a linear response and a minimum of zero and a maximum of one in all sliders.</p> <p> Warning</p> <p>slider8tablef opcodes do not output the required initial value immediately, but only after some k-cycles because the filter slightly delays the output.</p>"},{"location":"opcodes/slider8tablef/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/slider8tablef/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/sliderkawai/","title":"Sliderkawai","text":""},{"location":"opcodes/sliderkawai/#sliderkawai","title":"sliderKawai","text":"<p>Creates a bank of 16 different MIDI control message numbers from a KAWAI MM-16 midi mixer.</p>"},{"location":"opcodes/sliderkawai/#syntax","title":"Syntax","text":"<pre><code>k1, k2, ...., k16 sliderKawai imin1, imax1, init1, ifn1, imin2, imax2, \\\n                              init2, ifn2, ..., imin16, imax16, init16, ifn16\n</code></pre>"},{"location":"opcodes/sliderkawai/#initialization","title":"Initialization","text":"<p>imin1 ... imin16 -- minimum values for each controller</p> <p>imax1 ... imax16 -- maximum values for each controller</p> <p>init1 ... init16 -- initial value for each controller</p> <p>ifn1 ... ifn16 -- function table for conversion for each controller</p>"},{"location":"opcodes/sliderkawai/#performance","title":"Performance","text":"<p>k1 ... k16 -- output values</p> <p>The opcode sliderKawai is equivalent to slider16, but it has the controller and channel numbers (ichan and ictlnum) hard-coded to make for quick compatiblity with the KAWAI MM-16 midi mixer. This device doesn't allow changing the midi message associated to each slider. It can only output on control 7 for each fader on a separate midi channel. This opcode is a quick way of assigning the mixer's 16 faders to k-rate variables in csound.</p>"},{"location":"opcodes/sliderkawai/#see-also","title":"See Also","text":"<p>Slider Banks</p>"},{"location":"opcodes/sliderkawai/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 5.06</p>"},{"location":"opcodes/sndload/","title":"Sndload","text":""},{"location":"opcodes/sndload/#sndload","title":"sndload","text":"<p>Loads a sound file into memory for use by loscilx</p> <p> Note</p> <p>This opcode loads the file into memory but it is not available for use adfterwards.  In effect it just wastes memory.</p>"},{"location":"opcodes/sndload/#syntax","title":"Syntax","text":"<pre><code>sndload Sfname[, ifmt[, ichns[, isr[, ibas[, iamp[, istrt [, ilpmod[, ilps \\\n        [, ilpe]]]]]]]]]\n</code></pre>"},{"location":"opcodes/sndload/#initialization","title":"Initialization","text":"<p>Sfname - file name as a string constant or variable, string p-field, or a number that is used either as an index to strings set with strset, or, if that is not available, a file name in the format soundin.n is used. If the file name does not include a full path, the file is searched in the current directory first, then those specified by SSDIR (if defined), and finally SFDIR. If the same file was already loaded previously, it will not be read again, but the parameters ibas, iamp, istrt, ilpmod, ilps, and ilpe are still updated.</p> <p>ifmt (optional, defaults to zero) - default sample format for raw (headerless) sound files; if the file has a header, this is ignored. Can be one of the following:</p> <ul> <li>-1: do not allow headerless files (fail with an init error)</li> <li>0: use the same format as the one specified on the command line</li> <li>1: 8 bit signed integers</li> <li>2: a-law</li> <li>3: u-law</li> <li>4: 16 bit signed integers</li> <li>5: 32 bit signed integers</li> <li>6: 32 bit floats</li> <li>7: 8 bit unsigned integers</li> <li>8: 24 bit signed integers</li> <li>9: 64 bit floats</li> </ul> <p>ichns (optional, defaults to zero) - default number of channels for raw (headerless) sound files; if the file has a header, this is ignored. Zero or negative values are interpreted as 1 channel.</p> <p>isr (optional, defaults to zero) - default sample rate for raw (headerless) sound files; if the file has a header, this is ignored. Zero or negative values are interpreted as the orchestra sample rate (sr).</p> <p>ibas (optional, defaults to zero) - base frequency in Hz. If positive, overrides the value specified in the sound file header; otherwise, the value from the header is used if present, and 1.0 if the file does not include such information.</p> <p>iamp (optional, defaults to zero) - amplitude scale. If non-zero, overrides the value specified in the sound file header (note: negative values are allowed, and will invert the sound output); otherwise, the value from the header is used if present, and 1.0 if the file does not include such information.</p> <p>istrt (optional, defaults to -1) - starting position in sample frames, can be fractional. If non-negative, overrides the value specified in the sound file header; otherwise, the value from the header is used if present, and 0 if the file does not include such information. Note: even if this parameter is specified, the whole file is still read into memory.</p> <p>ilpmod (optional, defaults to -1) - loop mode, can be one of the following:</p> <ul> <li>any negative value: use the loop information specified in the sound file header, ignoring ilps and ilpe</li> <li>0: no looping (ilps and ilpe are ignored)</li> <li>1: forward looping (wrap around loop end if it is crossed in forward direction, and wrap around loop start if it is crossed in backward direction)</li> <li>2: backward looping (change direction at loop end if it is crossed in forward direction, and wrap around loop start if it is crossed in backward direction)</li> <li>3: forward-backward looping (change direction at both loop points if they are crossed as described above)</li> </ul> <p>ilps (optional, defaults to 0) - loop start in sample frames (fractional values are allowed), or loop end if ilps is greater than ilpe. Ignored unless ilpmod is set to 1, 2, or 3. If the loop points are equal, the whole sample is looped.</p> <p>ilpe (optional, defaults to 0) - loop end in sample frames (fractional values are allowed), or loop start if ilps is greater than ilpe.  Ignored unless ilpmod is set to 1, 2, or 3. If the loop points are equal, the whole sample is looped.</p>"},{"location":"opcodes/sndload/#credits","title":"Credits","text":"<p>Written by Istvan Varga.</p> <p>2006</p> <p>New in Csound 5.03</p>"},{"location":"opcodes/sndloop/","title":"Sndloop","text":""},{"location":"opcodes/sndloop/#sndloop","title":"sndloop","text":"<p>A sound looper with pitch control.</p> <p>This opcode records input audio and plays it back in a loop with user-defined duration and crossfade time. It also allows the pitch of the loop to be controlled, including reversed playback.</p>"},{"location":"opcodes/sndloop/#syntax","title":"Syntax","text":"<pre><code>asig, krec sndloop ain, kpitch, ktrig, idur, ifad\n</code></pre>"},{"location":"opcodes/sndloop/#initialization","title":"Initialization","text":"<p>_idur _ -- loop duration in seconds</p> <p>_ifad _ -- crossfade duration in seconds</p>"},{"location":"opcodes/sndloop/#performance","title":"Performance","text":"<p>asig -- output sig</p> <p>krec -- 'rec on' signal, 1 when recording, 0 otherwise</p> <p>kpitch -- pitch control (transposition ratio); negative values play the loop back in reverse</p> <p>ktrig -- trigger signal: when 0, processing is bypassed. When switched on (ktrig &gt;= 1), the opcode starts recording until the loop memory is full. It then plays the looped sound until it is switched off again (ktrig = 0). Another recording can start again with ktrig &gt;= 1.</p>"},{"location":"opcodes/sndloop/#examples","title":"Examples","text":"<p>Here is an example of the sndloop opcode. It uses the file sndloop.csd.</p> Example of the sndloop opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sndloop.wav -W  ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nitrig  = p4\nasig   diskin2 \"drumsMlp.wav\", 1, 0, 1          ;get the signal in, loop it\nktrig  line 0, itrig, 1                         ;when to trigger signal = p4\nkpitch line 1.2, p3, .5                         ;vary pitch of recorded signal\naout,krec sndloop asig, kpitch, ktrig, .4, 0.05 ;rec starts at p4 sec, for .4 secs and 0.05 crossfade\n       printk2 krec                             ; prints the recording signal\n       outs    aout, aout\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5 .5       ;trigger in seconds (=p4)\ni1 + 5 .8\ni1 + 10 1.2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The example above shows the basic operation of sndloop. Pitch can be controlled at the k-rate, recording is started as soon as the trigger value is &gt;= 1. Recording can be restarted by making the trigger 0 and then 1 again.</p>"},{"location":"opcodes/sndloop/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/sndloop/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini April 2005 </p> <p>New in Version 5.00</p>"},{"location":"opcodes/sndwarp/","title":"Sndwarp","text":""},{"location":"opcodes/sndwarp/#sndwarp","title":"sndwarp","text":"<p>Reads a mono sound sample from a table and applies time-stretching and/or pitch modification.</p> <p>sndwarp reads sound samples from a table and applies time-stretching and/or pitch modification. Time and frequency modification are independent from one another. For example, a sound can be stretched in time while raising the pitch!</p> <p>The window size and overlap arguments are important to the result and should be experimented with. In general they should be as small as possible. For example, start with iwsize=sr/10 and ioverlap=15. Try irandw=iwsize*0.2. If you can get away with less overlaps, the program will be faster. But too few may cause an audible flutter in the amplitude. The algorithm reacts differently depending upon the input sound and there are no fixed rules for the best use in all circumstances. But with proper tuning, excellent results can be achieved.</p>"},{"location":"opcodes/sndwarp/#syntax","title":"Syntax","text":"<pre><code>ares [, ac] sndwarp xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, \\\n                    irandw, ioverlap, ifn2, itimemode\n</code></pre>"},{"location":"opcodes/sndwarp/#initialization","title":"Initialization","text":"<p>ifn1 -- the number of the table holding the sound samples which will be subjected to the sndwarp processing. GEN01 is the appropriate function generator to use to store the sound samples from a pre-existing soundfile.</p> <p>ibeg -- the time in seconds to begin reading in the table (or soundfile). When itimemode is non- zero, the value of xtimewarp is offset by ibeg.</p> <p>iwsize -- the window size in samples used in the time scaling algorithm.</p> <p>irandw -- the bandwidth of a random number generator. The random numbers will be added to iwsize.</p> <p>ioverlap -- determines the density of overlapping windows.</p> <p>ifn2 -- a function used to shape the window. It is usually used to create a ramp of some kind from zero at the beginning and back down to zero at the end of each window. Try using a half sine (i.e.: f1 0 16384 9 .5 1 0) which works quite well. Other shapes can also be used.</p>"},{"location":"opcodes/sndwarp/#performance","title":"Performance","text":"<p>ares -- the single channel of output from the sndwarp unit generator. sndwarp assumes that the function table holding the sampled signal is a mono one. This simply means that sndwarp will index the table by single-sample frame increments. The user must be aware then that if a stereo signal is used with sndwarp, time and pitch will be altered accordingly.</p> <p>ac (optional) -- a single-layer (no overlaps), unwindowed versions of the time and/or pitch altered signal. They are supplied in order to be able to balance the amplitude of the signal output, which typically contains many overlapping and windowed versions of the signal, with a clean version of the time-scaled and pitch-shifted signal. The sndwarp process can cause noticeable changes in amplitude, (up and down), due to a time differential between the overlaps when time-shifting is being done. When used with a balance unit, ac can greatly enhance the quality of sound.</p> <p>xamp -- the value by which to scale the amplitude (see note on the use of this when using ac).</p> <p>xtimewarp -- determines how the input signal will be stretched or shrunk in time. There are two ways to use this argument depending upon the value given for itimemode. When the value of itimemode is 0, xtimewarp will scale the time of the sound. For example, a value of 2 will stretch the sound by 2 times. When itimemode is any non-zero value then xtimewarp is used as a time pointer in a similar way in which the time pointer works in lpread and pvoc. An example below illustrates this. In both cases, the pitch will not be altered by this process. Pitch shifting is done independently using xresample.</p> <p>xresample -- the factor by which to change the pitch of the sound. For example, a value of 2 will produce a sound one octave higher than the original. The timing of the sound, however, will not be altered.</p>"},{"location":"opcodes/sndwarp/#examples","title":"Examples","text":"<p>Here is an example of the sndwarp opcode. It uses the file sndwarp.csd.</p> Example of the sndwarp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sndwarp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nktimewarp line 0, p3, 2.7       ;length of \"fox.wav\"\nkresample init 1                ;do not change pitch\nibeg = 0                        ;start at beginning\nkwsize  line 4410, p3, 2000\niwsize = 4410                   ;window size in samples with\nirandw = 882                    ;bandwidth of a random number generator\nitimemode = 1                   ;ktimewarp is \"time\" pointer\nioverlap = p4\n\nasig  sndwarp  .5, ktimewarp, kresample, 1, ibeg, iwsize, irandw, ioverlap, 2, itimemode\nasig2 sndwarp  .5, ktimewarp, kresample, 1, ibeg, kwsize, irandw, ioverlap, 2, itimemode\n     outs asig, asig2\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 131072 1 \"fox.wav\" 0 0 0  ; audio file\nf 2 0 1024 9 0.5 1 0            ; half of a sine wave\n\ni 1 0 7 2                       ;different overlaps\ni 1 + 7 5\ni 1 + 7 15\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Other examples</p> <p>The below example shows a slowing down or stretching of the sound stored in the stored table (ifn1). Over the duration of the note, the stretching will grow from no change from the original to a sound which is ten times \u201cslower\u201d than the original. At the same time the overall pitch will move upward over the duration by an octave.</p> <pre><code>iwindfun = 1\nisampfun = 2\nibeg = 0\niwindsize = 2000\niwindrand = 400\nioverlap = 10\nawarp   line    1, p3, 1\naresamp line    1, p3, 2\nkenv    line    1, p3, .1\nasig    sndwarp kenv, awarp, aresamp, isampfun, ibeg, iwindsize, iwindrand, \\\n                ioverlap, iwindfun, 0\n</code></pre> <p>Now, here is an example using xtimewarp as a time pointer and using stereo:</p> <pre><code>itimemode     =         1\natime         line      0, p3, 10\nar1, ar2      sndwarpst kenv, atime, aresamp, sampfun, ibeg, iwindsize, \\\n                        iwindrand, ioverlap, iwindfun, itimemode\n</code></pre> <p>In the above, atime advances the time pointer used in the sndwarpst from 0 to 10 over the duration of the note. If p3 is 20 then the sound will be two times slower than the original. Of course you can use a more complex function than just a single straight line to control the time factor.</p> <p>Now the same as above but using the balance function with the optional outputs:</p> <pre><code>asig,acmp   sndwarp 1, awarp, aresamp, isampfun, ibeg, iwindsize, iwindrand, \\\n                    ioverlap, iwindfun, itimemode\nabal        balance asig, acmp\n\nasig1,asig2,acmp1,acmp2 sndwarpst 1, atime, aresamp, sampfun, ibeg, iwindsize, \\\n                                  iwindrand, ioverlap, iwindfun, itimemode\nabal1       balance asig1, acmp1\nabal2       balance asig2, acmp2\n</code></pre> <p>In the above two examples notice the use of the balance unit. The output of balance can then be scaled, enveloped, sent to an out or outs, and so on. Notice that the amplitude arguments to sndwarp and sndwarpst are \u201c1\u201d in these examples. By scaling the signal after the sndwarp process, abal, abal1, and abal2 should contain signals that have nearly the same amplitude as the original input signal to the sndwarp process. This makes it much easier to predict the levels and avoid samples out of range or sample values that are too small.</p> <p> More Advice</p> <p>Only use the stereo version when you really need to be processing a stereo file. It is somewhat slower than the mono version and if you use the balance function it is slower again. There is nothing wrong with using a mono sndwarp in a stereo orchestra and sending the result to one or both channels of the stereo output!</p>"},{"location":"opcodes/sndwarp/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/sndwarp/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1997</p>"},{"location":"opcodes/sndwarpst/","title":"Sndwarpst","text":""},{"location":"opcodes/sndwarpst/#sndwarpst","title":"sndwarpst","text":"<p>Reads a stereo sound sample from a table and applies time-stretching and/or pitch modification.</p> <p>sndwarpst reads stereo sound samples from a table and applies time-stretching and/or pitch modification. Time and frequency modification are independent from one another. For example, a sound can be stretched in time while raising the pitch!</p> <p>The window size and overlap arguments are important to the result and should be experimented with. In general they should be as small as possible. For example, start with iwsize=sr/10 and ioverlap=15. Try irandw=iwsize*.2. If you can get away with less overlaps, the program will be faster. But too few may cause an audible flutter in the amplitude. The algorithm reacts differently depending upon the input sound and there are no fixed rules for the best use in all circumstances. But with proper tuning, excellent results can be achieved.</p>"},{"location":"opcodes/sndwarpst/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2 [,ac1] [, ac2] sndwarpst xamp, xtimewarp, xresample, ifn1, \\\n    ibeg, iwsize, irandw, ioverlap, ifn2, itimemode\n</code></pre>"},{"location":"opcodes/sndwarpst/#initialization","title":"Initialization","text":"<p>ifn1 -- the number of the table holding the sound samples which will be subjected to the sndwarpst processing. GEN01 is the appropriate function generator to use to store the sound samples from a pre-existing soundfile.</p> <p>ibeg -- the time in seconds to begin reading in the table (or soundfile). When itimemode is non-zero, the value of xtimewarp is offset by ibeg.</p> <p>iwsize -- the window size in samples used in the time scaling algorithm.</p> <p>irandw -- the bandwidth of a random number generator. The random numbers will be added to iwsize.</p> <p>ioverlap -- determines the density of overlapping windows.</p> <p>ifn2 -- a function used to shape the window. It is usually used to create a ramp of some kind from zero at the beginning and back down to zero at the end of each window. Try using a half a sine (i.e.: f1 0 16384 9 .5 1 0) which works quite well. Other shapes can also be used.</p>"},{"location":"opcodes/sndwarpst/#performance","title":"Performance","text":"<p>ar1, ar2 -- ar1 and ar2 are the stereo (left and right) outputs from sndwarpst. sndwarpst assumes that the function table holding the sampled signal is a stereo one. sndwarpst will index the table by a two-sample frame increment. The user must be aware then that if a mono signal is used with sndwarpst, time and pitch will be altered accordingly.</p> <p>ac1, ac2 -- ac1 and ac2 are single-layer (no overlaps), unwindowed versions of the time and/or pitch altered signal. They are supplied in order to be able to balance the amplitude of the signal output, which typically contains many overlapping and windowed versions of the signal, with a clean version of the time-scaled and pitch-shifted signal. The sndwarpst process can cause noticeable changes in amplitude, (up and down), due to a time differential between the overlaps when time-shifting is being done. When used with a balance unit, ac1 and ac2 can greatly enhance the quality of sound. They are optional, but note that they must both be present in the syntax (use both or neither). An example of how to use this is given below.</p> <p>xamp -- the value by which to scale the amplitude (see note on the use of this when using ac1 and ac2).</p> <p>xtimewarp -- determines how the input signal will be stretched or shrunk in time. There are two ways to use this argument depending upon the value given for itimemode. When the value of itimemode is 0, xtimewarp will scale the time of the sound. For example, a value of 2 will stretch the sound by 2 times. When itimemode is any non-zero value then xtimewarp is used as a time pointer in a similar way in which the time pointer works in lpread and pvoc. An example below illustrates this. In both cases, the pitch will not be altered by this process. Pitch shifting is done independently using xresample.</p> <p>xresample -- the factor by which to change the pitch of the sound. For example, a value of 2 will produce a sound one octave higher than the original. The timing of the sound, however, will not be altered.</p> <p>Example</p> <p>Here is an example of the sndwarpst opcode. It uses the file sndwarpst.csd.</p> Example of the sndwarpst opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sndwarpst.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1\n\nktimewarp line 0, p3, 1         ;length of stereo file \"drumsSlp.wav\"\nkresample init 1                ;playback at the normal speed\nibeg = 0\niwsize = 4410\nirandw = 441\nioverlap = p4\nitimemode = 1                   ; Use the ktimewarp parameter as a \"time\" pointer\nprints  \"\\nnumber of overlaps = %d\\n\\n\", p4\n\naL, aR sndwarpst .35, ktimewarp, kresample, 1, ibeg, iwsize, irandw, ioverlap, 2, itimemode\naL dcblock aL                   ;get rid of DC offsets for left channel &amp;\naR dcblock aR                   ;right channel\n   outs aL, aR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 0 1 \"drumsSlp.wav\" 0 0 0\nf 2 0 16384 9 0.5 1 0           ;half of a sine wave\n\ni 1 0 7 2                       ;different overlaps\ni 1 + 7 5\ni 1 + 7 15\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sndwarpst/#other-examples","title":"Other examples","text":"<p>The below example shows a slowing down or stretching of the sound stored in the stored table (ifn1). Over the duration of the note, the stretching will grow from no change from the original to a sound which is ten times \u201cslower\u201d than the original. At the same time the overall pitch will move upward over the duration by an octave.</p> <pre><code>iwindfun = 1\nisampfun = 2\nibeg = 0\niwindsize = 2000\niwindrand = 400\nioverlap = 10\nawarp   line    1, p3, 1\naresamp line    1, p3, 2\nkenv    line    1, p3, .1\nasig    sndwarp kenv, awarp, aresamp, isampfun, ibeg, iwindsize, iwindrand, \\\n                ioverlap, iwindfun, 0\n</code></pre> <p>Now, here is an example using xtimewarp as a time pointer and using stereo:</p> <pre><code>itimemode     =         1\natime         line      0, p3, 10\nar1, ar2      sndwarpst kenv, atime, aresamp, sampfun, ibeg, iwindsize, \\\n                        iwindrand, ioverlap, iwindfun, itimemode\n</code></pre> <p>In the above, atime advances the time pointer used in the sndwarpst from 0 to 10 over the duration of the note. If p3 is 20 then the sound will be two times slower than the original. Of course you can use a more complex function than just a single straight line to control the time factor.</p> <p>Now the same as above but using the balance function with the optional outputs:</p> <pre><code>asig,acmp   sndwarp  1, awarp, aresamp, isampfun, ibeg, iwindsize, iwindrand, \\\n                     ioverlap, iwindfun, itimemode\nabal        balance asig, acmp\n\nasig1,asig2,acmp1,acmp2 sndwarpst 1, atime, aresamp, sampfun, ibeg, iwindsize, \\\n                                  iwindrand, ioverlap, iwindfun, itimemode\nabal1       balance asig1, acmp1\nabal2       balance asig2, acmp2\n</code></pre> <p>In the above two examples notice the use of the balance unit. The output of balance can then be scaled, enveloped, sent to an out or outs, and so on. Notice that the amplitude arguments to sndwarp and sndwarpst are \u201c1\u201d in these examples. By scaling the signal after the sndwarp process, abal, abal1, and abal2 should contain signals that have nearly the same amplitude as the original input signal to the sndwarp process. This makes it much easier to predict the levels and avoid samples out of range or sample values that are too small.</p> <p> More Advice</p> <p>Only use the stereo version when you really need to be processing a stereo file. It is somewhat slower than the mono version and if you use the balance function it is slower again. There is nothing wrong with using a mono sndwarp in a stereo orchestra and sending the result to one or both channels of the stereo output!</p>"},{"location":"opcodes/sndwarpst/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/sndwarpst/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1997</p>"},{"location":"opcodes/sorta/","title":"Sorta","text":""},{"location":"opcodes/sorta/#sorta","title":"sorta","text":"<p>Takes a numeric array (k or i-rate) and returns it sorted in ascending order.</p>"},{"location":"opcodes/sorta/#syntax","title":"Syntax","text":"<pre><code>k/i[] sorta k/i[]  (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/sorta/#examples","title":"Examples","text":"<p>Here is an example of the sorta opcode. It uses the file sorta.csd.</p> Example of the sorta opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n kArr[] fillarray 1,3,2,7,4\n kSorted[] sorta kArr\n kn = 0\n while kn &lt; lenarray(kSorted) do\n  printk2 kSorted[kn]\n  kn += 1\n od\n turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sorta/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/sorta/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini</p> <p>New in version 6.09</p>"},{"location":"opcodes/sortd/","title":"Sortd","text":""},{"location":"opcodes/sortd/#sortd","title":"sortd","text":"<p>Takes a numeric array (k or i-rate) and returns it sorted in descending order.</p>"},{"location":"opcodes/sortd/#syntax","title":"Syntax","text":"<pre><code>k/i[] sortd k/i[]  (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/sortd/#examples","title":"Examples","text":"<p>Here is an example of the sortd opcode. It uses the file sortd.csd.</p> Example of the sortd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n kArr[] fillarray 1,3,2,7,4\n kSorted[] sortd kArr\n kn = 0\n while kn &lt; lenarray(kSorted) do\n  printk2 kSorted[kn]\n  kn += 1\n od\n turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sortd/#see-also","title":"See Also","text":"<p>Array opcodes</p>"},{"location":"opcodes/sortd/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini</p> <p>New in version 6.09</p>"},{"location":"opcodes/soundin/","title":"Soundin","text":""},{"location":"opcodes/soundin/#soundin","title":"soundin","text":"<p>Reads audio data from an external device or stream.</p> <p>Up to 24 channels may be read before v5.14, extended to 40 in later versions.</p>"},{"location":"opcodes/soundin/#syntax","title":"Syntax","text":"<pre><code>ar1[, ar2[, ar3[, ... a24]]] soundin ifilcod [, iskptim] [, iformat] \\\n                                     [, iskipinit] [, ibufsize]\n</code></pre>"},{"location":"opcodes/soundin/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.filcod; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR. See also GEN01.</p> <p>iskptim (optional, default=0) -- time in seconds of input sound to be skipped. The default value is 0. In csound 5.00 and later, this may be negative to add a delay instead of skipping time.</p> <p>iformat (optional, default=0) -- specifies the audio data file format:</p> <ul> <li>1 = 8-bit signed char (high-order 8 bits of a 16-bit integer)</li> <li>2 = 8-bit A-law bytes</li> <li>3 = 8-bit U-law bytes</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> <li>7 = 8-bit unsigned int (not available in Csound versions older than 5.00)</li> <li>8 = 24-bit int (not available in Csound versions older than 5.00)</li> <li>9 = 64-bit doubles (not available in Csound versions older than 5.00)</li> </ul> <p>iskipinit -- switches off all initialisation if non zero (default=0). This was introduced in 4_23f13 and csound5.</p> <p>ibufsize -- buffer size in mono samples (not sample frames). Not available in Csound versions older than 5.00. The default buffer size is 2048.</p> <p>If iformat = 0 it is taken from the soundfile header, and if no header from the Csound -o command-line flag. The default value is 0.</p>"},{"location":"opcodes/soundin/#performance","title":"Performance","text":"<p>soundin is functionally an audio generator that derives its signal from a pre-existing file. The number of channels read in is controlled by the number of result cells, a1, a2, etc., which must match that of the input file. A soundin opcode opens this file whenever the host instrument is initialized, then closes it again each time the instrument is turned off.</p> <p>There can be any number of soundin opcodes within a single instrument or orchestra. Two or more of them can read simultaneously from the same external file.</p> <p> Note to Windows users</p> <p>Windows users typically use back-slashes, \u201c\\\u201d, when specifying the paths of their files. As an example, a Windows user might use the path \u201cc:\\music\\samples\\loop001.wav\u201d. This is problematic because back-slashes are normally used to specify special characters.</p> <p>To correctly specify this path in Csound, one may alternately:</p> <ul> <li>Use forward slashes: c:/music/samples/loop001.wav</li> <li>Use back-slash special characters, \u201c\\\\\u201d: c:\\\\music\\\\samples\\\\loop001.wav</li> </ul>"},{"location":"opcodes/soundin/#examples","title":"Examples","text":"<p>Here is an example of the soundin opcode. It uses the file soundin.csd, fox.wav and drumsSlp.wav.</p> Example of the soundin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc   ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o soundin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; choose between mono or stereo file\n\nichn filenchnls  p4     ;check number of channels\nprints  \"\\nnumber of channels = %d\\n\\n\", ichn\n\nif ichn == 1 then       \nasig   soundin p4       ;mono signal\n       outs    asig, asig\nelse                    ;stereo signal\naL, aR soundin p4\n       outs    aL, aR\nendif\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 \"drumsMlp.wav\"  ;mono signal\ni 1 3 2 \"drumsSlp.wav\"  ;stereo signal\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/soundin/#see-also","title":"See also","text":"<p>Signal Input</p>"},{"location":"opcodes/soundin/#credits","title":"Credits","text":"<p>Authors: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p> <p>Warning to Windows users added by Kevin Conder, April 2002</p>"},{"location":"opcodes/soundout/","title":"Soundout","text":""},{"location":"opcodes/soundout/#soundout","title":"soundout","text":"<p>Deprecated. Writes audio output to a disk file.</p> <p> Note</p> <p>The usage of soundout is discouraged. Please use  fout instead.</p>"},{"location":"opcodes/soundout/#syntax","title":"Syntax","text":"<pre><code>soundout  asig1, ifilcod [, iformat]\n</code></pre>"},{"location":"opcodes/soundout/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the destination soundfile name. An integer denotes the file soundin.filcod; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR. See also GEN01.</p> <p>iformat (optional, default=0) -- specifies the audio data file format:</p> <ul> <li>1 = 8-bit signed char (high-order 8 bits of a 16-bit integer)</li> <li>2 = 8-bit A-law bytes</li> <li>3 = 8-bit U-law bytes</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> </ul> <p>If iformat = 0 it is taken from the soundfile header, and if no header from the Csound -o command-line flag. The default value is 0.</p>"},{"location":"opcodes/soundout/#performance","title":"Performance","text":"<p>soundout writes audio output to a disk file.</p> <p> Note</p> <p>Use of fout is recommended instead of soundout</p>"},{"location":"opcodes/soundout/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/soundout/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe, Matt Ingalls/Mike Berry MIT, Mills College 1993-1997</p>"},{"location":"opcodes/soundouts/","title":"Soundouts","text":""},{"location":"opcodes/soundouts/#soundouts","title":"soundouts","text":"<p>Deprecated. Writes audio output to a disk file.</p> <p> Note</p> <p>The usage of soundouts is discouraged. Please use  fout instead.</p>"},{"location":"opcodes/soundouts/#syntax","title":"Syntax","text":"<pre><code>soundouts  asigl, asigr, ifilcod [, iformat]\n</code></pre>"},{"location":"opcodes/soundouts/#initialization","title":"Initialization","text":"<p>ifilcod -- integer or character-string denoting the destination soundfile name. An integer denotes the file soundout.ifilcod; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is written relative to the directory given by the SFDIR environment variable if defined, or the current directory. See also GEN01.</p> <p>iformat (optional, default=0) -- specifies the audio data file format:</p> <ul> <li>1 = 8-bit signed char (high-order 8 bits of a 16-bit integer)</li> <li>4 = 16-bit short integers</li> <li>5 = 32-bit long integers</li> <li>6 = 32-bit floats</li> </ul> <p>If iformat = 0 it is taken from the Csound -o command-line flag. The default value is 0.</p>"},{"location":"opcodes/soundouts/#performance","title":"Performance","text":"<p>soundouts writes stereo audio output to a disk file in raw (headerless) format without 0dBFS scaling. The expected range of the audio signals depends on the selected sample format.</p> <p> Note</p> <p>Use of fout is recommended instead of soundouts</p>"},{"location":"opcodes/soundouts/#see-also","title":"See also","text":"<p>Signal Output</p>"},{"location":"opcodes/soundouts/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p>"},{"location":"opcodes/space/","title":"Space","text":""},{"location":"opcodes/space/#space","title":"space","text":"<p>Distributes an input signal among 4 channels using cartesian coordinates.</p> <p>It uses Cartesian xy coordinates to calculate the balance of the outputs. The xy coordinates can be defined in a separate text file and accessed through a Function statement in the score using Gen28, or they can be specified using the optional kx, ky arguments. The advantages to the former are:</p> <ol> <li>A graphic user interface can be used to draw and edit the trajectory through the Cartesian plane</li> <li>The file format is in the form time1 X1 Y1 time2 X2 Y2 time3 X3 Y3 allowing the user to define a time-tagged trajectory</li> </ol> <p>space then allows the user to specify a time pointer (much as is used for pvoc, lpread and some other units) to have detailed control over the final speed of movement.</p>"},{"location":"opcodes/space/#syntax","title":"Syntax","text":"<pre><code>a1, a2, a3, a4  space asig, ifn, ktime, kreverbsend, kx, ky\n</code></pre>"},{"location":"opcodes/space/#initialization","title":"Initialization","text":"<p>ifn -- number of the stored function created using Gen28. This function generator reads a text file which contains sets of three values representing the xy coordinates and a time-tag for when the signal should be placed at that location. The file should look like:</p> <pre><code>0       -1       1\n1        1       1\n2        4       4\n2.1     -4      -4\n3       10     -10\n5      -40       0\n</code></pre> <p>If that file were named \u201cmove\u201d then the Gen28 call in the score would like:</p> <pre><code>f1 0 0 28 \"move\"\n</code></pre> <p>Gen28 takes 0 as the size and automatically allocates memory. It creates values to 10 milliseconds of resolution. So in this case there will be 500 values created by interpolating X1 to X2 to X3 and so on, and Y1 to Y2 to Y3 and so on, over the appropriate number of values that are stored in the function table. In the above example, the sound will begin in the left front, over 1 second it will move to the right front, over another second it move further into the distance but still in the right front, then in just 1/10th of a second it moves to the left rear, a bit distant. Finally over the last .9 seconds the sound will move to the right rear, moderately distant, and it comes to rest between the two left channels (due west!), quite distant. Since the values in the table are accessed through the use of a time-pointer in the space unit, the actual timing can be made to follow the file's timing exactly or it can be made to go faster or slower through the same trajectory. If you have access to the GUI that allows one to draw and edit the files, there is no need to create the text files manually. But as long as the file is ASCII and in the format shown above, it doesn't matter how it is made!</p> <p> Important</p> <p>If ifn is 0, then space will take its values for the xy coordinates from kx and ky.</p>"},{"location":"opcodes/space/#performance","title":"Performance","text":"<p>The configuration of the xy coordinates in space places the signal in the following way:</p> <ul> <li>a1 is -1, 1</li> <li>a2 is 1, 1</li> <li>a3 is -1, -1</li> <li>a4 is 1, -1</li> </ul> <p>This assumes a loudspeaker set up as a1 is left front, a2 is right front, a3 is left back, a4 is right back. Values greater than 1 will result in sounds being attenuated, as if in the distance. space considers the speakers to be at a distance of 1; smaller values of xy can be used, but space will not amplify the signal in this case. It will, however balance the signal so that it can sound as if it were within the 4 speaker space. x=0, y=1, will place the signal equally balanced between left and right front channels, x=y=0 will place the signal equally in all 4 channels, and so on. Although there must be 4 output signals from space, it can be used in a 2 channel orchestra. If the xy's are kept so that y&gt;=1, it should work well to do panning and fixed localization in a stereo field.</p> <p>asig -- input audio signal.</p> <p>ktime -- index into the table containing the xy coordinates. If used like:</p> <pre><code>ktime           line  0, 5, 5\na1, a2, a3, a4  space asig, 1, ktime, ...\n</code></pre> <p>with the file \u201cmove\u201d described above, the speed of the signal's movement will be exactly as described in that file. However:</p> <pre><code>ktime           line  0, 10, 5\n</code></pre> <p>the signal will move at half the speed specified. Or in the case of:</p> <pre><code>ktime           line  5, 15, 0\n</code></pre> <p>the signal will move in the reverse direction as specified and 3 times slower! Finally:</p> <pre><code>ktime           line  2, 10, 3\n</code></pre> <p>will cause the signal to move only from the place specified in line 3 of the text file to the place specified in line 5 of the text file, and it will take 10 seconds to do it.</p> <p>kreverbsend -- the percentage of the direct signal that will be factored along with the distance as derived from the xy coordinates to calculate signal amounts that can be sent to reverb units such as reverb, or reverb2.</p> <p>kx, ky -- when ifn is 0, space and spdist will use these values as the xy coordinates to localize the signal.</p>"},{"location":"opcodes/space/#examples","title":"Examples","text":"<p>Here is an example of the space opcode. It uses the file space_quad.csd.</p> <p>Example of the space opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o space_quad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 4\n\nga1     init    0\nga2     init    0\nga3     init    0\nga4     init    0\n\ninstr 1 ;uses GEN28 file \"move\", as found in /manual/examples\n\nkx    init 0\nky    init 0\nktime line  0, 5, 5                             ;same time as in table 1 (=\"move\")\nasig  diskin2 \"drumsMlp.wav\", 1, 0, 1           ;sound source is looped\na1, a2, a3, a4 space asig, 1, ktime, .1, kx, ky ;use table 1 = GEN28\nar1, ar2, ar3, ar4 spsend                       ;send to reverb\n\nga1  = ga1+ar1\nga2  = ga2+ar2\nga3  = ga3+ar3\nga4  = ga4+ar4\n     outq a1, a2, a3, a4\n\nendin\n\ninstr 99 ; reverb instrument\n\na1 reverb2 ga1, 2.5, .5\na2 reverb2 ga2, 2.5, .5\na3 reverb2 ga3, 2.5, .5\na4 reverb2 ga4, 2.5, .5\n   outq a1, a2, a3, a4\n\nga1=0   \nga2=0\nga3=0\nga4=0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 0 28 \"move\"\n\ni1 0 5          ;same time as ktime\ni 99 0 10       ;keep reverb active\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> In the above example, the signal, asig, is moved according to the data in Function #1 indexed by ktime. space sends the appropriate amount of the signal internally to spsend. The outputs of the spsend are added to global accumulators in a common Csound style and the global signals are used as inputs to the reverb units in a separate instrument.</p> <p>space can be useful for quad and stereo panning as well as fixed placed of sounds anywhere between two loudspeakers. Below is an example of the fixed placement of sounds in a stereo field using xy values from the score instead of a function table. It uses the file space_stereo.csd.</p> Second example of the space opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o space_stereo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\nga1 init 0\nga2 init 0\n\ninstr 1\n\nkx   = p4\nky   = p5\nasig diskin2 \"drumsMlp.wav\", 1\na1, a2, a3, a4 space asig, 0, 0, .1, kx, ky     ;take position values from p4, p5\nar1, ar2, ar3, ar4 spsend                       ;send to reverb\n\nga1 = ga1+ar1\nga2 = ga2+ar2\n    outs a1, a2\n\nendin\n\ninstr 99 ; reverb instrument\n\na1 reverb2 ga1, 2.5, .5\na2 reverb2 ga2, 2.5, .5\n   outs a1, a2\n\nga1=0\nga2=0\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;place the sound in the left speaker and near\ni1 0 1 -1 1\n;place the sound in the right speaker and far\ni1 1 1 45 45\n;place the sound equally between left and right and in the middle ground distance\ni1 2 1 0 12\n\ni 99 0 7        ;keep reverb active\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>spdist demonstrates an example of a simple intuitive use of the distance values to simulate Doppler shift.</p>"},{"location":"opcodes/space/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/space/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1998</p> <p>New in Csound version 3.48</p>"},{"location":"opcodes/spat3d/","title":"Spat3d","text":""},{"location":"opcodes/spat3d/#spat3d","title":"spat3d","text":"<p>Positions the input sound in a 3D space and allows moving the sound at k-rate.</p> <p>This opcode positions the input sound in a 3D space, with optional simulation of room acoustics, in various output formats. spat3d allows moving the sound at k-rate (this movement is interpolated internally to eliminate \"zipper noise\" if sr not equal to kr).</p>"},{"location":"opcodes/spat3d/#syntax","title":"Syntax","text":"<pre><code>aW, aX, aY, aZ spat3d ain, kX, kY, kZ, idist, ift, imode, imdel, iovr [, istor]\n</code></pre>"},{"location":"opcodes/spat3d/#initialization","title":"Initialization","text":"<p>idist -- For modes 0 to 3, idist is the unit circle distance in meters. For mode 4, idist is the distance between microphones.</p> <p>The following formulas describe amplitude and delay as a function of sound source distance from microphone(s):</p> <pre><code>amplitude = 1 / (0.1 + distance)\n\ndelay = distance / 340 (in seconds)\n</code></pre> <p>Distance can be calculated as:</p> <pre><code>distance = sqrt(iX^2 + iY^2 + iZ^2)\n</code></pre> <p>In Mode 4, distance can be calculated as:</p> <pre><code>distance from left mic = sqrt((iX + idist/2)^2 + iY^2 + iZ^2)\ndistance from right mic = sqrt((iX - idist/2)^2 + iY^2 + iZ^2)\n</code></pre> <p>With spat3d the distance between the sound source and any microphone should be at least (340 * 18) / sr meters. Shorter distances will work, but may produce artifacts in some cases.  There is no such limitation for spat3di and spat3dt.</p> <p>Sudden changes or discontinuities in sound source location can result in pops or clicks. Very fast movement may also degrade quality.</p> <p>ift -- Function table storing room parameters (for free field spatialization, set it to zero or negative). Table size is 54. The values in the table are:</p> Room Parameter Purpose 0 Early reflection recursion depth (0 is the sound source, 1 is the first reflection etc.) for spat3d and spat3di. The number of echoes for four walls (front, back, right, left) is: N = (2R + 2) * R. If all six walls are enabled: N = (((4R + 6)R + 8)R) / 3 1 Late reflection recursion depth (used by spat3dt only). spat3dt skips early reflections and renders echoes up to this level. If early reflection depth is negative, spat3d and spat3di will output zero, while spat3dt will start rendering from the sound source. 2 imdel for spat3d. Overrides opcode parameter if non-negative. 3 irlen for spat3dt. Overrides opcode parameter if non-negative. 4 idist value. Overrides opcode parameter if &gt;= 0. 5 Random seed (0 - 65535) -1 seeds from current time. 6 - 53 wall parameters (w = 6: ceil, w = 14: floor, w = 22: front, w = 30: back, w = 38: right, w = 46: left) w + 0 Enable reflections from this wall (0: no, 1: yes) w + 1 Wall distance from listener (in meters) w + 2 Randomization of wall distance (0 - 1) (in units of 1 / (wall distance)) w + 3 Reflection level (-1 - 1) w + 4 Parametric equalizer frequency in Hz. w + 5 Parametric equalizer level (1.0: no filtering) w + 6 Parametric equalizer Q (0.7071: no resonance) w + 7 Parametric equalizer mode (0: peak EQ, 1: low shelf, 2: high shelf) <p>imode -- Output mode</p> <ul> <li>0: B format with W output only (mono)</li> </ul> <pre><code>aout    =  aW\n</code></pre> <ul> <li>1: B format with W and Y output (stereo)</li> </ul> <pre><code>aleft   =  aW + 0.7071*aY\naright  =  aW - 0.7071*aY\n</code></pre> <ul> <li>2: B format with W, X, and Y output (2D). This can be converted to UHJ:</li> </ul> <pre><code>aWre, aWim      hilbert aW\naXre, aXim      hilbert aX\naYre, aYim      hilbert aY\naWXr    =  0.0928*aXre + 0.4699*aWre\naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre\naleft   =  aWXr + aWXiYr\naright  =  aWXr - aWXiYr\n</code></pre> <ul> <li>3: B format with all outputs (3D)</li> <li>4: Simulates a pair of microphones (stereo output)</li> </ul> <pre><code>aW      butterlp aW, ifreq      ; recommended values for ifreq\naY      butterlp aY, ifreq      ; are around 1000 Hz\naleft   =  aW + aX\naright  =  aY + aZ\n</code></pre> <p>Mode 0 is the cheapest to calculate, while mode 4 is the most expensive.</p> <p>In Mode 4, The optional lowpass filters can change the frequency response depending on direction. For example, if the sound source is located left to the listener then the high frequencies are attenuated in the right channel and slightly increased in the left. This effect can be disabled by not using filters. You can also experiment with other filters (tone etc.) for better effect.</p> <p>Note that mode 4 is most useful for listening with headphones, and is also more expensive to calculate than the B-format (0 to 3) modes. The idist parameter in this case sets the distance between left and right microphone; for headphones, values between 0.2 - 0.25 are recommended, although higher settings up to 0.4 may be used for wide stereo effects.</p> <p>More information about B format can be found here: http://www.york.ac.uk/inst/mustech/3d_audio/ambis2.htm</p> <p>imdel -- Maximum delay time for spat3d in seconds. This has to be longer than the delay time of the latest reflection (depends on room dimensions, sound source distance, and recursion depth; using this formula gives a safe (although somewhat overestimated) value:</p> <pre><code>imdel = (R + 1) * sqrt(W*W + H*H + D*D) / 340.0\n</code></pre> <p>where R is the recursion depth, W, H, and D are the width, height, and depth of the room, respectively).</p> <p>iovr -- Oversample ratio for spat3d (1 to 8). Setting it higher improves quality at the expense of memory and CPU usage. The recommended value is 2.</p> <p>istor (optional, default=0) -- Skip initialization if non-zero (default: 0).</p>"},{"location":"opcodes/spat3d/#performance","title":"Performance","text":"<p>aW, aX, aY, aZ -- Output signals</p> mode 0 mode 1 mode 2 mode 3 mode 4 aW W out W out W out W out left chn / low freq. aX 0 0 X out X out left chn / high freq. aY 0 Y out Y out Y out right chn / low freq. aZ 0 0 0 Z out right chn / high freq. <p>ain -- Input signal</p> <p>kX, kY, kZ -- Sound source coordinates (in meters)</p> <p>If you encounter very slow performance (up to 100 times slower), it may be caused by denormals (this is also true of many other IIR opcodes, including butterlp, pareq, hilbert, and many others). Underflows can be avoided by:</p> <ul> <li>Using the denorm opcode on ain before spat3d.</li> <li>mixing low level DC or noise to the input signal, e.g.</li> </ul> <p><pre><code>atmp rnd31 1/1e24, 0, 0\n\naW, aX, aY, aZ spa3di ain + atmp, ...\n</code></pre> or <pre><code>aW, aX, aY, aZ spa3di ain + 1/1e24, ...\n</code></pre></p> <ul> <li>reducing irlen in the case of spat3dt (which does not have an input signal). A value of about 0.005 is suitable for most uses, although it also depends on EQ settings. If the equalizer is not used, \u201cirlen\u201d can be set to 0.</li> </ul>"},{"location":"opcodes/spat3d/#examples","title":"Examples","text":"<p>Here is an example of the spat3d opcode that outputs a stereo file. It uses the file spat3d_stereo.csd.</p> Stereo example of the spat3d opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o spat3d_stereo.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Istvan Varga */\nsr      =  48000\nkr      =  1000\nksmps   =  48\nnchnls  =  2\n\n/* room parameters */\n\nidep    =  3    /* early reflection depth       */\n\nitmp    ftgen   1, 0, 64, -2,                                           \\\n                /* depth1, depth2, max delay, IR length, idist, seed */ \\\n                idep, 48, -1, 0.01, 0.25, 123,                          \\\n                1, 21.982, 0.05, 0.87, 4000.0, 0.6, 0.7, 2, /* ceil  */ \\\n                1,  1.753, 0.05, 0.87, 3500.0, 0.5, 0.7, 2, /* floor */ \\\n                1, 15.220, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* front */ \\\n                1,  9.317, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* back  */ \\\n                1, 17.545, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* right */ \\\n                1, 12.156, 0.05, 0.87, 5000.0, 0.8, 0.7, 2  /* left  */\n\n        instr 1\n\n/* some source signal */\n\na1      phasor 150              ; oscillator\na1      butterbp a1, 500, 200   ; filter\na1      =  taninv(a1 * 100)\na2      phasor 3                ; envelope\na2      mirror 40*a2, -100, 5\na2      limit a2, 0, 1\na1      =  a1 * a2 * 9000\n\nkazim   line 0, 2.5, 360        ; move sound source around\nkdist   line 1, 10, 4           ; distance\n\n; convert polar coordinates\nkX      =  sin(kazim * 3.14159 / 180) * kdist\nkY      =  cos(kazim * 3.14159 / 180) * kdist\nkZ      =  0\n\na1      =  a1 + 0.000001 * 0.000001     ; avoid underflows\n\nimode   =  1    ; change this to 3 for 8 spk in a cube,\n                ; or 1 for simple stereo\n\naW, aX, aY, aZ  spat3d a1, kX, kY, kZ, 1.0, 1, imode, 2, 2\n\naW      =  aW * 1.4142\n\n; stereo\n;\naL     =  aW + aY              /* left                 */\naR     =  aW - aY              /* right                */\n\n; quad (square)\n;\n;aFL     =  aW + aX + aY         /* front left           */\n;aFR     =  aW + aX - aY         /* front right          */\n;aRL     =  aW - aX + aY         /* rear left            */\n;aRR     =  aW - aX - aY         /* rear right           */\n\n; eight channels (cube)\n;\n;aUFL   =  aW + aX + aY + aZ    /* upper front left     */\n;aUFR   =  aW + aX - aY + aZ    /* upper front right    */\n;aURL   =  aW - aX + aY + aZ    /* upper rear left      */\n;aURR   =  aW - aX - aY + aZ    /* upper rear right     */\n;aLFL   =  aW + aX + aY - aZ    /* lower front left     */\n;aLFR   =  aW + aX - aY - aZ    /* lower front right    */\n;aLRL   =  aW - aX + aY - aZ    /* lower rear left      */\n;aLRR   =  aW - aX - aY - aZ    /* lower rear right     */\n\n        outs aL, aR\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Istvan Varga */\ni 1 0 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the spat3d opcode that outputs a UHJ file. It uses the file spat3d_UHJ.csd.</p> UHJ example of the spat3d opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o spat3d_UHJ.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Istvan Varga */\nsr      =  48000\nkr      =  750\nksmps   =  64\nnchnls  =  2\n\nitmp    ftgen   1, 0, 64, -2,                                           \\\n                /* depth1, depth2, max delay, IR length, idist, seed */ \\\n                3, 48, -1, 0.01, 0.25, 123,                             \\\n                1, 21.982, 0.05, 0.87, 4000.0, 0.6, 0.7, 2, /* ceil  */ \\\n                1,  1.753, 0.05, 0.87, 3500.0, 0.5, 0.7, 2, /* floor */ \\\n                1, 15.220, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* front */ \\\n                1,  9.317, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* back  */ \\\n                1, 17.545, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* right */ \\\n                1, 12.156, 0.05, 0.87, 5000.0, 0.8, 0.7, 2  /* left  */\n\n        instr 1\n\np3      =  p3 + 1.0\n\nkazim   line 0.0, 4.0, 360.0            ; azimuth\nkelev   line 40, p3 - 1.0, -20          ; elevation\nkdist   =  2.0                          ; distance\n; convert coordinates\nkX      =  kdist * cos(kelev * 0.01745329) * sin(kazim * 0.01745329)\nkY      =  kdist * cos(kelev * 0.01745329) * cos(kazim * 0.01745329)\nkZ      =  kdist * sin(kelev * 0.01745329)\n\n; source signal\na1      phasor 160.0\na2      delay1 a1\na1      =  a1 - a2\nkffrq1  port 200.0, 0.8, 12000.0\naffrq   upsamp kffrq1\naffrq   pareq affrq, 5.0, 0.0, 1.0, 2\nkffrq   downsamp affrq\naenv4   phasor 3.0\naenv4   limit 2.0 - aenv4 * 8.0, 0.0, 1.0\na1      butterbp a1 * aenv4, kffrq, 160.0\naenv    linseg 1.0, p3 - 1.0, 1.0, 0.04, 0.0, 1.0, 0.0\na_      =  4000000 * a1 * aenv + 0.00000001\n\n; spatialize\na_W, a_X, a_Y, a_Z      spat3d a_, kX, kY, kZ, 1.0, 1, 2, 2.0, 2\n\n; convert to UHJ format (stereo)\naWre, aWim      hilbert a_W\naXre, aXim      hilbert a_X\naYre, aYim      hilbert a_Y\n\naWXre   =  0.0928*aXre + 0.4699*aWre\naWXim   =  0.2550*aXim - 0.1710*aWim\n\naL      =  aWXre + aWXim + 0.3277*aYre\naR      =  aWXre - aWXim - 0.3277*aYre\n\n        outs aL, aR\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Istvan Varga */\nt 0 60\n\ni 1 0.0 8.0\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the spat3d opcode that outputs a quadrophonic file. It uses the file spat3d_quad.csd.</p> Quadrophonic example of the spat3d opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o spat3d_quad.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n/* Written by Istvan Varga */\nsr      =  48000\nkr      =  1000\nksmps   =  48\nnchnls  =  4\n\n/* room parameters */\n\nidep    =  3    /* early reflection depth       */\n\nitmp    ftgen   1, 0, 64, -2,                                           \\\n                /* depth1, depth2, max delay, IR length, idist, seed */ \\\n                idep, 48, -1, 0.01, 0.25, 123,                          \\\n                1, 21.982, 0.05, 0.87, 4000.0, 0.6, 0.7, 2, /* ceil  */ \\\n                1,  1.753, 0.05, 0.87, 3500.0, 0.5, 0.7, 2, /* floor */ \\\n                1, 15.220, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* front */ \\\n                1,  9.317, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* back  */ \\\n                1, 17.545, 0.05, 0.87, 5000.0, 0.8, 0.7, 2, /* right */ \\\n                1, 12.156, 0.05, 0.87, 5000.0, 0.8, 0.7, 2  /* left  */\n\n        instr 1\n\n/* some source signal */\n\na1      phasor 150              ; oscillator\na1      butterbp a1, 500, 200   ; filter\na1      =  taninv(a1 * 100)\na2      phasor 3                ; envelope\na2      mirror 40*a2, -100, 5\na2      limit a2, 0, 1\na1      =  a1 * a2 * 9000\n\nkazim   line 0, 2.5, 360        ; move sound source around\nkdist   line 1, 10, 4           ; distance\n\n; convert polar coordinates\nkX      =  sin(kazim * 3.14159 / 180) * kdist\nkY      =  cos(kazim * 3.14159 / 180) * kdist\nkZ      =  0\n\na1      =  a1 + 0.000001 * 0.000001     ; avoid underflows\n\nimode   =  2    ; change this to 3 for 8 spk in a cube,\n                ; or 1 for simple stereo\n\naW, aX, aY, aZ  spat3d a1, kX, kY, kZ, 1.0, 1, imode, 2, 2\n\naW      =  aW * 1.4142\n\n; stereo\n;\n;aL     =  aW + aY              /* left                 */\n;aR     =  aW - aY              /* right                */\n\n; quad (square)\n;\naFL     =  aW + aX + aY         /* front left           */\naFR     =  aW + aX - aY         /* front right          */\naRL     =  aW - aX + aY         /* rear left            */\naRR     =  aW - aX - aY         /* rear right           */\n\n; eight channels (cube)\n;\n;aUFL   =  aW + aX + aY + aZ    /* upper front left     */\n;aUFR   =  aW + aX - aY + aZ    /* upper front right    */\n;aURL   =  aW - aX + aY + aZ    /* upper rear left      */\n;aURR   =  aW - aX - aY + aZ    /* upper rear right     */\n;aLFL   =  aW + aX + aY - aZ    /* lower front left     */\n;aLFR   =  aW + aX - aY - aZ    /* lower front right    */\n;aLRL   =  aW - aX + aY - aZ    /* lower rear left      */\n;aLRR   =  aW - aX - aY - aZ    /* lower rear right     */\n\n        outq aFL, aFR, aRL, aRR\n\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n/* Written by Istvan Varga */\nt 0 60\ni 1 0 10\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/spat3d/#see-also","title":"See also","text":"<p>Panning and Spatialization: Simulation of room acoustics</p>"},{"location":"opcodes/spat3d/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2001</p> <p>New in version 4.12</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/spat3di/","title":"Spat3di","text":""},{"location":"opcodes/spat3di/#spat3di","title":"spat3di","text":"<p>Positions the input sound in a 3D space with the sound source position set at i-time.</p> <p>This opcode positions the input sound in a 3D space, with optional simulation of room acoustics, in various output formats. With spat3di, sound source position is set at i-time.</p>"},{"location":"opcodes/spat3di/#syntax","title":"Syntax","text":"<pre><code>aW, aX, aY, aZ spat3di ain, iX, iY, iZ, idist, ift, imode [, istor]\n</code></pre>"},{"location":"opcodes/spat3di/#initialization","title":"Initialization","text":"<p>iX -- Sound source X coordinate in meters (positive: right, negative: left)</p> <p>iY -- Sound source Y coordinate in meters (positive: front, negative: back)</p> <p>iZ -- Sound source Z coordinate in meters (positive: up, negative: down)</p> <p>idist -- For modes 0 to 3, idist is the unit circle distance in meters. For mode 4, idist is the distance between microphones.</p> <p>The following formulas describe amplitude and delay as a function of sound source distance from microphone(s):</p> <pre><code>amplitude = 1 / (0.1 + distance)\n\ndelay = distance / 340 (in seconds)\n</code></pre> <p>Distance can be calculated as:</p> <pre><code>distance = sqrt(iX^2 + iY^2 + iZ^2)\n</code></pre> <p>In Mode 4, distance can be calculated as:</p> <pre><code>distance from left mic = sqrt((iX + idist/2)^2 + iY^2 + iZ^2)\ndistance from right mic = sqrt((iX - idist/2)^2 + iY^2 + iZ^2)\n</code></pre> <p>With spat3d the distance between the sound source and any microphone should be at least (340 * 18) / sr meters. Shorter distances will work, but may produce artifacts in some cases.  There is no such limitation for spat3di and spat3dt.</p> <p>Sudden changes or discontinuities in sound source location can result in pops or clicks. Very fast movement may also degrade quality.</p> <p>ift -- Function table storing room parameters (for free field spatialization, set it to zero or negative). Table size is 54. The values in the table are:</p> Room Parameter Purpose 0 Early reflection recursion depth (0 is the sound source, 1 is the first reflection etc.) for spat3d and spat3di. The number of echoes for four walls (front, back, right, left) is: N = (2R + 2) * R. If all six walls are enabled: N = (((4R + 6)R + 8)R) / 3 1 Late reflection recursion depth (used by spat3dt only). spat3dt skips early reflections and renders echoes up to this level. If early reflection depth is negative, spat3d and spat3di will output zero, while spat3dt will start rendering from the sound source. 2 imdel for spat3d. Overrides opcode parameter if non-negative. 3 irlen for spat3dt. Overrides opcode parameter if non-negative. 4 idist value. Overrides opcode parameter if &gt;= 0. 5 Random seed (0 - 65535) -1 seeds from current time. 6 - 53 wall parameters (w = 6: ceil, w = 14: floor, w = 22: front, w = 30: back, w = 38: right, w = 46: left) w + 0 Enable reflections from this wall (0: no, 1: yes) w + 1 Wall distance from listener (in meters) w + 2 Randomization of wall distance (0 - 1) (in units of 1 / (wall distance)) w + 3 Reflection level (-1 - 1) w + 4 Parametric equalizer frequency in Hz. w + 5 Parametric equalizer level (1.0: no filtering) w + 6 Parametric equalizer Q (0.7071: no resonance) w + 7 Parametric equalizer mode (0: peak EQ, 1: low shelf, 2: high shelf) <p>imode -- Output mode</p> <ul> <li> <p>0: B format with W output only (mono) <pre><code>aout    =  aW\n</code></pre></p> </li> <li> <p>1: B format with W and Y output (stereo) <pre><code>aleft   =  aW + 0.7071*aY\naright  =  aW - 0.7071*aY\n</code></pre></p> </li> <li> <p>2: B format with W, X, and Y output (2D). This can be converted to UHJ: <pre><code>aWre, aWim      hilbert aW\naXre, aXim      hilbert aX\naYre, aYim      hilbert aY\naWXr    =  0.0928*aXre + 0.4699*aWre\naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre\naleft   =  aWXr + aWXiYr\naright  =  aWXr - aWXiYr\n</code></pre></p> </li> <li> <p>3: B format with all outputs (3D)</p> </li> <li>4: Simulates a pair of microphones (stereo output) <pre><code>aW      butterlp aW, ifreq      ; recommended values for ifreq\naY      butterlp aY, ifreq      ; are around 1000 Hz\naleft   =  aW + aX\naright  =  aY + aZ\n</code></pre></li> </ul> <p>Mode 0 is the cheapest to calculate, while mode 4 is the most expensive.</p> <p>In Mode 4, The optional lowpass filters can change the frequency response depending on direction. For example, if the sound source is located left to the listener then the high frequencies are attenuated in the right channel and slightly increased in the left. This effect can be disabled by not using filters. You can also experiment with other filters (tone etc.) for better effect.</p> <p>Note that mode 4 is most useful for listening with headphones, and is also more expensive to calculate than the B-format (0 to 3) modes. The idist parameter in this case sets the distance between left and right microphone; for headphones, values between 0.2 - 0.25 are recommended, although higher settings up to 0.4 may be used for wide stereo effects.</p> <p>More information about B format can be found here: http://www.york.ac.uk/inst/mustech/3d_audio/ambis2.htm</p> <p>istor (optional, default=0) -- Skip initialization if non-zero (default: 0).</p>"},{"location":"opcodes/spat3di/#performance","title":"Performance","text":"<p>ain -- Input signal</p> <p>aW, aX, aY, aZ -- Output signals</p> mode 0 mode 1 mode 2 mode 3 mode 4 aW W out W out W out W out left chn / low freq. aX 0 0 X out X out left chn / high freq. aY 0 Y out Y out Y out right chn / low freq. aZ 0 0 0 Z out right chn / high freq. <p>If you encounter very slow performance (up to 100 times slower), it may be caused by denormals (this is also true of many other IIR opcodes, including butterlp, pareq, hilbert, and many others). Underflows can be avoided by:</p> <ul> <li>Using the denorm opcode on ain before spat3di.</li> <li> <p>mixing low level DC or noise to the input signal, e.g. <pre><code>atmp rnd31 1/1e24, 0, 0\n\naW, aX, aY, aZ spat3di ain + atmp, ...\n</code></pre> or <pre><code>aW, aX, aY, aZ spa3di ain + 1/1e24, ...\n</code></pre></p> </li> <li> <p>reducing irlen in the case of spat3dt (which does not have an input signal). A value of about 0.005 is suitable for most uses, although it also depends on EQ settings. If the equalizer is not used, \u201cirlen\u201d can be set to 0.</p> </li> </ul>"},{"location":"opcodes/spat3di/#examples","title":"Examples","text":"<p>See the examples for spat3d.</p>"},{"location":"opcodes/spat3di/#see-also","title":"See also","text":"<p>Panning and Spatialization: Simulation of room acoustics</p>"},{"location":"opcodes/spat3di/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2001</p> <p>New in version 4.12</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/spat3dt/","title":"Spat3dt","text":""},{"location":"opcodes/spat3dt/#spat3dt","title":"spat3dt","text":"<p>Can be used to render an impulse response for a 3D space at i-time.</p> <p>This opcode positions the input sound in a 3D space, with optional simulation of room acoustics, in various output formats. spat3dt can be used to render the impulse response at i-time, storing output in a function table, suitable for convolution.</p>"},{"location":"opcodes/spat3dt/#syntax","title":"Syntax","text":"<pre><code>spat3dt ioutft, iX, iY, iZ, idist, ift, imode, irlen [, iftnocl]\n</code></pre>"},{"location":"opcodes/spat3dt/#initialization","title":"Initialization","text":"<p>ioutft -- Output ftable number for spat3dt. W, X, Y, and Z outputs are written interleaved to this table. If the table is too short, output will be truncated.</p> <p>iX -- Sound source X coordinate in meters (positive: right, negative: left)</p> <p>iY -- Sound source Y coordinate in meters (positive: front, negative: back)</p> <p>iZ -- Sound source Z coordinate in meters (positive: up, negative: down)</p> <p>idist -- For modes 0 to 3, idist is the unit circle distance in meters. For mode 4, idist is the distance between microphones.</p> <p>The following formulas describe amplitude and delay as a function of sound source distance from microphone(s):</p> <pre><code>amplitude = 1 / (0.1 + distance)\n\ndelay = distance / 340 (in seconds)\n</code></pre> <p>Distance can be calculated as:</p> <pre><code>distance = sqrt(iX^2 + iY^2 + iZ^2)\n</code></pre> <p>In Mode 4, distance can be calculated as:</p> <pre><code>distance from left mic = sqrt((iX + idist/2)^2 + iY^2 + iZ^2)\ndistance from right mic = sqrt((iX - idist/2)^2 + iY^2 + iZ^2)\n</code></pre> <p>With spat3d the distance between the sound source and any microphone should be at least (340 * 18) / sr meters. Shorter distances will work, but may produce artifacts in some cases.  There is no such limitation for spat3di and spat3dt.</p> <p>Sudden changes or discontinuities in sound source location can result in pops or clicks. Very fast movement may also degrade quality.</p> <p>ift -- Function table storing room parameters (for free field spatialization, set it to zero or negative). Table size is 54. The values in the table are:</p> Room Parameter Purpose 0 Early reflection recursion depth (0 is the sound source, 1 is the first reflection etc.) for spat3d and spat3di. The number of echoes for four walls (front, back, right, left) is: N = (2R + 2) * R. If all six walls are enabled: N = (((4R + 6)R + 8)R) / 3 1 Late reflection recursion depth (used by spat3dt only). spat3dt skips early reflections and renders echoes up to this level. If early reflection depth is negative, spat3d and spat3di will output zero, while spat3dt will start rendering from the sound source. 2 imdel for spat3d. Overrides opcode parameter if non-negative. 3 irlen for spat3dt. Overrides opcode parameter if non-negative. 4 idist value. Overrides opcode parameter if &gt;= 0. 5 Random seed (0 - 65535) -1 seeds from current time. 6 - 53 wall parameters (w = 6: ceil, w = 14: floor, w = 22: front, w = 30: back, w = 38: right, w = 46: left) w + 0 Enable reflections from this wall (0: no, 1: yes) w + 1 Wall distance from listener (in meters) w + 2 Randomization of wall distance (0 - 1) (in units of 1 / (wall distance)) w + 3 Reflection level (-1 - 1) w + 4 Parametric equalizer frequency in Hz. w + 5 Parametric equalizer level (1.0: no filtering) w + 6 Parametric equalizer Q (0.7071: no resonance) w + 7 Parametric equalizer mode (0: peak EQ, 1: low shelf, 2: high shelf) <p>imode -- Output mode</p> <ul> <li> <p>0: B format with W output only (mono) <pre><code>aout    =  aW\n</code></pre></p> </li> <li> <p>1: B format with W and Y output (stereo) <pre><code>aleft   =  aW + 0.7071*aY\naright  =  aW - 0.7071*aY\n</code></pre></p> </li> <li> <p>2: B format with W, X, and Y output (2D). This can be converted to UHJ: <pre><code>aWre, aWim      hilbert aW\naXre, aXim      hilbert aX\naYre, aYim      hilbert aY\naWXr    =  0.0928*aXre + 0.4699*aWre\naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre\naleft   =  aWXr + aWXiYr\naright  =  aWXr - aWXiYr\n</code></pre></p> </li> <li> <p>3: B format with all outputs (3D)</p> </li> <li>4: Simulates a pair of microphones (stereo output) <pre><code>aW      butterlp aW, ifreq      ; recommended values for ifreq\naY      butterlp aY, ifreq      ; are around 1000 Hz\naleft   =  aW + aX\naright  =  aY + aZ\n</code></pre></li> </ul> <p>Mode 0 is the cheapest to calculate, while mode 4 is the most expensive.</p> <p>In Mode 4, The optional lowpass filters can change the frequency response depending on direction. For example, if the sound source is located left to the listener then the high frequencies are attenuated in the right channel and slightly increased in the left. This effect can be disabled by not using filters. You can also experiment with other filters (tone etc.) for better effect.</p> <p>Note that mode 4 is most useful for listening with headphones, and is also more expensive to calculate than the B-format (0 to 3) modes. The idist parameter in this case sets the distance between left and right microphone; for headphones, values between 0.2 - 0.25 are recommended, although higher settings up to 0.4 may be used for wide stereo effects.</p> <p>More information about B format can be found here: http://www.york.ac.uk/inst/mustech/3d_audio/ambis2.htm</p> <p>irlen -- Impulse response length of echoes (in seconds). Depending on filter parameters, values around 0.005-0.01 are suitable for most uses (higher values result in more accurate output, but slower rendering)</p> <p>iftnocl (optional, default=0) -- Do not clear output ftable (mix to existing data) if set to 1, clear table before writing if set to 0 (default: 0).</p>"},{"location":"opcodes/spat3dt/#examples","title":"Examples","text":"<p>Here is an example of the spat3dt opcode. It uses the file spat3dt.csd.</p> Example of the spat3dt opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o spat3dt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt; \n\nsr = 44100\nksmps = 32  \nnchnls = 2\n0dbfs  = 1\n\ngarvb   init 0 \ngaW     init 0 \ngaX     init 0 \ngaY     init 0 \n\nitmp ftgen 1, 0, 64, -2, 2, 40, -1, -1, -1, 123,          \\ \n           1, 13.000, 0.05, 0.85, 20000.0, 0.0, 0.50, 2,   \\ \n           1,  2.000, 0.05, 0.85, 20000.0, 0.0, 0.25, 2,   \\ \n           1, 16.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\ \n           1,  9.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\ \n           1, 12.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\ \n           1,  8.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2 \n\nitmp ftgen 2, 0, 262144, -2, 0 \n     spat3dt 2, -0.2, 1, 0, 1, 1, 2, 0.005 \n\nitmp ftgen 3, 0, 262144, -52, 3, 2, 0, 4, 2, 1, 4, 2, 2, 4 \n\ninstr 1 \n\na1   vco2 1, 440, 10 \nkfrq port 100, 0.008, 20000 \na1   butterlp a1, kfrq \na2   linseg 0, 0.003, 1, 0.01, 0.7, 0.005, 0, 1, 0 \na1   =  a1 * a2 * 2 \n     denorm a1 \n     vincr garvb, a1 \naw, ax, ay, az spat3di a1, p4, p5, p6, 1, 1, 2 \n     vincr gaW, aw \n     vincr gaX, ax \n     vincr gaY, ay \n\nendin \n\ninstr 2 \n\ndenorm garvb \n; skip as many samples as possible without truncating the IR \narW, arX, arY ftconv garvb, 3, 2048, 2048, (65536 - 2048) \naW     =  gaW + arW \naX     =  gaX + arX \naY     =  gaY + arY \ngarvb  =  0 \ngaW    =  0 \ngaX    =  0 \ngaY    =  0 \n\naWre, aWim hilbert aW \naXre, aXim hilbert aX \naYre, aYim hilbert aY \naWXr    =  0.0928*aXre + 0.4699*aWre \naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre \naL      =  aWXr + aWXiYr \naR      =  aWXr - aWXiYr \n        outs aL, aR \n\nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 0.5  0.0  2.0 -0.8 \ni 1 1 0.5  1.4  1.4 -0.6 \ni 1 2 0.5  2.0  0.0 -0.4 \ni 1 3 0.5  1.4 -1.4 -0.2 \ni 1 4 0.5  0.0 -2.0  0.0 \ni 1 5 0.5 -1.4 -1.4  0.2 \ni 1 6 0.5 -2.0  0.0  0.4 \ni 1 7 0.5 -1.4  1.4  0.6 \ni 1 8 0.5  0.0  2.0  0.8 \ni 2 0 10 \ne \n\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/spat3dt/#see-also","title":"See also","text":"<p>Panning and Spatialization: Simulation of room acoustics</p>"},{"location":"opcodes/spat3dt/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2001</p> <p>New in version 4.12</p> <p>Updated April 2002 by Istvan Varga</p>"},{"location":"opcodes/spdist/","title":"Spdist","text":""},{"location":"opcodes/spdist/#spdist","title":"spdist","text":"<p>Calculates distance values from xy coordinates.</p> <p>spdist uses the same xy data as space, also either from a text file using Gen28 or from x and y arguments given to the unit directly. The purpose of this unit is to make available the values for distance that are calculated from the xy coordinates.</p> <p>In the case of space, the xy values are used to determine a distance which is used to attenuate the signal and prepare it for use in spsend. But it is also useful to have these values for distance available to scale the frequency of the signal before it is sent to the space unit.</p>"},{"location":"opcodes/spdist/#syntax","title":"Syntax","text":"<pre><code>k1 spdist ifn, ktime, kx, ky\n</code></pre>"},{"location":"opcodes/spdist/#initialization","title":"Initialization","text":"<p>ifn -- number of the stored function created using Gen28. This function generator reads a text file which contains sets of three values representing the xy coordinates and a time-tag for when the signal should be placed at that location. The file should look like:</p> <pre><code>0       -1       1\n1        1       1\n2        4       4\n2.1     -4      -4\n3       10     -10\n5      -40       0\n</code></pre> <p>If that file were named \"move\" then the Gen28 call in the score would like:</p> <pre><code>f1 0 0 28 \"move\"\n</code></pre> <p>Gen28 takes 0 as the size and automatically allocates memory. It creates values to 10 milliseconds of resolution. So in this case there will be 500 values created by interpolating X1 to X2 to X3 and so on, and Y1 to Y2 to Y3 and so on, over the appropriate number of values that are stored in the function table. In the above example, the sound will begin in the left front, over 1 second it will move to the right front, over another second it move further into the distance but still in the right front, then in just 1/10th of a second it moves to the left rear, a bit distant. Finally over the last .9 seconds the sound will move to the right rear, moderately distant, and it comes to rest between the two left channels (due west!), quite distant. Since the values in the table are  accessed through the use of a time-pointer in the space unit, the actual timing can be made to follow the file's timing exactly or it can be made to go faster or slower through the same trajectory. If you have access to the GUI that allows one to draw and edit the files, there is no need to create the text files manually. But as long as the file is ASCII and in the format shown above, it does not matter how it is made!</p> <p>IMPORTANT: If ifn is 0 then spdist will take its values for the xy coordinates from kx and ky.</p>"},{"location":"opcodes/spdist/#performance","title":"Performance","text":"<p>The configuration of the xy coordinates in space places the signal in the following way:</p> <ul> <li>a1 is -1, 1</li> <li>a2 is 1, 1</li> <li>a3 is -1, -1</li> <li>a4 is 1, -1</li> </ul> <p>This assumes a loudspeaker set up as a1 is left front, a2 is right front, a3 is left back, a4 is right back. Values greater than 1 will result in sounds being attenuated, as if in the distance. space considers the speakers to be at a distance of 1; smaller values of xy can be used, but space will not amplify the signal in this case. It will, however balance the signal so that it can sound as if it were within the 4 speaker space.  x=0, y=1, will place the signal equally balanced between left and right front channels, x=y=0 will place the signal equally in all 4 channels, and so on. Although there must be 4 output signals from space, it can be used in a 2 channel orchestra. If the xy's are kept so that Y&gt;=1, it should work well to do panning and fixed localization in a stereo field.</p> <p>ktime -- index into the table containing the xy coordinates. If used like:</p> <pre><code>ktime           line  0, 5, 5\na1, a2, a3, a4  space asig, 1, ktime, ...\n</code></pre> <p>with the file \"move\" described above, the speed of the signal's movement will be exactly as described in that file. However:</p> <pre><code>ktime           line  0, 10, 5\n</code></pre> <p>the signal will move at half the speed specified. Or in the case of:</p> <pre><code>ktime           line  5, 15, 0\n</code></pre> <p>the signal will move in the reverse direction as specified and 3 times slower! Finally:</p> <pre><code>ktime           line  2, 10, 3\n</code></pre> <p>will cause the signal to move only from the place specified in line 3 of the text file to the place specified in line 5 of the text file, and it will take 10 seconds to do it.</p> <p>kx, ky -- when ifn is 0, space and spdist will use these values as the XY coordinates to localize the signal.</p>"},{"location":"opcodes/spdist/#examples","title":"Examples","text":"<p>Here is an example of the spdist opcode. It uses the file spdist.csd.</p> Example of the spdist opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o spdist.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 4\n\nga1     init    0\nga2     init    0\nga3     init    0\nga4     init    0\n\ninstr 1 ;uses GEN28 file \"move2\", as found in /manual/examples\n\nifreq = 1\nkx    init 0\nky    init 0\nktime line  0, 5.6, 5.6                         ;same time as in table 1 (=\"move2\")\nkdist spdist 1, ktime, kx, ky\nkfreq = (ifreq*340) / (340 + kdist)             ;calculate doppler shift\nprintk2 kdist                                   ;print distance values\nasig  diskin2 \"flute.aiff\", kfreq, 0, 1         ;sound source is looped\na1, a2, a3, a4 space asig, 1, ktime, .1, kx, ky ;use table 1 = GEN28\nar1, ar2, ar3, ar4 spsend                       ;send to reverb\n\nga1  = ga1+ar1\nga2  = ga2+ar2\nga3  = ga3+ar3\nga4  = ga4+ar4\n     outq a1, a2, a3, a4\n\nendin\n\ninstr 99 ; reverb instrument\n\na1 reverb2 ga1, 2.5, .5\na2 reverb2 ga2, 2.5, .5\na3 reverb2 ga3, 2.5, .5\na4 reverb2 ga4, 2.5, .5\n   outq a1, a2, a3, a4\n\nga1=0   \nga2=0\nga3=0\nga4=0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 0 28 \"move2\"       ;from left front and left rear to the middle in front\n\ni 1 0 5.6               ;same time as ktime\ni 99 0 10               ;keep reverb active\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The same function and time values are used for both spdist and space. This insures that the distance values used internally in the space unit will be the same as those returned by spdist to give the impression of a Doppler shift!</p>"},{"location":"opcodes/spdist/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/spdist/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1998</p> <p>New in Csound version 3.48</p>"},{"location":"opcodes/spf/","title":"Spf","text":""},{"location":"opcodes/spf/#spf","title":"spf","text":"<p>Steiner-Parker filter.</p> <p>Spf is a digital implementation of a linear Steiner-Parker analogue filter, which is a second-order multimode filter with three separate inputs for lowpass, highpass, and bandpass and one output.</p>"},{"location":"opcodes/spf/#syntax","title":"Syntax","text":"<pre><code>asig spf alp,ahp,abp, xcf, xR[, istor]\n</code></pre>"},{"location":"opcodes/spf/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/spf/#performance","title":"Performance","text":"<p>alp, ahp, abp -- lowpass, highpass and bandpass input signals. Different signals can be used as inputs; if the same signal is placed at the lowpass and highpass inputs, the result is a band-reject output for that signal. If the same signal is used for all inputs, an allpass filter results.</p> <p>xcf -- filter cutoff frequency (a- or k-rate)</p> <p>xR -- filter damping factor, which controls peaking (for bandpass, R = 1/Q, where Q is the ratio of centre frequency and  bandwidth). A value of sqrt(2) (approx 1.414) gives no peaking (Butterworth response), and lower values will make the filter peak and ring. A value of 0 turns the filter into a sinusoidal oscillator. Valid values in the range of 0 - 2. At 2, the filter has real poles and so it is equivalent to two first-order filters in series.</p>"},{"location":"opcodes/spf/#examples","title":"Examples","text":"<p>Here is an example of the spf opcode. It uses the file spf.csd.</p> Example of the spf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n0dbfs = 1\n\n// three different inputs\ninstr 1\n alp = diskin:a(\"fox.wav\",1,0,1)/3\n ahp rand p4/3\n abp vco2 p4,100 \n af expon 100,p3,10000\n a3 spf alp,ahp,abp,af,0.707\n out a3\n a1 = 0\nendin\n\n// band-reject\ninstr 2\n a0 init 0\n anoi rand p4\n af expon 100,p3,10000\n as spf anoi,anoi,a0,af,0.3\n out as\nendin\n\n// self-oscillation\ninstr 3\n a0 init 0\n anoi rand p4\n af expon 100,p3,10000\n as spf anoi,a0,a0,af,0\n out as\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 10 0.2\ni2 10 10 0.5\ni3 20 10 0.004\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/spf/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/spf/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Feb 2021</p>"},{"location":"opcodes/splitrig/","title":"Splitrig","text":""},{"location":"opcodes/splitrig/#splitrig","title":"splitrig","text":"<p>Split a trigger signal (i.e. a timed sequence of control-rate impulses) into several channels following a structure designed by the user.</p>"},{"location":"opcodes/splitrig/#syntax","title":"Syntax","text":"<pre><code>splitrig ktrig, kndx, imaxtics, ifn, kout1 [,kout2,...,koutN]\n</code></pre>"},{"location":"opcodes/splitrig/#initialization","title":"Initialization","text":"<p>imaxtics - number of tics belonging to largest pattern</p> <p>ifn - number of table containing channel-data structuring</p>"},{"location":"opcodes/splitrig/#performance","title":"Performance","text":"<p>asig - incoming (input) signal</p> <p>ktrig - trigger signal</p> <p>The splitrig opcode splits a trigger signal into several output channels according to one or more patterns provided by the user. Normally the regular timed trigger signal generated by metro opcode is used to be transformed into rhythmic pattern that can trig several independent melodies or percussion riffs. But you can also start from non-isocronous trigger signals. This allows to use some \"interpretative\" and less \"mechanic\" groove variations. Patterns are looped and each numtics_of_pattern_N the cycle is repeated.</p> <p>The scheme of patterns is defined by the user and is stored into ifn table according to the following format:</p> <pre><code>gi1  ftgen 1,0,1024,  -2 \\  ; table is generated with GEN02 in this case\n\\                           ;\nnumtics_of_pattern_1, \\ ;pattern 1\n   tic1_out1, tic1_out2, ... , tic1_outN,\\\n   tic2_out1, tic2_out2, ... , tic2_outN,\\\n   tic3_out1, tic3_out2, ... , tic3_outN,\\\n   .....\n   ticN_out1, ticN_out2, ... , ticN_outN,\\\n\\\nnumtics_of_pattern_2, \\ ;pattern 2\n   tic1_out1, tic1_out2, ... , tic1_outN,\\\n   tic2_out1, tic2_out2, ... , tic2_outN,\\\n   tic3_out1, tic3_out2, ... , tic3_outN,\\\n   .....\n   ticN_out1, ticN_out2, ... , ticN_outN,\\\n   .....\n\\\nnumtics_of_pattern_N,\\ ;pattern N\n   tic1_out1, tic1_out2, ... , tic1_outN,\\\n   tic2_out1, tic2_out2, ... , tic2_outN,\\\n   tic3_out1, tic3_out2, ... , tic3_outN,\\\n   .....\n   ticN_out1, ticN_out2, ... , ticN_outN,\\\n</code></pre> <p>This scheme can contain more than one pattern, each one with a different number of rows. Each pattern is preceded by a a special row containing a single numtics_of_pattern_N field; this field expresses the number of tics that makes up the corresponding pattern. Each pattern's row makes up a tic.  Each pattern's column corresponds to a channel, and each field of a row is a number that makes up the value outputted by the corresponding koutXX channel (if number is a zero, corresponding output channel will not trigger anything in that particular arguments). Obviously, all rows must contain the same number of fields that must be equal to the number of koutXX channel. All patterns must contain the same number of rows, this number must be equal to the largest pattern and is defined by imaxtics variable. Even if a pattern has less tics than the largest pattern, it must be made up of the same number of rows, in this case, some of these rows, at the end of the pattern itself, will not be used (and can be set to any value, because it does not matter).</p> <p>The kndx variable chooses the number of the pattern to be played, zero indicating the first pattern. Each time the integer part of kndx changes, tic counter is reset to zero.</p> <p>Patterns are looped and each numtics_of_pattern_N the cycle is repeated.</p> <p>examples 4 - calculate average value of asig in the time interval</p> <p>This opcode can be useful in several situations, for example to implement a vu-meter</p>"},{"location":"opcodes/splitrig/#examples","title":"Examples","text":"<p>Here is an example of splitrig opcode. It uses the file splitrig.csd.</p> Example of the splitrig opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d -m0\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi &amp; Menno Knevel - 2020\n\nsr = 44100\nksmps =  32\nnchnls = 2\n0dbfs = 1\n\n; table with values \n; 4 lines =  4 kout triggers\n; 4 rows = number of tics for every pattern (imaxtics)\ngi1  ftgen 1, 0, 1024, -2,   ; Table is generated with GEN02\n\\            ; Every column represent a kout trigger           \n4, \\       ; define # of rows of numtics of pattern 0 == index 0\n\\; k1, k2, k3, k4\n   2,  3,  4,  5,\\                         \n   3,  4,  5,  5,\\\n   4, 10, 10,  3,\\\n   5,  2, 10,  4,\\\n\\\n4, \\     ; define # of rows of numtics of pattern 1 == index 1\n\\; k1, k2, k3, k4\n   6, 10,  7,  8,\\\n   8,  6,  7,  8,\\\n   8,  6, 10,  8,\\\n   9,  6, 10,  8\n\ninstr 1\n\nktrig  metro  4  ; general trigger\n; initialize out triggers\nk1 init 0\nk2 init 0\nk3 init 0\nk4 init 0\nkndx = p4    ;choose pattern 0 or 1\nimaxtics = 4 ; number of tics\nifn = 1\nsplitrig ktrig, kndx, imaxtics, ifn, k1, k2, k3, k4\nif (p5 == 1) then\n   schedkwhen ktrig, 0, 1, k1, 0, .1  ; 1st column\nelseif (p5 == 2) then\n   schedkwhen ktrig, 0, 1, k2, 0, .1  ; 2nd column\nelseif (p5 == 3) then\n   schedkwhen ktrig, 0, 1, k3, 0, .1  ; 3rd column\nelseif (p5 == 4) then\n   schedkwhen ktrig, 0, 1, k4, 0, .1  ; 4th column\nendif\nprint p5\nendin\n\ninstr 2\n\nprints \"instr 2\\n\"\nares linen  .3, 0.02, p3, .05 ;envelope \naout  poscil ares, 200\nouts aout, aout\nendin\n\ninstr 3\n\nprints \"instr 3\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 300\nouts aout, aout\nendin\n\ninstr 4\n\nprints \"instr 4\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 400\nouts aout, aout\nendin\n\ninstr 5\n\nprints \"instr 5\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 500\nouts aout, aout\nendin\n\ninstr 6\n\nprints \"instr 6\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 1500\nouts aout, aout\nendin\n\ninstr 7\n\nprints \"instr 7\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 2000\nouts aout, aout\nendin\n\ninstr 8\n\nprints \"instr 8\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 2500\nouts aout, aout\nendin\n\ninstr 9\n\nprints \"instr 9\\n\"\nares linen  .3, 0.02, p3, .05 \naout  poscil ares, 3000\nouts aout, aout\nendin\n\ninstr 10 ; dummy instrument\n\nprints \"instr 10\\n\"\n; silence\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni 1 0 4 0 1 ; play the 4 columns of pattern 0\ni 1 + 4 0 2\ni 1 + 4 0 3\ni 1 + 4 0 4\ns\ni 1 0 4 1 1 ; play the 4 colums of pattern 1\ni 1 + 4 1 2\ni 1 + 4 1 3\ni 1 + 4 1 4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/splitrig/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/splitrig/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p>"},{"location":"opcodes/spsend/","title":"Spsend","text":""},{"location":"opcodes/spsend/#spsend","title":"spsend","text":"<p>Generates output signals based on a previously defined space opcode.</p> <p>The output signals from spsend are derived from the values given for xy and reverb in the space and are ready to be sent to local or global reverb units (see example below).</p>"},{"location":"opcodes/spsend/#syntax","title":"Syntax","text":"<pre><code>a1, a2, a3, a4 spsend\n</code></pre>"},{"location":"opcodes/spsend/#performance","title":"Performance","text":"<p>The configuration of the xy coordinates in space places the signal in the following way:</p> <ul> <li>a1 is -1, 1</li> <li>a2 is 1, 1</li> <li>a3 is -1, -1</li> <li>a4 is 1, -1</li> </ul> <p>This assumes a loudspeaker set up as a1 is left front, a2 is right front, a3 is left back, a4 is right back. Values greater than 1 will result in sounds being attenuated, as if in the distance. space considers the speakers to be at a distance of 1; smaller values of xy can be used, but space will not amplify the signal in this case. It will, however balance the signal so that it can sound as if it were within the 4 speaker space.  x=0, y=1, will place the signal equally balanced between left and right front channels, x=y=0 will place the signal equally in all 4 channels, and so on. Although there must be 4 output signals from space, it can be used in a 2 channel orchestra. If the xy's are kept so that Y&gt;=1, it should work well to do panning and fixed localization in a stereo field.</p>"},{"location":"opcodes/spsend/#examples","title":"Examples","text":"<p>Here is a stereo example of the spsend opcode. It uses the file spsend.csd.</p> Example of the spsend opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o spsend.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2      ;stereo output\n\nga1 init 0\nga2 init 0\n\ninstr 1 ;sends different amounts to reverb\n\nirev = p6\nasig diskin2 \"fox.wav\", 1\na1, a2, a3, a4 space asig, 0, 0, irev, p4, p5   ;take position values from p4, p5\nar1, ar2, ar3, ar4 spsend                       ;send to reverb\n\nga1 = ga1+ar1\nga2 = ga2+ar2\n    outs a1, a2\n\nendin\n\ninstr 99 ; reverb instrument\n\na1 reverb2 ga1, 2.5, .5\na2 reverb2 ga2, 2.5, .5\n   outs a1, a2\n\nga1=0\nga2=0\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;WITH REVERB\n;place the sound in the left speaker and near\ni1 0 1 -1 1 .1\n;place the sound in the right speaker and far\ni1 1 1 45 45 .1\n;place the sound equally between left and right and in the middle ground distance\ni1 2 1 0 12 .1\n\n;NO REVERB\n;place the sound in the left speaker and near\ni1 6 1 -1 1 0\n;place the sound in the right speaker and far\ni1 7 1 45 45 0\n;place the sound equally between left and right and in the middle ground distance\ni1 8 1 0 12 0\n\ni 99 0 12       ;keep reverb active all the time\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/spsend/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/spsend/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, WA USA 1998</p> <p>New in Csound version 3.48</p>"},{"location":"opcodes/sqrt/","title":"Sqrt","text":""},{"location":"opcodes/sqrt/#sqrt","title":"sqrt","text":"<p>Returns the square root of x (x non-negative).</p> <p>The argument value is restricted for log, log10, and sqrt.</p>"},{"location":"opcodes/sqrt/#syntax","title":"Syntax","text":"<pre><code>sqrt(x)      (no rate restriction)\nsqrt(k/i[])  (k- or i-arrays )\n</code></pre> <p>where the argument within the parentheses may be an expression. Value converters perform arithmetic translation from units of one kind to units of another. The result can then be a term in a further expression.</p>"},{"location":"opcodes/sqrt/#examples","title":"Examples","text":"<p>Here is an example of the sqrt opcode. It uses the file sqrt.csd.</p> Example of the sqrt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sqrt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nasig   pluck 0.7, 55, 55, 0, 1\nkpan   line 0,p3,1 \nkleft  = sqrt(1-kpan) \nkright = sqrt(kpan) \nprintks \"square root of left channel = %f\\\\n\", 1, kleft ;show coarse of sqaure root values\n       outs asig*kleft, asig*kright                                     ;where 0.707126 is between 2 speakers\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>square root of left channel = 1.000000\nsquare root of left channel = 0.948688\nsquare root of left channel = 0.894437\nsquare root of left channel = 0.836676\nsquare root of left channel = 0.774620\nsquare root of left channel = 0.707139\nsquare root of left channel = 0.632499\nsquare root of left channel = 0.547781\nsquare root of left channel = 0.447295\nsquare root of left channel = 0.316242\n</code></pre>"},{"location":"opcodes/sqrt/#see-also","title":"See also","text":"<p>Mathematical Functions</p>"},{"location":"opcodes/squinewave/","title":"Squinewave","text":""},{"location":"opcodes/squinewave/#squinewave","title":"squinewave","text":"<p>A mostly bandlimited shape-shifting square-pulse-saw-sinewave oscillator with hardsync.</p> <p>This oscillator generates a variable shape waveform that can morph freely between classical shapes sine, square, pulse and saw. The shape is controlled by two interacting values: clip (squareness) and \"skew\" (symmetry). All shapes use a minimum number of samples per transition (ie, the sharp end of a saw or a pulse uses minimum N samples), this makes output bandlimited. At higher frequency, the minimum sweep rate takes over, so over a certain pitch all shapes \"degrade\" to sinewave. The minimum sweep rate is i-time configurable. Hardsync (a very quick sweep to phase=0) is supported, and a sync signal is output once per cycle.</p>"},{"location":"opcodes/squinewave/#syntax","title":"Syntax","text":"<pre><code>aout [, asyncout] squinewave acps, aClip, aSkew, asyncin [, iMinSweep] [, iphase]\naout [, asyncout] squinewave acps, aClip, aSkew [, ksyncin] [, iMinSweep] [, iphase]\n</code></pre>"},{"location":"opcodes/squinewave/#initialization","title":"Initialization","text":"<p>iMinSweep (optional) -- Range 4 and up. Sample count of the shortest square/pulse edges.  Default: sr/3000 (mostly alias-free).</p> <p>iphase (optional, default=-1) -- initial phase, range 0-2, proportional to the segments of the waveform (see notes). If negative value is given, skip setting phase</p>"},{"location":"opcodes/squinewave/#performance","title":"Performance","text":"<p>aout -- audio output, normalized +/-1</p> <p>asyncout -- (optional) - Sync signal: 1 at endpoint of each cycle, else 0.</p> <p>acps -- frequency. Range 0-anything; negative freq not implemented.</p> <p>aClip -- \"squareness\" of waveform shape. Range 0-1. Clip 0 is sinewave (or saw), clip 1 is squarewave (or pulse).</p> <p>aSkew -- symmetry of waveform shape. Range -1 to +1. Skew = 0 is symmetric like sine or square. Skew +1 or -1 is right/left-facing saw or pulse.</p> <p>asyncin/ksyncin -- (optional, ignored if not a-rate) - when &gt;= 1, waveform quickly sweeps to phase 0. Sweep length is 0 to about 1.5*iMinSweep samples depending on current phase.</p> <p>The squinewave opcode is a variable shape oscillator with internally generated waveform. The waveform has two parts:</p> <ol> <li>cosine sweep down, followed by flat part at -1</li> <li>cosine sweep up, followed by flat part at +1</li> </ol> <p>At the end of (2), sync signal is output.</p> <p>Clip (0-1) controls the proportion of flatness to sweep length in each segment. Skew (-1 to +1) controls the proportions of segments (1) and (2) in the waveform cycle.</p> <p>If skew &lt; 0, part (1) is shorter, if skew &gt; 0, (1) is longer than (2)</p> <p>Classic waveforms have simple values:</p> <ul> <li>sine: clip=0, skew=0</li> <li>saw(like): clip=0, skew=+1 or -1 (left- or right-facing)</li> <li>square: clip=1, skew=0</li> <li>pulse: clip=1, skew=+1 or -1</li> </ul> <p>Fractional values generate intermediate waveforms.</p> <p>asyncin</p> <p>Hardsync input (asyncin &gt;= 1) makes the waveform quickly sweep to end by raising frequency to 2 * sr/iMinSweep. Sync pulses are thus sharper than the pulse waveform.</p> <p>iMinSweep</p> <p>The waveform is bandlimited by always using a minimum number of samples for cosine sweeps, even when clip/skew are at extreme values. This is controlled by iMinSweep. Since iMinSweep is counted in samples, the waveform output is dependent on samplerate, but the spectrum will be very similiar independent of sr. Default sr/3000 is fairly \"soft\", the actual values are 14 samples at 44.1K, 16 at 48K, 32 at 96K etc. iMinSweep is counted in integers, although not strictly necessary.</p> <p>If several units of squinewave are run in unison, it is recommend to use different iMinSweep values. The min sweep value creates \"dips\" or quieter areas in the overtone series. By using slightly different min sweep settings, spectrum is filled, rather than emphasizing the spectral profile.</p>"},{"location":"opcodes/squinewave/#notes","title":"Notes","text":"<p>squinewave is based on cosine instead of sine to generate the waveform. (This simplifies the controlling logic.) The difference is that cosine cos(0) = 1, whereas sin(0) = 0. This means that hardsync occurs when waveform is at peak, just about to enter its down sweep. (Sinewave hardsync would occur at a zero-crossing)</p> <p>Tip</p> <p>The length of hardsync sweeps allows chain syncing several squinewave units, creating staggered hardsync pulses.</p> <p>Pitch stability</p> <p>Note that iMinSweep and shape limits the ability of squinewave to match frequency exactly. When skew or clip is active, and FM is applied, the squinewave waveform will be longer or shorter than the exact period. The differences even out however, so with symmetric FM, squinewave drifts back to match average frequency. Sinewave unshaped signal (clip=skew=0) matches poscil output to 7-8 significant digits (also under FM).</p> <p>Initial phase</p> <p>Setting initial phase is useful if squinewave is used as a shaped LFO. Init phase is split into 4 segments with symbolic values range 0-2, so it will start at the expected place regardless of skew/clip values. 0-1 represents the first part, 1-2 the second. Some interesting iphase segment values are:</p> <ul> <li>0 - start of 1st sweep down.</li> <li>0.5 - end of down sweep (start of \"low\" flat section).</li> <li>1 - midpoint, end of 1st flat section, start 2nd, \"up\" sweep</li> <li>1.5 - end of up sweep, (start of \"high\" flat section)</li> <li>0.25 and 1.25 are 0-crossings at middle of down/up sweep sections.</li> <li>0.75 and 1.75 are middle of low/high flat sections.</li> </ul> <p>If iphase &lt; 0 (skip) at first use, initial phase is set to 1.25, ie 0-crossing of the \"up\" sweep. This makes output look like a sinewave.</p>"},{"location":"opcodes/squinewave/#examples","title":"Examples","text":"<p>Here is an example of the squinewave opcode. It uses the file squinewave.csd.</p> Example of the squinewave opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sqrt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n;#################################################\n0dbfs = 1.1\nnchnls = 2\nksmps = 100\n\n; aSyncin, FMod for instr 2\ngafmod init 0\ngasync init 0\n\n; Modulator squinewave\ninstr 1\n    ; freq start, end\n    acps  line  p4, p3, p5\n    ; shape start, end\n    aclip  line  p6, p3, p7\n    askew  line  p8, p3, p9\n\n;  ar, async   squinewave   aFreq , aclip, askew [, asyncin, iMinSweep, iphase]\n    aout1, gasync   squinewave  cpsoct(acps), aclip, askew, 0, 17\n\n    outs1 aout1\n\n    gaFMod = aout1\nendin\n\n\n; squinewave using gaFMod and gasync input from i1\ninstr 2\n    ; freq &amp; shape start, end\n    acps  line  p4, p3, p5\n    aclip  line  p6, p3, p7\n    askew  line  p8, p3, p9\n\n    aFMindex line  p10, p3, p11\n    asyncin = gasync * p12\n    afreq = cpsoct(acps + aFMindex * gaFMod)\n\n;  ar  squinewave   aFreq, aclip, askew [, asyncin, iMinSweep, iphase]\n    aout2  squinewave   afreq , aclip, askew, asyncin\n\n    outs2 aout2\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\n; First part instr 1 hardsyncs instr 2 (p12)\n\n;          p4=fund   clip     skew \ni1 0  1.  6.11 6.06  0   1    -1  +1\ni1 +  1.  pp5  2.03  pp7  0   pp9  0\ni1 +  1.  pp5  7.11  pp7  .8  pp9 -.8\ni1 +  2.  pp5  8.11  pp7  .2  pp9  1\ni1 +  .5  pp5  6.05  pp7  .5  pp9  -.6\ni1 +  2.5 pp5  6.05  pp7  1   pp9  1\n\n;          p4=fund   clip     skew      p10=FM    p12=sync\ni2 0  .5  1.08 2.06  0   .3   -.5  +.5  0     0   1\ni2 +  .5  pp5  4.03  pp7 .5   pp9  -.6  pp11  .   .\ni2 +  .5  pp5  5.11  pp7 1    pp9   .5  pp11  .   .\ni2 +  .5  pp5  6.01  pp7 .8   pp9  -.5  pp11  .   .\ni2 +  .5  pp5  2.11  pp7 .1   pp9   .3  pp11  .   .\ni2 +  .5  pp5  3.11  pp7 .8   pp9  -.8  pp11  .   .\ni2 +  2.  pp5  4.00  pp7  0   pp9   0   pp11  .   .\ni2 +  3.  pp5  3.00  pp7  .3  pp9   1   pp11  .   .\n\n\ns  ; End section, reset clock\n\n; Second part instr 1 outputs FM for instr 2 (p10, p11)\n\n;          p4=fund   clip     skew \ni1 0  1.  6.11 6.06  0    1   -.3  +.3\ni1 +  1.  pp5  2.03  pp7  0   pp9  0\ni1 +  1.  pp5  7.11  pp7  .8  pp9  .8\ni1 +  2.  pp5  8.11  pp7  0   pp9  .4\ni1 +  .5  pp5  6.05  pp7 .5   pp9 -.6\ni1 +  2.5 pp5  6.05  pp7 .4   pp9  .8\n\n\n;          p4=fund   clip     skew      p10=FM    p12=sync\ni2 0  .5  8.08 6.06  0   .3   -.5  +.5  0     3   0\ni2 +  .5  pp5  6.03  pp7 .5   pp9  -.6  pp11  2   .\ni2 +  .5  pp5  5.11  pp7 1    pp9   .5  pp11  &lt;   .\ni2 +  .5  pp5  6.01  pp7 .8   pp9  -.5  pp11  1   .\ni2 +  .5  pp5  5.11  pp7 .5   pp9   .3  pp11  &lt;   .\ni2 +  .5  pp5  9.04  pp7 .1   pp9  -.3  pp11  .5  .\ni2 +  2.  pp5  8.11  pp7 .4   pp9   .4  pp11  2   .\ni2 +  3.  pp5  8.11  pp7 0    pp9   0   pp11  3   .\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/squinewave/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/squinewave/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman November 2017</p> <p>New in version 6.10</p>"},{"location":"opcodes/st2ms/","title":"St2ms","text":""},{"location":"opcodes/st2ms/#st2ms","title":"st2ms","text":"<p>Stereo to Mid-Side Conversion.</p> <p>It is a pure function with no side effects.</p>"},{"location":"opcodes/st2ms/#syntax","title":"Syntax","text":"<pre><code>am,as st2ms aleft,aright\n</code></pre>"},{"location":"opcodes/st2ms/#performance","title":"Performance","text":"<p>am -- mid signal output.</p> <p>as -- side signal output.</p> <p>aleft -- left channel input.</p> <p>aright -- right channel input.</p>"},{"location":"opcodes/st2ms/#examples","title":"Examples","text":"<p>Here is an example of the st2ms opcode. It uses the files st2ms.csd and stereoJungle.wav.</p> Example of the st2ms opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o st2ms.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by  Menno Knevel - 2021\n; sample = ambient sound of waterfall + animals (monkey)\n\ninstr 1 \nal, ar    diskin2    \"stereoJungle.wav\", 1          ; stereo sample\nam, as st2ms  al,ar\nfout \"MSJungleEncoded.wav\", -1, am *.6, as *.6      ; write MS encoded audio file to disk\nouts am *.6, as *.6                                 ; &amp; reduce volume a bit\n\nendin\n\ninstr 2 \nal, ar    diskin2    \"MSJungleEncoded.wav\", 1       ; get back in the MS encoded sample\nam, as ms2st  al,ar, p4\nouts am, as                               \n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 6.7          ; encode signal, write to disk\n\ni2 10 6.7 .5      ; read encoded file from disk and decode 1:1\ni2 17 6.7 .7      ; decode but with more width\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/st2ms/#see-also","title":"See also","text":"<p>Panning and Spatialization: Amplitude spatialization</p>"},{"location":"opcodes/st2ms/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini April 2021</p>"},{"location":"opcodes/stack/","title":"Stack","text":""},{"location":"opcodes/stack/#stack","title":"stack","text":"<p>Initializes and sets the size of the global stack. Deprecated.</p> <p>Plugin opcode in stackops.</p>"},{"location":"opcodes/stack/#syntax","title":"Syntax","text":"<pre><code>stack  iStackSize\n</code></pre>"},{"location":"opcodes/stack/#initialization","title":"Initialization","text":"<p>iStackSize  - size of the stack in bytes.</p>"},{"location":"opcodes/stack/#performance","title":"Performance","text":"<p>Csound implements a single global stack. Initializing the stack with the stack opcode is not required - it is optional, and if not done, the first use of push or push_f will automatically create a stack of 32768 bytes. Otherwise, stack is normally called from the orchestra header, and takes a stack size parameter in bytes (there is an upper limit of about 16 MB). Once set, the stack size is fixed and cannot be changed during performance.</p> <p>The global stack works in LIFO order: after multiple push calls, pop should be used in reverse order.</p> <p>Each push or pop operation can work on a \"bundle\" of multiple variables. When using pop, the number, type, and order of items must match those used by the corresponding push. That is, after a 'push Sfoo, ibar', you must call something like 'Sbar, ifoo pop', and not e.g. two separate 'pop' statements.</p> <p>push and pop opcodes can take variables of any type (i-, k-, a- and strings). Variables of type 'a' and 'k' are passed at performance time only, while 'i' and 'S' are passed at init time only.</p> <p>push/pop for a, k, i, and S types copy data by value. By contrast, push_f only pushes a \"reference\" to the f-signal, and then the corresponding pop_f will copy directly from the original variable to its output signal. For this reason, changing the source f-signal of push_f before pop_f is called is not recommended, and if the instrument instance owning the variable that was passed by push_f is deactivated before pop_f is called, undefined behavior may occur.</p> <p>Any stack errors (trying to push when there is no more space, or pop from an empty stack, inconsistent number or type of arguments, etc.) are fatal and terminate performance.</p>"},{"location":"opcodes/stack/#examples","title":"Examples","text":"<p>Here is an example of the stack opcode. It uses the file stack.csd.</p> Example of the stack opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o stack.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\nstack 100000 \n\ninstr 1 \n\na1      oscils 0.7, 220, 0 \nk1      line 0, p3, 1 \n        push \"blah\", 123.45, a1, k1 \n        push rnd(k1) \n\nk_rnd   pop \nS01, i01, a01, k01 pop \n        printf_i \"S01 = '%s', i01 = %g\\n\", 1, S01, i01 \nktrig   metro 5.0 \n        printf \"k01 = %.3f, k_rnd = %.3f\\n\", ktrig, k01, k_rnd \n        outs a01, a01 \n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 5 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/stack/#see-also","title":"See also","text":"<p>Stacks</p> <p>Using this opcode is somewhat hackish, as you can read here: http://csound.1045644.n5.nabble.com/passing-a-string-to-a-UDO-td1099284.html.</p>"},{"location":"opcodes/stack/#credits","title":"Credits","text":"<p>By: Istvan Varga. 2006</p> <p>Deprecated as of version 6.04.</p>"},{"location":"opcodes/statevar/","title":"Statevar","text":""},{"location":"opcodes/statevar/#statevar","title":"statevar","text":"<p>Statevar is a new digital implementation of the analogue state-variable filter.</p> <p>This filter has four simultaneous outputs: high-pass, low-pass, band-pass and band-reject. This filter uses oversampling for sharper resonance (default: 3 times oversampling). It includes a resonance limiter that prevents the filter from getting unstable.</p>"},{"location":"opcodes/statevar/#syntax","title":"Syntax","text":"<pre><code>ahp, alp, abp, abr statevar ain, xcf, xq [, iosamps, istor]\n</code></pre>"},{"location":"opcodes/statevar/#initialization","title":"Initialization","text":"<p>iosamps  -- number of times of oversampling used in the filtering process. This will determine the maximum sharpness of the filter resonance (Q). More oversampling allows higher Qs, less oversampling will limit the resonance. The default is 3 times (iosamps=0).</p> <p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/statevar/#performance","title":"Performance","text":"<p>ahp -- high-pass output signal.</p> <p>alp -- low-pass output signal.</p> <p>abp -- band-pass signal.</p> <p>abr -- band-reject signal.</p> <p>asig -- input signal.</p> <p>xcf -- filter cutoff frequency (k-rate or a-rate).</p> <p>xq -- filter Q (k-rate or a-rate). This value is limited internally depending on the frequency and the number of times of oversampling used in the process (3-times oversampling by default).</p>"},{"location":"opcodes/statevar/#examples","title":"Examples","text":"<p>Here is an example of the statevar opcode. It uses the file statevar.csd.</p> Example of the statevar opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o statevar.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nkenv linseg 0,0.1,1, p3-0.2,1, 0.1, 0           ;declick envelope       \nasig buzz .6*kenv, 100, 100, 1\nkf   expseg 100, p3/2, 5000, p3/2, 1000         ;envelope for filter cutoff\nahp,alp,abp,abr statevar asig, kf, 4\n     outs alp,ahp                               ; lowpass left, highpass right\n\nendin   \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n\ni1 0 5 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/statevar/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/statevar/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini January 2005</p> <p>New plugin in version 5</p> <p>January 2005.</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/sterrain/","title":"Sterrain","text":""},{"location":"opcodes/sterrain/#sterrain","title":"sterrain","text":"<p>A wave-terrain synthesis opcode using curves computed with the superformula</p> <p>See Wikipedia for more information.</p>"},{"location":"opcodes/sterrain/#syntax","title":"Syntax","text":"<pre><code>aout sterrain kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, km1, km2, \\\n              kn1, kn2, kn3, ka, kb, kperiod\n</code></pre>"},{"location":"opcodes/sterrain/#performance","title":"Performance","text":"<p>ktabx, ktaby -- The two tables that define the terrain - they can be changed at krate.</p> <p>The output is the result of drawing the superformula curve with parameters km1, km2, kn1, kn2, kn3, ka, kb (see on wikipedia), scaled with krx and kry and centered at kx, ky on the terrain, rotated around the center with krot radians, and traversing it at frequency kcps/kperiod.km1,km2 are converted to integers.</p> <p>As the speed of the point can change considerably for some parameter classes when drawing curve on the terrain some different sounds can be produced compared with other standard curves e.g. it can make triangle like parts in the output wave.</p> <p>The following ranges are supported and useful:</p> <p>kn1, ka, kb -- !=0 and continous.</p> <p>kn2, kn3 -- continous.</p> <p>km1, km2 -- positive integer &gt; 0: note that the curves are not on all combinations of km1,km2 closed and have poles (closed in infinity) for example if kn1&gt;0 and there exists an n,m in Z with 2*km1/km2 = 2m+1/n i.e curves with (3,2) (5,2) (7,2) etc and (5,4) (6,4) (7,4) (9,4) etc. have a pole which is noticeable when listening. If kn1 &lt; 0 then the curve is reversed and the poles go towards zero in this case. If km1 and km2 are zero silence is produced (a plain circ - same effect occurs with the tuple 2,2,2,2,2,1,1).</p> <p>kperiod -- some km1 and km2 ratios may cause pitch shifts. With the kperiod parameter this can be fixed. If the ratio is 1 then the kperiod value should also be set to km1 to get the incoming pitch out.</p>"},{"location":"opcodes/sterrain/#examples","title":"Examples","text":"<p>Here is an example of the sterrain opcode wich shows the impact of letting kn1 running towards zero. It uses the file sterrain.csd.</p> Example of the sterrain opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr     = 44100\nksmps  = 64\nnchnls = 1\n0dbfs  = 1\n\ngisine ftgen 0,0,2^12,10,1\n\ninstr 1\n\nkdclk   linseg  0, 0.1, 1, p3-0.02, 1, 0.1, 0\nkn1 transeg 2,p3/2,-5,0.15,p3/2,5,2\n\nasig sterrain 0.5, 220, 0.5, 0.5, 0.5, 0.5, 0, gisine, gisine, 4, 4, kn1, 1, 1.5, 1.5, 1, 4\nasig dcblock asig\nout asig*kdclk\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni 1 0 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an other example of the sterrain opcode showing overtone building. It uses the file sterrain2.csd.</p> Another Example of the sterrain opcode showing overtone building<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr     = 44100\nksmps  = 64\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 0,0,2^12,10,1\n\ninstr 1\n\nkdclk   linseg  0, 0.1, 1, p3-0.02, 1, 0.1, 0\nkb linseg 1,p3/2,1.7,p3/2,1\nkrot linseg 0,p3,1\n\nasig sterrain 0.5, 220, 0.5, 0.5, 0.5, 0.5, krot, gisine, gisine, 2,2,0.5,2,2,0.7,kb,2\nasig dcblock asig\nasig = asig * kdclk\naL,aR reverbsc asig, asig , 0.6, 12000, 44100, 0.5, 1\nouts aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni 1 0 40\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sterrain/#see-also","title":"See Also","text":"<p>Wave Terrain Synthesis</p>"},{"location":"opcodes/sterrain/#credits","title":"Credits","text":"<p>Author: Christian Bacher New in version 6.15</p>"},{"location":"opcodes/stix/","title":"Stix","text":""},{"location":"opcodes/stix/#stix","title":"stix","text":"<p>Semi-physical model of a stick sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/stix/#syntax","title":"Syntax","text":"<pre><code>ares stix iamp, idettack [, inum] [, idamp] [, imaxshake]\n</code></pre>"},{"location":"opcodes/stix/#initialization","title":"Initialization","text":"<p>iamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only a approximation.</p> <p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 30.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.998 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.998 which means that the default value of idamp is 0. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 1.0.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p>"},{"location":"opcodes/stix/#examples","title":"Examples","text":"<p>Here is an example of the stix opcode. It uses the file stix.csd.</p> Example of the stix opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o stix.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nidamp = p4                      ;vary damping amount\nasig stix .5, 0.01, 30, idamp\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1 .3\ni1 + 1  &gt;\ni1 + 1  &gt;\ni1 + 1 .95\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/stix/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/stix/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhOLIES (Physically-Oriented Library of Imitated Environmental Sounds) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/streson/","title":"Streson","text":""},{"location":"opcodes/streson/#streson","title":"streson","text":"<p>A string resonator with variable fundamental frequency.</p>"},{"location":"opcodes/streson/#syntax","title":"Syntax","text":"<pre><code>ares streson asig, kfr, kfdbgain\n</code></pre>"},{"location":"opcodes/streson/#performance","title":"Performance","text":"<p>asig -- the input audio signal.</p> <p>kfr -- the fundamental frequency of the string.</p> <p>kfdbgain -- feedback gain, typically between 0 and 1, of the internal delay line. A value close to 1 creates a slower decay and a more pronounced resonance. Small values may leave the input signal unaffected. Depending on the filter frequency, typical values are &gt; 0.9.  Values down to -1 are also useful.</p> <p>streson passes the input asig through a network composed of comb, low-pass and all-pass filters, similar to the one used in some versions of the Karplus-Strong algorithm, creating a string resonator effect. The fundamental frequency of the \u201cstring\u201d is controlled by the k-rate variable kfr.This opcode can be used to simulate sympathetic resonances to an input signal.</p> <p>See Modal Frequency Ratios for frequency ratios of real instruments which can be used to determine the values of kfrq.</p> <p>streson is an adaptation of the StringFlt object of the SndObj Sound Object Library developed by the author.</p>"},{"location":"opcodes/streson/#examples","title":"Examples","text":"<p>Here is an example of the streson opcode. It uses the file streson.csd.</p> Example of the streson opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o streson.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nasig diskin2 \"fox.wav\", 1, 0, 1\n\nkfr = p4\nifdbgain = 0.90\n\nastr streson asig, kfr, ifdbgain\nasig clip astr, 0, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 1 20\ni 1 + . &gt;\ni 1 + . &gt;\ni 1 + . &gt;\ni 1 + . &gt;\ni 1 + . &gt;\ni 1 + . 1000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/streson/#see-also","title":"See also","text":"<p>Waveguides</p>"},{"location":"opcodes/streson/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Music Department National University of Ireland, Maynooth Maynooth, Co. Kildare 1998</p> <p>New in Csound version 3.494</p>"},{"location":"opcodes/subinstr/","title":"Subinstr","text":""},{"location":"opcodes/subinstr/#subinstr","title":"subinstr","text":"<p>Creates and runs a numbered instrument instance as if it were an opcode.</p>"},{"location":"opcodes/subinstr/#syntax","title":"Syntax","text":"<pre><code>a1, [...] [, a8] subinstr instrnum [, p4] [, p5] [...]\na1, [...] [, a8] subinstr \"insname\" [, p4] [, p5] [...]\n</code></pre>"},{"location":"opcodes/subinstr/#initialization","title":"Initialization","text":"<p>instrnum -- Number of the instrument to be called.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p>"},{"location":"opcodes/subinstr/#performance","title":"Performance","text":"<p>a1, ..., a8 --  The audio output from the called instrument. This is generated using the signal output opcodes.</p> <p>p4, p5, ... -- Additional input values the are mapped to the called instrument p-fields, starting with p4.</p> <p>The called instrument's p2 and p3 values will be identical to the host instrument's values. While the host instrument can control its own duration, any such attempts inside the called instrument will most likely have no effect.</p>"},{"location":"opcodes/subinstr/#examples","title":"Examples","text":"<p>Here is an example of the subinstr opcode. It uses the file subinstr.csd.</p> Example of the subinstr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o subinstr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1 - Creates a basic tone.\ninstr 1\n  ; Print the value of p4, should be equal to\n  ; Instrument #2's iamp field.\n  print p4\n\n  ; Print the value of p5, should be equal to\n  ; Instrument #2's ipitch field.\n  print p5\n\n  ; Create a tone.\n  asig oscils p4, p5, 0\n\n  out asig\nendin\n\n\n; Instrument #2 - Demonstrates the subinstr opcode.\ninstr 2\n  iamp = 20000\n  ipitch = 440\n\n  ; Use Instrument #1 to create a basic sine-wave tone.\n  ; Its p4 parameter will be set using the iamp variable.\n  ; Its p5 parameter will be set using the ipitch variable.\n  abasic subinstr 1, iamp, ipitch\n\n  ; Output the basic tone that we have created.\n  out abasic\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #2 for one second.\ni 2 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the subinstr opcode using a named instrument. It uses the file subinstr_named.csd.</p> Example of the subinstr opcode using a named instrument.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o subinstr_named.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument \"basic_tone\" - Creates a basic tone.\ninstr basic_tone\n  ; Print the value of p4, should be equal to\n  ; Instrument #2's iamp field.\n  print p4\n\n  ; Print the value of p5, should be equal to\n  ; Instrument #2's ipitch field.\n  print p5\n\n  ; Create a tone.\n  asig oscils p4, p5, 0\n\n  out asig\nendin\n\n\n; Instrument #1 - Demonstrates the subinstr opcode.\ninstr 1\n  iamp = 20000\n  ipitch = 440\n\n  ; Use the \"basic_tone\" named instrument to create a \n  ; basic sine-wave tone.\n  ; Its p4 parameter will be set using the iamp variable.\n  ; Its p5 parameter will be set using the ipitch variable.\n  abasic subinstr \"basic_tone\", iamp, ipitch\n\n  ; Output the basic tone that we have created.\n  out abasic\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/subinstr/#see-also","title":"See also","text":"<p>event, schedule, subinstrinit</p> <p>Sub-instrument Control</p>"},{"location":"opcodes/subinstr/#credits","title":"Credits","text":"<p>New in version 4.21</p>"},{"location":"opcodes/subinstrinit/","title":"Subinstrinit","text":""},{"location":"opcodes/subinstrinit/#subinstrinit","title":"subinstrinit","text":"<p>Creates and runs a numbered instrument instance at init-time.</p> <p>Same as subinstr, but init-time only and has no output arguments.</p>"},{"location":"opcodes/subinstrinit/#syntax","title":"Syntax","text":"<pre><code>subinstrinit instrnum [, p4] [, p5] [...]\nsubinstrinit \"insname\" [, p4] [, p5] [...]\n</code></pre>"},{"location":"opcodes/subinstrinit/#initialization","title":"Initialization","text":"<p>instrnum -- Number of the instrument to be called.</p> <p>\u201cinsname\u201d -- A string (in double-quotes) representing a named instrument.</p> <p>p4, p5, ... -- Additional input values the are mapped to the called instrument p-fields, starting with p4.</p> <p>The called instrument's p2 and p3 values will be identical to the host instrument's values. While the host instrument can control its own duration, any such attempts inside the called instrument will most likely have no effect.</p>"},{"location":"opcodes/subinstrinit/#examples","title":"Examples","text":"<p>Here is an example of the subinstrinit opcode. It uses the file subinstrinit.csd.</p> Example of the subinstrinit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nsubinstrinit p4\nendin\n\ninstr 2\nprints \"instr. 2 playing\\n\"\nendin\n\ninstr 3\nprints \"instr. 3 playing\\n\"\nendin\n\ninstr 4\nprints \"instr. 4 playing\\n\"\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\ni1 0 2 2\ni1 2 2 3\ni1 4 2 4\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>instr. 2 playing\nB  0.000 ..  2.000 T  2.000 TT  2.000 M:  0.00000  0.00000\ninstr. 3 playing\nB  2.000 ..  4.000 T  4.000 TT  4.000 M:  0.00000  0.00000\ninstr. 4 playing\nB  4.000 ..  6.000 T  6.000 TT  6.000 M:  0.00000  0.00000\n.........\n</code></pre>"},{"location":"opcodes/subinstrinit/#see-also","title":"See also","text":"<p>Sub-instrument Control</p>"},{"location":"opcodes/subinstrinit/#credits","title":"Credits","text":"<p>New in version 4.23</p>"},{"location":"opcodes/subtracts/","title":"Subtracts","text":""},{"location":"opcodes/subtracts/#-","title":"\\(-\\)","text":"<p>Subtraction operator.</p> <p>Arithmetic operators perform operations of change-sign (negate), don't-change-sign, logical AND logical OR, add, subtract, multiply and divide. Note that a value or an expression may fall between two of these operators, either of which could take it as its left or right argument, as in</p> \\[ a + b * c. \\] <p>In such cases three rules apply:</p> <ol> <li> <p>\\(*\\) and \\(/\\) bind to their neighbors more strongly than \\(+\\) and \\(-\\). Thus the above expression is taken as: \\(a + (b * c)\\) with \\(*\\) taking \\(b\\) and \\(c\\) and then \\(+\\) taking \\(a\\) and \\(b * c\\).</p> </li> <li> <p>\\(+\\) and \\(-\\) bind more strongly than &amp;&amp;, which in turn is stronger than ||: \\(a \\;\\&amp;\\&amp;\\; b - c \\;||\\; d\\) is taken as \\((a \\;\\&amp;\\&amp;\\; (b - c))\\;||\\; d\\)</p> </li> <li> <p>When both operators bind equally strongly, the operations are done left to right: \\(a - b - c\\) is taken as \\((a - b) - c\\)</p> </li> </ol> <p>Parentheses may be used as above to force particular groupings.</p>"},{"location":"opcodes/subtracts/#syntax","title":"Syntax","text":"<pre><code>-a  (no rate restriction)\na - b  (no rate restriction)\n</code></pre> <p>where the arguments \\(a\\) and \\(b\\) may be further expressions.</p>"},{"location":"opcodes/subtracts/#arguments","title":"Arguments","text":"<p>The arguments of \\(-\\) can be scalar values or k-rate one dimensional arrays (vectors), or any combination.  If one of the arguments is an array, so is the value.</p>"},{"location":"opcodes/subtracts/#examples","title":"Examples","text":"<p>Here is an example of the - operator. It uses the file subtracts.csd.</p> Example of the - operator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac    ;;;realtime audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o -.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidur = p3\niatt = p4\nidec = p5\nisus = p3-iatt-idec                             ;calculate sustain time from subtracting attack and decay\nprintf_i \"sutain time= note duration - attack - decay --&gt; %.1f-%.1f-%.1f = %.1f\\n\", 1, idur, iatt, idec, isus\n\nkenv expseg 0.01, iatt, 1, isus, 1, idec, 0.01  ;envelope\nasig poscil 1*kenv, 200, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 4096 10 1 ;sine wave\n;      attack decay\ni 1 0 3 .1     .2\ni 1 4 3 .5    1.5\ni 1 8 5  4     .5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>sutain time= note duration - attack - decay --&gt; 3.0-0.1-0.2 = 2.7\nsutain time= note duration - attack - decay --&gt; 3.0-0.5-1.5 = 1.0\nsutain time= note duration - attack - decay --&gt; 5.0-4.0-0.5 = 0.5\n</code></pre>"},{"location":"opcodes/subtracts/#see-also","title":"See also","text":"<p>Arithmetic and Logic Operations</p>"},{"location":"opcodes/subtracts/#credits","title":"Credits","text":"<p>Arithmetic on vectors is new in version 6.00</p>"},{"location":"opcodes/sum/","title":"Sum","text":""},{"location":"opcodes/sum/#sum","title":"sum","text":"<p>Sums any number of a-rate signals, or array elements.</p>"},{"location":"opcodes/sum/#syntax","title":"Syntax","text":"<pre><code>ares sum asig1 [, asig2] [, asig3] [...]\nkres sum karr\nires sum iarr\n</code></pre>"},{"location":"opcodes/sum/#performance","title":"Performance","text":"<p>asig1, asig2, ... --  a-rate signals to be summed (mixed or added).</p> <p>karr, iarr -- Csound 1-dimensional arrays</p>"},{"location":"opcodes/sum/#examples","title":"Examples","text":"<p>Here is an example of the sum opcode. It uses the file sum.csd.</p> Example of the sum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o sum.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\na1   oscili 1, 10.0, gisine             ;combine 3 sinusses\na2   oscili 1, 1.0, gisine              ;at different rates\na3   oscili 1, 3.0, gisine\nares sum a1, a2, a3                     ;sum them\n\nares = ares*100                         ;scale result and\nasig poscil .5, ares+110, gisine        ;add to frequency                       \n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sum/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p>"},{"location":"opcodes/sum/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy April 1999</p> <p>New in Csound version 3.54</p> <p>Array versions new in version 6.09</p>"},{"location":"opcodes/sumarray/","title":"Sumarray","text":""},{"location":"opcodes/sumarray/#sumarray","title":"sumarray","text":"<p>Returns the sum of all elements in a k-rate array.</p>"},{"location":"opcodes/sumarray/#syntax","title":"Syntax","text":"<pre><code>ksum sumarray karray\n</code></pre>"},{"location":"opcodes/sumarray/#performance","title":"Performance","text":"<p>ksum --  variable for result.</p> <p>karray --  array for reading.</p>"},{"location":"opcodes/sumarray/#examples","title":"Examples","text":"<p>Here is an example of the sumarray opcode. It uses the file sumarray.csd.</p> Example of the sumarray opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-n \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example by joachim heintz\n\n           seed       0\n\ninstr 1\n;create an array with 10 elements\nkArr[]     init       10\n;fill in random numbers and print them out\nkIndx      =          0\n  until kIndx == 10 do\nkNum       random     0, 10\nkArr[kIndx] =         kNum\n           printf     \"kArr[%d] = %10f\\n\", kIndx+1, kIndx, kNum\nkIndx      +=         1\n  od\n;calculate sum of all values and print it out\nkSum       sumarray   kArr\n           printf     \"Sum of all values in kArr = %f\\n\", kIndx+1, kSum\n           turnoff\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 0.1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/sumarray/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/sumarray/#credits","title":"Credits","text":"<p>Author: John ffitch October 2011</p> <p>New in Csound version 5.14</p> <p>Revised in Csound version 6.00 to work on multidimensional arrays</p>"},{"location":"opcodes/svfilter/","title":"Svfilter","text":""},{"location":"opcodes/svfilter/#svfilter","title":"svfilter","text":"<p>A resonant second order filter, with simultaneous lowpass, highpass and bandpass outputs.</p>"},{"location":"opcodes/svfilter/#syntax","title":"Syntax","text":"<pre><code>alow, ahigh, aband svfilter  asig, kcf, kq [, iscl] [, iskip]\n</code></pre>"},{"location":"opcodes/svfilter/#initialization","title":"Initialization","text":"<p>iscl -- coded scaling factor, similar to that in reson. A non-zero value signifies a peak response factor of 1, i.e. all frequencies other than kcf are attenuated in accordance with the (normalized) response curve. A zero value signifies no scaling of the signal, leaving that to some later adjustment (see balance). The default value is 0.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/svfilter/#performance","title":"Performance","text":"<p>svfilter is a second order state-variable filter, with k-rate controls for cutoff frequency and Q.  As Q is increased, a resonant peak forms around the cutoff frequency. svfilter has simultaneous lowpass, highpass, and bandpass filter outputs; by mixing the outputs together, a variety of frequency responses can be generated. The state-variable filter, or \"multimode\" filter was a common feature in early analog synthesizers, due to the wide variety of sounds available from the interaction between cutoff, resonance, and output mix ratios. svfilter is well suited to the emulation of \"analog\" sounds, as well as other applications where resonant filters are called for.</p> <p>kcf -- Cutoff or resonant frequency of the filter, measured in Hz.</p> <p>kq -- Q of the filter, which is defined (for bandpass filters) as bandwidth/cutoff. kq should be in a range between 1 and 500. As kq is increased, the resonance of the filter increases, which corresponds to an increase in the magnitude and \"sharpness\" of the resonant peak. When using svfilter without any scaling of the signal (where iscl is either absent or 0), the volume of the resonant peak increases as Q increases. For high values of Q, it is recommended that iscl be set to a non-zero value, or that an external scaling function such as balance is used.</p> <p>svfilter is based upon an algorithm in Hal Chamberlin's _Musical Applications of Microprocessor_s (Hayden Books, 1985).</p>"},{"location":"opcodes/svfilter/#examples","title":"Examples","text":"<p>Here is an example of the svfilter opcode. It uses the file svfilter.csd.</p> Example of the svfilter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac   --limiter=.95 ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o svfilter.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidur     = p3\nifreq    = p4\niamp     = p5\nilowamp  = p6              ; determines amount of lowpass output in signal\nihighamp = p7              ; determines amount of highpass output in signal\nibandamp = p8              ; determines amount of bandpass output in signal\niq       = p9              ; value of q\n\niharms   =  (sr*.4) / ifreq\n\nasig    gbuzz .4, ifreq, iharms, 1, .9, 1               ; Sawtooth-like waveform\nkfreq   linseg 1, idur * 0.5, 4000, idur * 0.5, 1       ; Envelope to control filter cutoff\n\nalow, ahigh, aband   svfilter asig, kfreq, iq\n\naout1   =         alow * ilowamp\naout2   =         ahigh * ihighamp\naout3   =         aband * ibandamp\nasum    =         aout1 + aout2 + aout3\nkenv    linseg 0, .1, iamp, idur -.2, iamp, .1, 0       ; Simple amplitude envelope\nouts    asum * kenv, asum * kenv\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 9 1 1 .25\n\ni1  0 5 100 .1 1 0 0  5  ; lowpass sweep\ni1  5 5 200 .1 1 0 0 30  ; lowpass sweep, octave higher, higher q\ni1 10 5 100 .1 0 1 0  5  ; highpass sweep\ni1 15 5 200 .1 0 1 0 30  ; highpass sweep, octave higher, higher q\ni1 20 5 100 .1 0 0 1  5  ; bandpass sweep\ni1 25 5 200 .1 0 0 1 30  ; bandpass sweep, octave higher, higher q\ni1 30 5 200 .2 .4 .6  0  ; notch sweep - notch formed by combining highpass and lowpass outputs\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/svfilter/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/svfilter/#credits","title":"Credits","text":"<p>Author: Sean Costello Seattle, Washington 1999</p> <p>New in Csound version 3.55</p> <p>iskip new in version 6.06</p>"},{"location":"opcodes/svn/","title":"Svn","text":""},{"location":"opcodes/svn/#svn","title":"svn","text":"<p>Non-linear state variable filter.</p> <p>It has overdrive control and optional user-defined non-linear transfer function.</p>"},{"location":"opcodes/svn/#syntax","title":"Syntax","text":"<pre><code>ahp,alp,abp,abr svn asig, xcf, xQ, kdrive[, ifn,inm,imx, istor]\n</code></pre>"},{"location":"opcodes/svn/#initialization","title":"Initialization","text":"<p>ifn -- if non-zero, a function table number containing the transfer function for the filter non-linearity. This should be mid-point centered and defined in the interval -imx to imx. If zero, the filter employs an internal non-linear map based on a hyperbolic tangent. Defaults to 0.</p> <p>inm -- if non-zero, a function table number containing a normalising transfer function, generated from ifn (using GEN 4). Defaults to 0.</p> <p>imx -- The absolute max of the function table domain, which is defined as  -imx to imx. Defaults to 1.</p> <p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/svn/#performance","title":"Performance","text":"<p>ahp, alp, abp, abr -- highpass, lowpass, bandpass and bandreject ouputs.</p> <p>asig -- input</p> <p>xcf -- filter cutoff frequency (a- or k-rate)</p> <p>xQ -- filter Q (min 0.5) (a- or k-rate).</p> <p>kdrive -- overdrive factor. With the internal non-linear map, values above 0.125 will introduce progressively more non-linearities in the filter signal. When using a user-supplied transfer function, the amount of distortion introduced by this parameter will depend on the function employed. A value of 0 makes the filter completely linear. The amount of drive is also dependent on the level of the input signal. If this signal is significantly less than 0dBFS, then proportionally more drive is needed to introduce non-linearities in the signal. With a 0dBFS-level input, 100% drive is achieved with kdrive=1. With hotter input levels, kdrive can be used to moderate the non-linear distortion in the filter.</p>"},{"location":"opcodes/svn/#examples","title":"Examples","text":"<p>Here is an example of the svn opcode. It uses the file svn.csd.</p> Example of the svn opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n0dbfs = 1\n\ninstr 1\n as  vco2 0dbfs, 100\n kcf expseg 20, p3/2, 20000, p3/2, 20\n ahp, alp, abp, abr svn as, kcf, p5, p6, p7, p8\n     out alp*p4\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n// x - .2x^3 + .3x^5 - .1x^7\nf1 0 16385 3 -1 1 0 1 0 -.2 0 .3 0 -.1\nf2 0 8193 4 1 1\ni1 0 10 0.1 10 0    0 0 ; linear\ni1 + 10 0.1 10 0.25 0 0 ; 25% drive\ni1 + 10 0.1 10 0.75 0 0 ; 75% drive\ni1 + 10 0.1 10 1    0 0 ; 100% drive\ni1 + 10 0.1 10 0.25 1 2 ; table 1  25% drive \ni1 + 10 0.1 10 0.75 1 2 ; table 1  75%\ni1 + 10 0.1 10 1    1 2 ; table 1  100%\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/svn/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/svn/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Feb 2021</p>"},{"location":"opcodes/syncgrain/","title":"Syncgrain","text":""},{"location":"opcodes/syncgrain/#syncgrain","title":"syncgrain","text":"<p>Synchronous granular synthesis.</p> <p>The source sound for the grains is obtained by reading a function table containing the samples of the source waveform. For sampled-sound sources, GEN01 is used. syncgrain will accept deferred allocation tables.</p> <p>The grain generator has full control of frequency (grains/sec), overall amplitude, grain pitch (a sampling increment) and grain size (in secs), both as fixed or time-varying (signal) parameters. An extra parameter is the grain pointer speed (or rate), which controls which position the generator will start reading samples in the table for each successive grain. It is measured in fractions of grain size, so a value of 1 (the default) will make each successive grain read from where the previous grain should finish. A value of 0.5 will make the next grain start at the midway position from the previous grain start and finish, etc.. A value of 0 will make the generator read always from a fixed position of the table (wherever the pointer was last at). A negative value will decrement pointer positions. This control gives extra flexibility for creating timescale modifications in the resynthesis.</p> <p>syncgrain will generate any number of parallel grain streams (which will depend on grain density/frequency), up to the iolaps value (default 100). The number of streams (overlapped grains) is determined by grainsize*grain_freq. More grain overlaps will demand more calculations and the synthesis might not run in realtime (depending on processor power).</p> <p>syncgrain can simulate FOF-like formant synthesis, provided that a suitable shape is used as grain envelope and a sinewave as the grain wave. For this use, grain sizes of around 0.04 secs can be used. The formant centre frequency is determined by the grain pitch. Since this is a sampling increment, in order to use a frequency in Hz, that value has to be scaled by tablesize/sr. Grain frequency will determine the fundamental.</p> <p>syncgrain uses floating-point indexing, so its precision is not affected by large-size tables. This opcode is based on the SndObj library SyncGrain class.</p>"},{"location":"opcodes/syncgrain/#syntax","title":"Syntax","text":"<pre><code>asig syncgrain kamp, kfreq, kpitch, kgrsize, kprate, ifun1, ifun2, iolaps\n</code></pre>"},{"location":"opcodes/syncgrain/#initialization","title":"Initialization","text":"<p>ifun1 -- source signal function table. Deferred-allocation tables (see GEN01) are accepted, but the opcode expects a mono source.</p> <p>ifun2 -- grain envelope function table.</p> <p>iolaps -- maximum number of overlaps, max(kfreq)*max(kgrsize). Estimating a large value should not affect performance, but exceeding this value will probably have disastrous consequences.</p>"},{"location":"opcodes/syncgrain/#performance","title":"Performance","text":"<p>kamp -- amplitude scaling</p> <p>kfreq -- frequency of grain generation, or density, in grains/sec.</p> <p>kpitch -- grain pitch scaling (1=normal pitch, &lt; 1 lower, &gt; 1 higher; negative, backwards)</p> <p>kgrsize -- grain size in secs.</p> <p>kprate -- readout pointer rate, in grains. The value of 1 will advance the reading pointer 1 grain ahead in the source table. Larger values will time-compress and smaller values will time-expand the source signal. Negative values will cause the pointer to run backwards and zero will freeze it.</p>"},{"location":"opcodes/syncgrain/#examples","title":"Examples","text":"<p>Here is an example of the syncgrain opcode. It uses the file syncgrain.csd.</p> Example of the syncgrain opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o syncgrain.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\niolaps  = 2\nigrsize = 0.04\nifreq   = iolaps/igrsize\nips     = 1/iolaps\n\nistr    = .3   /* timescale  */\nipitch  = p4   /* pitchscale */\n\nasig    syncgrain 1, ifreq, ipitch, igrsize, ips*istr, 1, 2, iolaps\n        outs      asig, asig \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 0 1 \"Mathews.wav\" 0 0 0    ;deferred table\nf2   0   8192   20   2   1\n\ni1 0 11 1\ni1 + 11 4\ni1 + 11 .8\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/syncgrain/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/syncgrain/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini January 2005</p> <p>New plugin in version 5</p> <p>January 2005.</p>"},{"location":"opcodes/syncloop/","title":"Syncloop","text":""},{"location":"opcodes/syncloop/#syncloop","title":"syncloop","text":"<p>Synchronous granular synthesis.</p> <p>syncloop is a variation on syncgrain, which implements synchronous granular synthesis. syncloop adds loop start and end points and an optional start position. Loop start and end control grain start positions, so the actual grains can go beyond the loop points (if the loop points are not at the extremes of the table), enabling seamless crossfading. For more information on the granular synthesis process, check the syncgrain manual page.</p>"},{"location":"opcodes/syncloop/#syntax","title":"Syntax","text":"<pre><code>asig syncloop kamp, kfreq, kpitch, kgrsize, kprate, klstart, \\\n              klend, ifun1, ifun2, iolaps[,istart, iskip]\n</code></pre>"},{"location":"opcodes/syncloop/#initialization","title":"Initialization","text":"<p>ifun1 -- source signal function table. Deferred-allocation tables (see GEN01) are accepted, but the opcode expects a mono source.</p> <p>ifun2 -- grain envelope function table.</p> <p>iolaps -- maximum number of overlaps, max(kfreq)*max(kgrsize). Estimating a large value should not affect performance, but execeeding this value will probably have disastrous consequences.</p> <p>istart -- starting point of synthesis in secs (defaults to 0).</p> <p>iskip -- if 1, the opcode initialisation is skipped, for tied notes, performance continues from the position in the loop where the previous note stopped. The default, 0, does not skip initialisation</p>"},{"location":"opcodes/syncloop/#performance","title":"Performance","text":"<p>kamp -- amplitude scaling</p> <p>kfreq -- frequency of grain generation, or density, in grains/sec.</p> <p>kpitch -- grain pitch scaling (1=normal pitch, &lt; 1 lower, &gt; 1 higher; negative, backwards)</p> <p>kgrsize -- grain size in secs.</p> <p>kprate -- readout pointer rate, in grains. The value of 1 will advance the reading pointer 1 grain ahead in the source table. Larger values will time-compress and smaller values will time-expand the source signal. Negative values will cause the pointer to run backwards and zero will freeze it.</p> <p>klstart -- loop start in secs.</p> <p>klend -- loop end in secs.</p>"},{"location":"opcodes/syncloop/#examples","title":"Examples","text":"<p>Here is an example of the syncloop opcode. It uses the file syncloop.csd.</p> Example of the syncloop opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o syncloop.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\niolaps  = 2\nigrsize = 0.01\nifreq   = iolaps/igrsize\nips     = 1/iolaps\n\nistr    = p4  /* timescale  */\nipitch  = 1   /* pitchscale */\n\nasig    syncloop 1, ifreq, ipitch, igrsize, ips*istr, .3, .75, 1, 2, iolaps\n        outs     asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 0 1 \"drumsMlp.wav\" 0 0 0\nf2   0   8192   20   2   1\n\ni1 0 6 .5\ni1 7 6 .15\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/syncloop/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/syncloop/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini January 2005</p> <p>New plugin in version 5</p> <p>January 2005.</p>"},{"location":"opcodes/syncphasor/","title":"Syncphasor","text":""},{"location":"opcodes/syncphasor/#syncphasor","title":"syncphasor","text":"<p>Produces a normalized moving phase value with sync input and output.</p> <p>Produces a moving phase value between zero and one and an extra impulse output (\"sync out\") whenever its phase value crosses or is reset to zero. The phase can be reset at any time by an impulse on the \"sync in\" parameter.</p>"},{"location":"opcodes/syncphasor/#syntax","title":"Syntax","text":"<pre><code>aphase, asyncout syncphasor xcps, asyncin, [, iphs]\n</code></pre>"},{"location":"opcodes/syncphasor/#initialization","title":"Initialization","text":"<p>iphs (optional) -- initial phase, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is zero.</p>"},{"location":"opcodes/syncphasor/#performance","title":"Performance","text":"<p>aphase -- the output phase value; always between 0 and 1.</p> <p>asyncout -- the sync output has a value of 1.0 for one sample whenever the phase value crosses zero or whenever the sync input is non-zero.  It is zero at all other times.</p> <p>asyncin -- the sync input causes the phase to reset  to zero whenever asyncin is non-zero.</p> <p>xcps -- frequency of the phasor in cycles-per-second.  If xcps is negative, the phase value will decrease from 1 to 0 instead of increasing.</p> <p>An internal phase is successively accumulated in accordance with the xcps frequency to produce a moving phase value, normalized to lie in the range 0 &lt;= phs &lt; 1.  When used as the index to a table unit, this phase (multiplied by the desired function table length) will cause it to behave like an oscillator.</p> <p>The phase of syncphasor though can be synced to another phasor (or other signal) using the asyncin parameter.  Any time that asyncin is a non-zero value, the value of aphase will be reset to zero.  syncphasor also outputs its own \"sync\" signal that consists of a one-sample impulse whenever its phase crosses zero or is reset.  This makes it easy to chain together multiple syncphasor opcodes to create an oscillator \"hard sync\" effect.</p>"},{"location":"opcodes/syncphasor/#examples","title":"Examples","text":"<p>Here is an example of the syncphasor opcode. It uses the file syncphasor.csd.</p> Example of the syncphasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o abs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\ninstr 1\n    ; Use two syncphasors - one is the \"master\",\n    ; the other the \"slave\"\n\n    ; master's frequency determines pitch\n    imastercps  =           cpspch(p4)\n    imaxamp     =           10000\n\n    ; the slave's frequency affects the timbre \n    kslavecps   line        imastercps, p3, imastercps * 3\n\n    ; the master \"oscillator\"\n    ; the master has no sync input \n    anosync     init        0.0\n    am, async   syncphasor  imastercps, anosync\n\n    ; the slave \"oscillator\"\n    aout, as    syncphasor  kslavecps, async\n\n    adeclick    linseg      0.0, 0.05, 1.0, p3 - 0.1, 1.0, 0.05, 0.0\n\n    ; Output the slave's phase value which is a rising\n    ; sawtooth wave.  This produces aliasing, but hey, this\n    ; this is just an example ;)\n\n              out         aout * adeclick * imaxamp\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 1    7.00\ni1 + 0.5  7.02\ni1 + .    7.05\ni1 + .    7.07\ni1 + .    7.09\ni1 + 2    7.06\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the syncphasor opcode. It uses the file syncphasor-CZresonance.csd.</p> Another example of the syncphasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o syncphasor-CZresonance.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n; by Anthony Kozar. February 2008\n; http://www.anthonykozar.net/\n\n; Imitation of the Casio CZ-series synthesizer's \"Resonance\" waveforms\n; using a synced phasor to read a sinusoid table.  The jumps at the sync \n; points are smoothed by multiplying with a windowing function controlled\n; by the master phasor.\n\n; Based on information from the Wikipedia article on phase distortion:\n; http://en.wikipedia.org/wiki/Phase_distortion_synthesis\n\n; Sawtooth Resonance waveform. Smoothing function is just the inverted\n; master phasor.\n\n; The Wikipedia article shows an inverted cosine as the stored waveform,\n; which implies that it must be unipolar for the smoothing to work.\n; I have substituted a sine wave in the first phrase to keep the output\n; bipolar.  The second phrase demonstrates the much \"rezzier\" sound of the\n; bipolar cosine due to discontinuities.\n\ninstr 1\n  ifreq      =           cpspch(p4)\n  initReson  =           p5\n  itable     =           p6\n  imaxamp    =           10000\n  anosync    init        0.0\n\n  kslavecps       line        ifreq * initReson, p3, ifreq\n  amaster, async  syncphasor  ifreq, anosync            ; pair of phasors\n  aslave, async2  syncphasor  kslavecps, async          ; slave synced to master\n  aosc            tablei      aslave, itable, 1         ; use slave phasor to read a (co)sine table\n  aout            =           aosc * (1.0 - amaster)    ; inverted master smoothes jumps \n  adeclick        linseg      0.0, 0.05, 1.0, p3 - 0.1, 1.0, 0.05, 0.0\n\n                    out         aout * adeclick * imaxamp\nendin\n\n; Triangle or Trapezoidal Resonance waveform. Uses a second table to change\n; the shape of the smoothing function.  (This is my best guess so far as to\n; how these worked). The cosine table works fine with the triangular smoothing\n; but we once again need to use a sine table with the trapezoidal smoothing.\n\n; (It might be interesting to be able to vary the \"width\" of the trapezoid.\n; This could be done with the pdhalf opcode).\n\ninstr 2\n  ifreq      =           cpspch(p4)\n  initReson  =           p5\n  itable     =           p6\n  ismoothtbl =           p7\n  imaxamp    =           10000\n  anosync    init        0.0\n\n  kslavecps       line        ifreq * initReson, p3, ifreq\n  amaster, async  syncphasor  ifreq, anosync            ; pair of phasors\n  aslave, async2  syncphasor  kslavecps, async          ; slave synced to master\n  aosc            tablei      aslave, itable, 1         ; use slave phasor to read a (co)sine table\n  asmooth         tablei      amaster, ismoothtbl, 1    ; use master phasor to read smoothing table\n  aout            =           aosc * asmooth\n  adeclick        linseg      0.0, 0.05, 1.0, p3 - 0.1, 1.0, 0.05, 0.0\n\n  out         aout * adeclick * imaxamp\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16385 10  1\nf3 0 16385  9  1 1 270                  ; inverted cosine\nf5 0 4097   7  0.0 2048 1.0 2049 0.0    ; unipolar triangle\nf6 0 4097   7  1.0 2048 1.0 2049 0.0    ; \"trapezoid\"\n\n; Sawtooth resonance with a sine table\ni1 0 1    7.00  5.0  1\ni. + 0.5  7.02  4.0\ni. + .    7.05  3.0\ni. + .    7.07  2.0\ni. + .    7.09  1.0\ni. + 2    7.06  12.0\nf0 6\ns\n\n; Sawtooth resonance with a cosine table\ni1 0 1    7.00  5.0  3\ni. + 0.5  7.02  4.0\ni. + .    7.05  3.0\ni. + .    7.07  2.0\ni. + .    7.09  1.0\ni. + 2    7.06  12.0\nf0 6\ns\n\n; Triangle resonance with a cosine table\ni2 0 1    7.00  5.0  3  5\ni. + 0.5  7.02  4.0\ni. + .    7.05  3.0\ni. + .    7.07  2.0\ni. + .    7.09  1.0\ni. + 2    7.06  12.0\nf0 6\ns\n\n; Trapezoidal resonance with a sine table\ni2 0 1    7.00  5.0  1  6\ni. + 0.5  7.02  4.0\ni. + .    7.05  3.0\ni. + .    7.07  2.0\ni. + .    7.09  1.0\ni. + 2    7.06  12.0\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/syncphasor/#see-also","title":"See also","text":"<p>Phasors</p>"},{"location":"opcodes/syncphasor/#credits","title":"Credits","text":"<p>Adapted from the phasor opcode by Anthony Kozar January 2008</p> <p>New in Csound version 5.08</p>"},{"location":"opcodes/tab/","title":"Tab","text":""},{"location":"opcodes/tab/#tab","title":"tab","text":"<p>Fast table opcode.</p> <p>Faster than table because it does not allow wrap-around and limit. Has been implemented in order to provide fast access to arrays.</p>"},{"location":"opcodes/tab/#syntax","title":"Syntax","text":"<pre><code>kr tab kndx, ifn[, ixmode]\nar tab xndx, ifn[, ixmode]\n</code></pre>"},{"location":"opcodes/tab/#initialization","title":"Initialization","text":"<p>ifn -- table number</p> <p>ixmode -- defaults to zero.  If zero xndx range matches the length of the table; if non zero xndx has a 0 to 1 range.</p> <p>indx -- table index</p>"},{"location":"opcodes/tab/#performance","title":"Performance","text":"<p>andx, kndx -- table index.</p> <p>tab and tabw opcodes are similar to table but are faster, and use rounding of the index.</p>"},{"location":"opcodes/tab/#examples","title":"Examples","text":"<p>Here is an example of the tab opcode. It uses the file tab.csd.</p> Example of the tab opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tab.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngifn1 ftgen 1, 0, 0, 1, \"flute.aiff\", 0, 0, 0  ;deferred-size table\n\ninstr 1 \n\natab  init 0 \nisize tableng 1                                ;length of table?\nprint isize\nandx  phasor 1 / (isize / sr) \nasig  tab andx, 1, 1                           ;has a 0 to 1 range\n      outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 2.3\ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tab/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/tab/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p>"},{"location":"opcodes/tab2array/","title":"Tab2array","text":""},{"location":"opcodes/tab2array/#tab2array","title":"tab2array","text":"<p>Copy a slice from an f-table to an array</p> <p>Plugin opcode in emugens.</p> <p>The tab2array opcode takes an f-table and copies a slice to an array, possibly allocating it or changing its size</p>"},{"location":"opcodes/tab2array/#syntax","title":"Syntax","text":"<pre><code>kout[] tab2array ifn [, kstart, kend, kstep ]\niout[] tab2array ifn [, istart, iend, istep ]\n</code></pre>"},{"location":"opcodes/tab2array/#initialization","title":"Initialization","text":"<p>ifn - The table index to copy data from</p>"},{"location":"opcodes/tab2array/#performance","title":"Performance","text":"<p>kstart / istart - The index to start copying from. Defaults to 0</p> <p>kend / iend - The end index to stop cpying. This is NOT inclusive. 0 means copy to the end of the table. Defaults to length of table</p> <p>kstep / istep - How many elements to skip. Defaults to 1</p>"},{"location":"opcodes/tab2array/#examples","title":"Examples","text":"<p>Here is an example of the tab2array opcode. It uses the file tab2array.csd.</p> Example of the tab2array opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\n; Example file tab2array\n\n/*\n\ntab2array: copy a slice of a table to an array\n\nkout[] tab2array ifn, kstart=0, kend=0, kstep=1\niout[] tab2array ifn, istart=0, iend=0, istep=1\n\nifn: the table index to copy from\nstart: the index to start copying from\nend: the end index to stop copying. This is NOT inclusive. 0=end of table\nstep: how many elements to skip\n\n*/\n\ninstr 1\n  ifn ftgentmp 0,0,-13,-2,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n  ; copy everything at i-time, similar to copyf2array, but no need\n  ; to predefine the array\n  islice[] tab2array ifn\n  printarray islice, \"\", \"islice\"\n\n  ; copy the slice [1::2] to an array, at k-time\n  kslice[] tab2array ifn, 1, 0, 2\n  printarray kslice, 1, \"\", \"kslice\"\n\n  ; copy into a predefined array. If the number of elements to copy\n  ; excede the capacity of the array, the array is enlarged  \n  kxs[] init 3\n  kxs tab2array ifn, 0, 10\n  printarray kxs, 1, \"\", \"kxs\"\n  turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   0.1\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tab2array/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/tab2array/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2018</p> <p>New plugin in version 6.12</p>"},{"location":"opcodes/tab_i/","title":"Tab i","text":""},{"location":"opcodes/tab_i/#tab_i","title":"tab_i","text":"<p>Fast table opcodes.</p> <p>Faster than table because it does not allow wrap-around and limit. Has been implemented in order to provide fast access to arrays.</p>"},{"location":"opcodes/tab_i/#syntax","title":"Syntax","text":"<pre><code>ir tab_i indx, ifn[, ixmode]\n</code></pre>"},{"location":"opcodes/tab_i/#initialization","title":"Initialization","text":"<p>ifn -- table number</p> <p>ixmode -- defaults to zero.  If zero indx range matches the length of the table; if non zero indx has a 0 to 1 range.</p> <p>indx -- table index</p>"},{"location":"opcodes/tab_i/#performance","title":"Performance","text":"<p>indx -- table index.</p> <p>tab_i opcode is similar to table but is faster, and uses rounding of the index.</p>"},{"location":"opcodes/tab_i/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/tab_i/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p>"},{"location":"opcodes/table/","title":"Table","text":""},{"location":"opcodes/table/#table","title":"table","text":"<p>Accesses table values by direct indexing.</p>"},{"location":"opcodes/table/#syntax","title":"Syntax","text":"<pre><code>ares table andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires table indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres table kndx, ifn [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/table/#initialization","title":"Initialization","text":"<p>ifn -- function table number.</p> <p>ixmode (optional) -- index data mode. The default value is 0.</p> <ul> <li>0 = raw index</li> <li>1 = normalized (0 to 1)</li> </ul> <p>ixoff (optional) -- amount by which index is to be offset. For a table with origin at center, use tablesize/2 (raw) or .5 (normalized). The default value is 0.</p> <p>iwrap (optional) -- wraparound index flag. The default value is 0.</p> <ul> <li>0 = nowrap (index &lt; 0 treated as index=0; index &gt; tablesize sticks at index=size)</li> <li>1 = wraparound.</li> </ul>"},{"location":"opcodes/table/#performance","title":"Performance","text":"<p>table invokes table lookup on behalf of init, control or audio indices. These indices can be raw entry numbers (0,l,2...size - 1) or scaled values (0 to 1-e). Indices are first modified by the offset value then checked for range before table lookup (see iwrap). If index is likely to be full scale, or if interpolation is being used, the table should have an extended guard point. table indexed by a periodic phasor ( see phasor) will simulate an oscillator.</p>"},{"location":"opcodes/table/#examples","title":"Examples","text":"<p>Here is an example of the table opcode. It uses the file table.csd.</p> Example of the table opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac    ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o table.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkndx line 0, p3, 1                  ; Vary our index linearly from 0 to 1.\n\nifn = 1                             ; Read Table #1 with our index.\nixmode = 1\nkfreq table kndx, ifn, ixmode\na1 oscil .5, kfreq, 2; Generate a sine waveform, use our table values to vary its frequency.\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1025 -7 200 1024 2000 ; Table #1, a line from 200 to 2,000.\nf 2 0 16384 10 1            ; Table #2, a sine wave.\n\ni 1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/table/#see-also","title":"See Also","text":"<p>Table Access</p> <p>More information on this opcode: http://www.csoundjournal.com/issue12/genInstruments.html  , written by Jacob Joaquin</p>"},{"location":"opcodes/table3/","title":"Table3","text":""},{"location":"opcodes/table3/#table3","title":"table3","text":"<p>Accesses table values by direct indexing with cubic interpolation.</p>"},{"location":"opcodes/table3/#syntax","title":"Syntax","text":"<pre><code>ares table3 andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires table3 indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres table3 kndx, ifn [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/table3/#initialization","title":"Initialization","text":"<p>ifn -- function table number.</p> <p>ixmode (optional) -- index data mode. The default value is 0.</p> <ul> <li>0 = raw index</li> <li>1 = normalized (0 to 1)</li> </ul> <p>ixoff (optional) -- amount by which index is to be offset. For a table with origin at center, use tablesize/2 (raw) or .5 (normalized). The default value is 0.</p> <p>iwrap (optional) -- wraparound index flag. The default value is 0.</p> <ul> <li>0 = nowrap (index &lt; 0 treated as index=0; index &gt; tablesize sticks at index=size)</li> <li>1 = wraparound.</li> </ul>"},{"location":"opcodes/table3/#performance","title":"Performance","text":"<p>table3 is identical to tablei, except that it uses cubic interpolation. (New in Csound version 3.50).</p> <p> Warning</p> <p>Reading tables which contain stereo- or multichannel-information probably causes unwanted noise as the opcode interpolates between subsequent positions of the table regardless of the origin of its content. Usually just the content of one channel is expected. Consider using loscilx instead.</p>"},{"location":"opcodes/table3/#see-also","title":"See Also","text":"<p>Table Access</p> <p>More information on this opcode: http://www.csoundjournal.com/issue12/genInstruments.html  , written by Jacob Joaquin</p>"},{"location":"opcodes/tablecopy/","title":"Tablecopy","text":""},{"location":"opcodes/tablecopy/#tablecopy","title":"tablecopy","text":"<p>Simple, fast table copy opcode.</p>"},{"location":"opcodes/tablecopy/#syntax","title":"Syntax","text":"<pre><code>tablecopy kdft, ksft\n</code></pre>"},{"location":"opcodes/tablecopy/#performance","title":"Performance","text":"<p>kdft -- Destination function table.</p> <p>ksft -- Number of source function table.</p> <p>tablecopy -- Simple, fast table copy opcode. Takes the table length from the destination table, and reads from the start of the source table. For speed reasons, does not check the source length - just copies regardless - in \u201cwrap\u201d mode. This may read through the source table several times. A source table with length 1 will cause all values in the destination table to be written to its value.</p> <p>tablecopy cannot read or write the guardpoint. To read it use table, with ndx = the table length. Likewise use table write to write it.</p> <p>To write the guardpoint to the value in location 0, use tablegpw.</p> <p>This is primarily to change function tables quickly in a real-time situation.</p>"},{"location":"opcodes/tablecopy/#examples","title":"Examples","text":"<p>Here is an example of the tablecopy opcode. It uses the file tablecopy.csd.</p> Example of the tablecopy opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tablecopy.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr  = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n;after an example from Jonathan Murphy \n\ngilen = 7\ngilist  ftgen 1, 0, gilen + 1, -2, 2, 3, 4, 5, 6, 7     ;only 6 elements, so 1 is doubled\ngitmp   ftgen 2, 0, gilen + 1, -2, 0                    ;empty table\ngkmax   init gilen\n\nseed 0                                                  ;each time different \n\ninstr 1\n\nktrig metro 3                                           ;trigger values\nkrnd  random 0, gkmax\n\nif (ktrig == 1) then\n  kval    table  krnd, gilist\n          tablew 0, krnd, gilist\n  kread   = 0\n  kwrite  = 0\nstart:\n  knew    table kread, gilist\nif (knew != 0) then\n          tablew knew, kwrite, gitmp\n  kwrite    =  kwrite + 1\nendif\n  kread   = kread + 1\nif (kread &lt;= gilen) kgoto start\n          tablecopy gilist, gitmp                       ;fill with zeroes\n  gkmax   = gkmax - 1\nendif\n\nprintk2 kval\n\nif (gkmax &lt; 0) then\n          event \"i\", 2, 0, 1/kr                         ;when ready, then stop\nendif\n\nasig vco2 .5, 40*kval                                   ;sound generation\nouts asig, asig\n\nendin\n\ninstr 2\n\nexitnow\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Its output should include a lines like these:</p> <pre><code>i1     5.00000\ni1     3.00000\ni1     2.00000\ni1     4.00000\ni1     7.00000\ni1     6.00000\ni1     7.00000\n</code></pre>"},{"location":"opcodes/tablecopy/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablecopy/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tablefilter/","title":"Tablefilter","text":""},{"location":"opcodes/tablefilter/#tablefilter","title":"tablefilter","text":"<p>Filters a source table and writes result into a destination table.</p> <p>This opcode can be used in order to filter values from function tables following certain algorithms. The filtered output is written into a destination table and the number of elements that have passed the filter is returned.</p>"},{"location":"opcodes/tablefilter/#syntax","title":"Syntax","text":"<pre><code>knumpassed tablefilter kouttable, kintatble, kmode, kparam\n</code></pre>"},{"location":"opcodes/tablefilter/#performance","title":"Performance","text":"<p>knumpassed -- the number of elements that have passed the filter.</p> <p>kouttable -- the number of the table containing the values that have passed.</p> <p>kintatble -- the number of the table used as filter input.</p> <p>kmode -- mode of the filter:</p> <ul> <li>1 -- tests the weight of the denominators of the fractions in the source table.  Letting pass only values from the source that are less heavy than the weight of the threshold.</li> <li>2 -- tests the weight of the denominators of the fractions in the source table.  Letting pass only values from the source that are heavier than or equal to the weight of the threshold.</li> </ul> <p>kparam -- integer threshold parameter for the filter. It means that denominators whose weights are heavier than the weight of this threshold are not passed through the filter. The weight of an integer is calculated using Clarence Barlow's function of indigestibility of a number. According to this function, higher prime numbers contribute to an increased weight of any natural integer they divide.  The order of the first 16 integers according to their indigestibility is: 1, 2, 4, 3, 8, 6, 16, 12, 9, 5, 10, 15, 7, 14.</p>"},{"location":"opcodes/tablefilter/#examples","title":"Examples","text":"<p>Here is an example of the tablefilter opcode. It uses the file tablefilter.csd.</p> Example of the tablefilter opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=10\nnchnls=1\n\n      gifarn init 8     ; initialise integer for Farey Sequence F_8\n      gires fareyleni gifarn  ; calculate length of F_8, returns 23\n      ; the table length won't be a power of 2\n      ; (The length of a Farey Sequence with n &gt; 1 is always odd)\n      gilen init gires * -1\n\n      gifarey ftgen 200, 0, gilen, \"farey\", gifarn, 0\n\n      ; initialize destiniation table with 0s\n      gifiltered ftgen 0, 0, gilen, 21, 1, 0\n\n      ; initialize second destiniation table with 0s\n      gifiltered2 ftgen 0, 0, gilen, 21, 1, 0\n\n      ; table filtering opcode:   dest.         source,         mode,   threshold\n      ginumpassed tablefilteri    gifiltered,   gifarey,        1,      6\n      ; the threshold parameter indicates that denominators whose weights are heavier\n      ; than 6 are not passing through the filter. The weight is calculated using\n      ; Clarence Barlow's function of indigestibility of a number. According to this function,\n      ; higher prime numbers contribute to an increased weight of any natural integer they divide.\n      ; ginumpassed is the number of elements from the source table 'gifarey'\n      ; that have passed the test and which have been copied to the destination table 'gifiltered'\n\n      ; apply a different filter:\n      ginumpassed2 tablefilteri   gifiltered2,  gifarey,        2,      5\n      ; In mode=2 we again test the digestibility of the denominators of the\n      ; fractions in the source table.\n      ; The difference to mode=1 is that we now let pass only vaules from the\n      ; source that are as heavy as the threshold or greater.\n\n\ninstr 4\n      kndx init 0 ; read out elements of now filtered F_8 sequentially and print to file\n      if (kndx &lt; ginumpassed) then\n         kelem tab kndx, gifiltered\n         fprintks \"fareyfilter_lp.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\nendin\n\ninstr 5\n      kndx init 0 ; read out elements and print to file\n      if (kndx &lt; ginumpassed2) then\n         kelem tab kndx, gifiltered2\n         fprintks \"fareyfilter_hp.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni4      0     1\ni5      0     1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tablefilter/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablefilter/#credits","title":"Credits","text":"<p>Author: Georg Boenn  University of Glamorgan, UK</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/tablefilteri/","title":"Tablefilteri","text":""},{"location":"opcodes/tablefilteri/#tablefilteri","title":"tablefilteri","text":"<p>Filters a source table and writes result into a destination table.</p> <p>This opcode can be used in order to filter values from function tables following certain algorithms. The filtered output is written into a destination table and the number of elements that have passed the filter is returned.</p>"},{"location":"opcodes/tablefilteri/#syntax","title":"Syntax","text":"<pre><code>inumpassed tablefilteri iouttable, iintatble, imode, iparam\n</code></pre>"},{"location":"opcodes/tablefilteri/#initialization","title":"Initialization","text":"<p>inumpassed -- the number of elements that have passed the filter.</p> <p>iouttable -- the number of the table containing the values that have passed.</p> <p>iintatble -- the number of the table used as filter input.</p> <p>imode -- mode of the filter:</p> <ul> <li>1 -- tests the weight of the denominators of the fractions in the source table.  Letting pass only values from the source that are less heavy than the weight of the threshold.</li> <li>2 -- tests the weight of the denominators of the fractions in the source table.  Letting pass only values from the source that are heavier than or equal to the weight of the threshold.</li> </ul> <p>iparam -- integer threshold parameter for the filter. It means that denominators whose weights are heavier than the weight of this threshold are not passed through the filter. The weight of an integer is calculated using Clarence Barlow's function of indigestibility of a number. According to this function, higher prime numbers contribute to an increased weight of any natural integer they divide.  The order of the first 16 integers according to their indigestibility is: 1, 2, 4, 3, 8, 6, 16, 12, 9, 5, 10, 15, 7, 14.</p>"},{"location":"opcodes/tablefilteri/#examples","title":"Examples","text":"<p>Here is an example of the tablefilteri opcode. It uses the file tablefilter.csd.</p> Example of the tablefilteri opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=10\nnchnls=1\n\n      gifarn init 8     ; initialise integer for Farey Sequence F_8\n      gires fareyleni gifarn  ; calculate length of F_8, returns 23\n      ; the table length won't be a power of 2\n      ; (The length of a Farey Sequence with n &gt; 1 is always odd)\n      gilen init gires * -1\n\n      gifarey ftgen 200, 0, gilen, \"farey\", gifarn, 0\n\n      ; initialize destiniation table with 0s\n      gifiltered ftgen 0, 0, gilen, 21, 1, 0\n\n      ; initialize second destiniation table with 0s\n      gifiltered2 ftgen 0, 0, gilen, 21, 1, 0\n\n      ; table filtering opcode:   dest.         source,         mode,   threshold\n      ginumpassed tablefilteri    gifiltered,   gifarey,        1,      6\n      ; the threshold parameter indicates that denominators whose weights are heavier\n      ; than 6 are not passing through the filter. The weight is calculated using\n      ; Clarence Barlow's function of indigestibility of a number. According to this function,\n      ; higher prime numbers contribute to an increased weight of any natural integer they divide.\n      ; ginumpassed is the number of elements from the source table 'gifarey'\n      ; that have passed the test and which have been copied to the destination table 'gifiltered'\n\n      ; apply a different filter:\n      ginumpassed2 tablefilteri   gifiltered2,  gifarey,        2,      5\n      ; In mode=2 we again test the digestibility of the denominators of the\n      ; fractions in the source table.\n      ; The difference to mode=1 is that we now let pass only vaules from the\n      ; source that are as heavy as the threshold or greater.\n\n\ninstr 4\n      kndx init 0 ; read out elements of now filtered F_8 sequentially and print to file\n      if (kndx &lt; ginumpassed) then\n         kelem tab kndx, gifiltered\n         fprintks \"fareyfilter_lp.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\nendin\n\ninstr 5\n      kndx init 0 ; read out elements and print to file\n      if (kndx &lt; ginumpassed2) then\n         kelem tab kndx, gifiltered2\n         fprintks \"fareyfilter_hp.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni4      0     1\ni5      0     1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tablefilteri/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablefilteri/#credits","title":"Credits","text":"<p>Author: Georg Boenn  University of Glamorgan, UK</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/tablegpw/","title":"Tablegpw","text":""},{"location":"opcodes/tablegpw/#tablegpw","title":"tablegpw","text":"<p>Writes a table's guard point.</p>"},{"location":"opcodes/tablegpw/#syntax","title":"Syntax","text":"<pre><code>tablegpw kfn\n</code></pre>"},{"location":"opcodes/tablegpw/#performance","title":"Performance","text":"<p>kfn -- Table number to be interrogated</p> <p>tablegpw -- For writing the table's guard point, with the value which is in location 0. Does nothing if table does not exist.</p> <p>Likely to be useful after manipulating a table with tablemix or tablecopy.</p>"},{"location":"opcodes/tablegpw/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablegpw/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tablei/","title":"Tablei","text":""},{"location":"opcodes/tablei/#tablei","title":"tablei","text":"<p>Accesses table values by direct indexing with linear interpolation.</p>"},{"location":"opcodes/tablei/#syntax","title":"Syntax","text":"<pre><code>ares tablei andx, ifn [, ixmode] [, ixoff] [, iwrap]\nires tablei indx, ifn [, ixmode] [, ixoff] [, iwrap]\nkres tablei kndx, ifn [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/tablei/#initialization","title":"Initialization","text":"<p>ifn -- function table number. tablei requires the extended guard point.</p> <p>ixmode (optional) -- index data mode. The default value is 0.</p> <ul> <li>0 = raw index</li> <li>1 = normalized (0 to 1)</li> </ul> <p>ixoff (optional) -- amount by which index is to be offset. For a table with origin at center, use tablesize/2 (raw) or .5 (normalized). The default value is 0.</p> <p>iwrap (optional) -- wraparound index flag. The default value is 0.</p> <ul> <li>0 = nowrap (index &lt; 0 treated as index=0; index &gt; tablesize sticks at index=size)</li> <li>1 = wraparound.</li> </ul>"},{"location":"opcodes/tablei/#performance","title":"Performance","text":"<p>tablei is a interpolating unit in which the fractional part of index is used to interpolate between adjacent table entries. The smoothness gained by interpolation is at some small cost in execution time (see also oscili, etc.), but the interpolating and non-interpolating units are otherwise interchangeable. Note that when tablei uses a periodic index whose modulo n is less than the power of 2 table length, the interpolation process requires that there be an (n + 1)th table value that is a repeat of the 1st (see f Statement in score).</p> <p> Warning</p> <p>Reading tables which contain stereo- or multichannel-information probably causes unwanted noise as the opcode interpolates between subsequent positions of the table regardless of the origin of its content. Usually just the content of one channel is expected. Consider using loscilx instead. </p>"},{"location":"opcodes/tablei/#examples","title":"Examples","text":"<p>Here is an example of the tablei opcode. It uses the file tablei.csd.</p> Example of the tablei opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tablei.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0  ;generate new values every time the instr is played\n\ninstr 1\n\nifn = p4\nisize = p5\nithresh = 0.5\n\nitemp ftgen ifn, 0, isize, 21, 2\n\niwrite_value = 0\ni_index = 0\n\nloop_start:\n    iread_value tablei i_index, ifn\n\n    if iread_value &gt; ithresh then\n         iwrite_value = 1\n    else\n         iwrite_value = -1\n    endif\ntableiw iwrite_value, i_index, ifn\nloop_lt i_index, 1, isize, loop_start        \n    turnoff\n\nendin\n\ninstr 2\n\nifn = p4\nisize = ftlen(ifn)    \nprints \"Index\\tValue\\n\"\n\ni_index = 0\nloop_start:\n    ivalue tablei i_index, ifn\n    prints \"%d:\\t%f\\n\", i_index, ivalue\n\n  loop_lt i_index, 1, isize, loop_start    ;read table 1 with our index\n\naout oscili .5, 100, ifn                   ;use table to play the polypulse\n     outs   aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1 100 16\ni 2 0 2 100\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tablei/#see-also","title":"See Also","text":"<p>Table Access</p> <p>More information on this opcode: http://www.csoundjournal.com/issue12/genInstruments.html  , written by Jacob Joaquin</p>"},{"location":"opcodes/tableicopy/","title":"Tableicopy","text":""},{"location":"opcodes/tableicopy/#tableicopy","title":"tableicopy","text":"<p>Simple, fast table copy opcode.</p>"},{"location":"opcodes/tableicopy/#syntax","title":"Syntax","text":"<pre><code>tableicopy idft, isft\n</code></pre>"},{"location":"opcodes/tableicopy/#initialization","title":"Initialization","text":"<p>idft -- Destination function table.</p> <p>isft -- Number of source function table.</p>"},{"location":"opcodes/tableicopy/#performance","title":"Performance","text":"<p>tableicopy -- Simple, fast table copy opcodes. Takes the table length from the destination table, and reads from the start of the source table. For speed reasons, does not check the source length - just copies regardless - in \"wrap\" mode. This may read through the source table several times. A source table with length 1 will cause all values in the destination table to be written to its value.</p> <p>tableicopy cannot read or write the guardpoint. To read it use table, with ndx = the table length. Likewise use table write to write it.</p> <p>To write the guardpoint to the value in location 0, use tablegpw.</p> <p>This is primarily to change function tables quickly in a real-time situation.</p>"},{"location":"opcodes/tableicopy/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tableicopy/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tableigpw/","title":"Tableigpw","text":""},{"location":"opcodes/tableigpw/#tableigpw","title":"tableigpw","text":"<p>Writes a table's guard point.</p>"},{"location":"opcodes/tableigpw/#syntax","title":"Syntax","text":"<pre><code>tableigpw ifn\n</code></pre>"},{"location":"opcodes/tableigpw/#initialization","title":"Initialization","text":"<p>ifn -- Table number to be interrogated</p>"},{"location":"opcodes/tableigpw/#performance","title":"Performance","text":"<p>tableigpw -- For writing the table's guard point, with the value which is in location 0. Does nothing if table does not exist.</p> <p>Likely to be useful after manipulating a table with tablemix or tablecopy.</p>"},{"location":"opcodes/tableigpw/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tableigpw/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tableikt/","title":"Tableikt","text":""},{"location":"opcodes/tableikt/#tableikt","title":"tableikt","text":"<p>Provides k-rate control over table numbers.</p> <p>Function tables are read with linear interpolation.</p> <p>The standard Csound opcode tablei, when producing a k- or a-rate result, can only use an init-time variable to select the table number. tableikt accepts k-rate control as well as i-time. In all other respects they are similar to the original opcodes.</p>"},{"location":"opcodes/tableikt/#syntax","title":"Syntax","text":"<pre><code>ares tableikt xndx, kfn [, ixmode] [, ixoff] [, iwrap]\nkres tableikt kndx, kfn [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/tableikt/#initialization","title":"Initialization","text":"<p>ixmode -- if 0, xndx and ixoff ranges match the length of the table. if non-zero xndx and ixoff have a 0 to 1 range. Default is 0</p> <p>ixoff -- if 0, total index is controlled directly by xndx, ie. the indexing starts from the start of the table. If non-zero, start indexing from somewhere else in the table. Value must be positive and less than the table length (ixmode = 0) or less than 1 (ixmode not equal to 0). Default is 0.</p> <p>iwrap -- if iwrap = 0, Limit mode: when total index is below 0, then final index is 0.Total index above table length results in a final  index of the table length - high out of range total indexes stick at the upper limit of the table. If iwrap not equal to 0, Wrap mode: total index is wrapped  modulo the table length so that all total indexes map into the table. For instance, in a table of length 8, xndx = 5 and ixoff = 6 gives a total index of 11, which wraps to a final  index of 3. Default is 0.</p>"},{"location":"opcodes/tableikt/#performance","title":"Performance","text":"<p>kndx -- Index into table, either a positive number range matching the table length (ixmode = 0) or a 0 to 1 range (ixmode not equal to 0).</p> <p>xndx -- matching the table length (ixmode = 0) or a 0 to 1 range (ixmode not equal to 0)</p> <p>kfn -- Table number. Must be &gt;= 1. Floats are rounded down to an integer.  If a table number does not point to a valid table, or the table has not yet been loaded (GEN01) then an error will result and the instrument will be de-activated.</p> <p> Caution with k-rate table numbers</p> <p>At k-rate, if a table number of &lt; 1 is given, or the table number points to a non-existent table, or to one which has a length of 0 (it is to be loaded from a file later) then an error will result and the instrument will be deactivated. kfn must be initialized at the appropriate rate using init. Attempting to load an i-rate value into kfn will result in an error.</p>"},{"location":"opcodes/tableikt/#examples","title":"Examples","text":"<p>Here is an example of the tableikt opcode. It uses the file tableikt.csd.</p> Example of the tableikt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tableikt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nilowfn  = p4                                    ;lowest ftable wave\nihighfn = p5                                    ;highest ftable wave\n\nkswpenv line 1, p3, 0                           ;sweep envelope, calculate current table pair and interpolation amount\ninumtables = ihighfn - ilowfn                   ;1 less than number of tables\nkfn1    = int(kswpenv*inumtables) + ilowfn\n        printks \"play table no: %d\\n\", 1, kfn1\nkfn2    = kfn1 + 1\nkinterp = frac(kswpenv*inumtables)              \nixmode  = 1                                     ;read tables with phasor\naphase  phasor  40      \nasig    tableikt aphase, kfn1, ixmode           ;normalized index\n   if kswpenv == 1.0 kgoto skipfn2              ;if kfn1 is last table, there is no kfn2\n        asig2   tableikt aphase, kfn2, ixmode\n   skipfn2:\n   amix ntrpol  asig, asig2, kinterp            ;interpolate between tables and output\n        outs    amix*.5, amix*.5\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1  0 16384 10 1  \nf 2  0 16384 10 1 .5  \nf 3  0 16384 1 \"fox.wav\" 0 0 0                          ;a sample\nf 4  0 16384 10 1 .5 .3 .25 .2 .16 .14 .125 .111        ;sawtooth \nf 5  0 16384 10 1 .4 .3 .25 .2\nf 6  0 16384 10 1 .3 .3 .25 .2 .16 \nf 7  0 16384 10 1  1  1  1  .7 .5  .3  .1               ;pulse\nf 8  0 16384 1 \"drumsMlp.wav\" 0 0 0                     ;a sample\n\ni 1 0 10 1 8\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>play table no: 8\nplay table no: 7\nplay table no: 6\n.....\nplay table no: 2\nplay table no: 1\n</code></pre>"},{"location":"opcodes/tableikt/#see-also","title":"See also","text":"<p>Table Reading with Dynamic Selection</p>"},{"location":"opcodes/tableikt/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tableimix/","title":"Tableimix","text":""},{"location":"opcodes/tableimix/#tableimix","title":"tableimix","text":"<p>Mixes two tables.</p>"},{"location":"opcodes/tableimix/#syntax","title":"Syntax","text":"<pre><code>tableimix idft, idoff, ilen, is1ft, is1off, is1g, is2ft, is2off, is2g\n</code></pre>"},{"location":"opcodes/tableimix/#initialization","title":"Initialization","text":"<p>idft -- Destination function table.</p> <p>idoff -- Offset to start writing from. Can be negative.</p> <p>ilen -- Number of write operations to perform. Negative means work backwards.</p> <p>is1ft, is2ft -- Source function tables. These can be the same as the destination table, if care is exercised about direction of copying data.</p> <p>is1off, is2off -- Offsets to start reading from in source tables.</p> <p>is1g, is2g -- Gains to apply when reading from the source tables. The results are added and the sum is written to the destination table.</p>"},{"location":"opcodes/tableimix/#performance","title":"Performance","text":"<p>tableimix -- This opcode mixes from two tables, with separate gains into the destination table. Writing is done for ilen locations, usually stepping forward through the table - if ilen is positive. If it is negative, then the writing and reading order is backwards - towards lower indexes in the tables. This bi-directional option makes it easy to shift the contents of a table sideways by reading from it and writing back to it with a different offset.</p> <p>If ilen is 0, no writing occurs. Note that the internal integer value of ilen is derived from the ANSI C floor() function - which returns the next most negative integer. Hence a fractional negative ilen value of -2.3 would create an internal length of 3, and cause the copying to start from the offset locations and proceed for two locations to the left.</p> <p>The total index for table reading and writing is calculated from the starting offset for each table, plus the index value, which starts at 0 and then increments (or decrements) by 1 as mixing proceeds.</p> <p>These total indexes can potentially be very large, since there is no restriction on the offset or the ilen. However each total index for each table is ANDed with a length mask (such as 0000 0111 for a table of length 8) to form a final index which is actually used for reading or writing. So no reading or writing can occur outside the tables. This is the same as \u201cwrap\u201d mode in table read and write. These opcodes do not read or write the guardpoint. If a table has been rewritten with one of these, then if it has a guardpoint which is supposed to contain the same value as the location 0, then call tableigpw afterwards.</p> <p>The indexes and offsets are all in table steps - they are not normalized to 0 - 1. So for a table of length 256, ilen should be set to 256 if all the table was to be read or written.</p> <p>The tables do not need to be the same length - wrapping occurs individually for each table.</p>"},{"location":"opcodes/tableimix/#examples","title":"Examples","text":"<p>Here is an example of the tableimix opcode. It uses the file tableimix.csd.</p> Example of the tableimix opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tableimix.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 1, 0, 256, 10, 1, 0, 0, .4         ;sinoid\ngisaw  ftgen 2, 0, 1024, 7, 0, 256, 1           ;saw\ngimix  ftgen 100, 0, 256, 7, 0, 256, 1          ;used to mix\n\ninstr 1\n\n      tableimix 100, 0, 256, 1, 0, 1, 2, 0, .5\nasig  poscil .5, 110, gimix                     ;mix table 1 &amp; 2                        \n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tableimix/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tableimix/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tableiw/","title":"Tableiw","text":""},{"location":"opcodes/tableiw/#tableiw","title":"tableiw","text":"<p>Deprecated as of version 3.49. Use the tablew opcode instead.</p>"},{"location":"opcodes/tableiw/#syntax","title":"Syntax","text":"<pre><code>tableiw isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]\n</code></pre>"},{"location":"opcodes/tableiw/#initialization","title":"Initialization","text":"<p>isig -- Input value to write to the table.</p> <p>indx -- Index into table, either a positive number range matching the table length (ixmode = 0) or a 0 to 1 range (ixmode not equal to 0)</p> <p>ifn -- Table number. Must be &gt;= 1. Floats are rounded down to an integer. If a table number does not point to a valid table, or the table has not yet been loaded (GEN01) then an error will result and the instrument will be de-activated.</p> <p>ixmode (optional, default=0) -- index mode.</p> <ul> <li>0 = indx and ixoff ranges match the length of the table.</li> <li>not equal to 0 = indx and ixoff have a 0 to 1 range.</li> </ul> <p>ixoff (optional, default=0) -- index offset.</p> <ul> <li>0 = Total index is controlled directly by indx, i.e. the indexing starts from the start of the table.</li> <li>Not equal to 0 = Start indexing from somewhere else in the table. Value must be positive and less than the table length (ixmode = 0) or less than 1 (ixmode not equal to  0).</li> </ul> <p>iwgmode (optional, default=0) -- Wrap and guard point mode.</p> <ul> <li>0 = Limit mode.</li> <li>1 = Wrap mode.</li> <li>2 = Guardpoint mode.</li> </ul>"},{"location":"opcodes/tableiw/#performance","title":"Performance","text":""},{"location":"opcodes/tableiw/#limit-mode-0","title":"Limit mode (0)","text":"<p>Limit the total index (indx + ixoff) to between 0 and the guard point. For a table of length 5, this means that locations 0 to 3 and location 4 (the guard point) can be written. A negative total index writes to location 0.</p>"},{"location":"opcodes/tableiw/#wrap-mode-1","title":"Wrap mode (1)","text":"<p>Wrap total index value into locations 0 to E, where E is either one less than the table length or the factor of 2 number which is one less than the table length. For example, wrap into a 0 to 3 range - so that total index 6 writes to location 2.</p>"},{"location":"opcodes/tableiw/#guardpoint-mode-2","title":"Guardpoint mode (2)","text":"<p>The guardpoint is written at the same time as location 0 is written - with the same value.</p> <p>This facilitates writing to tables which are intended to be read with interpolation for producing smooth cyclic waveforms. In addition, before it is used, the total index is incremented by half the range between one location and the next, before being rounded down to the integer address of a table location.</p> <p>Normally (iwgmode = 0 or 1) for a table of length 5 - which has locations 0 to 3 as the main table and location 4 as the guard point, a total index in the range of 0 to 0.999 will write to location 0. (\"0.999\" means just less than 1.0.) 1.0 to 1.999 will write to location 1 etc. A similar pattern holds for all total indexes 0 to 4.999 (igwmode = 0) or to 3.999 (igwmode = 1). igwmode = 0 enables locations 0 to 4 to be written - with the guardpoint (4) being written with a potentially different value from location 0.</p> <p>With a table of length 5 and the iwgmode = 2, then when the total index is in the range 0 to 0.499, it will write to locations 0 and 4. Range 0.5 to 1.499 will write to location 1 etc. 3.5 to 4.0 will also write to locations 0 and 4.</p> <p>This way, the writing operation most closely approximates the results of interpolated reading. Guard point mode should only be used with tables that have a guardpoint.</p> <p>Guardpoint mode is accomplished by adding 0.5 to the total index, rounding to the next lowest integer, wrapping it modulo the factor of two which is one less than the table length, writing the table (locations 0 to 3 in our example) and then writing to the guard point if index = 0.</p>"},{"location":"opcodes/tableiw/#examples","title":"Examples","text":"<p>Here is an example of the tableiw opcode. It uses the file tableiw.csd.</p> Example of the tableiw opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tableiw.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0  ;generate new values every time the instr is played\n\ninstr 1\n\nifn = p4\nisize = p5\nithresh = 0.5\n\nitemp ftgen ifn, 0, isize, 21, 2\n\niwrite_value = 0\ni_index = 0\n\nloop_start:\n    iread_value tablei i_index, ifn\n\n    if iread_value &gt; ithresh then\n         iwrite_value = 1\n    else\n         iwrite_value = -1\n    endif\ntableiw iwrite_value, i_index, ifn\nloop_lt i_index, 1, isize, loop_start        \n    turnoff\n\nendin\n\ninstr 2\n\nifn = p4\nisize = ftlen(ifn)    \nprints \"Index\\tValue\\n\"\n\ni_index = 0\nloop_start:\n    ivalue tablei i_index, ifn\n    prints \"%d:\\t%f\\n\", i_index, ivalue\n\n  loop_lt i_index, 1, isize, loop_start         ;read table 1 with our index\n\naout oscili .5, 100, ifn                        ;use table to play the polypulse\n     outs   aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1 100 16\ni 2 0 2 100\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tableiw/#see-also","title":"See Also","text":"<p>tablew, tablewkt</p> <p>More information on this opcode: http://www.csoundjournal.com/issue12/genInstruments.html  , written by Jacob Joaquin</p>"},{"location":"opcodes/tableiw/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p> <p>Updated August 2002, thanks go to Abram Hindle for pointing out the correct syntax.</p>"},{"location":"opcodes/tablekt/","title":"Tablekt","text":""},{"location":"opcodes/tablekt/#tablekt","title":"tablekt","text":"<p>Provides k-rate control over table numbers.</p> <p>The standard Csound opcode table when producing a k- or a-rate result, can only use an init-time variable to select the table number. tablekt accepts k-rate control as well as i-time. In all other respects they are similar to the original opcodes.</p>"},{"location":"opcodes/tablekt/#syntax","title":"Syntax","text":"<pre><code>ares tablekt xndx, kfn [, ixmode] [, ixoff] [, iwrap]\nkres tablekt kndx, kfn [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/tablekt/#initialization","title":"Initialization","text":"<p>ixmode -- if 0, xndx and ixoff ranges match the length of the table. if non-zero xndx and ixoff have a 0 to 1 range. Default is 0</p> <p>ixoff -- if 0, total index is controlled directly by xndx, ie. the indexing starts from the start of the table. If non-zero, start indexing from somewhere else in the table. Value must be positive and less than the table length (ixmode = 0) or less than 1 (ixmode not equal to 0). Default is 0.</p> <p>iwrap -- if iwrap = 0, Limit mode: when total index is below 0, then final index is 0.Total index above table length results in a final  index of the table length - high out of range total indexes stick at the upper limit of the table. If iwrap not equal to 0, Wrap mode: total index is wrapped  modulo the table length so that all total indexes map into the table. For instance, in a table of length 8, xndx = 5 and ixoff = 6 gives a total index of 11, which wraps to a final  index of 3. Default is 0.</p>"},{"location":"opcodes/tablekt/#performance","title":"Performance","text":"<p>kndx -- Index into table, either a positive number range matching the table length (ixmode = 0) or a 0 to 1 range (ixmode not equal to 0).</p> <p>xndx -- matching the table length (ixmode = 0) or a 0 to 1 range (ixmode not equal to  0)</p> <p>kfn -- Table number. Must be &gt;= 1. Floats are rounded down to an integer.  If a table number does not point to a valid table, or the table has not yet been loaded (GEN01) then an error will result and the instrument will be de-activated.</p> <p> Caution with k-rate table numbers</p> <p>At k-rate, if a table number of &lt; 1 is given, or the table number points to a non-existent table, or to one which has a length of 0 (it is to be loaded from a file later) then an error will result and the instrument will be deactivated. kfn must be initialized at the appropriate rate using init. Attempting to load an i-rate value into kfn will result in an error.</p>"},{"location":"opcodes/tablekt/#examples","title":"Examples","text":"<p>Here is an example of the tablekt opcode. It uses the file tablekt.csd.</p> Example of the tablekt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tablekt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0\n\ngift1 ftgen 1, 0, 1024, 10, 1                           ;sine wave\ngift2 ftgen 2, 0, 1024, 10, 1, 1, 1, 1, 1, 1, 1, 1, 1   ;pulse\n\n\ninstr 1\nandx phasor 400                 ;phasor for reading the index\nkfn init 1                      ;initialize the choice of the function table\nkmetro init 1                   ;initialize the frequency of the metro\nknewft metro kmetro             ;make a new choice for selecting the function table once a second\n\nif knewft == 1 then\n  kfn = (kfn == 1 ? 2 : 1)      ;switch between 1 and 2\n  kmetro random .5, 2           ;create new metro frequency\n  printk2 kfn\nendif\n\nares tablekt andx, kfn, 1\nouts ares,  ares\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1     2.00000\ni1     1.00000\ni1     2.00000\ni1     1.00000\n....\n</code></pre>"},{"location":"opcodes/tablekt/#see-also","title":"See also","text":"<p>Table Reading with Dynamic Selection</p>"},{"location":"opcodes/tablekt/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tablemix/","title":"Tablemix","text":""},{"location":"opcodes/tablemix/#tablemix","title":"tablemix","text":"<p>Mixes two tables.</p>"},{"location":"opcodes/tablemix/#syntax","title":"Syntax","text":"<pre><code>tablemix kdft, kdoff, klen, ks1ft, ks1off, ks1g, ks2ft, ks2off, ks2g\n</code></pre>"},{"location":"opcodes/tablemix/#performance","title":"Performance","text":"<p>kdft -- Destination function table.</p> <p>kdoff -- Offset to start writing from. Can be negative.</p> <p>klen -- Number of write operations to perform. Negative means work backwards.</p> <p>ks1ft, ks2ft -- Source function tables. These can be the same as the destination table, if care is exercised about direction of copying data.</p> <p>ks1off, ks2off -- Offsets to start reading from in source tables.</p> <p>ks1g, ks2g -- Gains to apply when reading from the source tables. The results are added and the sum is written to the destination table.</p> <p>tablemix -- This opcode mixes from two tables, with separate gains into the destination table. Writing is done for klen locations, usually stepping forward through the table - if klen is positive. If it is negative, then the writing and reading order is backwards - towards lower indexes in the tables. This bi-directional option makes it easy to shift the contents of a table sideways by reading from it and writing back to it with a different offset.</p> <p>If klen is 0, no writing occurs. Note that the internal integer value of klen is derived from the ANSI C floor() function - which returns the next most negative integer. Hence a fractional negative klen value of -2.3 would create an internal length of 3, and cause the copying to start from the offset locations and proceed for two locations to the left.</p> <p>The total index for table reading and writing is calculated from the starting offset for each table, plus the index value, which starts at 0 and then increments (or decrements) by 1 as mixing proceeds.</p> <p>These total indexes can potentially be very large, since there is no restriction on the offset or the klen. However each total index for each table is ANDed with a length mask (such as 0000 0111 for a table of length 8) to form a final index which is actually used for reading or writing. So no reading or writing can occur outside the tables. This is the same as \u201cwrap\u201d mode in table read and write. These opcodes do not read or write the guardpoint. If a table has been rewritten with one of these, then if it has a guardpoint which is supposed to contain the same value as the location 0, then call tablegpw afterwards.</p> <p>The indexes and offsets are all in table steps - they are not normalized to 0 - 1. So for a table of length 256, klen should be set to 256 if all the table was to be read or written.</p> <p>The tables do not need to be the same length - wrapping occurs individually for each table.</p>"},{"location":"opcodes/tablemix/#examples","title":"Examples","text":"<p>Here is an example of the tablemix opcode. It uses the file tablemix.csd.</p> Example of the tablemix opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tablemix.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisinoid ftgen 1, 0, 256, 10, 1, 0, 0, .4               ;sinoid\ngisaw    ftgen 2, 0, 1024, 7, 0, 256, 1                 ;saw\ngimix    ftgen 100, 0, 256, 7, 0, 256, 1                ;destination table\n\ninstr 1\n\nkgain linseg 0, p3*.5, .5, p3*.5, 0\n      tablemix 100, 0, 256, 1, 0, 1, 2, 0, kgain\nasig  poscil .5, 110, gimix                     ;mix table 1 &amp; 2                        \n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tablemix/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablemix/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p>"},{"location":"opcodes/tableng/","title":"Tableng","text":""},{"location":"opcodes/tableng/#tableng","title":"tableng","text":"<p>Interrogates a function table for length.</p>"},{"location":"opcodes/tableng/#syntax","title":"Syntax","text":"<pre><code>ires tableng ifn\nkres tableng kfn\n</code></pre>"},{"location":"opcodes/tableng/#initialization","title":"Initialization","text":"<p>ifn -- Table number to be interrogated</p>"},{"location":"opcodes/tableng/#performance","title":"Performance","text":"<p>kfn -- Table number to be interrogated</p> <p>tableng returns the length of the specified table. This will be a power of two number in most circumstances. It will not show whether a table has a guardpoint or not. It seems this information is not available in the table's data structure. If the specified table is not found, then 0 will be returned.</p> <p>Likely to be useful for setting up code for table manipulation operations, such as tablemix and tablecopy.</p>"},{"location":"opcodes/tableng/#examples","title":"Examples","text":"<p>Here is an example of the tableng opcode. It uses the file tableng.csd.</p> Example of the tableng opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tableng.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngifn1 ftgen 1, 0, 0, 1, \"flute.aiff\", 0, 0, 0   ;deferred-size table\n\ninstr 1 \n\nisize tableng 1\nprint isize\nandx  phasor 1 / (isize / sr)                   ;play at correct pitch\nasig  tab andx, 1, 1\n      outs asig, asig\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \n\ni 1 0 2.3       \ne\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  isize = 115506.000\n</code></pre>"},{"location":"opcodes/tableng/#see-also","title":"See also","text":"<p>Table Control:Table Queries</p>"},{"location":"opcodes/tableng/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/tablera/","title":"Tablera","text":""},{"location":"opcodes/tablera/#tablera","title":"tablera","text":"<p>Reads tables in sequential locations to an a-rate variable.</p> <p>Some thought is required before using it. It has at least two major, and quite different, applications which are discussed below.</p>"},{"location":"opcodes/tablera/#syntax","title":"Syntax","text":"<pre><code>ares tablera kfn, kstart, koff\n</code></pre>"},{"location":"opcodes/tablera/#performance","title":"Performance","text":"<p>ares -- a-rate destination for reading ksmps values from a table.</p> <p>kfn -- i- or k-rate number of the table to read or write.</p> <p>kstart -- Where in table to read or write.</p> <p>koff -- i- or k-rate offset into table. Range unlimited - see explanation at end of this section.</p> <p>In one application, tablera is intended to be used in pair with tablewa, or with several tablera opcodes before a tablewa -- all sharing the same kstart variable.</p> <p>These read from and write to sequential locations in a table at audio rates, with ksmps floats being written and read each cycle.</p> <p>tablera starts reading from location kstart. tablewa starts writing to location kstart, and then writes to kstart with the number of the location one more than the one it last wrote. (Note that for tablewa, kstart is both an input and output variable.) If the writing index reaches the end of the table, then no further writing occurs and zero is written to kstart.</p> <p>For instance, if the table's length was 16 (locations 0 to 15), and ksmps was 5. Then the following steps would occur with repetitive runs of the tablewa opcode, assuming that kstart started at 0.</p> Run Number Initial kstart Final kstart Locations Written 1 0 5 0 1 2 3 4 2 5 10 5 6 7 8 9 3 10 15 10 11 12 13 14 4 15 0 15 <p>This is to facilitate processing table data using standard a-rate orchestra code between the tablera and tablewaopcodes. They allow all Csound k-rate operators to be used (with caution) on a-rate variables - something that would only be possible otherwise by ksmps = 1, downsamp and upsamp.</p> <p> Several cautions</p> <ul> <li>The k-rate code in the processing loop is really running at a-rate, so time dependent functions like port and oscil work faster than normal - their code is expecting to be running at k-rate.</li> <li>This system will produce undesirable results unless the ksmps fits within the table length. For instance a table of length 16 will accommodate 1 to 16 samples, so this example will work with ksmps = 1 to 16.</li> </ul> <p>Both these opcodes generate an error and deactivate the instrument if a table with length &lt; ksmps is selected. Likewise an error occurs if kstart is below 0 or greater than the highest entry in the table - if kstart = table length.</p> <ul> <li>kstart is intended to contain integer values between 0 and (table length - 1). Fractional values above this should not affect operation but do not achieve anything useful.</li> <li>These opcodes are not interpolating, and the kstart and koff parameters always have a range of 0 to (table length - 1) - not 0 to 1 as is available in other table read/write opcodes. koff can be outside this range but it is wrapped around by the final AND operation.</li> <li>These opcodes are permanently in wrap mode. When koff is 0, no wrapping needs to occur, since the kstart++ index will always be within the table's normal range. koff not equal to  0 can lead to wrapping.</li> <li>The offset does not affect the number of read/write cycles performed, or the value written to kstart by tablewa.</li> <li>These opcodes cannot read or write the guardpoint. Use tablegpw to write the guardpoint after manipulations have been done with tablewa.</li> </ul>"},{"location":"opcodes/tablera/#examples","title":"Examples","text":"<pre><code>kstart   =       0         \n\nlab1:\n  atemp  tablera ktabsource, kstart, 0  ; Read 5 values from table into an\n                                        ; a-rate variable.                  \n  atemp  =       log(atemp)             ; Process the values using a-rate code.\n  kstart tablewa ktabdest, atemp, 0     ; Write it back to the table\nif ktemp  0 goto lab1                   ; Loop until all table locations\n                                        ; have been processed.\n</code></pre> <p>The above example shows a processing loop, which runs every k-cycle, reading each location in the table ktabsource, and writing the log of those values into the same locations of table ktabdest.</p> <p>This enables whole tables, parts of tables (with offsets and different control loops) and data from several tables at once to be manipulated with a-rate code and written back to another (or to the same) table. This is a bit of a fudge, but it is faster than doing it with k-rate table read and write code.</p> <p>Another application is:</p> <pre><code>  kzero = 0                    \n  kloop = 0                    \n\n  kzero   tablewa 23, asignal, 0   ; ksmps a-rate samples written\n                                   ; into locations 0 to (ksmps -1) of table 23.\nlab1:\n  ktemp   table    kloop, 23       ; Start a loop which runs ksmps times,\n                                   ; in which each cycle processes one of\n  [ Some code to manipulate ]      ; table 23's values with k-rate orchestra\n  [ the value of ktemp. ]          ; code.\n\n          tablew  ktemp, kloop, 23 ; Write the processed value to the table.\n  kloop   = kloop + 1              ; Increment the kloop, which is both the\n                                   ; pointer into the table and the loop\n  if kloop &lt; ksmps goto lab1       ; counter. Keep looping until all values\n                                   ; in the table have been processed.\n  asignal tablera 23, 0, 0         ; Copy the table contents back\n                                   ; to an a-rate variable.\n</code></pre> <p>koff -- This is an offset which is added to the sum of kstart and the internal index variable which steps through the table. The result is then ANDed with the lengthmask (000 0111 for a table of length 8 - or 9 with guardpoint) and that final index is used to read or write to the table. koff can be any value. It is converted into a long using the ANSI floor() function so that -4.3 becomes -5. This is what we would want when using offsets which range above and below zero.</p> <p>Ideally this would be an optional variable, defaulting to 0, however with the existing Csound orchestra read code, such default parameters must be init time only. We want k-rate here, so we cannot have a default.</p>"},{"location":"opcodes/tablera/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tableshuffle/","title":"Tableshuffle","text":""},{"location":"opcodes/tableshuffle/#tableshuffle","title":"tableshuffle","text":"<p>Shuffles the content of a function table.</p> <p>Each element of the source table is put into a different random position, without loosing any of them. Imagine shuffling a deck of cards. Each element of the table is copied to a different random position. If that position was already chosen before then the next free position is chosen. The length of the table remains the same.</p>"},{"location":"opcodes/tableshuffle/#syntax","title":"Syntax","text":"<pre><code>tableshuffle ktablenum\ntableshufflei itablenum\n</code></pre>"},{"location":"opcodes/tableshuffle/#performance","title":"Performance","text":"<p>ktablenum or itablenum -- the number of the table to shuffle.</p>"},{"location":"opcodes/tableshuffle/#examples","title":"Examples","text":"<p>Here is an example of the tableshuffle opcode. It uses the file tableshuffle.csd.</p> Example of the tableshuffle opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o tableshuffle.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1 \nkIndex phasor 1/p3\nkIndex = kIndex * 16\n\nif kIndex &gt;= 15.99 then \ntableshuffle 1; shuffle table 1\nendif\n\nkFreq table kIndex, 1, 0\nasound oscili 0.3, kFreq\noutch 1, asound\noutch 2, asound\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0   16      -2      200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950\n\ni1 0 4\ni1 5 4\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tableshuffle/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tableshuffle/#credits","title":"Credits","text":"<p>Author: Georg Boenn  University of Glamorgan, UK</p> <p>New in Csound version 5.13</p>"},{"location":"opcodes/tablew/","title":"Tablew","text":""},{"location":"opcodes/tablew/#tablew","title":"tablew","text":"<p>Change the contents of existing function tables.</p> <p>tablew is for writing at k- or at a-rates, with the table number being specified at init time. Using tablew with i-rate signal and index values is allowed, but the specified data will always be written to the function table at k-rate, not during the initialization pass. The valid combinations of variable types are shown by the first letter of the variable names.</p>"},{"location":"opcodes/tablew/#syntax","title":"Syntax","text":"<pre><code>tablew asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]\ntablew isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]\ntablew ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]\n</code></pre>"},{"location":"opcodes/tablew/#initialization","title":"Initialization","text":"<p>asig, isig, ksig -- The value to be written into the table.</p> <p>andx, indx, kndx -- Index into table, either a positive number range matching the table length (ixmode = 0) or a 0 to 1 range (ixmode != 0)</p> <p>ifn -- Table number. Must be &gt;= 1. Floats are rounded down to an integer. If a table number does not point to a valid table, or the table has not yet been loaded (GEN01) then an error will result and the instrument will be de-activated.</p> <p>ixmode (optional, default=0) -- index mode.</p> <ul> <li>0 = xndx and ixoff ranges match the length of the table.</li> <li>!=0 = xndx and ixoff have a 0 to 1 range.</li> </ul> <p>ixoff (optional, default=0) -- index offset.</p> <ul> <li>0 = Total index is controlled directly by xndx, i.e. the indexing starts from the start of the table.</li> <li>!=0 = Start indexing from somewhere else in the table. Value must be positive and less than the table length (ixmode = 0) or less than 1 (ixmode != 0).</li> </ul> <p>iwgmode (optional, default=0) -- Wrap and guardpoint mode.</p> <ul> <li>0 = Limit mode.</li> <li>1 = Wrap mode.</li> <li>2 = Guardpoint mode.</li> </ul>"},{"location":"opcodes/tablew/#performance","title":"Performance","text":""},{"location":"opcodes/tablew/#limit-mode-0","title":"Limit mode (0)","text":"<p>Limit the total index (ndx + ixoff) to between 0 and the guard point. For a table of length 5, this means that locations 0 to 3 and location 4 (the guard point) can be written. A negative total index writes to location 0.</p>"},{"location":"opcodes/tablew/#wrap-mode-1","title":"Wrap mode (1)","text":"<p>Wrap total index value into locations 0 to E, where E is either one less than the table length or the factor of 2 number which is one less than the table length. For example, wrap into a 0 to 3 range - so that total index 6 writes to location 2.</p>"},{"location":"opcodes/tablew/#guardpoint-mode-2","title":"Guardpoint mode (2)","text":"<p>The guardpoint is written at the same time as location 0 is written - with the same value.</p> <p>This facilitates writing to tables which are intended to be read with interpolation for producing smooth cyclic waveforms. In addition, before it is used, the total index is incremented by half the range between one location and the next, before being rounded down to the integer address of a table location.</p> <p>Normally (igwmode = 0 or 1) for a table of length 5 - which has locations 0 to 3 as the main table and location 4 as the guard point, a total index in the range of 0 to 0.999 will write to location 0. (\"0.999\" means just less than 1.0.) 1.0 to 1.999 will write to location 1 etc. A similar pattern holds for all total indexes 0 to 4.999 (igwmode = 0) or to 3.999 (igwmode = 1). igwmode = 0 enables locations 0 to 4 to be written - with the guardpoint (4) being written with a potentially different value from location 0.</p> <p>With a table of length 5 and the iwgmode = 2, then when the total index is in the range 0 to 0.499, it will write to locations 0 and 4. Range 0.5 to 1.499 will write to location 1 etc. 3.5 to 4.0 will also write to locations 0 and 4.</p> <p>This way, the writing operation most closely approximates the results of interpolated reading. Guard point mode should only be used with tables that have a guardpoint.</p> <p>Guardpoint mode is accomplished by adding 0.5 to the total index, rounding to the next lowest integer, wrapping it modulo the factor of two which is one less than the table length, writing the table (locations 0 to 3 in our example) and then writing to the guard point if index = 0.</p> <p>tablew has no output value. The last three parameters are optional and have default values of 0.</p>"},{"location":"opcodes/tablew/#caution-with-k-rate-table-numbers","title":"Caution with k-rate table numbers","text":"<p>At k-rate or a-rate, if a table number of &lt; 1 is given, or the table number points to a non-existent table, or to one which has a length of 0 (it is to be loaded from a file later) then an error will result and the instrument will be deactivated. kfn and afn must be initialized at the appropriate rate using init. Attempting to load an i-rate value into kfn or afn will result in an error.</p> <p> Warning</p> <p>Note that tablew is always a k-rate opcode. This means that even its i-rate version runs at k-rate and will write the value of the i-rate variable. For this reason, the following code will not work as expected:</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ngiFt ftgen  1, 0, 8, 2, 0\ninstr 1\nindx = 0\n     tablew 10, indx, giFt\nival tab_i  indx, giFt\n     print  ival\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Although it may seem this program should print a 10 to the console. It will print 0, because  tab_i will read the value at the initialization of the note, before the first performance pass, when tablew writes its value.</p>"},{"location":"opcodes/tablew/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablew/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/tablewa/","title":"Tablewa","text":""},{"location":"opcodes/tablewa/#tablewa","title":"tablewa","text":"<p>Writes tables in sequential locations to and from an a-rate variable.</p> <p>Some thought is required before using it. It has at least two major, and quite different, applications which are discussed below.</p>"},{"location":"opcodes/tablewa/#syntax","title":"Syntax","text":"<pre><code>kstart tablewa kfn, asig, koff\n</code></pre>"},{"location":"opcodes/tablewa/#performance","title":"Performance","text":"<p>kstart -- Where in table to read or write.</p> <p>kfn -- i- or k-rate number of the table to read or write.</p> <p>asig -- a-rate signal to read from when writing to the table.</p> <p>koff -- i- or k-rate offset into table. Range unlimited - see explanation at end of this section.</p> <p>In one application, it is intended to be used with one or with several tablera opcodes before a tablewa -- all sharing the same kstart variable.</p> <p>These read from and write to sequential locations in a table at audio rates, with ksmps floats being written and read each cycle.</p> <p>tablera starts reading from location kstart. tablewa starts writing to location kstart, and then writes to kstart with the number of the location one more than the one it last wrote. (Note that for tablewa, kstart is both an input and output variable.) If the writing index reaches the end of the table, then no further writing occurs and zero is written to kstart.</p> <p>For instance, if the table's length was 16 (locations 0 to 15), and ksmps was 5. Then the following steps would occur with repetitive runs of the tablewa opcode, assuming that kstart started at 0.</p> Run Number Initial kstart Final kstart Locations Written 1 0 5 0 1 2 3 4 2 5 10 5 6 7 8 9 3 10 15 10 11 12 13 14 4 15 0 15 <p>This is to facilitate processing table data using standard a-rate orchestra code between the tablera and tablewa opcodes. They allow all Csound k-rate operators to be used (with caution) on a-rate variables - something that would only be possible otherwise by ksmps = 1, downsamp and upsamp.</p> <p> Several cautions</p> <ul> <li>The k-rate code in the processing loop is really running at a-rate, so time dependent functions like port and oscil work faster than normal - their code is expecting to be running at k-rate.</li> <li>This system will produce undesirable results unless the ksmps fits within the table length. For instance a table of length 16 will accommodate 1 to 16 samples, so this example will work with ksmps = 1 to 16.</li> </ul> <p>Both these opcodes generate an error and deactivate the instrument if a table with length &lt; ksmps is selected. Likewise an error occurs if kstart is below 0 or greater than the highest entry in the table - if kstart = table length.</p> <ul> <li>kstart is intended to contain integer values between 0 and (table length - 1). Fractional values above this should not affect operation but do not achieve anything useful.</li> <li>These opcodes are not interpolating, and the kstart and koff parameters always have a range of 0 to (table length - 1) - not 0 to 1 as is available in other table read/write opcodes. koff can be outside this range but it is wrapped around by the final AND operation.</li> <li>These opcodes are permanently in wrap mode. When koff is 0, no wrapping needs to occur, since the kstart++ index will always be within the table's normal range. koff not equal to  0 can lead to wrapping.</li> <li>The offset does not affect the number of read/write cycles performed, or the value written to kstart by tablewa.</li> <li>These opcodes cannot read or write the guardpoint. Use tablegpw to write the guardpoint after manipulations have been done with tablewa.</li> </ul>"},{"location":"opcodes/tablewa/#examples","title":"Examples","text":"<pre><code>kstart   =       0         \n\nlab1:\n  atemp  tablera ktabsource, kstart, 0  ; Read 5 values from table into an\n                                        ; a-rate variable.                  \n  atemp  =       log(atemp)             ; Process the values using a-rate code.\n  kstart tablewa ktabdest, atemp, 0     ; Write it back to the table\nif ktemp  0 goto lab1                   ; Loop until all table locations\n                                        ; have been processed.\n</code></pre> <p>The above example shows a processing loop, which runs every k-cycle, reading each location in the table ktabsource, and writing the log of those values into the same locations of table ktabdest.</p> <p>This enables whole tables, parts of tables (with offsets and different control loops) and data from several tables at once to be manipulated with a-rate code and written back to another (or to the same) table. This is a bit of a fudge, but it is faster than doing it with k-rate table read and write code.</p> <p>Another application is:</p> <pre><code>  kzero = 0                    \n  kloop = 0                    \n\n  kzero   tablewa 23, asignal, 0   ; ksmps a-rate samples written\n                                   ; into locations 0 to (ksmps -1) of table 23.\nlab1:\n  ktemp   table    kloop, 23       ; Start a loop which runs ksmps times,\n                                   ; in which each cycle processes one of\n  [ Some code to manipulate ]      ; table 23's values with k-rate orchestra\n  [ the value of ktemp. ]          ; code.\n\n          tablew  ktemp, kloop, 23 ; Write the processed value to the table.\n  kloop   = kloop + 1              ; Increment the kloop, which is both the\n                                   ; pointer into the table and the loop\n  if kloop &lt; ksmps goto lab1       ; counter. Keep looping until all values\n                                   ; in the table have been processed.\n  asignal tablera 23, 0, 0         ; Copy the table contents back\n                                   ; to an a-rate variable.\n</code></pre> <p>koff -- This is an offset which is added to the sum of kstart and the internal index variable which steps through the table. The result is then ANDed with the lengthmask (000 0111 for a table of length 8 - or 9 with guardpoint) and that final index is used to read or write to the table. koff can be any value. It is converted into a long using the ANSI floor() function so that -4.3 becomes -5. This is what we would want when using offsets which range above and below zero.</p> <p>Ideally this would be an optional variable, defaulting to 0, however with the existing Csound orchestra read code, such default parameters must be init time only. We want k-rate here, so we cannot have a default.</p>"},{"location":"opcodes/tablewa/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablewa/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia</p>"},{"location":"opcodes/tablewkt/","title":"Tablewkt","text":""},{"location":"opcodes/tablewkt/#tablewkt","title":"tablewkt","text":"<p>Change the contents of existing function tables.</p> <p>tablewkt uses a k-rate variable for selecting the table number. The valid combinations of variable types are shown by the first letter of the variable names.</p>"},{"location":"opcodes/tablewkt/#syntax","title":"Syntax","text":"<pre><code>tablewkt asig, andx, kfn [, ixmode] [, ixoff] [, iwgmode]\ntablewkt ksig, kndx, kfn [, ixmode] [, ixoff] [, iwgmode]\n</code></pre>"},{"location":"opcodes/tablewkt/#initialization","title":"Initialization","text":"<p>asig, ksig -- The value to be written into the table.</p> <p>andx, kndx -- Index into table, either a positive number range matching the table length (ixmode = 0) or a 0 to 1 range (ixmode != 0)</p> <p>kfn -- Table number. Must be &gt;= 1. Floats are rounded down to an integer. If a table number does not point to a valid table, or the table has not yet been loaded (GEN01) then an error will result and the instrument will be de-activated.</p> <p>ixmode -- index mode. Default is zero.</p> <ul> <li>0 = xndx and ixoff ranges match the length of the table.</li> <li>Not equal to 0 = xndx and ixoff have a 0 to 1 range.</li> </ul> <p>ixoff -- index offset. Default is 0.</p> <ul> <li>0 = Total index is controlled directly by xndx, i.e. the indexing starts from the start of the table.</li> <li>Not equal to 0 = Start indexing from somewhere else in the table. Value must be positive and less than the table length (ixmode = 0) or less than 1 (ixmode != 0).</li> </ul> <p>iwgmode -- table writing mode. Default is 0.</p> <ul> <li>0 = Limit mode.</li> <li>1 = Wrap mode.</li> <li>2 = Guardpoint mode.</li> </ul>"},{"location":"opcodes/tablewkt/#performance","title":"Performance","text":""},{"location":"opcodes/tablewkt/#limit-mode-0","title":"Limit mode (0)","text":"<p>Limit the total index (ndx + ixoff) to between 0 and the guard point. For a table of length 5, this means that locations 0 to 3 and location 4 (the guard point) can be written. A negative total index writes to location 0.</p>"},{"location":"opcodes/tablewkt/#wrap-mode-1","title":"Wrap mode (1)","text":"<p>Wrap total index value into locations 0 to E, where E is one less than either the table length or the factor of 2 number which is one less than the table length. For example, wrap into a 0 to 3 range - so that total index 6 writes to location 2.</p>"},{"location":"opcodes/tablewkt/#guardpoint-mode-2","title":"Guardpoint mode (2)","text":"<p>The guardpoint is written at the same time as location 0 is written - with the same value.</p> <p>This facilitates writing to tables which are intended to be read with interpolation for producing smooth cyclic waveforms. In addition, before it is used, the total index is incremented by half the range between one location and the next, before being rounded down to the integer address of a table location.</p> <p>Normally (igwmode = 0 or 1) for a table of length 5 - which has locations 0 to 3 as the main table and location 4 as the guard point, a total index in the range of 0 to 0.999 will write to location 0. (\"0.999\" means just less than 1.0.) 1.0 to 1.999 will write to location 1 etc. A similar pattern holds for all total indexes 0 to 4.999 (igwmode = 0) or to 3.999 (igwmode = 1). igwmode = 0 enables locations 0 to 4 to be written - with the guardpoint (4) being written with a potentially different value from location 0.</p> <p>With a table of length 5 and the iwgmode = 2, then when the total index is in the range 0 to 0.499, it will write to locations 0 and 4. Range 0.5 to 1.499 will write to location 1 etc. 3.5 to 4.0 will also write to locations 0 and 4.</p> <p>This way, the writing operation most closely approximates the results of interpolated reading. Guard point mode should only be used with tables that have a guardpoint.</p> <p>Guardpoint mode is accomplished by adding 0.5 to the total index, rounding to the next lowest integer, wrapping it modulo the factor of two which is one less than the table length, writing the table (locations 0 to 3 in our example) and then writing to the guard point if index = 0.</p>"},{"location":"opcodes/tablewkt/#caution-with-k-rate-table-numbers","title":"Caution with k-rate table numbers","text":"<p>At k-rate or a-rate, if a table number of &lt; 1 is given, or the table number points to a non-existent table, or to one which has a length of 0 (it is to be loaded from a file later) then an error will result and the instrument will be deactivated. kfn and afn must be initialized at the appropriate rate using init. Attempting to load an i-rate value into kfn or afn will result in an error.</p>"},{"location":"opcodes/tablewkt/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tablewkt/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/tablexkt/","title":"Tablexkt","text":""},{"location":"opcodes/tablexkt/#tablexkt","title":"tablexkt","text":"<p>Reads function tables with linear, cubic, or sinc interpolation.</p>"},{"location":"opcodes/tablexkt/#syntax","title":"Syntax","text":"<pre><code>ares tablexkt xndx, kfn, kwarp, iwsize [, ixmode] [, ixoff] [, iwrap]\n</code></pre>"},{"location":"opcodes/tablexkt/#initialization","title":"Initialization","text":"<p>iwsize -- This parameter controls the type of interpolation to be used:</p> <ul> <li>2: Use linear interpolation. This is the lowest quality, but also the fastest mode.</li> <li>4: Cubic interpolation. Slightly better quality than iwsize = 2, at the expense of being somewhat slower.</li> <li>8 and above (up to 1024): sinc interpolation with window size set to iwsize (should be an integer multiply of 4). Better quality than linear or cubic interpolation, but very slow. When transposing up, a kwarp value above 1 can be used for anti-aliasing (this is even slower).</li> </ul> <p>ixmode1 (optional) -- index data mode. The default value is 0.</p> <ul> <li>0: raw index</li> <li>any non-zero value: normalized (0 to 1)</li> </ul> <p> Notes</p> <p>If tablexkt is used to play back samples with looping (e.g.  table index is generated by lphasor), there must be at least iwsize / 2 extra samples after the loop end point for interpolation, otherwise audible clicking may occur (also, at least iwsize / 2 samples should be before the loop start point).</p> <p>ixoff (optional) -- amount by which index is to be offset. For a table with origin at center, use tablesize / 2 (raw) or 0.5 (normalized). The default value is 0.</p> <p>iwrap (optional) -- wraparound index flag. The default value is 0.</p> <ul> <li>0: Nowrap (index &lt; 0 treated as index = 0; index &gt;= tablesize (or 1.0 in normalized mode) sticks at the guard point).</li> <li>any non-zero value: Index is wrapped to the allowed range (not including the guard point in this case).</li> </ul> <p> Note</p> <p>iwrap also applies to extra samples for interpolation.</p>"},{"location":"opcodes/tablexkt/#performance","title":"Performance","text":"<p>ares -- audio output</p> <p>xndx -- table index</p> <p>kfn -- function table number</p> <p>kwarp -- if greater than 1, use sin (x / kwarp) / x function for sinc interpolation, instead of the default sin (x) / x. This is useful to avoid aliasing when transposing up (kwarp should be set to the transpose factor in this case, e.g. 2.0 for one octave), however it makes rendering up to twice as slow. Also, iwsize should be at least kwarp * 8. This feature is experimental, and may be optimized both in terms of speed and quality in new versions.</p> <p> Note</p> <p>kwarp has no effect if it is less than, or equal to 1, or linear or cubic interpolation is used.</p>"},{"location":"opcodes/tablexkt/#examples","title":"Examples","text":"<p>Here is an example of the tablexkt opcode. It uses the file tablexkt.csd.</p> Example of the tablexkt opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o tablexkt.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n;Example by Jonathan Murphy\n\n  sr        =  44100\n  ksmps     =  10\n  nchnls    =  1\n\n    instr 1\n\n  ifn       =  1    ; query f1 as to number of samples\n  ilen      =  nsamp(ifn)\n\n  itrns     =  4   ; transpose up 4 octaves\n  ilps      =  16  ; allow iwsize/2 samples at start\n  ilpe      =  ilen - 16   ; and at end\n  imode     =  3  ; loop forwards and backwards\n  istrt     =  16  ; start 16 samples into loop\n\n  alphs     lphasor   itrns, ilps, ilpe, imode, istrt\n        ; use lphasor as index\n  andx      =  alphs\n\n  kfn       =  1   ; read f1\n  kwarp     =  4 ; anti-aliasing, should be same value as itrns above\n  iwsize    =  32  ; iwsize must be at least 8 * kwarp\n\n  atab      tablexkt  andx, kfn, kwarp, iwsize\n\n  atab      =  atab * 10000\n\n            out       atab\n\n    endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf 1 0 262144 1 \"drumsMlp.wav\" 0 4 1\ni1 0 60\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tablexkt/#see-also","title":"See also","text":"<p>Table Reading with Dynamic Selection</p>"},{"location":"opcodes/tablexkt/#credits","title":"Credits","text":"<p>Author: Istvan Varga January 2002 Example by: Jonathan Murphy 2006</p> <p>New in version 4.18</p>"},{"location":"opcodes/tabmorph/","title":"Tabmorph","text":""},{"location":"opcodes/tabmorph/#tabmorph","title":"tabmorph","text":"<p>Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables.</p>"},{"location":"opcodes/tabmorph/#syntax","title":"Syntax","text":"<pre><code>kout tabmorph kindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 \\\n              [, ifn3, ifn4, ...,ifnN]\n</code></pre>"},{"location":"opcodes/tabmorph/#initialization","title":"Initialization","text":"<p>ifn1, ifn2 [, ifn3, ifn4, ..., ifnN] - function table numbers. This is a set of chosen tables the user want to use in the morphing. All tables must have the same length. Be aware that only two of these tables can be chosen for the morphing at one time. Since it is possible to use non-integer numbers for the ktabnum1 and ktabnum2 arguments, the morphing is the result from the interpolation between adjacent consecutive tables of the set.</p>"},{"location":"opcodes/tabmorph/#performance","title":"Performance","text":"<p>kout - The output value for index kindex, resulting from morphing two tables (see below).</p> <p>kindex - main index of the morphed resultant table. The range is 0 to table_length (not included).</p> <p>kweightpoint - the weight of the influence of a pair of selected tables in the morphing. The range of this argument is 0 to 1. A zero makes it output the first table unaltered, a 1 makes it output the second table of the pair unaltered. All intermediate values between 0 and 1 determine the gradual morphing between the two tables of the pair.</p> <p>ktabnum1 - the first table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, the corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>ktabnum2 - the second table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>The tabmorph family of opcodes is similar to the table family, but allows morphing between two tables chosen into a set of tables. Firstly the user has to provide a set of tables of equal length (ifn2 [, ifn3, ifn4, ..., ifnN]). Then he can choose a pair of tables in the set in order to perform the morphing: ktabnum1 and ktabnum2 are filled with numbers (zero represents the first table in the set, 1 the second, 2 the third and so on). Then determine the morphing between the two chosen tables with the kweightpoint parameter. After that the resulting table can be indexed with the kindex parameter like a normal table opcode. If the value of this parameter surpasses the length of tables (which must be the same for all tables), then it is wrapped around.</p> <p>tabmorph acts similarly to the table opcode, that is, without using interpolation. This means that it truncates the fractional part of the kindex argument. Anyway, fractional parts of ktabnum1 and ktabnum2 are significant, resulting in linear interpolation between the same element of two adjacent subsequent tables.</p>"},{"location":"opcodes/tabmorph/#examples","title":"Examples","text":"<p>Here is an example of the tabmorph opcode. It uses the file tabmorph.csd.</p> Example of the tabmorph opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tabmorph.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine   ftgen 0, 0, 8193, 10, 1                                ;sine wave\ngiSquare ftgen 0, 0, 8193, 7, 1, 4096, 1, 0, -1, 4096, -1       ;square wave\ngiTri    ftgen 0, 0, 8193, 7, 0, 2048, 1, 4096, -1, 2048, 0     ;triangle wave\ngiSaw    ftgen 0, 0, 8193, 7, 1, 8192, -1                       ;sawtooth wave, downward slope\n\ninstr    1\n\niamp   = .7\nkindex phasor 440                       ;read table value at this index\nkindex = kindex*8192                    ;for all 8192 index points\nkweightpoint = 0.5                      ;set weightpoint\nktabnum1 line 0, p3, 3                  ;morph through all tables\nktabnum2 = 2                            ;set to triangle wave\nksig tabmorph kindex, kweightpoint, ktabnum1, ktabnum2, giSine, giSquare, giTri, giSaw\nksig = ksig*iamp\nasig interp ksig                        ;convert to audio signal\nouts asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabmorph/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabmorph/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/tabmorpha/","title":"Tabmorpha","text":""},{"location":"opcodes/tabmorpha/#tabmorpha","title":"tabmorpha","text":"<p>Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables.</p>"},{"location":"opcodes/tabmorpha/#syntax","title":"Syntax","text":"<pre><code>aout tabmorpha aindex, aweightpoint, atabnum1, atabnum2, ifn1, ifn2 \\\n               [, ifn3, ifn4, ... ifnN]\n</code></pre>"},{"location":"opcodes/tabmorpha/#initialization","title":"Initialization","text":"<p>ifn1, ifn2 , ifn3, ifn4, ... ifnN - function table numbers. This is a set of chosen tables the user want to use in the morphing. All tables must have the same length. Be aware that only two of these tables can be chosen for the morphing at one time. Since it is possible to use non-integer numbers for the atabnum1 and atabnum2 arguments, the morphing is the result from the interpolation between adjacent consecutive tables of the set.</p>"},{"location":"opcodes/tabmorpha/#performance","title":"Performance","text":"<p>aout - The output value for index aindex, resulting from morphing two tables (see below).</p> <p>aindex - main index index of the morphed resultant table. The range is 0 to table_length (not included).</p> <p>aweightpoint - the weight of the influence of a pair of selected tables in the morphing. The range of this argument is 0 to 1. A zero makes it output the first table unaltered, a 1 makes it output the second table of the pair unaltered. All intermediate values between 0 and 1 determine the gradual morphing between the two tables of the pair.</p> <p>atabnum1 - the first table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, the corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>atabnum2 - the second table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>The tabmorpha family of opcodes is similar to the table family, but allows morphing between two tables chosen into a set of tables. Firstly the user has to provide a set of tables of equal length (ifn2 [, ifn3, ifn4,\u2026ifnN]). Then he can choose a pair of tables in the set in order to perform the morphing: atabnum1 and atabnum2 are filled with numbers (zero represents the first table in the set, 1 the second, 2 the third and so on). Then determine the morphing between the two chosen tables with the aweightpoint parameter. After that the resulting table can be indexed with the aindex parameter like a normal table opcode. If the value of this parameter surpasses the length of tables (which must be the same for all tables), then it is wrapped around.</p> <p>tabmorpha is the audio-rate version of tabmorphi (it uses interpolation). All input arguments work at a-rate.</p>"},{"location":"opcodes/tabmorpha/#examples","title":"Examples","text":"<p>Here is an example of the tabmorpha opcode. It uses the file tabmorpha.csd.</p> Example of the tabmorpha opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tabmorpha.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ngiSine   ftgen  0, 0, 8193, 10, 1                                               ; sine wave\ngiSquare ftgen  0, 0, 8193, 7, 1, 4096, 1, 0, -1, 4096, -1                      ; square wave \ngiTri    ftgen  0, 0, 8193, 7, 0, 2048, 1, 4096, -1, 2048, 0                    ; triangle wave \ngiSaw    ftgen  0, 0, 8193, 7, 1, 8192, -1                                      ; sawtooth wave, downward slope \n\n\ninstr   1\n\niamp    = .7\naindex  phasor 110                      ; read table value at this index\naweightpoint = 0                        ; set weightpoint\natabnum1 line 0, p3, 3                  ; morph through all tables\natabnum2 = 2                            ; set to triangle wave\nasig     tabmorpha aindex, aweightpoint, atabnum1,atabnum2, giSine, giSquare, giTri, giSaw\nasig     = asig*iamp\n         outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabmorpha/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabmorpha/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/tabmorphak/","title":"Tabmorphak","text":""},{"location":"opcodes/tabmorphak/#tabmorphak","title":"tabmorphak","text":"<p>Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables.</p>"},{"location":"opcodes/tabmorphak/#syntax","title":"Syntax","text":"<pre><code>aout tabmorphak aindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 \\\n                [, ifn3, ifn4, ... ifnN]\n</code></pre>"},{"location":"opcodes/tabmorphak/#initialization","title":"Initialization","text":"<p>ifn1, ifn2 , ifn3, ifn4, ... ifnN - function table numbers. This is a set of chosen tables the user want to use in the morphing. All tables must have the same length. Be aware that only two of these tables can be chosen for the morphing at one time. Since it is possible to use non-integer numbers for the ktabnum1 and ktabnum2 arguments, the morphing is the result from the interpolation between adjacent consecutive tables of the set.</p>"},{"location":"opcodes/tabmorphak/#performance","title":"Performance","text":"<p>aout - The output value for index aindex, resulting from morphing two tables (see below).</p> <p>aindex - main index index of the morphed resultant table. The range is 0 to table_length (not included).</p> <p>kweightpoint - the weight of the influence of a pair of selected tables in the morphing. The range of this argument is 0 to 1. A zero makes it output the first table unaltered, a 1 makes it output the second table of the pair unaltered. All intermediate values between 0 and 1 determine the gradual morphing between the two tables of the pair.</p> <p>ktabnum1 - the first table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, the corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>ktabnum2 - the second table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>The tabmorphak family of opcodes is similar to the table family, but allows morphing between two tables chosen into a set of tables. Firstly the user has to provide a set of tables of equal length (ifn2 [, ifn3, ifn4, ... ifnN]). Then he can choose a pair of tables in the set in order to perform the morphing: ktabnum1 and ktabnum2 are filled with numbers (zero represents the first table in the set, 1 the second, 2 the third and so on). Then determine the morphing between the two chosen tables with the kweightpoint parameter. After that the resulting table can be indexed with the aindex parameter like a normal table opcode. If the value of this parameter surpasses the length of tables (which must be the same for all tables), then it is wrapped around.</p> <p>tabmorphak works at a-rate, but kweightpoint, ktabnum1 and ktabnum2 are working at k-rate, making it more efficient than tabmorpha, since there are less calculations. Except the rate of these three arguments, it is identical to tabmorpha.</p>"},{"location":"opcodes/tabmorphak/#examples","title":"Examples","text":"<p>Here is an example of the tabmorphak opcode. It uses the file tabmorphak.csd.</p> Example of the tabmorphak opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tabmorphak.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ngiSine   ftgen  0, 0, 8193, 10, 1                                               ; sine wave\ngiSquare ftgen  0, 0, 8193, 7, 1, 4096, 1, 0, -1, 4096, -1                      ; square wave \ngiTri    ftgen  0, 0, 8193, 7, 0, 2048, 1, 4096, -1, 2048, 0                    ; triangle wave \ngiSaw    ftgen  0, 0, 8193, 7, 1, 8192, -1                                      ; sawtooth wave, downward slope \n\ninstr   1\n\niamp    = .7\naindex  phasor  110                     ; read table value at this index\nkweightpoint expon 0.001, p3, 1         ; using the weightpoint to morph between two tables exponentially\nktabnum1 = p4                           ; first wave, it morphs to\nktabnum2 = p5                           ; the second wave\nasig    tabmorphak aindex, kweightpoint, ktabnum1,ktabnum2, giSine, giSquare, giTri, giSaw\nasig    = asig*iamp\n        outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5 0 1      ;from sine to square wave\ni1 6 5 2 3      ;from triangle to saw\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabmorphak/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabmorphak/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/tabmorphi/","title":"Tabmorphi","text":""},{"location":"opcodes/tabmorphi/#tabmorphi","title":"tabmorphi","text":"<p>Allows morphing between a set of tables of the same size, by means of a weighted average between two currently selected tables.</p>"},{"location":"opcodes/tabmorphi/#syntax","title":"Syntax","text":"<pre><code>kout tabmorphi kindex, kweightpoint, ktabnum1, ktabnum2, ifn1, ifn2 \\\n               [, ifn3, ifn4, ..., ifnN]\n</code></pre>"},{"location":"opcodes/tabmorphi/#initialization","title":"Initialization","text":"<p>ifn1, ifn2 [, ifn3, ifn4, ..., ifnN] - function table numbers. This is a set of chosen tables the user want to use in the morphing. All tables must have the same length. Be aware that only two of these tables can be chosen for the morphing at one time. Since it is possible to use non-integer numbers for the ktabnum1 and ktabnum2 arguments, the morphing is the result from the interpolation between adjacent consecutive tables of the set.</p>"},{"location":"opcodes/tabmorphi/#performance","title":"Performance","text":"<p>kout - The output value for index kindex, resulting from morphing two tables (see below).</p> <p>kindex - main index index of the morphed resultant table. The range is 0 to table_length (not included).</p> <p>kweightpoint - the weight of the influence of a pair of selected tables in the morphing. The range of this argument is 0 to 1. A zero makes it output the first table unaltered, a 1 makes it output the second table of the pair unaltered. All intermediate values between 0 and 1 determine the gradual morphing between the two tables of the pair.</p> <p>ktabnum1 - the first table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, the corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>ktabnum2 - the second table chosen for the morphing. This number doesn\u2019t express the table number directly, but the position of the table in the set sequence (starting from 0 to N-1). If this number is an integer, corresponding table will be chosen unaltered. If it contains fractional values, then an interpolation with the next adjacent table will result.</p> <p>The tabmorphi family of opcodes is similar to the table family, but allows morphing between two tables chosen into a set of tables. Firstly the user has to provide a set of tables of equal length (ifn2 [, ifn3, ifn4, ..., ifnN]). Then he can choose a pair of tables in the set in order to perform the morphing: ktabnum1 and ktabnum2 are filled with numbers (zero represents the first table in the set, 1 the second, 2 the third and so on). Then determine the morphing between the two chosen tables with the kweightpoint parameter. After that the resulting table can be indexed with the kindex parameter like a normal table opcode. If the value of this parameter surpasses the length of tables (which must be the same for all tables), then it is wrapped around.</p> <p>tabmorphi is identical to tabmorph, but it performs linear interpolation for non-integer values of kindex, much like tablei.</p>"},{"location":"opcodes/tabmorphi/#examples","title":"Examples","text":"<p>Here is an example of the tabmorphi opcode. It uses the file tabmorphi.csd.</p> Example of the tabmorphi opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tabmorphi.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine   ftgen 0, 0, 8193, 10, 1                                ;sine wave\ngiSquare ftgen 0, 0, 8193, 7, 1, 4096, 1, 0, -1, 4096, -1       ;square wave\ngiTri    ftgen 0, 0, 8193, 7, 0, 2048, 1, 4096, -1, 2048, 0     ;triangle wave\ngiSaw    ftgen 0, 0, 8193, 7, 1, 8192, -1                       ;sawtooth wave, downward slope\n\ninstr    1\n\niamp   = .7\nkindex phasor 440                       ;read table value at this index\nkindex = kindex*8192                    ;for all 8192 index points\nkweightpoint = 0.5                      ;set weightpoint\nktabnum1 line 0, p3, 3                  ;morph through all tables\nktabnum2 = 2                            ;set to triangle wave\nksig tabmorphi kindex, kweightpoint, ktabnum1, ktabnum2, giSine, giSquare, giTri, giSaw\nksig = ksig*iamp\nasig interp ksig                        ;convert to audio signal\nouts asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabmorphi/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabmorphi/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/tabplay/","title":"Tabplay","text":""},{"location":"opcodes/tabplay/#tabplay","title":"tabplay","text":"<p>Plays-back control-rate signals on trigger-temporization basis.</p>"},{"location":"opcodes/tabplay/#syntax","title":"Syntax","text":"<pre><code>tabplay  ktrig, knumtics, kfn, kout1 [,kout2,..., koutN]\n</code></pre>"},{"location":"opcodes/tabplay/#performance","title":"Performance","text":"<p>ktrig -- starts playing when non-zero.</p> <p>knumtics -- stop recording or reset playing pointer to zero when the number of tics defined by this argument is reached.</p> <p>kfn -- table where k-rate signals are recorded.</p> <p>kout1,...,koutN -- playback output signals.</p> <p>The tabplay and tabrec opcodes allow to record/playback control signals on trigger-temporization basis.</p> <p>tabplay plays back a group of k-rate signals, previously recorded by tabrec into a table. Each time ktrig argument is triggered, an internal counter is increased of one unit. After knumtics trigger impluses are received by ktrig argument, the internal counter is zeroed and playback is restarted from the beginning, in looping style.</p> <p>These opcodes can be used like a  sort of \u201cmiddle-term\u201d memory that \u201cremembers\u201d generated signals. Such memory can be used to supply generative music with a coherent iterative compositional structure.</p>"},{"location":"opcodes/tabplay/#examples","title":"Examples","text":"<p>For an examle of use see the example in the tabrec opcode.</p>"},{"location":"opcodes/tabplay/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabplay/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p>"},{"location":"opcodes/tabrec/","title":"Tabrec","text":""},{"location":"opcodes/tabrec/#tabrec","title":"tabrec","text":"<p>Records control-rate signals on trigger-temporization basis.</p>"},{"location":"opcodes/tabrec/#syntax","title":"Syntax","text":"<pre><code>tabrec   ktrig_start, ktrig_stop, knumtics, kfn, kin1 [,kin2,...,kinN]\n</code></pre>"},{"location":"opcodes/tabrec/#performance","title":"Performance","text":"<p>ktrig_start -- start recording when non-zero.</p> <p>ktrig_stop -- stop recording when knumtics trigger impulses are received by this input argument.</p> <p>knumtics -- stop recording or reset playing pointer to zero when the number of tics defined by this argument is reached.</p> <p>kfn -- table where k-rate signals are recorded.</p> <p>kin1,...,kinN -- input signals to record.</p> <p>The tabrec and tabplay opcodes allow to record/playback control signals on trigger-temporization basis.</p> <p>tabrec opcode records a group of k-rate signals by storing them into kfn table. Each time ktrig_start is triggered, tabrec resets the table pointer to zero and begins to record. Recording phase stops after knumtics trigger impulses have been received by ktrig_stop argument.</p> <p>These opcodes can be used like a  sort of \u201cmiddle-term\u201d memory that \u201cremembers\u201d generated signals. Such memory can be used to supply generative music with a coherent iterative compositional structure.</p>"},{"location":"opcodes/tabrec/#examples","title":"Examples","text":"<p>Here is an example of the tabrec opcode. It uses the file tabrec.csd.</p> Example of the tabrec opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o oscil.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngifn ftgen 0,0,1049576,2,0\n\n; record control signals\ninstr 1\nktrig_start init    1\nkoct        rspline 7,10,1,2\nkpan        rspline 7,10,0.1,0.9\nktrig_stop  =       1\nknumtics    =       kr*p3\n            tabrec  ktrig_start,ktrig_stop,knumtics,gifn,koct,kpan\nktrig_start =   0\nendin\n\n; play control signals\ninstr 2\nkoct,kpan   init    0\nktrig       init    1\nknumtics    =       kr*p3\n            tabplay ktrig,knumtics,gifn,koct,kpan\n\nktrig       =       0\n\nasig        poscil 0.1, cpsoct(koct)\naL,aR       pan2    asig,kpan\n            outs    aL,aR\nendin\n\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 10\ni2 2 10\ni2 4 10\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabrec/#see-also","title":"See also","text":"<p>Read/Write Operations</p>"},{"location":"opcodes/tabrec/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>Example written by Iain McCurdy</p>"},{"location":"opcodes/tabsum/","title":"Tabsum","text":""},{"location":"opcodes/tabsum/#tabsum","title":"tabsum","text":"<p>Sums the values in an f-table in a consecutive range.</p>"},{"location":"opcodes/tabsum/#syntax","title":"Syntax","text":"<pre><code>kr tabsum ifn[[, kmin] [, kmax]]\n</code></pre>"},{"location":"opcodes/tabsum/#initialization","title":"Initialization","text":"<p>ifn -- table number</p>"},{"location":"opcodes/tabsum/#performance","title":"Performance","text":"<p>kr -- input signal to write.</p> <p>kmin, kmax -- range of the table to sum. If omitted or zero they default to 0 to length of the table.</p>"},{"location":"opcodes/tabsum/#examples","title":"Examples","text":"<p>Here is an example of the tabsum opcode. It uses the file tabsum.csd.</p> Example of the tabsum opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o tab.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 2205\nnchnls = 1\n0dbfs  = 1\n\ninstr 1       ;;; Give a value to the increment\n  kmax = 256\n  knorm tabsum 1, 0, kmax\n  gkinc = knorm/10\nendin\n\ninstr 2\n  kmax = 256\n  kx = rnd(kmax)\n  krnd  tabsum 1, 0, kx\n  knorm tabsum 1, 0, kmax\n  kvar  = krnd / knorm          ;;; now n [0,1] range\n  asig  oscil  kvar, p4, 2\n        out    asig\n;;; Make randomness give 1 more often\n  kc    tab     0, 1\n        tablew  kc+gkinc, 0, 1\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 256 21 1  \nf2 0 4096 10 1\ni1 0 0.1\ni2 0.1 3 440\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabsum/#see-also","title":"See Also","text":"<p>Vectorial opcodes</p>"},{"location":"opcodes/tabsum/#credits","title":"Credits","text":"<p>Author: John ffitch Codemist Ltd 2009</p> <p>New in version 5.11</p>"},{"location":"opcodes/tabw/","title":"Tabw","text":""},{"location":"opcodes/tabw/#tabw","title":"tabw","text":"<p>Fast table opcodes.</p> <p>Faster than tablew because it does not allow wrap-around and limit. Has been implemented in order to provide fast access to arrays.</p>"},{"location":"opcodes/tabw/#syntax","title":"Syntax","text":"<pre><code>tabw ksig, kndx, ifn [,ixmode]\ntabw asig, andx, ifn [,ixmode]\n</code></pre>"},{"location":"opcodes/tabw/#initialization","title":"Initialization","text":"<p>ifn -- table number</p> <p>ixmode -- defaults to zero.  If zero xndx range matches the length of the table; if non zero xndx has a 0 to 1 range.</p>"},{"location":"opcodes/tabw/#performance","title":"Performance","text":"<p>andx, kndx -- table index.</p> <p>tabw opcode is similar to tablew but are faster, and use rounding of the index.</p> <p>Special care of index value must be taken into account. Index values out of the table allocated space will crash Csound.</p>"},{"location":"opcodes/tabw/#examples","title":"Examples","text":"<p>Here is an example of the tabw opcode. It uses the file tabw.csd.</p> Example of the tabw opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tabw.wav -W ;;; for file output any platform\n\n;By Stefano Cucchi 2024\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\ntabw p4, 0, 2 ; write content of function number \"2\"\ntabw p5, 1, 2\ntabw p6, 2, 2\ntabw p7, 3, 2\ntabw p8, 4, 2\n\nkamp oscili 1, 1/p3, 2 ;use f2 as envelope\nasig poscil kamp, 440, 1    \n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1 0.6 0 0.4 0.6  \nf2 0 5 2 0 0 0 0 0\n\ni1 0 3   0 0.9  0 0.2 0.9 ; every note has different envelope\ni1 4 3   1 0.01 1 0.5  0\ni1 8 3   1  1   0 0.5  0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tabw/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/tabw/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p>"},{"location":"opcodes/tabw_i/","title":"Tabw i","text":""},{"location":"opcodes/tabw_i/#tabw_i","title":"tabw_i","text":"<p>Fast table opcodes.</p> <p>Faster than tablew because it does not allow wrap-around and limit. Has been implemented in order to provide fast access to arrays.</p>"},{"location":"opcodes/tabw_i/#syntax","title":"Syntax","text":"<pre><code>tabw_i isig, indx, ifn [,ixmode]\n</code></pre>"},{"location":"opcodes/tabw_i/#initialization","title":"Initialization","text":"<p>ifn -- table number</p> <p>ixmode -- defaults to zero.  If zero indx range matches the length of the table; if non zero xndx has a 0 to 1 range.</p> <p>isig -- input value to write.</p> <p>indx -- table index</p>"},{"location":"opcodes/tabw_i/#performance","title":"Performance","text":"<p>tabw_i opcode is similar to tablew but is faster, and use rounding of the index.</p>"},{"location":"opcodes/tabw_i/#see-also","title":"See Also","text":"<p>Table Access</p>"},{"location":"opcodes/tabw_i/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p>"},{"location":"opcodes/tambourine/","title":"Tambourine","text":""},{"location":"opcodes/tambourine/#tambourine","title":"tambourine","text":"<p>Semi-physical model of a tambourine sound.</p> <p>It is one of the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event Modeling) is an algorithmic approach for simulating collisions of multiple independent sound producing objects.</p>"},{"location":"opcodes/tambourine/#syntax","title":"Syntax","text":"<pre><code>ares tambourine kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \\\n                [, ifreq1] [, ifreq2]\n</code></pre>"},{"location":"opcodes/tambourine/#initialization","title":"Initialization","text":"<p>idettack -- period of time over which all sound is stopped</p> <p>inum (optional) -- The number of beads, teeth, bells, timbrels, etc.  If zero, the default value is 32.</p> <p>idamp (optional) -- the damping factor, as part of this equation:</p> <pre><code>damping_amount = 0.9985 + (idamp * 0.002)\n</code></pre> <p>The default damping_amount is 0.9985 which means that the default value of idamp is 0. The maximum damping_amount is 1.0 (no damping). This means the maximum value for idamp is 0.75.</p> <p>The recommended range for idamp is usually below 75% of the maximum value.</p> <p>imaxshake (optional, default=0) -- amount of energy to add back into the system. The value should be in range 0 to 1.</p> <p>ifreq (optional) -- the main resonant frequency. The default value is 2300.</p> <p>ifreq1 (optional) -- the first resonant frequency. The default value is 5600.</p> <p>ifreq2 (optional) -- the second resonant frequency. The default value is 8100.</p>"},{"location":"opcodes/tambourine/#performance","title":"Performance","text":"<p>kamp -- Amplitude of output.  Note: As these instruments are stochastic, this is only an approximation.</p>"},{"location":"opcodes/tambourine/#examples","title":"Examples","text":"<p>Here is an example of the tambourine opcode. It uses the file tambourine.csd.</p> Example of the tambourine opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tambourine.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidamp = p4\nasig  tambourine .8, 0.01, 30, idamp, 0.4\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 .2 0\ni 1 + .2 &gt;\ni 1 + 1 .7\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tambourine/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/tambourine/#credits","title":"Credits","text":"<p>Author: Perry Cook, part of the PhISEM (Physically Informed Stochastic Event Modeling) Adapted by John ffitch University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p> <p>Added notes by Rasmus Ekman on May 2002.</p>"},{"location":"opcodes/tan/","title":"Tan","text":""},{"location":"opcodes/tan/#tan","title":"tan","text":"<p>Returns the tangent of x (x in radians).</p>"},{"location":"opcodes/tan/#syntax","title":"Syntax","text":"<pre><code>tan(x)     (no rate restriction)\ntan(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/tan/#examples","title":"Examples","text":"<p>Here is an example of the tan opcode. It uses the file tan.csd.</p> Example of the tan opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n  ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o tan.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nirad = 25\ni1 = tan(irad)\nprint i1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = -0.134\n</code></pre>"},{"location":"opcodes/tan/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/tan/#credits","title":"Credits","text":"<p>Written by John ffitch.</p> <p>New in version 3.47</p>"},{"location":"opcodes/tanh/","title":"Tanh","text":""},{"location":"opcodes/tanh/#tanh","title":"tanh","text":"<p>Returns the hyperbolic tangent of x.</p>"},{"location":"opcodes/tanh/#syntax","title":"Syntax","text":"<pre><code>tanh(x)     (no rate restriction)\ntanh(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/tanh/#examples","title":"Examples","text":"<p>Here is an example of the tanh opcode. It uses the file tanh.csd.</p> Example of the tanh opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac    ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o tanh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nasig1 vco  1, 440, 2, 0.4, 1\nasig2 vco  1, 800, 3, 0.5, 1\nasig  =    asig1+asig2              ; will go out of range\nouts  tanh(asig), tanh(asig)        ; but tanh is a limiter\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 65536 10 1 ; sine\n\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tanh/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/tanh/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.47</p>"},{"location":"opcodes/taninv/","title":"Taninv","text":""},{"location":"opcodes/taninv/#taninv","title":"taninv","text":"<p>Returns the arctangent of x (x in radians).</p>"},{"location":"opcodes/taninv/#syntax","title":"Syntax","text":"<pre><code>taninv(x)     (no rate restriction)\ntaninv(k/i[]) (k- or i-arrays )\n</code></pre>"},{"location":"opcodes/taninv/#examples","title":"Examples","text":"<p>Here is an example of the taninv opcode. It uses the file taninv.csd.</p> Example of the taninv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n  ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o taninv.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nirad = 0.5\ni1 = taninv(irad)\nprint i1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 0.464\n</code></pre>"},{"location":"opcodes/taninv/#see-also","title":"See also","text":"<p>Trigonometric Functions</p>"},{"location":"opcodes/taninv/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 3.48</p>"},{"location":"opcodes/taninv2/","title":"Taninv2","text":""},{"location":"opcodes/taninv2/#taninv2","title":"taninv2","text":"<p>Returns the arctangent of iy/ix, ky/kx, or ay/ax.</p>"},{"location":"opcodes/taninv2/#syntax","title":"Syntax","text":"<pre><code>ares taninv2 ay, ax\nires taninv2 iy, ix\nkres taninv2 ky, kx\n ... taninv2(ky, kx)... (no rate restriction)\n</code></pre> <p>Returns the arctangent of iy/ix, ky/kx, or ay/ax. If y is zero, taninv2 returns zero regardless of the value of x. If x is zero, the return value is:</p> <ul> <li>\u03c0/2, if y is positive.</li> <li>-\u03c0/2, if y is negative.</li> <li>0, if y is 0.</li> </ul>"},{"location":"opcodes/taninv2/#initialization","title":"Initialization","text":"<p>iy, ix -- values to be converted</p>"},{"location":"opcodes/taninv2/#performance","title":"Performance","text":"<p>ky, kx -- control rate signals to be converted</p> <p>ay, ax -- audio rate signals to be converted</p>"},{"location":"opcodes/taninv2/#examples","title":"Examples","text":"<p>Here is an example of the taninv2 opcode. It uses the file taninv2.csd.</p> Example of the taninv2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-n   ; no sound\n; For Non-realtime ouput leave only the line below:\n; -o system.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt; \n\n;  by Kevin Conder\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\ni1 taninv2 1, 2     ; Returns the arctangent for 1/2.\nprint i1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>instr 1:  i1 = 0.464\n</code></pre> <p>Here is another example of the taninv2 opcode. It uses the file taninv2-advanced.csd.</p> Advanced example of the taninv2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\na1 oscili 0.1, p4\na2 oscili 0.1, p5\nashape taninv2 a1, a2\nkdeclick linseg 0, 0.3, 0.2, p3-0.6, 0.2, 0.3, 0\nouts ashape*kdeclick, ashape*kdeclick\nendin\n\ninstr 2\n\na1 diskin  p4, 1\na2 = a1\nashape taninv2 a1, a2\nkdeclick linseg 0, 0.3, 0.2, p3-0.6, 0.2, 0.3, 0\nouts ashape*kdeclick*.5, ashape*kdeclick*.5\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 440 300\ni 1 3 3 200 210\ni 1 6 3 50 40\ni 1 9 3 50 3000\ni 2 12 3 \"fox.wav\"\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/taninv2/#see-also","title":"See also","text":"<p>Opcode Equivalents of Functions</p> <p>Trigonometric Functions</p>"},{"location":"opcodes/taninv2/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK April 1998</p> <p>New in Csound version 3.48</p> <p>Corrected on May 2002, thanks to Istvan Varga.</p> <p>Available as a function in version 6.00</p>"},{"location":"opcodes/tbvcf/","title":"Tbvcf","text":""},{"location":"opcodes/tbvcf/#tbvcf","title":"tbvcf","text":"<p>Models some of the filter characteristics of a Roland TB303 voltage-controlled filter.</p> <p>Euler's method is used to approximate the system, rather than traditional filter methods. Cutoff frequency, Q, and distortion are all coupled. Empirical methods were used to try to unentwine,  but frequency is only approximate as a result. Future fixes for some problems with this opcode may break existing orchestras relying on this version of tbvcf.</p>"},{"location":"opcodes/tbvcf/#syntax","title":"Syntax","text":"<pre><code>ares tbvcf asig, xfco, xres, kdist, kasym [, iskip]\n</code></pre>"},{"location":"opcodes/tbvcf/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/tbvcf/#performance","title":"Performance","text":"<p>asig -- input signal. Should be normalized to \u00b11.</p> <p>xfco -- filter cutoff frequency. Optimum range is 10,000 to 1500. Values below 1000 may cause problems.</p> <p>xres -- resonance or Q. Typically in the range 0 to 2.</p> <p>kdist -- amount of distortion. Typical value is 2. Changing kdist significantly from 2 may cause odd interaction with xfco and xres.</p> <p>kasym -- asymmetry of resonance. Typically in the range 0 to 1.</p>"},{"location":"opcodes/tbvcf/#examples","title":"Examples","text":"<p>Here is an example of the tbvcf opcode. It uses the file tbvcf.csd.</p> Example of the tbvcf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o tbvcf.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n;---------------------------------------------------------\n; TBVCF Test\n; Coded by Hans Mikelson December, 2000\n;---------------------------------------------------------\n  sr =  44100   ; Sample rate\n  ksmps =  10   ; Samples/Kontrol period\n  nchnls =  2        ; Normal stereo\n  0dbfs = 1\n\n\n          instr 10\n\n  idur  =       p3                      ; Duration\n  iamp  =       p4                      ; Amplitude\n  ifqc  =       cpspch(p5)              ; Pitch to frequency\n  ipanl =       sqrt(p6)                ; Pan left\n  ipanr =       sqrt(1-p6)              ; Pan right\n  iq    =       p7\n  idist =       p8\n  iasym =       p9\n\nkdclck          linseg  0, .002, 0.9, idur-.004, 0.9, .002, 0   ; Declick envelope\nkfco            expseg  10000, idur, 1000                       ; Frequency envelope\nax              vco             1, ifqc, 2, 0.5                 ; Square wave\nay              tbvcf           ax, kfco, iq, idist, iasym              ; TB-VCF\nay              buthp   ay/1, 100                               ; Hi-pass\n\n                outs            ay*iamp*ipanl*kdclck, ay*iamp*ipanr*kdclck\n          endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1 0 65536 10 1\n\n; TeeBee Test\n;   Sta  Dur  Amp    Pitch Pan  Q    Dist1 Asym\ni10 0    0.2  0.5    7.00  .5   0.0  2.0   0.0\ni10 0.3  0.2  0.5    7.00  .5   0.8  2.0   0.0\ni10 0.6  0.2  0.5    7.00  .5   1.6  2.0   0.0\ni10 0.9  0.2  0.5    7.00  .5   1.7  2.0   0.0\ni10 1.2  0.2  0.5    7.00  .5   1.8  2.0   0.0\ni10 1.8  0.2  0.5    7.00  .5   0.0  2.0   0.25\ni10 2.1  0.2  0.5    7.00  .5   0.8  2.0   0.25\ni10 2.4  0.2  0.5    7.00  .5   1.6  2.0   0.25\ni10 2.7  0.2  0.5    7.00  .5   1.8  2.0   0.25\ni10 3.0  0.2  0.5    7.00  .5   1.9  2.0   0.25\ni10 3.3  0.2  0.5    7.00  .5   2.0  2.0   0.25\ni10 3.6  0.2  0.5    7.00  .5   0.0  2.0   0.5\ni10 3.9  0.2  0.5    7.00  .5   0.8  2.0   0.5\ni10 4.2  0.2  0.5    7.00  .5   1.6  2.0   0.5\ni10 4.5  0.2  0.5    7.00  .5   1.8  2.0   0.5\ni10 4.8  0.2  0.5    7.00  .5   1.9  2.0   0.5\ni10 5.1  0.2  0.5    7.00  .5   2.0  2.0   0.5\ni10 5.4  0.2  0.5    7.00  .5   0.0  2.0   0.75\ni10 5.7  0.2  0.5    7.00  .5   0.8  2.0   0.75\ni10 6.0  0.2  0.5    7.00  .5   1.6  2.0   0.75\ni10 6.3  0.2  0.5    7.00  .5   1.8  2.0   0.75\ni10 6.6  0.2  0.5    7.00  .5   1.9  2.0   0.75\ni10 6.9  0.2  0.5    7.00  .5   2.0  2.0   0.75\ni10 7.2  0.2  0.5    7.00  .5   0.0  2.0   1.0\ni10 7.5  0.2  0.5    7.00  .5   0.8  2.0   1.0\ni10 7.8  0.2  0.5    7.00  .5   1.6  2.0   1.0\ni10 8.1  0.2  0.5    7.00  .5   1.8  2.0   1.0\ni10 8.4  0.2  0.5    7.00  .5   1.9  2.0   1.0\ni10 8.7  0.2  0.5    7.00  .5   2.0  2.0   1.0\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tbvcf/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/tbvcf/#credits","title":"Credits","text":"<p>Author: Hans Mikelson December, 2000 -- January, 2001</p> <p>New in Csound 4.10</p>"},{"location":"opcodes/tempest/","title":"Tempest","text":""},{"location":"opcodes/tempest/#tempest","title":"tempest","text":"<p>Estimate the tempo of beat patterns in a control signal.</p>"},{"location":"opcodes/tempest/#syntax","title":"Syntax","text":"<pre><code>ktemp tempest kin, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, \\\n              istartempo, ifn [, idisprd] [, itweek]\n</code></pre>"},{"location":"opcodes/tempest/#initialization","title":"Initialization","text":"<p>iprd -- period between analyses (in seconds). Typically about .02 seconds.</p> <p>imindur -- minimum duration (in seconds) to serve as a unit of tempo. Typically about .2 seconds.</p> <p>imemdur -- duration (in seconds) of the kin short-term memory buffer which will be scanned for periodic patterns. Typically about 3 seconds.</p> <p>ihp -- half-power point (in Hz) of a low-pass filter used to smooth input kin prior to other processing. This will tend to suppress activity that moves much faster. Typically 2 Hz.</p> <p>ithresh -- loudness threshold by which the low-passed kin is center-clipped before being placed in the short-term buffer as tempo-relevant data. Typically at the noise floor of the incoming data.</p> <p>ihtim -- half-time (in seconds) of an internal forward-masking filter that masks new kin data in the presence of recent, louder data. Typically about .005 seconds.</p> <p>ixfdbak -- proportion of this unit's anticipated value to be mixed with the incoming kin prior to all processing. Typically about .3.</p> <p>istartempo -- initial tempo (in beats per minute). Typically 60.</p> <p>ifn -- table number of a stored function (drawn left-to-right) by which the short-term memory data is attenuated over time.</p> <p>idisprd (optional) -- if non-zero, display the short-term past and future buffers every idisprd seconds (normally a multiple of iprd). The default value is 0 (no display).</p> <p>itweek (optional) -- fine-tune adjust this unit so that it is stable when analyzing events controlled by its own output. The default value is 1 (no change).</p>"},{"location":"opcodes/tempest/#performance","title":"Performance","text":"<p>tempest examines kin for amplitude periodicity, and estimates a current tempo. The input is first low-pass filtered, then center-clipped, and the residue placed in a short-term memory buffer (attenuated over time) where it is analyzed for periodicity using a form of autocorrelation. The period, expressed as a tempo in beats per minute, is output as ktemp. The period is also used internally to make predictions about future amplitude patterns, and these are placed in a buffer adjacent to that of the input. The two adjacent buffers can be periodically displayed, and the predicted values optionally mixed with the incoming signal to simulate expectation.</p> <p>This unit is useful for sensing the metric implications of any k-signal (e.g.- the RMS of an audio signal, or the second derivative of a conducting gesture), before sending to a tempo statement.</p>"},{"location":"opcodes/tempest/#examples","title":"Examples","text":"<p>Here is an example of the tempest opcode. It uses the file tempest.csd, and drumsMlp.wav.</p> Example of the tempest opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o tempest.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Use the \"drumsMlp.wav\" sound file.\n  asig soundin \"drumsMlp.wav\"\n  ; Extract the pitch and the envelope.\n  kcps, krms pitchamdf asig, 150, 500, 200\n\n  iprd = 0.01\n  imindur = 0.1\n  imemdur = 3\n  ihp = 1\n  ithresh = 30\n  ihtim = 0.005\n  ixfdbak = 0.05\n  istartempo = 110\n  ifn = 1\n\n  ; Estimate its tempo.\n  k1 tempest krms, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, istartempo, ifn\n  printk2 k1\n\n  out asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a declining line.\nf 1 0 128 16 1 128 1\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>The tempo of the audio file \u201cdrumsMlp.wav\u201d is 120 beats per minute. In this examples, tempest will print out its best guess as the audio file plays. Its output should include lines like this:</p> <pre><code>. i1   118.24654\n. i1   121.72949\n</code></pre>"},{"location":"opcodes/tempest/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Pitch estimation</p>"},{"location":"opcodes/tempo/","title":"Tempo","text":""},{"location":"opcodes/tempo/#tempo","title":"tempo","text":"<p>Apply tempo control to an uninterpreted score.</p>"},{"location":"opcodes/tempo/#syntax","title":"Syntax","text":"<pre><code>tempo ktempo, istartempo\n</code></pre>"},{"location":"opcodes/tempo/#initialization","title":"Initialization","text":"<p>istartempo -- initial tempo (in beats per minute). Typically 60.</p>"},{"location":"opcodes/tempo/#performance","title":"Performance","text":"<p>ktempo -- The tempo to which the score will be adjusted.</p> <p>tempo allows the performance speed of Csound scored events to be controlled from within an orchestra. It operates only in the presence of the Csound -t flag. When that flag is set, scored events will be performed from their uninterpreted p2 and p3 (beat) parameters, initially at the given command-line tempo. When a tempo statement is activated in any instrument (ktempo 0.), the operating tempo will be adjusted to ktempo beats per minute. There may be any number of tempo statements in an orchestra, but coincident activation is best avoided.</p>"},{"location":"opcodes/tempo/#examples","title":"Examples","text":"<p>Here is an example of the tempo opcode. Remember, it only works if you use the -t flag with Csound. The example uses the file tempo.csd.</p> Example of the tempo opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    -t60 ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o tempo.wav -W -t60 ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  kval tempoval\n\n  printk 0.1, kval\n\n  ; If the fourth p-field is 1, increase the tempo.\n  if (p4 == 1) kgoto speedup\n    kgoto playit\n\nspeedup:\n  ; Increase the tempo to 150 beats per minute.\n  tempo 150, 60\n\nplayit:\n\n  a1 oscil 10000, 440, 1\n  out a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; p4 = plays at a faster tempo (when p4=1).\n; Play Instrument #1 at the normal tempo, repeat 3 times.\nr3\ni 1 00.00 00.25 0\ni 1 00.25 00.25 0\ni 1 00.50 00.25 0\ni 1 00.75 00.25 0\ns\n\n; Play Instrument #1 at a faster tempo, repeat 3 times.\nr3\ni 1 00.00 00.25 1\ni 1 00.25 00.25 0\ni 1 00.50 00.25 0\ni 1 00.75 00.25 0\ns\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tempo/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/tempo/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/tempoval/","title":"Tempoval","text":""},{"location":"opcodes/tempoval/#tempoval","title":"tempoval","text":"<p>Reads the current value of the tempo.</p>"},{"location":"opcodes/tempoval/#syntax","title":"Syntax","text":"<pre><code>kres tempoval\n</code></pre>"},{"location":"opcodes/tempoval/#performance","title":"Performance","text":"<p>kres -- the value of the tempo. If you use a positive value with the -t command-line flag, tempoval returns the percentage increase/decrease from the original tempo of 60 beats per minute. If you do not, its value will be 60 (for 60 beats per minute).</p>"},{"location":"opcodes/tempoval/#examples","title":"Examples","text":"<p>Here is an example of the tempoval opcode. Remember, it only works if you use the -t flag with Csound. It uses the file tempoval.csd.</p> Example of the tempoval opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    -t60 ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o tempoval.wav -W -t60 ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Adjust the tempo to 120 beats per minute.\n  tempo 120, 60\n\n  ; Get the tempo value.\n  kval tempoval\n\n  printks \"kval = %f\\\\n\", 0.1, kval\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for one second.\ni 1 0 1\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Since 120 beats per minute is a 50% increase over the original 60 beats per minute, its output should include lines like:</p> <pre><code>kval = 0.500000\n</code></pre>"},{"location":"opcodes/tempoval/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/tempoval/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p> <p>New in version 4.15</p> <p>December 2002. Thanks to Drake Wilson for pointing out unclear documentation.</p>"},{"location":"opcodes/tigoto/","title":"Tigoto","text":""},{"location":"opcodes/tigoto/#tigoto","title":"tigoto","text":"<p>Transfer control at i-time when a new note is being tied onto a previously held note</p> <p>Similar to igoto but effective only during an i-time pass at which a new note is being \u201ctied\u201d onto a previously held note. (See i Statement) It does not work when a tie has not taken place. Allows an instrument to skip initialization of units according to whether a proposed tie was in fact successful. (See also tival).</p>"},{"location":"opcodes/tigoto/#syntax","title":"Syntax","text":"<pre><code>tigoto label\n</code></pre> <p>where label is in the same instrument block and is not an expression.</p>"},{"location":"opcodes/tigoto/#examples","title":"Examples","text":"<p>Here is an example of the tigoto opcode. It uses the file tigoto.csd.</p> Example of the tigoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tigoto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2\n0dbfs  = 1 \n\ninstr 1\n\nidur  = abs(p3)                         ;make p3 positive even if p3 is negative in score\nitiv  tival\ni1    = -1                              ;assume this is tied note, so keep fase of oscili\n      tigoto slur                       ;no reinitialisation on tied notes\ni1    = 0                               ;first note, so reset phase\naatt  line p4, idur, 0                  ;primary envelope\n\nslur:\n      if itiv==0 kgoto note             ;no expression on first and second note\naslur linseg 0, idur*.3, p4, idur*.7, 0 ;envelope for slurred note\naatt  = aatt + aslur\n\nnote:\nasig  oscili aatt, p5, 1, i1\n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1  ;sine wave\n\ni1  0    -5  .8  451    ;p3 = 5 seconds\ni1  1.5 -1.5 .1  512 \ni1  3    2   .7  440    ;3 notes together--&gt; duration = 5 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the tigoto opcode. It uses the file tigoto2.csd.</p> Second example of the tigoto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tigoto2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Steven Yi 2024\n\nsr = 44100 \nksmps = 32 \nnchnls = 2\n0dbfs  = 1 \n\ninstr 1\n\niamp = ampdbfs(p5)\nipch = cps2pch(p4,12)\n\nxtratim 4              ; extend the duration of the note\ntigoto skipInit        ; csound \"jumps\" to the label, skipping initialization for the code in between\n                       ; but only if this is a \"tied\" note  \nkpch = port(ipch, 0.05, ipch)\nasig = vco2(iamp, kpch)\n;asig = zdf_2pole(asig, min:k(10000, kpch * 16), 4)  ; uncomment to use filter\nasig *= linsegr(0, 1, 1, 4, 0)\nout(asig, asig)\n\nskipInit:\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 -.5 8.00 -12\ni1 + -.5 9.00 -12\ni1 + 2 6.00 -12\n\ni1.1 .25 -.5 9.00 -12\ni1.1 + -.5 10.00 -12\ni1.1 + 2 7.00 -12\n\ni1.2 1 -.25 7.00 .\ni1.2 + 2 8.00 .\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tigoto/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/timedseq/","title":"Timedseq","text":""},{"location":"opcodes/timedseq/#timedseq","title":"timedseq","text":"<p>Time Variant Sequencer</p> <p>An event-sequencer in which time can be controlled by a time-pointer. Sequence data are stored into a table.</p>"},{"location":"opcodes/timedseq/#syntax","title":"Syntax","text":"<pre><code>ktrig  timedseq  ktimpnt, ifn, kp1 [,kp2, kp3, ...,kpN]\n</code></pre>"},{"location":"opcodes/timedseq/#initialization","title":"Initialization","text":"<p>ifn -- number of table containing sequence data.</p>"},{"location":"opcodes/timedseq/#performance","title":"Performance","text":"<p>ktri -- output trigger signal</p> <p>ktimpnt -- time pointer into sequence file, in seconds.</p> <p>kp1,...,kpN -- output p-fields of notes. kp2 meaning is relative action time and kp3 is the duration of notes in seconds.</p> <p>timedseq is a sequencer that allows to schedule notes starting from a user sequence, and depending from an external timing given by a time-pointer value (ktimpnt argument). User should fill table ifn with a list of notes, that can be provided in an external text file by using GEN23, or by typing it directly in the orchestra (or score) file with GEN02. The format of the text file containing the sequence is made up simply by rows containing several numbers separated by space (similarly to normal Csound score).  The first value of each row must be a positive or null value, except for a special case that will be explained below. This first value is normally used to define the instrument number corresponding to that particular note (like normal score). The second value of each row must contain the action time of corresponding note and the third value its duration. This is an example:</p> <pre><code>0 0    0.25 1  93\n0 0.25 0.25 2  63\n0 0.5  0.25 3  91\n0 0.75 0.25 4  70\n0 1    0.25 5  83\n0 1.25 0.25 6  75\n0 1.5  0.25 7  78\n0 1.75 0.25 8  78\n0 2    0.25 9  83\n0 2.25 0.25 10 70\n0 2.5  0.25 11 54\n0 2.75 0.25 12 80\n-1 3   -1   -1 -1  ;; last row of the sequence\n</code></pre> <p>In this example, the first value of each row is always zero (it is a dummy value, but this p-field can be used, for example, to express a MIDI channel or an instrument number), except the last row, that begins with -1. This value (-1) is a special value, that indicates the end of sequence. It has itself an action time, because sequences can be looped. So the previous sequence has a default duration of 3 seconds, being value 3 the last action time of the sequence.</p> <p>It is important that ALL lines contains the same number of values (in the example all rows contains exactly 5 values). The number of values contained by each row, MUST be the number of kpXX output arguments (notice that, even if kp1, kp2 etc. are placed at the right of the opcode, they are output arguments, not input arguments).</p> <p>ktimpnt argument provide the real temporization of the sequence. Actually the passage of time through sequence is specified by ktimpnt itself, which represents the time in seconds. ktimpnt must always be positive, but can move forwards or backwards in time, be stationary or discontinuous, as a pointer into the sequence file, in the same way of pvoc or lpread. When ktimpnt crosses the action time of a note, a trigger signal is sent to ktrig output argument, and kp1, kp2,...kpN arguments are updated with the values of that note. This information can then be used with schedkwhen to actually activate note events. Notice that kp1,...kpn data can be further processed (for example delayed with delayk, transposed, etc.) before feeding schedkwhen.</p> <p>ktimpnt can be controlled by a linear signal, for example:</p> <pre><code>ktimpnt line     0, p3, 3  ; original sequence duration was 3 secs\nktrig   timedseq ktimpnt, 1, kp1, kp2, kp3, kp4, kp5\n        schedkwhen   ktrig, 105, 2, 0, kp3, kp4, kp5\n</code></pre> <p>in this case the complete sequence (with original duration of 3 seconds) will be played in p3 seconds.</p> <p>You can loop a sequence by controlling it with a phasor:</p> <pre><code>kphs    phasor   1/3\nktimpnt =        kphs * 3\nktrig   timedseq ktimpnt ,1 ,kp1, kp2, kp3, kp4, kp5\n        schedkwhen   ktrig, 105, 2, 0, kp3, kp4, kp5\n</code></pre> <p>Obviously you can play only a fragment of the sequence,  read it backward, and non-linearly access sequence data in the same way of pvoc and lpread opcodes.</p> <p>With timedseq opcode you can do almost all things of a normal score, except you have the following limitations:</p> <ol> <li>You cannot have two notes exactly starting with the same action time; actually at least a k-cycle should separate timing of two notes (otherwise the schedkwhen mechanism eats one of them).</li> <li>All notes of the sequence must have the same number of p-fields (even if they activate different instruments).</li> </ol> <p>You can remedy this limitation by filling with dummy values notes that belongs to instruments with less p-fields than other ones.</p>"},{"location":"opcodes/timedseq/#examples","title":"Examples","text":"<p>Here is a complete example of the timedseq opcode. It uses the file timedseq.csd.</p> Example of the timedseq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o timedseq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiseq ftgen 0,0,128,-2, 2,  0,   0.5, 8.00,\\            ;first note\n                        2,  1,   0.5, 8.02,\\            ;second note\n                        2,  2,   0.5, 8.04,\\            ;third\n                        2,  3,   0.5, 8.05,\\            ;fourth\n                        2,  4,   0.5, 8.07,\\            ;fifth\n                        2,  5,   0.5, 8.09,\\            ;sixth\n                        2,  6,   0.5, 8.11,\\            ;seventh\n                        2,  7,   0.5, 9.00,\\            ;eight note\n                        2,  8,   0.5, 8.00,\\            ;due to a quirk in the opcode, it needs an extra note - a copy of the first note\n                        -1, 8,   -1,  -1                ;last line is a dummy event that indicates to timedseq when to loop back to the beginning\n\ninstr   1\n\nibeats  = 8                                             ;lengths of sequence in beats\nitempo  = p4                                            ;tempo\niBPS    = itempo/60                                     ;beats per second       \nkphase  phasor  iBPS/ibeats                             ;phasor to move through table\nkpointer = kphase*ibeats                                ;multiply phase (range 0 - 1) by the number of beats contained within the sequence\nkp1 init 0\nkp2 init 0\nkp3 init 0 \nkp4 init 0                      \nktrigger   timedseq kpointer, giseq, kp1, kp2,kp3, kp4\nschedkwhen ktrigger, 0, 0, 2, 0, kp3/abs(iBPS), kp4     ;p3 values have been scaled according to tempo so that they maesure beats rather than seconds\nendin                                                   ;abs(iBPS)(absolute value) is used because the tempo provided by the fourth note of the score is negative.\n                                                        ;Durations here should be positive, because negative values for duration would indicate a held note.\ninstr   2\n\naenv    linseg  0,0.01,1,p3-0.01,0                      ;amplitude envelope\nasig    vco2    0.4, cpspch(p4), 4, 0.5\n        outs    asig*aenv, asig*aenv                    \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 4 120\ni 1 + . 240\ni 1 + . 480\ni 1 + . -480    ;when negative it plays backwards \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/timedseq/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/timedseq/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"opcodes/timeinstk/","title":"Timeinstk","text":""},{"location":"opcodes/timeinstk/#timeinstk","title":"timeinstk","text":"<p>Read absolute time in k-rate cycles, since the start of aninstance of an instrument.</p> <p>Called at both i-time as well as k-time. NB: the returned value at k-time starts at 1</p>"},{"location":"opcodes/timeinstk/#syntax","title":"Syntax","text":"<pre><code>kres timeinstk\n</code></pre>"},{"location":"opcodes/timeinstk/#performance","title":"Performance","text":"<p>timeinstk is for time in k-rate cycles. So with:</p> <pre><code>  sr    = 44100\n  kr    = 6300\n  ksmps = 7\n</code></pre> <p>then after half a second, the timeinstk opcode would report 3150. It will always report an integer.</p> <p>timeinstk produces a k-rate variable for output. There are no input parameters.</p> <p>timeinstk is similar to timek except it returns the time since the start of this instance of the instrument.</p>"},{"location":"opcodes/timeinstk/#examples","title":"Examples","text":"<p>Here is an example of the timeinstk opcode. It uses the file timeinstk.csd.</p> Example of the timeinstk opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o timeinstk.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Print out the value from timeinstk every half-second.\n  k1 timeinstk\n  printks \"k1 = %f samples\\\\n\", 0.5, k1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1 = 1.000000 samples\nk1 = 2205.000000 samples\nk1 = 4410.000000 samples\nk1 = 6615.000000 samples\nk1 = 8820.000000 samples\n</code></pre>"},{"location":"opcodes/timeinstk/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/timeinstk/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/timeinsts/","title":"Timeinsts","text":""},{"location":"opcodes/timeinsts/#timeinsts","title":"timeinsts","text":"<p>Read absolute time, in seconds, since the start of an instance of an instrument.</p>"},{"location":"opcodes/timeinsts/#syntax","title":"Syntax","text":"<pre><code>kres timeinsts\n</code></pre>"},{"location":"opcodes/timeinsts/#performance","title":"Performance","text":"<p>Time in seconds is available with timeinsts. This would return 0.5 after half a second.</p> <p>timeinsts produces a k-rate variable for output. There are no input parameters.</p> <p>timeinsts is similar to times except it returns the time since the start of this instance of the instrument.</p>"},{"location":"opcodes/timeinsts/#examples","title":"Examples","text":"<p>Here is an example of the timeinsts opcode. It uses the file timeinsts.csd.</p> Example of the timeinsts opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o timeinsts.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nkvib init 1\nktim timeinsts                          ;read time \n\nif ktim &gt; 2 then                        ;do something after 2 seconds\n   kvib oscili 2, 3, giSine             ;make a vibrato\nendif\n\nasig poscil .5, 600+kvib, giSine        ;add vibrato\n     outs asig, asig\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/timeinsts/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/timeinsts/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/timek/","title":"Timek","text":""},{"location":"opcodes/timek/#timek","title":"timek","text":"<p>Read absolute time, in k-rate cycles, since the start of the performance.</p>"},{"location":"opcodes/timek/#syntax","title":"Syntax","text":"<pre><code>ires timek\nkres timek\n</code></pre>"},{"location":"opcodes/timek/#performance","title":"Performance","text":"<p>timek is for time in k-rate cycles. So with:</p> <pre><code>  sr    = 44100\n  kr    = 6300\n  ksmps = 7\n</code></pre> <p>then after half a second, the timek opcode would report 3150. It will always report an integer.</p> <p>timek can produce a k-rate variable for output. There are no input parameters.</p> <p>timek can also operate only at the start of the instance of the instrument. It produces an i-rate variable (starting with i or gi) as its output.</p>"},{"location":"opcodes/timek/#examples","title":"Examples","text":"<p>Here is an example of the timek opcode. It uses the file timek.csd.</p> Example of the timek opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o timek.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; Print out the value from timek every half-second.\n  k1 timek\n  printks \"k1 = %f samples\\\\n\", 0.5, k1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Play Instrument #1 for two seconds.\ni 1 0 2\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1 = 1.000000 samples\nk1 = 2205.000000 samples\nk1 = 4410.000000 samples\nk1 = 6615.000000 samples\nk1 = 8820.000000 samples\n</code></pre>"},{"location":"opcodes/timek/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/timek/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p> <p>New in version 3.47</p> <p>Example written by Kevin Conder.</p>"},{"location":"opcodes/times/","title":"Times","text":""},{"location":"opcodes/times/#times","title":"times","text":"<p>Read absolute time, in seconds, since the start of the performance.</p>"},{"location":"opcodes/times/#syntax","title":"Syntax","text":"<pre><code>ires times\nkres times\n</code></pre>"},{"location":"opcodes/times/#performance","title":"Performance","text":"<p>Time in seconds is available with times. This would return 0.5 after half a second.</p> <p>times can both produce a k-rate variable for output. There are no input parameters.</p> <p>times can also operate at the start of the instance of the instrument. It produces an i-rate variable (starting with i or gi) as its output.</p>"},{"location":"opcodes/times/#examples","title":"Examples","text":"<p>Here is an example of the times opcode. It uses the file times_complex.csd.</p> Example of the times opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too \n; For Non-realtime ouput leave only the line below: \n; -o times_complex.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n;by joachim heintz and rory walsh \nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs = 1 \n\ngiWave   ftgen      0, 0, 1024, 10, 1, .5, .25 \n\ninstr again \n\ninstance =          p4 \n ;reset the duration of this instance \niDur     rnd31      5, 3                                ;shorter values are more probable \niDur     =          abs(iDur) + 0.2 \np3       =          iDur \n ;trigger the effect instrument of this instance \n         event_i    \"i\", \"fx_processor\", 0, iDur, instance \n ;print the status quo \nkTime    times \n         prints     \"instance = %d, start = %f, duration = %f\\n\", instance, i(kTime), iDur \n ;make sound \niamp     active     1                                   ;scale amplitudes \niOct     random     5, 10                               ;find pitch \naEnv     transeg    0, 0.02, 0, 1/iamp, p3-0.02, -6, 0  ;output envelope \naSend    poscil     aEnv, cpsoct(iOct), giWave          ;audio signal \n ;send signal to effect instrument \nSbus     sprintf    \"audio_%d\", instance                ;create unique software bus \n         chnset     aSend/2, Sbus                       ;send audio on this bus \n ;get the last k-cycle of this instance and trigger the successor in it \nkLast    release \n         schedkwhen kLast, 0, 0, \"again\", 0, 1, instance+1 \nendin \n\ninstr fx_processor \n ;apply feedback delay to the above instrument \niwhich    =         p4                                  ;receive instance number ... \nSbus      sprintf   \"audio_%d\", iwhich                  ; ... and related software bus \naudio     chnget    Sbus                                ;receive audio on this bus \nirvbtim   random    1, 5                                ;find reverb time \np3        =         p3+irvbtim                          ;adjust instrument duration \niltptmL   random    .1, .5                              ;find looptime left ... \niltptmR   random    .1, .5                              ;...and right \nipan      random    0, 1                                ; pan and ... \nimix      random    0, 1                                ;... mix audio \naL,aR     pan2      audio, ipan                         ;create stereo \nawetL     comb      aL, irvbtim, iltptmL                ;comb filter \nawetR     comb      aR, irvbtim, iltptmR \naoutL     ntrpol    aL, awetL, imix                     ;wet-dry mix \naoutR     ntrpol    aR, awetR, imix \n          outs      aoutL/2, aoutR/2 \nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \ni \"again\" 0 1 1 \n\ne 3600 \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>new alloc for instr again:\ninstance = 1, start = 0.000000, duration = 0.650439\nnew alloc for instr fx_processor:\ninstance = 2, start = 0.650884, duration = 0.411043\nnew alloc for instr fx_processor:\ninstance = 3, start = 1.061587, duration = 0.231085\nnew alloc for instr fx_processor:\ninstance = 4, start = 1.292336, duration = 0.543473\nnew alloc for instr fx_processor:\ninstance = 5, start = 1.835828, duration = 1.777097\n</code></pre>"},{"location":"opcodes/times/#see-also","title":"See also","text":"<p>Time Reading</p>"},{"location":"opcodes/times/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/timout/","title":"Timout","text":""},{"location":"opcodes/timout/#timout","title":"timout","text":"<p>Conditional branch during p-time depending on elapsed note time.</p> <p>istrt and idur specify time in seconds. The branch to label will become effective at time istrt, and will remain so for just idur seconds. Note that timout can be reinitialized for multiple activation within a single note (see example under reinit).</p>"},{"location":"opcodes/timout/#syntax","title":"Syntax","text":"<pre><code>timout istrt, idur, label\n</code></pre> <p>where label is in the same instrument block and is not an expression.</p>"},{"location":"opcodes/timout/#examples","title":"Examples","text":"<p>Here is an example of the timout opcode. It uses the file timout.csd.</p> Example of the timout opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o timout.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nindx = 0\nitim = p4                               ;change time for one step\n\nclock: \n   timout 0, itim, time\n   reinit clock\n\ntime:\n   itmp table indx, 2, 0, 0, 1\n   if itmp == 1 then\n   print itmp\n   event_i \"i\",2, 0, .1                 ;event has duration of .1 second\nendif\nindx = indx+1\n\nendin\n\ninstr 2 ;play it\n\nkenv transeg 0.01, p3*0.25, 1, 1, p3*0.75, .5, 0.01\nasig oscili kenv*.4, 400, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 1024 10 1 ;sine\nf 2 0 16 2 1 0 0 1 0 1 0 1 0 1 0 0 0 0 0 0 ;the rythm table\n\ni1 0 10 .1\ni1 + 10 .05\ni1 + 10 .01\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/timout/#see-also","title":"See also","text":"<p>Program Flow Control</p>"},{"location":"opcodes/tival/","title":"Tival","text":""},{"location":"opcodes/tival/#tival","title":"tival","text":"<p>Puts the value of the instrument's internal \u201ctie-in\u201d flag into the named i-rate variable.</p>"},{"location":"opcodes/tival/#syntax","title":"Syntax","text":"<pre><code>ir tival\n</code></pre>"},{"location":"opcodes/tival/#initialization","title":"Initialization","text":"<p>Puts the value of the instrument's internal \u201ctie-in\u201d flag into the named i-rate variable. Assigns 1 if this note has been \u201ctied\u201d onto a previously held note (see i statement); assigns 0 if no tie actually took place. (See also tigoto.)</p>"},{"location":"opcodes/tival/#examples","title":"Examples","text":"<p>Here is an example of the tival opcode. It uses the file tival.csd.</p> Example of the tival opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tival.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2\n0dbfs  = 1 \n\ninstr 1\n\nidur  = abs(p3)                         ;make p3 positive even if p3 is negative in score\nitiv  tival\ni1    = -1                              ;assume this is tied note, so keep fase of oscili\n      tigoto slur                       ;no reinitialisation on tied notes\ni1    = 0                               ;first note, so reset phase\naatt  line p4, idur, 0                  ;primary envelope\n\nslur:\n      if itiv==0 kgoto note             ;no expression on first and second note\naslur linseg 0, idur*.3, p4, idur*.7, 0 ;envelope for slurred note\naatt  = aatt + aslur\n\nnote:\nasig  oscili aatt, p5, 1, i1\n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1  ;sine wave\n\ni1  0    -5  .8  451    ;p3 = 5 seconds\ni1  1.5 -1.5 .1  512 \ni1  3    2   .7  440    ;3 notes together--&gt; duration = 5 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical examples featuring the tival opcode: TivalNstrnum_Yi.csd by Steven Yi.</p>"},{"location":"opcodes/tival/#see-also","title":"See also","text":"<p>Initialization and Reinitialization</p> <p>More on this opcode: http://www.csoundjournal.com/2005fall/tiedNotes.html, written by Steven Yi</p>"},{"location":"opcodes/tlineto/","title":"Tlineto","text":""},{"location":"opcodes/tlineto/#tlineto","title":"tlineto","text":"<p>Generate glissandos starting from a control signal with a trigger.</p>"},{"location":"opcodes/tlineto/#syntax","title":"Syntax","text":"<pre><code>kres tlineto ksig, ktime, ktrig\n</code></pre>"},{"location":"opcodes/tlineto/#performance","title":"Performance","text":"<p>kres -- Output signal.</p> <p>ksig -- Input signal.</p> <p>ktime -- Time length of glissando in seconds.</p> <p>ktrig -- Trigger signal.</p> <p>tlineto is similar to lineto but can be applied to any kind of signal (not only stepped signals) without producing discontinuities.  Last value of each segment is sampled and held from input signal each time ktrig value is set to a nonzero value. Normally ktrig signal consists of a sequence of zeroes (see trigger opcode).</p> <p>The effect of glissando is quite different from port. Since in these cases, the lines are straight. Also the context of usage is different.</p>"},{"location":"opcodes/tlineto/#examples","title":"Examples","text":"<p>Here is an example of the tlineto opcode. It uses the file tlineto.csd.</p> Example of the tlineto opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tlineto.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\n\nkmtr lfo 1, .5, 1                       ;produce trigger signal                 \nktr  trigger kmtr, .5, 0                ;with triangle wave\n\nktime = p4                              \nkfreq randh 1000, 3, .2, 0, 500         ;generate random values\nkfreq tlineto kfreq, ktime, ktr         ;different glissando times\naout  poscil .4, kfreq, giSine\n      outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10 .2     ;short glissando\ni 1 11 10 .8    ;longer glissande\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tlineto/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/tlineto/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.13</p>"},{"location":"opcodes/tone/","title":"Tone","text":""},{"location":"opcodes/tone/#tone","title":"tone","text":"<p>A first-order recursive low-pass filter with variable frequency response.</p> <p>tone is a 1 term IIR filter. Its formula is:</p> <p>y<sub>n</sub> = c1 * x<sub>n</sub> + c2 * y<sub>n-1</sub></p> <p>where</p> <ul> <li>b  = 2 - cos(2 \u03c0 hp/sr);</li> <li>c2 = b - sqrt(b<sup>2</sup> - 1.0)</li> <li>c1 = 1 - c2</li> </ul>"},{"location":"opcodes/tone/#syntax","title":"Syntax","text":"<pre><code>ares tone asig, khp [, iskip]\n</code></pre>"},{"location":"opcodes/tone/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/tone/#performance","title":"Performance","text":"<p>ares -- the output audio signal.</p> <p>asig -- the input audio signal.</p> <p>khp --  the response curve's half-power point, in Hertz. Half power is defined as peak power / root 2.</p> <p>tone implements a first-order recursive low-pass filter in which the variable khp (in Hz) determines the response curve's half-power point. Half power is defined as peak power / root 2.</p>"},{"location":"opcodes/tone/#examples","title":"Examples","text":"<p>Here is an example of the tone opcode. It uses the file tone.csd.</p> Example of the tone opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tone.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1\n     outs asig, asig\nendin\n\ninstr 2\n\nkton line 10000, p3, 0          ;all the way down to 0 Hz\nasig diskin2 \"drumsMlp.wav\", 1\nasig tone asig, kton            ;half-power point at 500 Hz\n     outs asig, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 2 2\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tone/#see-also","title":"See also","text":"<p>Standard filters: Low-pass filters</p>"},{"location":"opcodes/tonek/","title":"Tonek","text":""},{"location":"opcodes/tonek/#tonek","title":"tonek","text":"<p>A first-order recursive low-pass filter with variable frequency response.</p>"},{"location":"opcodes/tonek/#syntax","title":"Syntax","text":"<pre><code>kres tonek ksig, khp [, iskip]\n</code></pre>"},{"location":"opcodes/tonek/#initialization","title":"Initialization","text":"<p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/tonek/#performance","title":"Performance","text":"<p>kres -- the output signal at control-rate.</p> <p>ksig -- the input signal at control-rate.</p> <p>khp --  the response curve's half-power point, in Hertz. Half power is defined as peak power / root 2.</p> <p>tonek is like tone except its output is at control-rate rather than audio rate.</p>"},{"location":"opcodes/tonek/#examples","title":"Examples","text":"<p>Here is an example of the tonek opcode. It uses the file tonek.csd.</p> Example of the tonek opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tonek.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisin ftgen 0, 0, 2^10, 10, 1\n\ninstr 1\n\nksig    randomh 400, 1800, 150\naout    poscil  .2, 100+ksig, gisin\n        outs    aout, aout\nendin\n\ninstr 2\n\nksig    randomh 400, 1800, 150\nkhp     line    1, p3, 100      ;vary high-pass\nksig    tonek   ksig, khp\naout    poscil  .2, 100+ksig, gisin\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\ni 2 5.5 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tonek/#see-also","title":"See also","text":"<p>Standard Filters: Control signal filters</p>"},{"location":"opcodes/tonek/#credits","title":"Credits","text":"<p>Author: Robin Whittle Australia May 1997</p>"},{"location":"opcodes/tonex/","title":"Tonex","text":""},{"location":"opcodes/tonex/#tonex","title":"tonex","text":"<p>Emulates a stack of filters using the tone opcode.</p> <p>tonex is equivalent to a filter consisting of more layers of tone with the same arguments, serially connected. Using a stack of a larger number of filters allows a sharper cutoff. They are faster than using a larger number instances in a Csound orchestra of the old opcodes, because only one initialization and k- cycle are needed at time and the audio loop falls entirely inside the cache memory of processor.</p>"},{"location":"opcodes/tonex/#syntax","title":"Syntax","text":"<pre><code>ares tonex  asig, khp [, inumlayer] [, iskip]\nares tonex  asig, ahp [, inumlayer] [, iskip]\n</code></pre>"},{"location":"opcodes/tonex/#initialization","title":"Initialization","text":"<p>inumlayer (optional) -- number of elements in the filter stack. Default value is 4.</p> <p>iskip (optional, default=0) -- initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant. A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/tonex/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>khp/ahp -- the response curve's half-power point. Half power is defined as peak power / root 2.</p>"},{"location":"opcodes/tonex/#examples","title":"Examples","text":"<p>Here is an example of the tonex opcode. It uses the file tonex.csd.</p> Example of the tonex opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o tonex.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1\n     outs asig, asig\nendin\n\ninstr 2\n\nkton line 10000, p3, 0          ;all the way down to 0 Hz\nasig diskin2 \"drumsMlp.wav\", 1\nasig tonex asig, kton, 8        ;8 filters\n     outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2\ni 2 3 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tonex/#see-also","title":"See also","text":"<p>Standard filters: Low-pass filters</p>"},{"location":"opcodes/tonex/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado (adapted by John ffitch) Italy</p> <p>New in Csound version 3.49</p> <p>Audio rate parameters introduced in version 6.02</p> <p>October 2013.</p>"},{"location":"opcodes/trandom/","title":"Trandom","text":""},{"location":"opcodes/trandom/#trandom","title":"trandom","text":"<p>Generates a controlled pseudo-random number series between min and max values at k-rate whenever the trigger parameter is different to 0.</p>"},{"location":"opcodes/trandom/#syntax","title":"Syntax","text":"<pre><code>kout trandom ktrig, kmin, kmax\n</code></pre>"},{"location":"opcodes/trandom/#performance","title":"Performance","text":"<p>ktrig -- trigger opcode produces a new random number whenever this value is not 0.</p> <p>kmin -- minimum range limit</p> <p>kmax -- maximum range limit</p> <p>trandom is almost identical to random opcode, except trandom updates its output with a new random value only when the ktrig argument is triggered (i.e. whenever it is not zero).</p>"},{"location":"opcodes/trandom/#examples","title":"Examples","text":"<p>Here is an example of the trandom opcode. It uses the file trandom.csd.</p> Example of the trandom opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o trandom.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed 0                          ; every run time different values       \n\ninstr 1 \n\nkmin init 0                     ;random number between 0 and 220\nkmax init 220\nktrig = p4\nk1   trandom ktrig, kmin, kmax\n     printk2 k1                 ;print when k1 changes\nasig poscil .4, 220+k1, 1       ;if triggered, add random values to frequency\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1\n\ni 1 0 2 0       ;not triggered\ni 1 + 2 1       ;triggered\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trandom/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/trandom/#credits","title":"Credits","text":"<p>Written by Gabriel Maldonado.</p> <p>New in Csound 5.06</p>"},{"location":"opcodes/transeg/","title":"Transeg","text":""},{"location":"opcodes/transeg/#transeg","title":"transeg","text":"<p>Constructs a user-definable envelope.</p>"},{"location":"opcodes/transeg/#syntax","title":"Syntax","text":"<pre><code>ares transeg ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\nkres transeg ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\n</code></pre>"},{"location":"opcodes/transeg/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after idur seconds.</p> <p>idur -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2,... idurx etc. -- duration in seconds of segment</p> <p>itype, itype2, etc. -- if 0, a straight line is produced. If non-zero, then transeg creates the following curve, for n steps:</p> <pre><code>ibeg + (ivalue - ibeg) * (1 - exp( i*itype/(n-1) )) / (1 - exp(itype))\n</code></pre>"},{"location":"opcodes/transeg/#performance","title":"Performance","text":"<p>If itype &gt; 0, there is a slowly rising (concave) or slowly decaying (convex) curve, while if itype &lt; 0, the curve is fast rising (convex) or fast decaying (concave). See also GEN16.</p>"},{"location":"opcodes/transeg/#examples","title":"Examples","text":"<p>Here is an example of the transeg opcode. It uses the file transeg.csd. The example produces the following output:</p> Output of the transeg example. Example of the transeg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o transeg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n\n0dbfs = 1\n\ninstr 1\n;p4 and p5 determine the type of curve for each\n;section of the envelope\nkenv transeg 0.01, p3*0.25, p4, 1, p3*0.75, p5, 0.01\na1 oscil kenv, 440, 1\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2 2 2\ni 1 + . 5 5\ni 1 + . 1 1\ni 1 + . 0 0\ni 1 + . -2 -2\ni 1 + . -2 2\ni 1 + . 2 -2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/transeg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/transeg/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK October 2000</p> <p>New in Csound version 4.09</p> <p>Thanks goes to Matt Gerassimoff for pointing out the correct command syntax.</p>"},{"location":"opcodes/transegb/","title":"Transegb","text":""},{"location":"opcodes/transegb/#transegb","title":"transegb","text":"<p>Constructs a user-definable envelope in absolute time.</p>"},{"location":"opcodes/transegb/#syntax","title":"Syntax","text":"<pre><code>ares transegb ia, itim, itype, ib [, itim2] [, itype] [, ic] ...\nkres transegb ia, itim, itype, ib [, itim2] [, itype] [, ic] ...\n</code></pre>"},{"location":"opcodes/transegb/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after itim seconds.</p> <p>itim -- time in seconds of end of first segment.</p> <p>itim2,... itimx etc. -- time in seconds at the end of the segment.</p> <p>itype, itype2, etc. -- if 0, a straight line is produced. If non-zero, then transegb creates the following curve, for n steps:</p> <pre><code>ibeg + (ivalue - ibeg) * (1 - exp( i*itype/(n-1) )) / (1 - exp(itype))\n</code></pre>"},{"location":"opcodes/transegb/#performance","title":"Performance","text":"<p>If itype &gt; 0, there is a slowly rising (concave) or slowly decaying (convex) curve, while if itype &lt; 0, the curve is fast rising (convex) or fast decaying (concave). See also GEN16.</p>"},{"location":"opcodes/transegb/#examples","title":"Examples","text":"<p>Here is an example of the transegb opcode. It uses the file transegb.csd. The example produces the following output:</p> Output of the transegb example. Example of the transegb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o transeg.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n\n0dbfs = 1\n\ninstr 1\n;p4 and p5 determine the type of curve for each\n;section of the envelope\nkenv transegb 0.01, p3*0.25, p4, 1, p3, p5, 0.01\na1 oscil kenv, 440, 1\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\ni 1 0 2 2 2\ni 1 + . 5 5\ni 1 + . 1 1\ni 1 + . 0 0\ni 1 + . -2 -2\ni 1 + . -2 2\ni 1 + . 2 -2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/transegb/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/transegb/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK June 2011</p> <p>New in Csound version 5.14</p>"},{"location":"opcodes/transegr/","title":"Transegr","text":""},{"location":"opcodes/transegr/#transegr","title":"transegr","text":"<p>Constructs a user-definable envelope with extended release segment.</p> <p>It is the same as transeg, with an extended release segment.</p>"},{"location":"opcodes/transegr/#syntax","title":"Syntax","text":"<pre><code>ares transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\nkres transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...\n</code></pre>"},{"location":"opcodes/transegr/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after idur seconds.</p> <p>idur -- duration in seconds of first segment. A zero or negative value will cause all initialization to be skipped.</p> <p>idur2,... idurx etc. -- duration in seconds of segment</p> <p>itype, itype2, etc. -- if 0, a straight line is produced. If non-zero, then transegr creates the following curve, for n steps:</p> <pre><code>ibeg + (ivalue - ibeg) * (1 - exp( i*itype/(n-1) )) / (1 - exp(itype))\n</code></pre>"},{"location":"opcodes/transegr/#performance","title":"Performance","text":"<p>If itype &gt; 0, there is a slowly rising (concave) or slowly decaying (convex) curve, while if itype &lt; 0, the curve is fast rising (convex) or fast decaying (concave). See also GEN16.</p> <p>This opcode is the same as of transeg with an additional release segment triggered by a MIDI noteoff event, a negative p1 note event in the score or a turnoff2 opcode.</p>"},{"location":"opcodes/transegr/#examples","title":"Examples","text":"<p>Here is an example of the transegr opcode. It uses the file transegr.csd.</p> Example of the transegr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -+rtmidi=virtual -M0  ;;;realtime audio out and realtime midi in\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o transegr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nicps cpsmidi             \niamp ampmidi .2  \n;             st,dur1,typ1,val,dur2,typ2,end                     \nkenv transegr 0,  .2,  2,  .5,  1, - 3,   0\nasig pluck kenv*iamp, icps, icps, 1, 1   \n     outs asig, asig\n\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1  ;sine\n\nf0 30   ;runs 30 seconds\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/transegr/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/transegr/#credits","title":"Credits","text":"<p>Author: John ffitch january 2010</p> <p>New in Csound version 5.12</p>"},{"location":"opcodes/trigexpseg/","title":"Trigexpseg","text":""},{"location":"opcodes/trigexpseg/#trigexpseg","title":"trigexpseg","text":"<p>Triggers a series of exponential segments between specified points.</p>"},{"location":"opcodes/trigexpseg/#syntax","title":"Syntax","text":"<pre><code>ares trigexpseg kTrig, ia, idur1, ib [, idur2] [, ic] [...]\nkres trigexpseg kTrig, ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/trigexpseg/#initialization","title":"Initialization","text":"<p>ia -- starting value. Zero is illegal for exponentials.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc. For exponentials, must be non-zero and must agree in sign with ia.</p> <p>idur1 -- duration in seconds of first segment</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments.</p>"},{"location":"opcodes/trigexpseg/#performance","title":"Performance","text":"<p>kTrig -- trigger value. Will trigger playback of envelop when kTrig is equal 1</p> <p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern. Triggering the envelop while it is already playing will cause the envelop to jump to the start and play again. This might cause a pop or a click. It is best to wait till the envelope has ended before retriggering it.</p>"},{"location":"opcodes/trigexpseg/#examples","title":"Examples","text":"<p>Here is an example of the trigexpseg opcode. It uses the file trigexpseg.csd.</p> Example of the trigexpseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac   -d    -m0d     -M0  -+rtmidi=virtual ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o midiin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\naEnv expseg 0.0001, .2, 1, .2, .5, .2, .7, .2, 0.0001\na1 oscili aEnv, 400\nouts a1, a1\nendin\n\ninstr 2\nkTrig metro 1\naEnv trigexpseg kTrig, 0.0001, .2, 1, .2, .5, .2, .7, .2, 0.0001\na1 oscili aEnv, 400\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ni2 3 8\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trigexpseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/trigexpseg/#credits","title":"Credits","text":"<p>Author: Rory Walsh 2021</p>"},{"location":"opcodes/trigger/","title":"Trigger","text":""},{"location":"opcodes/trigger/#trigger","title":"trigger","text":"<p>Informs when a krate signal crosses a threshold.</p>"},{"location":"opcodes/trigger/#syntax","title":"Syntax","text":"<pre><code>kout trigger ksig, kthreshold, kmode\n</code></pre>"},{"location":"opcodes/trigger/#performance","title":"Performance","text":"<p>ksig -- input signal</p> <p>kthreshold -- trigger threshold</p> <p>kmode -- can be 0 , 1 or 2</p> <p>Normally trigger outputs zeroes: only each time ksig crosses kthreshold trigger outputs a 1. There are three modes of using ktrig:</p> <ul> <li>kmode = 0 - (down-up) ktrig outputs a 1 when current value of ksig is higher than kthreshold, while old value of ksig was equal to or lower than kthreshold.</li> <li>kmode = 1 - (up-down) ktrig outputs a 1 when current value of ksig is lower than kthreshold while old value of ksig was equal or higher than kthreshold.</li> <li>kmode = 2  - (both) ktrig outputs a 1 in both the two previous cases.</li> </ul>"},{"location":"opcodes/trigger/#examples","title":"Examples","text":"<p>Here is an example of the trigger opcode. It uses the file trigger.csd.</p> Example of the trigger opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o trigger.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkmtr lfo 1, 1, 1                        ;triangle wave\nkmode = p4\nktr  trigger kmtr, .5, kmode\n     printk2  ktr\n     schedkwhen ktr, 0, 3, 2, 0, .3\n\n\nendin\n\ninstr 2                                            \n\naenv linseg 0,p3*.1,1,p3*.3,1,p3*.6,0   ;envelope\na1   poscil .3*aenv, 1000, 1\n     outs a1, a1\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine \n\ni 1 0 3 0               ;down-up\ni 1 4 3 2               ;down-up &amp; up=down\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trigger/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/trigger/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/trighold/","title":"Trighold","text":""},{"location":"opcodes/trighold/#trighold","title":"trighold","text":"<p>Timed trigger, holds a value for a given time</p> <p>Plugin opcode in scugens.</p> <p>Port of Supercollider's Trig ugen. When a nonpositive to positive transition occurs at the input, trighold outputs the level of the triggering input for the specified duration, otherwise it outputs zero.</p>"},{"location":"opcodes/trighold/#syntax","title":"Syntax","text":"<pre><code>aout trighold ain, kdur\nkout trighold kin, kdur\n</code></pre>"},{"location":"opcodes/trighold/#initialization","title":"Initialization","text":"<p>initialvalue If given, sets the internal state. Default=0</p>"},{"location":"opcodes/trighold/#performance","title":"Performance","text":"<p>ain -- Trigger. Trigger can be any signal. A trigger happens when the signal changes from non-positive to positive.</p> <p>kdur -- Duration of the trigger in seconds.</p>"},{"location":"opcodes/trighold/#examples","title":"Examples","text":"<p>Here is an example of the trighold opcode. It uses the file trighold.csd.</p> Example of the trighold opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 2\n0dbfs = 1.0\n\ninstr 1\n  km = metro(1)\n  kt timeinsts\n  ktrig = trighold(km, 0.5)\n  printks \"t=%f  km=%f    ktrig=%f\\n\", 0.01, kt, km, ktrig\nendin\n\ninstr 2\n  am = upsamp(metro(1))\n  aenv = trighold(am, 0.5)\n  asig pinker\n  outch 1, asig*aenv\n  outch 2, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 10\ni 2 0 10\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trighold/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/trighold/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/triglinseg/","title":"Triglinseg","text":""},{"location":"opcodes/triglinseg/#triglinseg","title":"triglinseg","text":"<p>Triggers a series of line segments between specified points.</p>"},{"location":"opcodes/triglinseg/#syntax","title":"Syntax","text":"<pre><code>ares triglinseg kTrig, ia, idur1, ib [, idur2] [, ic] [...]\nkres triglinseg kTrig, ia, idur1, ib [, idur2] [, ic] [...]\n</code></pre>"},{"location":"opcodes/triglinseg/#initialization","title":"Initialization","text":"<p>ia -- starting value.</p> <p>ib, ic, etc. -- value after dur1 seconds, etc.</p> <p>idur1 -- duration in seconds of first segment.</p> <p>idur2, idur3, etc. -- duration in seconds of subsequent segments.</p>"},{"location":"opcodes/triglinseg/#performance","title":"Performance","text":"<p>kTrig -- trigger value. Will trigger playback of envelop when kTrig is equal 1</p> <p>These units generate control or audio signals whose values can pass through 2 or more specified points. The sum of dur values may or may not equal the instrument's performance time: a shorter performance will truncate the specified pattern. Triggering the envelop while it is already playing will cause the envelop to jump to the start and play again. This might cause a pop or a click. It is best to wait till the envelope has ended before retriggering it.</p>"},{"location":"opcodes/triglinseg/#examples","title":"Examples","text":"<p>Here is an example of the triglinseg opcode. It uses the file triglinseg.csd.</p> Example of the triglinseg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac   -d    -m0d     -M0  -+rtmidi=virtual ;;;RT audio I/O with MIDI in\n; For Non-realtime ouput leave only the line below:\n; -o midiin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\naEnv linseg 0, .2, 1, .2, .5, .2, .7, .2, 0\na1 oscili aEnv, 400\nouts a1, a1\nendin\n\ninstr 2\nkTrig metro 1\naEnv trigLinseg kTrig, 0, .2, 1, .2, .5, .2, .7, .2, 0\na1 oscili aEnv, 400\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 1\ni2 1 10\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/triglinseg/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/triglinseg/#credits","title":"Credits","text":"<p>Author: Rory Walsh 2021</p>"},{"location":"opcodes/trigphasor/","title":"Trigphasor","text":""},{"location":"opcodes/trigphasor/#trigphasor","title":"trigphasor","text":"<p>A resettable linear ramp between two levels.</p> <p>Plugin opcode in scugens.</p> <p>A resettable linear ramp between two levels (port of Supercollider's Phasor). trigphasor is a linear ramp between kstart and kend values. When its trigger input crosses from non-positive to positive, trigphasor's output will jump to its reset position (or to _kstart_if no reset value was given). Upon reaching the end of its ramp, trigphasor will wrap back to its start.</p>"},{"location":"opcodes/trigphasor/#syntax","title":"Syntax","text":"<pre><code>aindex trigphasor xtrig, xrate, kstart, kend [, kresetPos]\nkindex trigphasor xtrig, xrate, kstart, kend [, kresetPos]\n</code></pre>"},{"location":"opcodes/trigphasor/#performance","title":"Performance","text":"<p>xtrig -- trigger, whenever this crosses from non-positive to possitive</p> <p>xrate -- value added at each evaluation. When running at k-rate, this value is added at each cycle; at a-rate, this value is added per sample (ksmps per cycle).</p> <p>kstart, kend -- start and end values of the phasor</p> <p>xtrig -- trigger, whenever this crosses from non-positive to possitive</p> <p>kresetPos -- if specified, this value will be used to jump to after a trigger. Otherwise, a trigger will set the position back to kstart</p> <p>To generate a phasing signal from kstart to kend with a given period (duration of each cycle), the calculation would be:</p> <pre><code>rate = (end - start) / (period * sr)\n</code></pre> <p>In the case of phasor being used at k-rate, use kr instead of sr in the above formula.</p>"},{"location":"opcodes/trigphasor/#examples","title":"Examples","text":"<p>Here is an example of the trigphasor opcode. It uses the file trigphasor.csd.</p> Example of the trigphasor opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 64\nnchnls = 2\n0dbfs = 1.0\n\ngisnd ftgen 0, 0, 0, -1, \"finneganswake1.flac\", 0, 0, 0\n\ninstr 1\n  ; use trigphasor to read a soundfile\n  inumsamps = nsamp(gisnd)\n  irate = 1  ; play at original speed\n  ktrig metro 0.25\n  aphase trigphasor ktrig, irate, 0, inumsamps\n  asig table3 aphase, gisnd\n  asig *= linsegr:a(0, 0.01, 1, 0.01, 0)\n  outch 1, asig\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 20\nf0 3600\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trigphasor/#see-also","title":"See also","text":"<p>Phasors</p>"},{"location":"opcodes/trigphasor/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/trigseq/","title":"Trigseq","text":""},{"location":"opcodes/trigseq/#trigseq","title":"trigseq","text":"<p>Accepts a trigger signal as input and outputs a group of values.</p>"},{"location":"opcodes/trigseq/#syntax","title":"Syntax","text":"<pre><code>trigseq ktrig_in, kstart, kloop, kinitndx, kfn_values, kout1 [, kout2] [...]\n</code></pre>"},{"location":"opcodes/trigseq/#performance","title":"Performance","text":"<p>ktrig_in -- input trigger signal</p> <p>kstart -- start index of looped section</p> <p>kloop -- end index of looped section</p> <p>kinitndx -- initial index</p> <p> Note</p> <p>Although kinitndx is listed as k-rate, it is in fact accessed only at init-time. So if you are using a k-rate argument, it must be assigned with init.</p> <p>kfn_values -- number of a table containing a sequence of groups of values</p> <p>kout1 -- output values</p> <p>kout2, ... (optional) -- more output values</p> <p>This opcode handles timed-sequences of groups of values stored into a table.</p> <p>trigseq accepts a trigger signal (ktrig_in) as input and outputs group of values (contained in the kfn_values table) each time ktrig_in assumes a non-zero value. Each time a group of values is triggered, table pointer is advanced of a number of positions corresponding to the number of group-elements, in order to point to the next group of values. The number of elements of groups is determined by the number of koutX arguments.</p> <p>It is possible to start the sequence from a value different than the first, by assigning to kinitndx an index different than zero (which corresponds to the first value of the table). Normally the sequence is looped, and the start and end of loop can be adjusted by modifying kstart and kloop arguments. User must be sure that values of these arguments (as well as kinitndx) correspond to valid table numbers, otherwise Csound will crash because no range-checking is implemented.</p> <p>It is possible to disable loop (one-shot mode) by assigning the same value both to kstart and kloop arguments. In this case, the last read element will be the one corresponding to the value of such arguments. Table can be read backward by assigning a negative kloop value.</p> <p>trigseq is designed to be used together with seqtime or trigger opcodes.</p>"},{"location":"opcodes/trigseq/#examples","title":"Examples","text":"<p>Here is an example of the trigseq opcode. It uses the file trigseq.csd.</p> Example of the trigseq opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o trigseq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiTimes ftgen   91, 0, 128, -2,     1, 1/2, 1/2, 1/8, 1/8, 1/2,1/2, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16, 1/16; times\ngiSeq   ftgen   90, 0, 128, -2,     1, 2,     .5, 3,    .25, 4,      .10, 5,       .05, 6 ;** sequence amplitude and freq-ratio bins\n\n\ninstr   1\n\nicps    init    p4\niamp    init    .3\n\nkloop   init    p5\ninitndx init    p6\nkloop2  init    p7\ninitndx2 init   p8\nkdur    init    p9\niminTime init   p10\nimaxTime init   p11\nkampratio init  1\nkfreqratio init 1\n\nktime_unit expseg iminTime,p3/8,iminTime,p3* 3/4,imaxTime,p3/8,imaxTime\n\n\n;**ktrig        seqtime ktime_unit, kstart, kloop, initndx, kfn_times \n;ktrig  seqtime 1/ktime_unit, 0,      15, 0,      giTimes       \n\nktrig   metro   ktime_unit\n\n;****   trigseq ktrig_in,  kstart,  kloop, initndx,  kfn_values, kout1 [, kout2, kout3, ....,  koutN] \n        trigseq ktrig,  0,      kloop2,initndx2,   giSeq,      kampratio, kfreqratio\n\n;atrig  = ktrig*10000\n        schedkwhen ktrig, -1, -1, 3, 0, kdur, kampratio*iamp, kfreqratio*icps\n;       schedkwhen ktrig, -1, -1, 2, 0, ktrig, kampratio*iamp, kfreqratio*icps\n        endin\n\ninstr   2\n\nicps    init    p4\niamp    init .2 \n\nkloop   init    p5\ninitndx init    p6\nkloop2  init    p7\ninitndx2 init   p8\nkdur    init    p9\niminTime init   p10\nimaxTime init   p11\nkampratio init  1\nkfreqratio init 1\n\nktime_unit expseg iminTime,p3/8,iminTime,p3* 3/4,imaxTime,p3/8,imaxTime\n\n\n;**ktrig        seqtime ktime_unit, kstart, kloop, initndx, kfn_times \nktrig   seqtime 1/ktime_unit, 0,      15, 0,      giTimes       \n\n;ktrig  metro   ktime_unit\n\n;****   trigseq ktrig_in,  kstart,  kloop, initndx,  kfn_values, kout1 [, kout2, kout3, ....,  koutN] \n        trigseq ktrig,      0,     kloop2, initndx2,   giSeq,    kampratio, kfreqratio\nprintk2 ktrig\n;atrig  = ktrig*10000\n;       schedkwhen ktrig, -1, -1, 2, 0, kdur, kampratio*iamp, kfreqratio*icps\n        schedkwhen ktrig, -1, -1, 3, 0, ktrig, kampratio*iamp, kfreqratio*icps\nendin\n\ninstr   3\n\nprint p3\nkenv    expseg   1.04, p3,.04\na1      foscili p4*a(kenv-0.04), p5,1,1,kenv*5, 2\n        outs    a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf2 0 8192 10 1\n\n;       icps    unused  unused  kloop2  initndx2 kdur iminTime  imaxTime\n\ns\n\ni1 0  6 100     0       0       5       0       .2      3       15\ni1 8  6 150     0       0       4       1       .1      4       30\ni1 16 6 200     0       0       5       3       .25     8       50  \ni1 24 6 300     0       0       3       0       .1      1       30  \n\ni2 32 6 100     0       0       5       0       .2      1       1\ni2 40 6 150     0       0       4       1       .1      .5      .5\ni2 48 6 200     0       0       5       3       .25     3       .5  \ni2 56 6 300     0       0       5       0       .1      1       8  \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trigseq/#see-also","title":"See also","text":"<p>Sensing and Control: Tempo and Sequencing</p>"},{"location":"opcodes/trigseq/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>November 2002. Added a note about the kinitndx parameter, thanks to Rasmus Ekman.</p> <p>January 2003. Thanks to a note from \u00d8yvind Brandtsegg, I corrected the credits.</p> <p>New in version 4.06</p>"},{"location":"opcodes/trim/","title":"Trim","text":""},{"location":"opcodes/trim/#trim","title":"trim","text":"<p>Adjust size of a one-dimensional array.</p>"},{"location":"opcodes/trim/#syntax","title":"Syntax","text":"<pre><code>trim_i iarray, ilen\ntrim xarray, klen\n</code></pre>"},{"location":"opcodes/trim/#performance","title":"Performance","text":"<p>iarray -- a one-dimensional irate array</p> <p>xarray -- a one-dimensional array</p> <p>klen -- desired length</p> <p>Makes the array the desired length, either truncating or padding with zero/Null values.</p>"},{"location":"opcodes/trim/#examples","title":"Examples","text":"<p>Here is an example of the trim opcode. It uses the file trim.csd.</p> Example of the trim opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n    kA1[]   fillarray       0, 1, 2, 3, 4, 5, 6, 7 ; &lt;-- 8 elements\n            printf          \"lenarray(kA1) before slicearray: %d\\n\", 1, lenarray:k(kA1)\n            kA1     slicearray      kA1, 1, 4 ; &lt;-- 4 elements\n            printf          \"lenarray(kA1) AFTER  slicearray: %d\\n\", 1, lenarray:k(kA1)\n            trim            kA1, 4\n            printks         \"kA1 after trim: { \", 0\n      kCnt    =               0\n\n    while (kCnt &lt; lenarray:k(kA1)) do\n                    printf  \"%d \", kCnt + 1, kA1[kCnt]\n            kCnt    +=      1\n     od\n\n            printks         \"}\\n\", 0\n            turnoff\nendin\n\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1  0 0.1\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/trim/#see-also","title":"See also","text":"<p>Array opcodes</p>"},{"location":"opcodes/trim/#credits","title":"Credits","text":"<p>Author: John ffitch 2018</p> <p>New in version 6.12</p>"},{"location":"opcodes/trirand/","title":"Trirand","text":""},{"location":"opcodes/trirand/#trirand","title":"trirand","text":"<p>Triangular distribution random number generator</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/trirand/#syntax","title":"Syntax","text":"<pre><code>ares trirand krange\nires trirand krange\nkres trirand krange\n</code></pre>"},{"location":"opcodes/trirand/#performance","title":"Performance","text":"<p>krange -- the range of the random numbers (-krange to +krange).</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/trirand/#examples","title":"Examples","text":"<p>Here is an example of the trirand opcode. It uses the file trirand.csd.</p> Example of the trirand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o trirand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; every run time same values\n\nktri    trirand 100\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nktri    trirand 100\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like this:</p> <pre><code>i   1 time     0.00067:    -4.97993\ni   1 time     0.20067:     1.20909\ni   1 time     0.40067:    17.45873\ni   1 time     0.60067:    52.55409\ni   1 time     0.80067:    -1.92888\ni   1 time     1.00000:   -11.01149\ni   1 time     1.20067:     9.79521\ni   1 time     1.40067:    26.98504\ni   1 time     1.60067:    24.67405\ni   1 time     1.80000:   -67.59846\ni   1 time     2.00000:    64.24861\nWARNING: Seeding from current time 521999639\ni   2 time     3.00067:     3.28969\ni   2 time     3.20067:    54.98986\ni   2 time     3.40067:   -33.84788\ni   2 time     3.60000:   -41.93523\ni   2 time     3.80067:    -6.61742\ni   2 time     4.00000:    39.67097\ni   2 time     4.20000:     2.95123\ni   2 time     4.40067:    45.59255\ni   2 time     4.60067:    16.57259\ni   2 time     4.80067:   -18.80273\ni   2 time     5.00000:    -2.01697\n</code></pre>"},{"location":"opcodes/trirand/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/trirand/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/turnoff/","title":"Turnoff","text":""},{"location":"opcodes/turnoff/#turnoff","title":"turnoff","text":"<p>Enables an instrument to turn itself off or to turn an instance of another instrument off.</p>"},{"location":"opcodes/turnoff/#syntax","title":"Syntax","text":"<pre><code>turnoff\nturnoff inst\nturnoff knst\n</code></pre>"},{"location":"opcodes/turnoff/#initialization","title":"Initialization","text":"<p>inst -- when used with an i-time parameter, this is the instance handle of an instrument to be turned off (obtained from the nstance opcode).</p>"},{"location":"opcodes/turnoff/#performance","title":"Performance","text":"<p>turnoff -- with no parameters this p-time statement enables an instrument to turn itself off. Whether of finite duration or \u201cheld\u201d, the note currently being performed by this instrument is immediately removed from the active note list. No other notes are affected.</p> <p>kinst -- when used with an k-time parameter, this is the instance handle of an instrument to be turned off (obtained from the nstance opcode).</p>"},{"location":"opcodes/turnoff/#examples","title":"Examples","text":"<p>The following example uses the turnoff opcode. It will cause a note to terminate when a control signal passes a certain threshold (here the Nyquist frequency). It uses the file turnoff.csd.</p> Example of the turnoff opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o turnoff.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  k1 expon 440, p3/10,880     ; begin gliss and continue\n  if k1 &lt; sr/2  kgoto contin  ; until Nyquist detected\n    turnoff  ; then quit\n\ncontin:\n  a1 oscil 10000, k1, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1: an ordinary sine wave.\nf 1 0 32768 10 1\n\n; Play Instrument #1 for 4 seconds.\ni 1 0 4\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/turnoff/#see-also","title":"See also","text":"<p>Duration Control Statements</p>"},{"location":"opcodes/turnoff2/","title":"Turnoff2","text":""},{"location":"opcodes/turnoff2/#turnoff2","title":"turnoff2","text":"<p>Turn off instance(s) of other instruments at performance time.</p>"},{"location":"opcodes/turnoff2/#syntax","title":"Syntax","text":"<pre><code>turnoff2 kinsno, kmode, krelease\nturnoff2_i insno, imode, irelease\n</code></pre>"},{"location":"opcodes/turnoff2/#initialization","title":"Initialization","text":"<p>insno -- instrument to be turned off (can be fractional) if zero or negative, no instrument is turned off</p> <p>imode -- sum of the following values:</p> <ul> <li>0, 1, or 2: turn off all instances (0), oldest only (1), or newest only (2)</li> <li>4: only turn off notes with exactly matching (fractional) instrument number, rather than ignoring fractional part</li> <li>8: only turn off notes with indefinite duration (p3 &lt; 0 or MIDI)</li> </ul> <p>irelease -- if non-zero, the turned off instances are allowed to release, otherwise are deactivated immediately (possibly resulting in clicks)</p>"},{"location":"opcodes/turnoff2/#performance","title":"Performance","text":"<p>kinsno -- instrument to be turned off (can be fractional) if zero or negative, no instrument is turned off</p> <p>kmode -- sum of the following values:</p> <ul> <li>0, 1, or 2: turn off all instances (0), oldest only (1), or newest only (2)</li> <li>4: only turn off notes with exactly matching (fractional) instrument number, rather than ignoring fractional part</li> <li>8: only turn off notes with indefinite duration (p3 &lt; 0 or MIDI)</li> </ul> <p>krelease -- if non-zero, the turned off instances are allowed to release, otherwise are deactivated immediately (possibly resulting in clicks)</p> <p> Note</p> <p>As a rule of thumb, you should turn off instruments with a higher instrument number than the one where turnoff is called, as doing otherwise might cause initialization issues.</p>"},{"location":"opcodes/turnoff2/#examples","title":"Examples","text":"<p>Here is an example of the turnoff2 opcode. It uses the file turnoff2.csd.</p> Example of the turnoff2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o turnoff2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      = 44100    ;samples per second for sound\nksmps   = 32\nnchnls  = 2\n0dbfs   = 1\n\n; example by Lou Cohen\n\ngisine    ftgen    1, 0, 131073, 9, 1, 1, 0                ;single sine tone\n\n;-----------------------------------------\ninstr 2 ;start\n    ktrigger        init        0\n    if (ktrigger = 0) then\n        kMultiple    =    1.1\n        kHz            =    440\n        kAmp            =    (0dbfs/10)\n;startup four instances of instrument 200\n        event    \"i\", 200, 0, 3000, kAmp, kHz\n        kAmp    =    kAmp * 0.75\n        kHz    =    kHz * kMultiple\n        event    \"i\", 200, 0, 3000, kAmp, kHz\n        kAmp    =    kAmp * 0.75\n        kHz    =    kHz * kMultiple\n        event    \"i\", 200, 0, 3000, kAmp, kHz\n        kAmp    =    kAmp * 0.75\n        kHz    =    kHz * kMultiple\n        event    \"i\", 200, 0, 3000, kAmp, kHz\n        kAmp    =    kAmp * 0.75\n        kHz    =    kHz * kMultiple\n        ktrigger        =    1\n    endif\nendin\n;---------------------------------------------\ninstr 3 ;after 10 seconds, turn off the instruments\n    ktrigger init 1\n   if (ktrigger==1) then\n        turnoff2 200, 1, 1       ;turn off must recently started instrument instance\n        kactive active 200       ;find out how many are still active\n        printk2 kactive          ;print mainly to show progress\n        turnoff2    200, 0, 1    ;turn off all the rest of the instruments\n        kactive    active 200    ;find out how many are still active\n        printk2    kactive, 10   ;print to show progress\nendif\nendin\n;----------------------------------------------------\ninstr 200 ;play the tone\nkEnv    linen    1, 0.1, p3, 0.1\nar      oscil    kEnv*p4, p5, 1\n        outs     ar, ar\n        print    p4, p5\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni2 0 0.1 \ni3 10 0.1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/turnoff2/#see-also","title":"See also","text":"<p>Duration Control Statements</p>"},{"location":"opcodes/turnoff2/#credits","title":"Credits","text":"<p>Author: Istvan Varga 2005</p> <p>New in Csound 5.00</p>"},{"location":"opcodes/turnoff3/","title":"Turnoff3","text":""},{"location":"opcodes/turnoff3/#turnoff3","title":"turnoff3","text":"<p>Turn off instance(s) of other instruments at performance time in the queue of scheduled events.</p>"},{"location":"opcodes/turnoff3/#syntax","title":"Syntax","text":"<pre><code>turnoff3 kinsno\n</code></pre>"},{"location":"opcodes/turnoff3/#performance","title":"Performance","text":"<p>kinsno -- instrument to be turned off (can be fractional) if zero or negative, no instrument is turned off</p>"},{"location":"opcodes/turnoff3/#examples","title":"Examples","text":"<p>The following example uses the turnoff3 opcode.</p> Example of the turnoff3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsInstruments&gt;\ninstr 1\n  print p2\n  turnoff3 1\n  schedule  1,6,0.1\n  endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 0.1\ni1 1 0.1\ni1 2 0.1\ni1 3 0.1\ni1 4 0.1\ni1 5 0.1\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/turnoff3/#see-also","title":"See also","text":"<p>Duration Control Statements</p>"},{"location":"opcodes/turnoff3/#credits","title":"Credits","text":"<p>Author: John ffitch 2020</p> <p>New in Csound 6.16</p>"},{"location":"opcodes/turnon/","title":"Turnon","text":""},{"location":"opcodes/turnon/#turnon","title":"turnon","text":"<p>Activate an instrument for an indefinite time.</p>"},{"location":"opcodes/turnon/#syntax","title":"Syntax","text":"<pre><code>turnon insnum [, itime]\n</code></pre>"},{"location":"opcodes/turnon/#initialization","title":"Initialization","text":"<p>insnum -- instrument number to be activated</p> <p>itime (optional, default=0) -- delay, in seconds, after which instrument insnum will be activated. Default is 0.</p>"},{"location":"opcodes/turnon/#performance","title":"Performance","text":"<p>turnon activates instrument insnum after a delay of itime seconds, or immediately if itime is not specified. Instrument is active until explicitly turned off. (See turnoff.)</p>"},{"location":"opcodes/turnon/#examples","title":"Examples","text":"<p>Here is an example of the turnon opcode. It uses the files turnon.csd.</p> Example of the turnon opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac ;;;realtime audio out\n;-iadc ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o turnon.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Stefano Cucchi 2020 and Richard Boulanger\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ngasend1 init 0\ngasend2 init 0\n\nturnon 100\nturnon 101\n\ninstr 1\n\nabar barmodel 2, 2, p4, 0.000001, 0.0103, 20, p5, p6, p7\nkenvelope expseg 1, p3, .01\nabar = abar * kenvelope * p8\n; NO local output\n\ngasend1 = gasend1 + abar*p8\ngasend2 = gasend2 + abar*p8\n\nendin\n\n\ninstr 2\n\nidenStart = p4\nkdensity expseg p4, p3, 0.001\napulse mpulse 1, kdensity\nkenvelope expseg 1, p3, .001\napulse = apulse * kenvelope * p5\n; NO local output\n\ngasend1 = gasend1 + apulse\ngasend2 = gasend2 + apulse\n\nendin\n\n\ninstr dry\n\nidryLeft = p4\nidryRight = p5\nkgate adsr .01,.01,1,0\nouts (gasend1*kgate) * p4, (gasend2*kgate) * p5\n\nendin\n\n\ninstr 100\n\naphaser phaser1 gasend1, 4700, 1000, -0.8\narevphaser reverb aphaser, 1.618\nouts arevphaser * 0.2, arevphaser * 0.2\nclear gasend1\n\nendin\n\n\ninstr 101\n\nafold fold gasend2, 26\nadelfoldL multitap afold, 0.62, 0.52, 1.19, 0.44\nadelfoldR multitap afold, 0.94, 0.64, 1.42, 0.54\nouts adelfoldL * 0.5, adelfoldR * 0.5\nclear gasend2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\n\ni2 0 6 .07  1\n\ni \"dry\" 0 2 .87 .2\n\ni1 3 4 10 0.13 300 0.3 0.8\n\ni2 7 5 .007  1\n\ni \"dry\" 7 3 .12 .86\n\ni1 11 9 09 0.09 400 0.23 0.78\n\ni2 15 9 .01 1\n\n\ni \"dry\" 15 12 .94 .09\n\n\ns\n\n\ni \"dry\" 0 26.9 .68 .48 ; lowered\n\ni 2 0.0 4 .07  1\ni 2 0.1 4 .02  1\n\ni 1 0.21 1 08 0.13 300 0.3 0.8 \ni 1 2 2 14 0.02 500 0.2 0.7 \n\ni 2 2 5 .06  0.8 ; lowered\ni 2 4 5 .05  0.7 ; lowered\ni 2 4 6 .01  0.6 ; lowered\n\n\ni 1 4.3 3 9 0.08 1145 0.1 0.5 ; lowered\ni 1 4.5 3 11 0.10 245 0.2 0.4 ; lowered\n\ni 1 8.00 7 08 0.11 125 0.1 0.6\ni 1 8.01 6 28 0.13 280 0.3 0.8\ni 1 8.02 5 39 0.02 600 0.2 0.7\ni 1 8.03 4 39 0.02 600 0.2 0.7\n\ni 2 8.24 18 .09 1\ni 2 8.75 11 .05 1\ni 2 8.99 4 .01 1\n\n\n\ni 1 18 9 8.1 0.12 105 0.12 0.56\ni 1 18.01 8 8.8 0.13 205 0.52 0.46\n\ni 1 18.02 7 8.2 0.15 745 0.42 0.26\ni 1 18.03 11 8.3 0.14 905 0.62 0.36\n\ni \"dry\" 25 .85 .32 .38\n\ni 2 25 5 .71 1\n\ni \"dry\" 27 .74 .62 .68\n\ni 2 27 6 .11 1\n\ni \"dry\" 32.3 .42 .32 .38\n\ni 2 32.3 14 .005  1\n\n\ni 1 36 13 9.9 0.233 333 0.23 0.63\ni 1 39 12 8.9 0.323 403 0.34 0.53\ni 1 42 10 7.8 0.123 283 0.42 0.73\n\ni 1 48.01 9 8.11 0.122 108 0.13 0.54\ni 1 48.03 8 8.82 0.135 208 0.50 0.44\ni 1 48.05 7 8.23 0.158 748 0.40 0.24\ni 1 48.08 11 8.35 0.147 908 0.60 0.34\n\ne 60 ; score extended to allow for reverb and multitap tails to ring out\n\n; keeping instr 100 and instr 101 \"turned on\" for 60 seconds\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/turnon/#see-also","title":"See also","text":"<p>Duration Control Statements</p>"},{"location":"opcodes/tvconv/","title":"Tvconv","text":""},{"location":"opcodes/tvconv/#tvconv","title":"tvconv","text":"<p>A time-varying convolution (FIR filter) opcode.</p> <p>An opcode that takes two incoming signals and interprets one of them as the coefficients of linear time-variable finite impulse response filter. This is implemented via direct convolution (for partition sizes of 1 sample) or DFT-based partitioned convolution. The signals can be 'frozen' (i.e. the filter coefficients are kept the same) at any point in time, at a-rate or k-rate.</p>"},{"location":"opcodes/tvconv/#syntax","title":"Syntax","text":"<pre><code>ares tvconv asig1, asig2, xfreez1, xfreez2, iparts, ifils\n</code></pre>"},{"location":"opcodes/tvconv/#initialization","title":"Initialization","text":"<p>iparts -- partition size, for sizes &gt; 1, a DFT-based partitioned convolution process is used. Otherwise a time-domain delay line FIR is implemented. Partition sizes &gt; 1 are rounded to the nearest power-of-two.</p> <p>ifils -- filter size. For partition sizes &gt; 1, filter sizes are rounded to the nearest power-of-two. With partition size = 1, since direct convolution is used, filters can be of any size.</p>"},{"location":"opcodes/tvconv/#performance","title":"Performance","text":"<p>ares -- audio output.</p> <p>asig1, asig2 -- audio inputs.</p> <p>xfreez1 -- freeze switch for asig1. Coefficients are only updated (ie. the signal is passing into the convolution) if xfreez1 &gt; 0. This input can take an audio or a k-rate signal, or a constant.</p> <p>xfreez2 -- freeze switch for asig2, similar to xfreez1 in operation.</p>"},{"location":"opcodes/tvconv/#examples","title":"Examples","text":"<p>Here is an example of the tvconv opcode. It uses the file tvconv.csd.</p> Example of the tvconv opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac \n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\n asig diskin \"fox.wav\",1,0,1\n air diskin \"drumsMlp.wav\",1,0,1\n air buthp air/0dbfs,1000\n k1 linseg 0,p3/3,0,0,1,2*p3/3,1\n a1 oscili k1, 0.5, 1\n a2 oscili k1, 0.6, 1\n asig tvconv asig,air,1-a2,1-a1,256,1024\n asig clip asig,1,0dbfs\n outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 1024 7 0 512 0 1 1 511 1\ni1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/tvconv/#see-also","title":"See also","text":"<p>Convolution and Morphing</p>"},{"location":"opcodes/tvconv/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini  2017</p> <p>New in version 6.09</p>"},{"location":"opcodes/unirand/","title":"Unirand","text":""},{"location":"opcodes/unirand/#unirand","title":"unirand","text":"<p>Uniform distribution random number generator (positive values only).</p> <p>This is an x-class noise generator.</p>"},{"location":"opcodes/unirand/#syntax","title":"Syntax","text":"<pre><code>ares unirand krange\nires unirand krange\nkres unirand krange\n</code></pre>"},{"location":"opcodes/unirand/#performance","title":"Performance","text":"<p>krange -- the range of the random numbers (0 - krange).</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/unirand/#examples","title":"Examples","text":"<p>Here is an example of the unirand opcode. It uses the file unirand.csd.</p> Example of the unirand opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o unirand.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; every run time same values\n\nktri    unirand 100\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nktri    unirand 100\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00067:    81.47237\ni   1 time     0.20067:    41.72671\ni   1 time     0.40067:     5.96189\ni   1 time     0.60067:    91.59912\ni   1 time     0.80067:    85.07127\ni   1 time     1.00000:    92.50948\ni   1 time     1.20067:    98.79347\ni   1 time     1.40067:    98.91449\ni   1 time     1.60067:    50.37808\ni   1 time     1.80000:    72.02497\ni   1 time     2.00000:    52.94362\n\nWARNING: Seeding from current time 4007444022\n\ni   2 time     3.00067:    91.86294\ni   2 time     3.20067:    94.68759\ni   2 time     3.40067:     1.05825\ni   2 time     3.60000:    78.57628\ni   2 time     3.80067:    27.67408\ni   2 time     4.00000:    76.46347\ni   2 time     4.20000:    77.10071\ni   2 time     4.40067:    34.28921\ni   2 time     4.60067:    37.72286\ni   2 time     4.80067:    54.96646\ni   2 time     5.00000:    11.67566\nB  3.000 ..  5.000 T  5.000 TT  5.000 M:  0.80000  0.80000\nScore finished in csoundPerform().\n</code></pre>"},{"location":"opcodes/unirand/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/unirand/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/until/","title":"Until","text":""},{"location":"opcodes/until/#until","title":"until","text":"<p>A syntactic looping construction.</p>"},{"location":"opcodes/until/#syntax","title":"Syntax","text":"<pre><code>until condition do\n... od\n</code></pre>"},{"location":"opcodes/until/#performance","title":"Performance","text":"<p>The statements between the do and od form the body of a loop which is obeyed until the conditional becomes true.</p>"},{"location":"opcodes/until/#examples","title":"Examples","text":"<p>Here is an example of the until construction. It uses the file until.csd.</p> Example of the until opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ifthen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\ninstr 1\nlab99:\nif p4&lt;0 goto lab100\n  p4 = p4-1\n  print p4\n  goto lab99\nlab100:\nendin\n\ninstr 2\n  until p4&lt;0 do\n    p4 = p4-1\n    print p4\n  od\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 1 1 4\ni 2 2 1 4\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>B  0.000 ..  1.000 T  1.000 TT  1.000 M:      0.0\nnew alloc for instr 1:\ninstr 1:  p4 = 3.000\ninstr 1:  p4 = 2.000\ninstr 1:  p4 = 1.000\ninstr 1:  p4 = 0.000\ninstr 1:  p4 = -1.000\nB  1.000 ..  2.000 T  2.000 TT  2.000 M:      0.0\nnew alloc for instr 2:\ninstr 2:  p4 = 3.000\ninstr 2:  p4 = 2.000\ninstr 2:  p4 = 1.000\ninstr 2:  p4 = 0.000\ninstr 2:  p4 = -1.000\nB  2.000 ..  3.000 T  3.000 TT  3.000 M:      0.0\n</code></pre>"},{"location":"opcodes/until/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p>"},{"location":"opcodes/until/#credits","title":"Credits","text":"<p>John ffitch.</p> <p>New in Csound version 5.14 with new parser</p>"},{"location":"opcodes/upsamp/","title":"Upsamp","text":""},{"location":"opcodes/upsamp/#upsamp","title":"upsamp","text":"<p>Modify a signal by up-sampling.</p>"},{"location":"opcodes/upsamp/#syntax","title":"Syntax","text":"<pre><code>ares upsamp ksig\n</code></pre>"},{"location":"opcodes/upsamp/#performance","title":"Performance","text":"<p>upsamp converts a control signal to an audio signal. It does it by simple repetition of the kval. upsamp is a slightly more efficient form of the assignment, asig = ksig.</p>"},{"location":"opcodes/upsamp/#examples","title":"Examples","text":"<p>Here is an example of the upsamp opcode. It uses the file upsamp.csd.</p> Example of the upsamp opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o upsamp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;;with code from Steven Cook / David Akbari, Menno Knevel and Joachim Heintz\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nseed      0\n\n  opcode Decimator, a, akk      ;UDO Sample rate / Bit depth reducer\n  ;see http://www.csounds.com/udo/displayOpcode.php?opcode_id=73\n         setksmps   1\nain, kbit, ksrate xin\n\nkbits    =        2^kbit                ;bit depth (1 to 16)\nkfold    =        (sr/ksrate)           ;sample rate\nkin      downsamp ain                   ;convert to kr\nkin      =        (kin+0dbfs)           ;add DC to avoid (-)\nkin      =        kin*(kbits/(0dbfs*2)) ;scale signal level\nkin      =        int(kin)              ;quantise\naout     upsamp   kin                   ;convert to sr\naout     =        aout*(2/kbits)-0dbfs  ;rescale and remove DC\na0ut     fold     aout, kfold           ;resample\n         xout     a0ut\n  endop\n\n\ninstr 1 ;avoid playing this too loud\n\nkbit     =        p4\nksr      =        44100\nasig     diskin   \"fox.wav\", 1\naout     Decimator asig, kbit, ksr\n         printks  \"bitrate = %d, \", 3, kbit\n         printks  \"with samplerate = %d\\\\n\", 3, ksr\n         outs     aout*.7, aout*.7\nendin\n\n\ninstr 2 ;moving randomly between different bit values (1 - 6)\n\nkbit     randomi  1, 6, .5, 1\nasig     diskin   \"fox.wav\", 1, 0, 1 ;loop play\naout     Decimator asig, kbit, 44100\n         printks  \"bitrate = %f\\n\", .3, kbit\n         outs     aout*.7, aout*.7\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0   3 16            ;sounds allright but\ni 1 +   3 5             ;it's getting worse\ni 1 +   3 2             ;and worse...\ni 2 9  22               ;or quality moves randomly\ne       \n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/upsamp/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/urandom/","title":"Urandom","text":""},{"location":"opcodes/urandom/#urandom","title":"urandom","text":"<p>Truly random opcodes with controllable range.</p> <p>Plugin opcode in urandom.</p> <p>These units are for Unix-like systems only and use /dev/urandom to construct Csound random values</p>"},{"location":"opcodes/urandom/#syntax","title":"Syntax","text":"<pre><code>ax urandom [imin, imax]\nix urandom [imin, imax]\nkx urandom [imin, imax]\n</code></pre>"},{"location":"opcodes/urandom/#initialization","title":"Initialization","text":"<p>ix -- i-rate output value.</p> <p>imin -- minimum value of range; defaults to -1.</p> <p>imax -- maximum value of range; defaults to +1.</p> <p> Notes</p> <p>The algorithm produces 2^64 different possible values which are scaled to fit the range requested.  The randomness comes form the usual Linux/OSX /dev/urandom method, and there is no guarantee that it will be truly random, but there is a good chance. It does not show any cycles.</p>"},{"location":"opcodes/urandom/#performance","title":"Performance","text":"<p>ax -- a-rate output value.</p> <p>kx -- k-rate output value.</p>"},{"location":"opcodes/urandom/#examples","title":"Examples","text":"<p>Here is an example of the urandom opcode at a-rate. It uses the file urandom.csd.</p> An example of the urandom opcode at a-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o urandom.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; Create random numbers at a-rate in the range -2 to 2\n\naur     urandom  -2, 2\nafreq1  =   aur * 500 + 100         ; Use the random numbers to choose a frequency.\nafreq2  =   aur * 500 + 200\na1 oscil .3, afreq1\na2 oscil .3, afreq2\nouts a1, a2\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example of the urandom opcode at k-rate. It uses the file urandom_krate.csd.</p> An example of the urandom opcode at k-rate.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac      ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o urandom_krate.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; Create random numbers at k-rate in the range -1 to 1 at krate\n\nk1 urandom                              ; with a uniform distribution.\nprintks \"k1=%f\\\\n\", 0.1, k1\nasig1    poscil.2, k1 * 500 + 100\nasig2    poscil.2, k1 * 500 + 200\nouts    asig1, asig2    \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>k1=0.229850\nk1=-0.077047\nk1=-0.199339\nk1=-0.620577\nk1=-0.119447\nk1=-0.596258\nk1=0.525800\nk1=-0.171583\nk1=-0.017196\nk1=-0.974613\nk1=-0.036276\n</code></pre>"},{"location":"opcodes/urandom/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/urandom/#credits","title":"Credits","text":"<p>Author: John ffitch</p> <p>New in version 5.13</p>"},{"location":"opcodes/urd/","title":"Urd","text":""},{"location":"opcodes/urd/#urd","title":"urd","text":"<p>A discrete user-defined-distribution random generator that can be used as a function.</p>"},{"location":"opcodes/urd/#syntax","title":"Syntax","text":"<pre><code>aout = urd(ktableNum)\niout = urd(itableNum)\nkout = urd(ktableNum)\n</code></pre>"},{"location":"opcodes/urd/#initialization","title":"Initialization","text":"<p>itableNum -- number of table containing the random-distribution function. Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2.</p>"},{"location":"opcodes/urd/#performance","title":"Performance","text":"<p>ktableNum -- number of table containing the random-distribution function. Such table is generated by the user. See GEN40, GEN41, and GEN42. The table length does not need to be a power of 2.</p> <p>urd is the same opcode as duserrnd, but can be used in function fashion.</p> <p>For a tutorial about random distribution histograms and functions see:</p> <ul> <li>D. Lorrain. \"A panoply of stochastic cannons\". In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ul>"},{"location":"opcodes/urd/#examples","title":"Examples","text":"<p>Here is an example of the urd opcode. It uses the file urd.csd.</p> Example of the urd opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o urd.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nktab  = 1                       ;ftable 1\nkurd  = urd(ktab) \nktrig metro 5                   ;triggers 5 times per second\nkres  samphold kurd, ktrig      ;sample and hold value of kurd\n      printk2 kres              ;print it\nasig  poscil .5, 220+kres, 2\n      outs asig, asig\nendin\n\ninstr 2\n\nseed 0  ;every run new values\n\nktab  = 1                       ;ftable 1\nkurd  = urd(ktab) \nktrig metro 5                   ;triggers 5 times per second\nkres  samphold kurd, ktrig      ;sample and hold value of kurd\n      printk2 kres              ;print it\nasig  poscil .5, 220+kres, 2\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 -20 -42  10 20 .3 100 200 .7 ;30% choose between 10 and 20 and 70% between 100 and 200\nf2 0 8192 10 1                    ;sine wave\n\ni 1 0 5\ni 2 6 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1   184.61538\ni1   130.76923\ni1   169.23077\ni1    12.00000\n.......\n\nWARNING: Seeding from current time 3751086165\n\ni2   138.46154\ni2    12.00000\ni2   123.07692\ni2   161.53846\ni2   123.07692\ni2   153.84615\n......\n</code></pre>"},{"location":"opcodes/urd/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/urd/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.16</p>"},{"location":"opcodes/vactrol/","title":"Vactrol","text":""},{"location":"opcodes/vactrol/#vactrol","title":"vactrol","text":"<p>Envelope follower unit generator emmulating a Perkin Elmer Vactrole VTL5C3/2.</p> <p>Plugin opcode in buchla</p>"},{"location":"opcodes/vactrol/#syntax","title":"Syntax","text":"<pre><code>ares vactrol asig [iup, idown]\n</code></pre> <p>Initialisation</p> <p>iup -- The rise time of the filter, which defaults to 20,</p> <p>idown -- The fall time of the filter, which defaults to 3000,</p>"},{"location":"opcodes/vactrol/#performance","title":"Performance","text":"<p>asig -- The signal from which to extract the envelope.</p>"},{"location":"opcodes/vactrol/#examples","title":"Examples","text":"<p>Here is an example of the vactrol opcode. It uses the file vactrol.csd.</p> Example of the vactrol opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n -odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n    nchnls = 2\n    0dbfs = 1\n\ninstr 1\n    a1 lfo     0.3, 1, 4\n    a2 vactrol a1\n    a3 oscili  2, 440\n       out     a1*a3,a2*a3\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n    i1 0 3\n    e\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This opcode can reduce zipper noise produced from complex envelope tracking as it smooths the transitions.</p>"},{"location":"opcodes/vactrol/#see-also","title":"See also","text":"<p>Sensing and Control: Envelope followers</p>"},{"location":"opcodes/vactrol/#credits","title":"Credits","text":"<p>Author: John ffitch after Julian Parker New in 6.04</p>"},{"location":"opcodes/vaget/","title":"Vaget","text":""},{"location":"opcodes/vaget/#vaget","title":"vaget","text":"<p>Access values of the current buffer of an a-rate variable by indexing.</p> <p>Useful for doing sample-by-sample manipulation at k-rate without using setksmps 1.</p> <p> Note</p> <p>Because this opcode does not do any bounds checking, the user must be careful not to try to read values past ksmps (the size of a buffer for an a-rate variable) by using index values greater than ksmps.</p> <p> Note</p> <p>In Csound6 this opcode does do bounds checking.</p>"},{"location":"opcodes/vaget/#syntax","title":"Syntax","text":"<pre><code>kval vaget kndx, avar\n</code></pre>"},{"location":"opcodes/vaget/#performance","title":"Performance","text":"<p>kval - value read from avar</p> <p>kndx - index of the sample to read from the current buffer of the given avar variable</p> <p>avar - a-rate variable to read from</p>"},{"location":"opcodes/vaget/#examples","title":"Examples","text":"<p>Here is an example of the vaget opcode. It uses the file vaget.csd.</p> Example of the vaget opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o avarget.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr=44100\nksmps=16\nnchnls=2\n\n        instr 1 ; Sqrt Signal\nifreq = (p4 &gt; 15 ? p4 : cpspch(p4))\niamp = ampdb(p5)\n\naout init 0\nksampnum init 0\n\nkenv    linseg 0, p3 * .5, 1, p3 * .5, 0\n\naout1   vco2    1, ifreq\naout2   vco2    .5, ifreq * 2\naout3   vco2    .2, ifreq * 4\n\naout    sum     aout1, aout2, aout3\n\n;Take Sqrt of signal, checking for negatives\nkcount = 0\n\nloopStart:\n\n        kval vaget kcount,aout\n\n        if (kval &gt; .0) then\n                kval = sqrt(kval)\n        elseif (kval &lt; 0) then\n                kval = sqrt(-kval) * -1\n        else\n                kval = 0\n        endif\n\n        vaset kval, kcount,aout\n\nloop_lt kcount, 1, ksmps, loopStart\n\naout = aout * kenv\n\naout    moogladder aout, 8000, .1\n\naout = aout * iamp\n\nouts aout, aout\n        endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni1      0.0     2 440 80\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vaget/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/vaget/#credits","title":"Credits","text":"<p>Author: Steven Yi</p> <p>New in version 5.04</p> <p>September 2006.</p>"},{"location":"opcodes/valpass/","title":"Valpass","text":""},{"location":"opcodes/valpass/#valpass","title":"valpass","text":"<p>Variably reverberates an input signal with a flat frequency response.</p>"},{"location":"opcodes/valpass/#syntax","title":"Syntax","text":"<pre><code>ares valpass asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]\n</code></pre>"},{"location":"opcodes/valpass/#initialization","title":"Initialization","text":"<p>imaxlpt -- maximum loop time for klpt</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p> <p>insmps (optional, default=0) -- delay amount, as a number of samples.</p>"},{"location":"opcodes/valpass/#performance","title":"Performance","text":"<p>krvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>xlpt -- variable loop time in seconds, same as ilpt in comb.  Loop time can be as large as imaxlpt.</p> <p>This filter reiterates input with an echo density determined by loop time xlpt. The attenuation rate is independent and is determined by krvt, the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude). Its output will begin to appear immediately.</p>"},{"location":"opcodes/valpass/#examples","title":"Examples","text":"<p>Here is an example of the valpass opcode. It uses the file valpass.csd.</p> Example of the valpass opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o valpass.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nkrvt = 1.5\nklpt line p4, p3, p5\nimaxlpt = .1\n\na1 diskin2 \"fox.wav\", 1\na1 valpass a1, krvt, klpt, imaxlpt\na2 valpass a1, krvt, klpt*.5, imaxlpt\n   outs a1, a2  \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5 .01 .2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Here is another example of the valpass opcode. It uses the file valpass-2.csd.</p> Second example of the valpass opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o valpass-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngiSine ftgen 0, 0, 65536, 10, 1                 ;sine wave\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1\nkrvt line 0.01, p3, p3                          ;reverb time\nadepth = p4                                     ;sine depth \nkrate = 0.3                                     ;sine rate (speed)\nadel oscil 0.5, krate, giSine                   ;delay time oscillator (LFO)\nadel = ((adel+0.5)*adepth)                      ;scale and offset LFO\naout valpass asig, krvt, adel*0.01, 0.5\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0  10 1\ni1 11 10 5      \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/valpass/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/valpass/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss University of Texas at Austin Austin, Texas USA January 2002</p>"},{"location":"opcodes/vaset/","title":"Vaset","text":""},{"location":"opcodes/vaset/#vaset","title":"vaset","text":"<p>Write values into the current buffer of an a-rate variable at the given index.</p> <p>Useful for doing sample-by-sample manipulation at k-rate without using setksmps 1.</p> <p> Note</p> <p>Because this opcode does not do any bounds checking, the user must be careful not to try to write values past ksmps (the size of a buffer for an a-rate variable) by using index values greater than ksmps.</p> <p> Note</p> <p>In Csound6 this opcode does do bounds checking.</p>"},{"location":"opcodes/vaset/#syntax","title":"Syntax","text":"<pre><code>vaset kval, kndx, avar\n</code></pre>"},{"location":"opcodes/vaset/#performance","title":"Performance","text":"<p>kval - value to write into avar</p> <p>kndx - index of the sample to write to the current buffer of the given avar variable</p> <p>avar - a-rate variable to write to</p>"},{"location":"opcodes/vaset/#examples","title":"Examples","text":"<p>Here is an example of the vaset opcode. It uses the file vaset.csd.</p> Example of the vaset opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o avarset.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr=44100\nksmps=1\nnchnls=2\n\n        instr 1 ; Sine Wave\nifreq = (p4 &gt; 15 ? p4 : cpspch(p4))\niamp = ampdb(p5)\n\nkenv adsr 0.1, 0.05, .9, 0.2\n\naout init 0\nksampnum init 0\n\nkcount = 0\n\niperiod = sr / ifreq\n\ni2pi = 3.14159 * 2\n\nloopStart:\n\nkphase = (ksampnum % iperiod) / iperiod\n\nknewval = sin(kphase * i2pi)\n\n        vaset knewval, kcount,aout\n\n        ksampnum = ksampnum + 1\n\nloop_lt kcount, 1, ksmps, loopStart\n\naout = aout * iamp * kenv\n\nouts aout, aout\n        endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni1      0.0     2 440 80\ne\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vaset/#see-also","title":"See also","text":"<p>Sample Level Operators</p>"},{"location":"opcodes/vaset/#credits","title":"Credits","text":"<p>Author: Steven Yi</p> <p>New in version 5.04</p> <p>September 2006.</p>"},{"location":"opcodes/vbap/","title":"Vbap","text":""},{"location":"opcodes/vbap/#vbap","title":"vbap","text":"<p>Distributes an audio signal among many channels, up to 64 in the first form, arbitrary in the second.</p>"},{"location":"opcodes/vbap/#syntax","title":"Syntax","text":"<pre><code>ar1[, ar2...] vbap asig, kazim [,kelev] [, kspread] [, ilayout]\narray[] vbap asig, kazim [,kelev] [, kspread] [, ilayout]\n</code></pre>"},{"location":"opcodes/vbap/#initialization","title":"Initialization","text":"<p>ilayout -- index of the speaker layout in the range 0-99, corresponding to a call to vbaplsinit.</p>"},{"location":"opcodes/vbap/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>vbap takes an input signal, asig and distributes it among the outputs, according to the controls kazim and kelev, and the configured loudspeaker placement.  If idim = 2, kelev is set to zero. The distribution is performed using Vector Base Amplitude Panning (VBAP - See reference).  VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap/#examples","title":"Examples","text":"<p>See the entry for vbap8 for an example of usage of the vbap opcodes.</p> <p>Here is an example of the vbap opcode. It uses the file vbap.csd.</p> Example of the vbap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbap.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1                    ;loop drumsMlp.wav\nkaz  line 0, p3, p4                                     ;come from right rear speaker &amp; \na1,a2,a3,a4 vbap  asig, 180, 100, kaz                   ;change spread of soundsource\n     printks \"spread of source = %d\\n\", 1, kaz          ;print spread value\n     outq a1,a2,a3,a4\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 12 100\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>spread of source = 0\nspread of source = 8\nspread of source = 17\nspread of source = 25\nspread of source = 33\nspread of source = 42\nspread of source = 50\nspread of source = 58\nspread of source = 67\nspread of source = 75\nspread of source = 83\nspread of source = 92\nspread of source = 100\n</code></pre>"},{"location":"opcodes/vbap/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000 Author: John ffitch July 2012, Sept 2013</p> <p>New in Csound Version 5.17.13.</p> <p>Array version new in Csound Version 6.01.</p>"},{"location":"opcodes/vbap16/","title":"Vbap16","text":""},{"location":"opcodes/vbap16/#vbap16","title":"vbap16","text":"<p>Distributes an audio signal among 16 channels.</p>"},{"location":"opcodes/vbap16/#syntax","title":"Syntax","text":"<pre><code>ar1, ..., ar16 vbap16 asig, kazim [, kelev] [, kspread]\n</code></pre>"},{"location":"opcodes/vbap16/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>vbap16 takes an input signal, asig, and distribute it among 16 outputs, according to the controls kazim and kelev, and the configured loudspeaker placement.  If idim = 2, kelev is set to zero. The distribution is performed using Vector Base Amplitude Panning (VBAP - See reference).  VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap16/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap16/#examples","title":"Examples","text":"<p>See the entry for vbap8 for an example of usage of the vbap opcodes.</p>"},{"location":"opcodes/vbap16/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap16/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07. Input parameters accept k-rate since Csound 5.09.</p>"},{"location":"opcodes/vbap16move/","title":"Vbap16move","text":""},{"location":"opcodes/vbap16move/#vbap16move","title":"vbap16move","text":"<p>Distribute an audio signal among 16 channels with moving virtual sources. Distribute an audio signal among 16 channels with moving virtual sources.</p>"},{"location":"opcodes/vbap16move/#syntax","title":"Syntax","text":"<pre><code>ar1, ..., ar16 vbap16move asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...]\n</code></pre>"},{"location":"opcodes/vbap16move/#initialization","title":"Initialization","text":"<p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases.</p>"},{"location":"opcodes/vbap16move/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>vbap16move allows the use of moving virtual sources. If ifldnum is positive, the fields represent directions of virtual sources and equal times, iazi1, [iele1,] iazi2, [iele2,], etc.  The position of the virtual source is interpolated between directions starting from the first direction and ending at the last. Each interval is interpolated in time that is fraction total_time / number_of_intervals of the duration of the sound event.</p> <p>If ifldnum is negative, the fields represent angular velocities and equal times. The first field is, however, the starting direction, iazi1, [iele1,] iazi_vel1, [iele_vel1,] iazi_vel2, [iele_vel2,] .... Each velocity is applied to the note that is fraction total_time / number_of_velocities of the duration of the sound event.  If the elevation of the virtual source becomes greater than 90 degrees or less than 0 degrees, the polarity of angular velocity is changed. Thus the elevational angular velocity produces a virtual source that moves up and down between 0 and 90 degrees.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap16move/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap16move/#examples","title":"Examples","text":"<p>See the entry for vbap8move for an example of usage of the vbapXmove opcodes.</p>"},{"location":"opcodes/vbap16move/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap16move/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/vbap4/","title":"Vbap4","text":""},{"location":"opcodes/vbap4/#vbap4","title":"vbap4","text":"<p>Distributes an audio signal among 4 channels.</p>"},{"location":"opcodes/vbap4/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4 vbap4 asig, kazim [, kelev] [, kspread]\n</code></pre>"},{"location":"opcodes/vbap4/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>vbap4 takes an input signal, asig and distributes it among 4 outputs, according to the controls kazim and kelev, and the configured loudspeaker placement.  If idim = 2, kelev is set to zero. The distribution is performed using Vector Base Amplitude Panning (VBAP - See reference).  VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap4/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap4/#examples","title":"Examples","text":"<p>See the entry for vbap8 for an example of usage of the vbap opcodes.</p> <p>Here is an example of the vbap4 opcode. It uses the file vbap4.csd.</p> Example of the vbap4 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbap4.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1                    ;loop drumsMlp.wav\nkaz  line 0, p3, p4                                     ;come from right rear speaker &amp; \na1,a2,a3,a4 vbap4  asig, 180, 100, kaz                  ;change spread of soundsource\n     printks \"spread of source = %d\\n\", 1, kaz          ;print spread value\n     outq a1,a2,a3,a4\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 12 100\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>spread of source = 0\nspread of source = 8\nspread of source = 17\nspread of source = 25\nspread of source = 33\nspread of source = 42\nspread of source = 50\nspread of source = 58\nspread of source = 67\nspread of source = 75\nspread of source = 83\nspread of source = 92\nspread of source = 100\n</code></pre>"},{"location":"opcodes/vbap4/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap4/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.06. Input parameters accept k-rate since Csund 5.09.</p>"},{"location":"opcodes/vbap4move/","title":"Vbap4move","text":""},{"location":"opcodes/vbap4move/#vbap4move","title":"vbap4move","text":"<p>Distributes an audio signal among 4 channels with moving virtual sources.</p>"},{"location":"opcodes/vbap4move/#syntax","title":"Syntax","text":"<pre><code>ar1, ar2, ar3, ar4 vbap4move asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...]\n</code></pre>"},{"location":"opcodes/vbap4move/#initialization","title":"Initialization","text":"<p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases (see below).</p>"},{"location":"opcodes/vbap4move/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>vbap4move allows the use of moving virtual sources. If ifldnum is positive, the fields represent directions of virtual sources and equal times, iazi1, [iele1,] iazi2, [iele2,], etc.  The position of the virtual source is interpolated between directions starting from the first direction and ending at the last. Each interval is interpolated in time that is fraction total_time / number_of_intervals of the duration of the sound event.</p> <p>If ifldnum is negative, the fields represent angular velocities and equal times. The first field is, however, the starting direction, iazi1, [iele1,] iazi_vel1, [iele_vel1,] iazi_vel2, [iele_vel2,] .... Each velocity is applied to the note that is fraction total_time / number_of_velocities of the duration of the sound event.  If the elevation of the virtual source becomes greater than 90 degrees or less than 0 degrees, the polarity of angular velocity is changed. Thus the elevational angular velocity produces a virtual source that moves up and down between 0 and 90 degrees.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap4move/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap4move/#examples","title":"Examples","text":"<p>See the entry for vbap8move for an example of usage of the vbapXmove opcodes.</p> <p>Here is an example of the vbap4move opcode. It uses the file vbap4move.csd.</p> Example of the vbap4move opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbap4move.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1            ;loop drumsMlp.wav\na1,a2,a3,a4 vbap4move  asig, p3, 1, 2, 310, 180 ;change movement of soundsource in\n     outq a1,a2,a3,a4                           ;the rear speakers\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vbap4move/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap4move/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/vbap8/","title":"Vbap8","text":""},{"location":"opcodes/vbap8/#vbap8","title":"vbap8","text":"<p>Distributes an audio signal among 8 channels.</p>"},{"location":"opcodes/vbap8/#syntax","title":"Syntax","text":"<pre><code>ar1, ..., ar8 vbap8 asig, kazim [, kelev] [, kspread]\n</code></pre>"},{"location":"opcodes/vbap8/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>vbap8 takes an input signal, asig, and distributes it among 8 outputs, according to the controls kazim and kelev, and the configured loudspeaker placement.  If idim = 2, kelev is set to zero. The distribution is performed using Vector Base Amplitude Panning (VBAP - See reference).  VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap8/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap8/#example","title":"Example","text":"<p>Here is a simple example of the vbap8 opcode. It uses the file vbap8.csd.</p> Example of the vbap8 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n;-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n-o vbap8.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n  sr       =          44100\n  kr       =           441\n  ksmps    =           100\n  nchnls   =             4\n  vbaplsinit          2, 8,  0, 45, 90, 135, 200, 245, 290, 315 \n\n          instr  1\n  asig    oscil       20000, 440, 1\n  a1,a2,a3,a4,a5,a6,a7,a8   vbap8   asig, p4, 0, 20 ;p4 = azimuth\n\n  ;render twice with alternate outq  statements\n  ;  to obtain two 4 channel .wav files:\n\n          outq        a1,a2,a3,a4\n  ;       outq        a5,a6,a7,a8\n; or use an 8-channel output for realtime output (set nchnls to 8):\n;        outo a1,a2,a3,a4,a5,a6,a7,a8\n          endin \n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1\n; Play Instrument #1 for one second.\n;          azimuth\ni 1 0 1      20\ni 1 + .      40\ni 1 + .      60\ni 1 + .      80\ni 1 + .      100\ni 1 + .      120\ni 1 + .      140\ni 1 + .      160\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vbap8/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap8/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07. Input parameters accept k-rate since Csund 5.09.</p>"},{"location":"opcodes/vbap8move/","title":"Vbap8move","text":""},{"location":"opcodes/vbap8move/#vbap8move","title":"vbap8move","text":"<p>Distributes an audio signal among 8 channels with moving virtual sources.</p>"},{"location":"opcodes/vbap8move/#syntax","title":"Syntax","text":"<pre><code>ar1, ..., ar8 vbap8move asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...]\n</code></pre>"},{"location":"opcodes/vbap8move/#initialization","title":"Initialization","text":"<p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases (see below).</p>"},{"location":"opcodes/vbap8move/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>vbap8move allows the use of moving virtual sources. If ifldnum is positive, the fields represent directions of virtual sources and equal times, iazi1, [iele1,] iazi2, [iele2,], etc.  The position of the virtual source is interpolated between directions starting from the first direction and ending at the last. Each interval is interpolated in time that is fraction total_time / number_of_intervals of the duration of the sound event.</p> <p>If ifldnum is negative, the fields represent angular velocities and equal times. The first field is, however, the starting direction, iazi1, [iele1,] iazi_vel1, [iele_vel1,] iazi_vel2, [iele_vel2,] .... Each velocity is applied to the note that is fraction total_time / number_of_velocities of the duration of the sound event.  If the elevation of the virtual source becomes greater than 90 degrees or less than 0 degrees, the polarity of angular velocity is changed. Thus the elevational angular velocity produces a virtual source that moves up and down between 0 and 90 degrees.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbap8move/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbap8move/#example","title":"Example","text":"<p>Here is a simple example of the vbap8move opcode. It uses the file vbap8move.csd.</p> Example of the vbap8move opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o vbap4move.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 48000\nksmps = 10\nnchnls = 8\n\n;Example by Hector Centeno 2007\n\nvbaplsinit    2, 8, 15, 65, 115, 165, 195, 245, 295, 345\n\n    instr 1\nifldnum = 9\nispread = 30\nidur = p3\n\n;; Generate a sound source\nkenv loopseg 10, 0, 0, 0, 0.5, 1, 10, 0\na1 pinkish 3000*kenv\n\n;; Move circling around once all the speakers\naout1, aout2, aout3, aout4, aout5, aout6, aout7, aout8 vbap8move a1, idur, ispread, ifldnum, 15, 65, 115, 165, 195, 245, 295, 345, 15\n\n;; Speaker mapping\naFL = aout8 ; Front Left\naFR = aout1 ; Front Right\naMFL = aout7 ; Mid Front Left\naMFR = aout2 ; Mid Front Right\naMBL = aout6 ; Mid Back Left\naMBR = aout3 ; Mid Back Right\naBL = aout5 ; Back Left\naBR = aout4 ; Back Right\n\nouto aFL, aFR, aMFL, aMFR, aMBL, aMBR, aBL, aBR\n\n    endin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 30\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vbap8move/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbap8move/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/vbapg/","title":"Vbapg","text":""},{"location":"opcodes/vbapg/#vbapg","title":"vbapg","text":"<p>Calculates the gains for a sound location for up to 64.</p>"},{"location":"opcodes/vbapg/#syntax","title":"Syntax","text":"<pre><code>k1[, k2...] vbapg kazim [,kelev] [, kspread] [, ilayout]\nkarray[] vbapg kazim [,kelev] [, kspread] [, ilayout]\n</code></pre>"},{"location":"opcodes/vbapg/#initialization","title":"Initialization","text":"<p>ilayout -- index of the speaker layout in the range 0-99, corresponding to a call to vbaplsinit.  The default value is 0.</p>"},{"location":"opcodes/vbapg/#performance","title":"Performance","text":"<p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>vbapg calculates the gains that an input signal would have between multiple speakers according to the controls kazim and kelev, and the configured loudspeaker placement ilayout.  If idim = 2, kelev is set to zero. The distribution is performed using Vector Base Amplitude Panning (VBAP - See reference).  VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbapg/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbapg/#examples","title":"Examples","text":"<p>Here is an example of the vbapg opcode. It uses the file vbapg.csd.</p> Example of the vbapg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbap4.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2.01, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1            ;loop drumsMlp.wav\nkaz  line 0, p3, p4                             ;come from right rear speaker &amp; \nk1,k2,k3,k4 vbapg  180, 100, kaz, 1             ;change spread of soundsource\n     printks \"spread of source = %d\\n\", 1, kaz  ;print spread value\n     outq asig*k1,asig*k2,asig*k3,asig*k4\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 12 100\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>spread of source = 0\nspread of source = 8\nspread of source = 17\nspread of source = 25\nspread of source = 33\nspread of source = 42\nspread of source = 50\nspread of source = 58\nspread of source = 67\nspread of source = 75\nspread of source = 83\nspread of source = 92\nspread of source = 100\n</code></pre>"},{"location":"opcodes/vbapg/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbapg/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000 Author: John ffitch July 2012, Sept 2013</p> <p>New in Csound Version 5.17.13.</p> <p>Array version new in Csound Version 6.01.</p>"},{"location":"opcodes/vbapgmove/","title":"Vbapgmove","text":""},{"location":"opcodes/vbapgmove/#vbapgmove","title":"vbapgmove","text":"<p>Calculates the gains for a sound location between multiple channels with moving virtual sources.</p>"},{"location":"opcodes/vbapgmove/#syntax","title":"Syntax","text":"<pre><code>kr1[, kr2...] vbapgmove idur, ispread, ifldnum, ifld1 [, ifld2] [...]\nkarray[] vbapgmove idur, ispread, ifldnum, ifld1 [, ifld2] [...]\n</code></pre>"},{"location":"opcodes/vbapgmove/#initialization","title":"Initialization","text":"<p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases (see below).</p>"},{"location":"opcodes/vbapgmove/#performance","title":"Performance","text":"<p>vbapgmove allows the use of moving virtual sources. If ifldnum is positive, the fields represent directions of virtual sources and equal times, iazi1, [iele1,] iazi2, [iele2,], etc.  The position of the virtual source is interpolated between directions starting from the first direction and ending at the last. Each interval is interpolated in time that is fraction total_time / number_of_intervals of the duration of the sound event.</p> <p>If ifldnum is negative, the fields represent angular velocities and equal times. The first field is, however, the starting direction, iazi1, [iele1,] iazi_vel1, [iele_vel1,] iazi_vel2, [iele_vel2,] .... Each velocity is applied to the note that is fraction total_time / number_of_velocities of the duration of the sound event.  If the elevation of the virtual source becomes greater than 90 degrees or less than 0 degrees, the polarity of angular velocity is changed. Thus the elevational angular velocity produces a virtual source that moves up and down between 0 and 90 degrees.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbapgmove/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbapgmove/#examples","title":"Examples","text":"<p>Here is an example of the vbapgmove opcode. It uses the file vbapgmove.csd.</p> Example of the vbapg opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbapgmove.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1            ;loop drumsMlp.wav\n\nk0,k1,k2,k3 vbapgmove  p3, 1, 2, 310, 180       ;change movement of soundsource in\n     outq k0*asig,k1*asig,k2*asig,k3*asig       ;the rear speakers\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vbapgmove/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbapgmove/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000 Author: John ffitch July 2012, Sept 2013</p> <p>New in Csound Version 5.17.13</p> <p>Array outputs new in Csound Version 6.01</p>"},{"location":"opcodes/vbaplsinit/","title":"Vbaplsinit","text":""},{"location":"opcodes/vbaplsinit/#vbaplsinit","title":"vbaplsinit","text":"<p>Configures VBAP output according to loudspeaker parameters. Configures VBAP output according to loudspeaker parameters.</p>"},{"location":"opcodes/vbaplsinit/#syntax","title":"Syntax","text":"<pre><code>vbaplsinit idim, ilsnum [, idir1] [, idir2] [...] [, idir32]\nvbaplsinit idim, ilsnum, ilsarray\n</code></pre>"},{"location":"opcodes/vbaplsinit/#initialization","title":"Initialization","text":"<p>idim -- dimensionality of loudspeaker array. Either 2 or 3.  If the dimension has a fractional part then that is used as the index of the layout created (used in vbap, vbapz and vbapg only).  The factional part should be between .00 and .99.</p> <p>ilsnum -- number of loudspeakers. In two dimensions, the number can vary from 2 to 64. In three dimensions, the number can vary from 3 and 64.</p> <p>idir1, idir2, ..., idir32 -- directions of loudspeakers. Number of directions must be less than or equal to 16. In two-dimensional loudspeaker positioning, idir_n is the azimuth angle respective to _n_th channel.  In three-dimensional loudspeaker positioning, fields are the azimuth and elevation angles of each loudspeaker consequently (_azi1, ele1, azi2, ele2, etc.).</p> <p>ilsarray -- a one dimesional array of the data as described above.</p> <p> Note</p> <p>In 2 dimensions the angle between two adjacent speakers must be less than 179 degrees (170 degrees in earlier versions). This is a restriction of the algorithm.</p>"},{"location":"opcodes/vbaplsinit/#performance","title":"Performance","text":"<p>VBAP distributes the signal using loudspeaker data configured with vbaplsinit. The signal is applied to, at most, two loudspeakers in 2-D loudspeaker configurations, and three loudspeakers in 3-D loudspeaker configurations. If the virtual source is panned outside the region spanned by loudspeakers, the nearest loudspeakers are used in panning.</p>"},{"location":"opcodes/vbaplsinit/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbaplsinit/#examples","title":"Examples","text":"<p>Here is an example of the vbaplsinit opcode. It uses the file vbaplsinit.csd.</p> Example of the vbaplsinit opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbaplsinit.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 8      \n0dbfs  = 1\n\nvbaplsinit 2, 8, 0, 45, 90, 180, 270, 0, 0, 0           ;5 speakers for 5.1 amps\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1                    ;loop drumsMlp.wav\nkazim line 1, p3, 355                           \na1,a2,a3,a4,a5,a6,a7,a8 vbap8  asig, kazim, 0, 1        ;change azimuth of soundsource\n; Speaker mapping\naFL = a1                                                ; Front Left\naMF = a5                                                ; Mid Front \naFR = a2                                                ; Front Right\naBL = a3                                                ; Back Left\naBR = a4                                                ; Back Right\n    outo aFL,aFR,aBL,aBR,aMF,a6,a7,a8                   ;a6, a7 and a8 are dummies                              \n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>See the other entries of the vbap opcodes for different examples.</p>"},{"location":"opcodes/vbaplsinit/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbaplsinit/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000</p> <p>New in Csound Version 4.07</p> <p>Multiple layouts new ib version 5.17.14</p>"},{"location":"opcodes/vbapmove/","title":"Vbapmove","text":""},{"location":"opcodes/vbapmove/#vbapmove","title":"vbapmove","text":"<p>Distributes an audio signal among upto 64 channels with moving virtual sources.</p>"},{"location":"opcodes/vbapmove/#syntax","title":"Syntax","text":"<pre><code>ar1[, ar2...] vbapmove asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...]\naarray[] vbapmove asig, idur, ispread, ifldnum, ifld1 [, ifld2] [...]\n</code></pre>"},{"location":"opcodes/vbapmove/#initialization","title":"Initialization","text":"<p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases (see below).</p>"},{"location":"opcodes/vbapmove/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>vbapmove allows the use of moving virtual sources. If ifldnum is positive, the fields represent directions of virtual sources and equal times, iazi1, [iele1,] iazi2, [iele2,], etc.  The position of the virtual source is interpolated between directions starting from the first direction and ending at the last. Each interval is interpolated in time that is fraction total_time / number_of_intervals of the duration of the sound event.</p> <p>If ifldnum is negative, the fields represent angular velocities and equal times. The first field is, however, the starting direction, iazi1, [iele1,] iazi_vel1, [iele_vel1,] iazi_vel2, [iele_vel2,] .... Each velocity is applied to the note that is fraction total_time / number_of_velocities of the duration of the sound event.  If the elevation of the virtual source becomes greater than 90 degrees or less than 0 degrees, the polarity of angular velocity is changed. Thus the elevational angular velocity produces a virtual source that moves up and down between 0 and 90 degrees.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbapmove/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbapmove/#examples","title":"Examples","text":"<p>See the entry for vbap8move for an example of usage of the vbapXmove opcodes.</p> <p>Here is an example of the vbapmove opcode. It uses the file vbapmove.csd.</p> Example of the vbapmove opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vbapmove.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4      ;quad\n0dbfs  = 1\n\nvbaplsinit 2, 4, 0, 90, 180, 270\n\ninstr 1\n\nasig diskin2 \"drumsMlp.wav\", 1, 0, 1            ;loop drumsMlp.wav\na1,a2,a3,a4 vbapmove  asig, p3, 1, 2, 310, 180  ;change movement of soundsource in\n     outq a1,a2,a3,a4                           ;the rear speakers\n\nendin \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vbapmove/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbapmove/#credits","title":"Credits","text":"<p>Author: Ville Pulkki Sibelius Academy Computer Music Studio Laboratory of Acoustics and Audio Signal Processing Helsinki University of Technology Helsinki, Finland May 2000 Author: John ffitch July 2012, Sept 2013</p> <p>New in Csound Version 5.17.13</p> <p>Array outputs new in Csound Version 6.01</p>"},{"location":"opcodes/vbapz/","title":"Vbapz","text":""},{"location":"opcodes/vbapz/#vbapz","title":"vbapz","text":"<p>Writes a multi-channel audio signal to a ZAK array.</p>"},{"location":"opcodes/vbapz/#syntax","title":"Syntax","text":"<pre><code>vbapz inumchnls, istartndx, asig, kazim [, kelev] [, kspread]\n</code></pre>"},{"location":"opcodes/vbapz/#initialization","title":"Initialization","text":"<p>inumchnls -- number of channels to write to the ZA array. Must be in the range 2 - 256.</p> <p>istartndx -- first index or position in the ZA array to use</p>"},{"location":"opcodes/vbapz/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>kazim -- azimuth angle of the virtual source</p> <p>kelev (optional) -- elevation angle of the virtual source</p> <p>kspread (optional) -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When kspread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>The opcode vbapz is the multiple channel analog of the opcodes like vbap4, working on inumchnls and using a ZAK array for output.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbapz/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbapz/#examples","title":"Examples","text":"<p>See the entry for vbap8 for an example of usage of the vbap opcodes.</p>"},{"location":"opcodes/vbapz/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbapz/#credits","title":"Credits","text":"<p>John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07. Input parameters accept k-rate since Csund 5.09.</p>"},{"location":"opcodes/vbapzmove/","title":"Vbapzmove","text":""},{"location":"opcodes/vbapzmove/#vbapzmove","title":"vbapzmove","text":"<p>Writes a multi-channel audio signal to a ZAK array with moving virtual sources.</p>"},{"location":"opcodes/vbapzmove/#syntax","title":"Syntax","text":"<pre><code>vbapzmove inumchnls, istartndx, asig, idur, ispread, ifldnum, ifld1, ifld2, [...]\n</code></pre>"},{"location":"opcodes/vbapzmove/#initialization","title":"Initialization","text":"<p>inumchnls -- number of channels to write to the ZA array. Must be in the range 2 - 256.</p> <p>istartndx -- first index or position in the ZA array to use</p> <p>idur -- the duration over which the movement takes place.</p> <p>ispread -- spreading of the virtual source (range 0 - 100).  If value is zero, conventional amplitude panning is used. When ispread is increased, the number of loudspeakers used in panning increases. If value is 100, the sound is applied to all loudspeakers.</p> <p>ifldnum -- number of fields (absolute value must be 2 or larger). If ifldnum is positive, the virtual source movement is a polyline specified by given directions. Each transition is performed in an equal time interval. If ifldnum is negative, specified angular velocities are applied to the virtual source during specified relative time intervals (see below).</p> <p>ifld1, ifld2, ... -- azimuth angles or angular velocities, and relative durations of movement phases (see below).</p>"},{"location":"opcodes/vbapzmove/#performance","title":"Performance","text":"<p>asig -- audio signal to be panned</p> <p>The opcode vbapzmove is the multiple channel analog of the opcodes like vbap4move, working on inumchnls and using a ZAK array for output.</p> <p> Warning</p> <p>Please note that all vbap panning opcodes require the vbap system to be initialized using vbaplsinit.</p>"},{"location":"opcodes/vbapzmove/#reference","title":"Reference","text":"<p>Ville Pulkki: \u201cVirtual Sound Source Positioning Using Vector Base Amplitude Panning\u201d Journal of the Audio Engineering Society, 1997 June, Vol. 45/6, p. 456.</p>"},{"location":"opcodes/vbapzmove/#examples","title":"Examples","text":"<p>See the entry for vbap8move for an example of usage of the vbapXmove opcodes.</p>"},{"location":"opcodes/vbapzmove/#see-also","title":"See also","text":"<p>Panning and Spatialization: Vector Base Amplitude Panning</p>"},{"location":"opcodes/vbapzmove/#credits","title":"Credits","text":"<p>John ffitch University of Bath/Codemist Ltd. Bath, UK May 2000</p> <p>New in Csound Version 4.07</p>"},{"location":"opcodes/vcella/","title":"Vcella","text":""},{"location":"opcodes/vcella/#vcella","title":"vcella","text":"<p>Cellular Automata</p> <p>Unidimensional Cellular Automata applied to Csound vectors</p>"},{"location":"opcodes/vcella/#syntax","title":"Syntax","text":"<pre><code>vcella ktrig, kreinit, ioutFunc, initStateFunc, \\\n       iRuleFunc, ielements, irulelen [, iradius]\n</code></pre>"},{"location":"opcodes/vcella/#initialization","title":"Initialization","text":"<p>ioutFunc - number of the table where the state of each cell is stored</p> <p>initStateFunc  - number of a table containig the inital states of each cell</p> <p>iRuleFunc - number of a lookup table containing the rules</p> <p>ielements - total number of cells</p> <p>irulelen  - total number of rules</p> <p>iradius (optional) - radius of Cellular Automata. At present time CA radius can be 1 or 2 (1 is the default)</p>"},{"location":"opcodes/vcella/#performance","title":"Performance","text":"<p>ktrig - trigger signal. Each time it is non-zero, a new generation of cells is evaluated</p> <p>kreinit - trigger signal. Each time it is non-zero, state of all cells is forced to be that of initStateFunc.</p> <p>vcella supports unidimensional cellular automata, where the state of each cell is stored in ioutFunc. So ioutFunc is a vector containing current state of each cell. This variant vector can be used together with any other vector-based opcode, such as adsynt, vmap, vpowv etc.</p> <p>initStateFunc is an input vector containing the inital value of the row of cells, while iRuleFunc is an input vector containing the rules in the form of a lookup table. Notice that initStateFunc and iRuleFunc can be updated during the performance by means of other vector-based opcodes (for example vcopy) in order to force to change rules and status at performance time.</p> <p>A new generation of cells is evaluated each time ktrig contains a non-zero value. Also the status of all cells can be forced to assume the status corresponding to the contents of initStateFunc each time kreinit contains a non-zero value.</p> <p>Radius of CA algorithm can be 1 or 2 (optional iradius arguement).</p>"},{"location":"opcodes/vcella/#examples","title":"Examples","text":"<p>Here is an example of the vcella opcode. It uses the file vcella.csd.</p> <p>The following example uses vcella</p> Example of the vcella opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o vcella.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n; vcella.csd\n; by Anthony Kozar\n\n; This file demonstrates some of the new opcodes available in\n; Csound 5 that come from Gabriel Maldonado's CsoundAV.\n\nsr        = 44100\nkr        = 4410\nksmps     = 10\nnchnls    = 1\n\n; Cellular automata-driven oscillator bank using vcella and adsynt\ninstr 1\n  idur      = p3\n  iCArate   = p4                                ; number of times per second the CA calculates new values\n\n  ; f-tables for CA parameters\n  iCAinit   = p5                                ; CA initial states                                     \n  iCArule   = p6                                ; CA rule values\n  ; The rule is used as follows:\n  ; the states (values) of each cell are summed with their neighboring cells within\n  ; the specied radius (+/- 1 or 2 cells).  Each sum is used as an index to read a \n  ; value from the rule table which becomes the new state value for its cell.\n  ; All new states are calculated first, then the new values are all applied \n  ; simultaneously.\n\n  ielements = ftlen(iCAinit)\n  inumrules = ftlen(iCArule)\n  iradius   = 1\n\n  ; create some needed tables\n  iCAstate  ftgen     0, 0, ielements, -2, 0    ; will hold the current CA states\n  ifreqs    ftgen     0, 0, ielements, -2, 0    ; will hold the oscillator frequency for each cell\n  iamps     ftgen     0, 0, ielements, -2, 0    ; will hold the amplitude for each cell\n\n  ; calculate cellular automata state\n  ktrig     metro     iCArate                   ; trigger the CA to update iCArate times per second\n            vcella    ktrig, 0, iCAstate, iCAinit, iCArule, ielements, inumrules, iradius\n\n  ; scale CA state for use as amplitudes of the oscillator bank\n            vcopy     iamps, iCAstate, ielements\n            vmult     iamps, (1/3), ielements   ; divide by 3 since state values are 0-3\n\n            vport     iamps, .01, ielements     ; need to smooth the amplitude changes for adsynt\n  ; we could use adsynt2 instead of adsynt, but it does not seem to be working\n\n  ; i-time loop for calculating frequencies\n  index     =         0\n  inew      =         1\n  iratio    =         1.125                     ; just major second (creating a whole tone scale)\nloop1:\n            tableiw   inew, index, ifreqs, 0    ; 0 indicates integer indices\n  inew      =         inew * iratio\n  index     =         index + 1\n  if (index &lt; ielements) igoto loop1\n\n  ; create sound with additive oscillator bank\n  ifreqbase = 64\n  iwavefn   = 1\n  iphs      = 2                                 ; random oscillator phases\n\n  kenv      linseg    0.0, 0.5, 1.0, idur - 1.0, 1.0, 0.5, 0.0\n  aosc      adsynt    kenv, ifreqbase, iwavefn, ifreqs, iamps, ielements, iphs\n\n            out       aosc * ampdb(68)\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 16384 10 1\n\n; This example uses a 4-state cellular automata\n; Possible state values are 0, 1, 2, and 3\n\n; CA initial state\n; We have 16 cells in our CA, so the initial state table is size 16\nf10 0 16 -2  0 1 0 0  1 0 0 2  2 0 0 1  0 0 1 0\n\n; CA rule\n; The maximum sum with radius 1 (3 cells) is 9, so we need 10 values in the rule (0-9)\nf11 0 16 -2  1 0 3 2 1  0 0 2 1 0\n\n; Here is our one and only note!\ni1 0  20  4  10  11\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vcella/#see-also","title":"See also","text":"<p>Vectorial:Cellular Automata</p> <p>Models and Emulations</p>"},{"location":"opcodes/vcella/#credits","title":"Credits","text":"<p>Written by: Gabriel Maldonado.</p> <p>New in Csound 5 (Previously available only on CsoundAV)</p> <p>Example by: Anthony Kozar</p>"},{"location":"opcodes/vclpf/","title":"Vclpf","text":""},{"location":"opcodes/vclpf/#vclpf","title":"vclpf","text":"<p>Resonant 4pole linear lowpass filter.</p> <p>Vclpf is an digital implementation of a standard 4-pole linear analogue filter, similar to the Moog, Arp, and SSM2040/2044 filters, consisting of four identical 1-pole filters with a feedback (resonance or regeneration) path. Unlike the moogladder opcode, this filter does not have any non-linearities, but its implementation preserves the analogue filter topology. The code is based on the work of Federico Fontana, described in the paper \"PRESERVING THE STRUCTURE OF THE MOOG VCF IN THE DIGITAL DOMAIN\" (Proceedings of ICMC 2007).</p>"},{"location":"opcodes/vclpf/#syntax","title":"Syntax","text":"<pre><code>asig vclpf ain, xcf, xres[, istor]\n</code></pre>"},{"location":"opcodes/vclpf/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/vclpf/#performance","title":"Performance","text":"<p>asig -- input signal.</p> <p>xcf -- filter cutoff frequency (a- or k-rate)</p> <p>xres -- resonance, between 0 and 1. Higher values will make the filter self-oscillate (a- or k-rate).</p>"},{"location":"opcodes/vclpf/#examples","title":"Examples","text":"<p>Here is an example of the vclpf opcode. It uses the file vclpf.csd.</p> Example of the vclpf opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n0dbfs = 1\n\ninstr 1\n\na1 rand p4\naf expon 20, p3, 20000\na2 vclpf a1, af, 0.7\n   out a2\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5 0.5\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vclpf/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/vclpf/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini Feb 2021</p>"},{"location":"opcodes/vco/","title":"Vco","text":""},{"location":"opcodes/vco/#vco","title":"vco","text":"<p>Implementation of a band limited, analog modeled oscillator.</p> <p>It is based on integration of band limited impulses. vco can be used to simulate a variety of analog wave forms.</p>"},{"location":"opcodes/vco/#syntax","title":"Syntax","text":"<pre><code>ares vco xamp, xcps, iwave, kpw [, ifn] [, imaxd] [, ileak] [, inyx] \\\n         [, iphs] [, iskip]\n</code></pre>"},{"location":"opcodes/vco/#initialization","title":"Initialization","text":"<p>iwave -- determines the waveform:</p> <ul> <li>iwave = 1 - sawtooth</li> <li>iwave = 2 - square/PWM</li> <li>iwave = 3 - triangle/saw/ramp</li> </ul> <p>ifn (optional, default = 1) -- Must point to a valid table which contains a sine wave. Csound will report an error if this parameter is not set and table 1 does not exist.</p> <p>imaxd (optional, default = 1) -- is the maximum delay time. A time of 1/ifqc may be required for the PWM and triangle waveform. To bend the pitch down this value must be as large as 1/(minimum frequency).</p> <p>ileak (optional, default = 0) -- if ileak is between zero and one (0 &lt; ileak &lt; 1) then ileak is used as the leaky integrator value. Otherwise a leaky integrator value of .999 is used for the saw and square waves and .995 is used for the triangle wave. This can be used to \u201cflatten\u201d the square wave or \u201cstraighten\u201d the saw wave at low frequencies by setting ileak to .99999 or a similar value. This should give a hollower sounding square wave.</p> <p>inyx (optional, default = .5) -- this is used to determine the number of harmonics in the band limited pulse.  All overtones up to sr * inyx will be used.  The default gives sr * .5 (sr/2).  For sr/4 use inyx = .25.  This can generate a \u201cfatter\u201d sound in some cases.</p> <p>iphs (optional, default = 0) -- this is a phase value.  There is an artifact (bug-like feature) in vco which occurs during the first half cycle of the square wave which causes the waveform to be greater in magnitude than all others.  The value of iphs has an effect on this artifact.  In particular setting iphs to .5 will cause the first half cycle of the square wave to resemble a small triangle wave.  This may be more desirable than the large wave artifact which is the current default.</p> <p>iskip (optional, default = 0) -- if non zero skip the initialisation of the filter. (New in Csound version 4.23f13 and 5.0)</p>"},{"location":"opcodes/vco/#performance","title":"Performance","text":"<p>kpw -- determines either the pulse width (if iwave is 2) or the saw/ramp character (if iwave is 3) The value of kpw should be greater than 0 and less than 1. A value of 0.5 will generate either a square wave (if iwave is 2) or a triangle wave (if iwave is 3).</p> <p>xamp -- determines the amplitude</p> <p>xcps -- is the frequency of the wave in cycles per second.</p>"},{"location":"opcodes/vco/#examples","title":"Examples","text":"<p>Here is an example of the vco opcode. It uses the file vco.csd.</p> Example of the vco opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n;-o vco.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp  = .4 \nkcps  = cpspch(p4) \niwave = p5                              ; Select the wave form\nkpw init 0.5                            ; Set the pulse-width/saw-ramp character.\nifn = 1\nasig vco kamp, kcps, iwave, kpw, ifn\nouts asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 65536 10 1    ; a sine wave.\n\n;           pitch-class waveform\ni 1 00 02       05.00       1   ; saw\ni 1 02 02       05.00       2   ; square\ni 1 04 02       05.00       3   ; tri/saw/ramp\n\ni 1 06 02       07.00       1\ni 1 08 02       07.00       2\ni 1 10 02       07.00       3\n\ni 1 12 02       09.00       1\ni 1 14 02       09.00       2\ni 1 16 02       09.00       3\n\ni 1 18 02       11.00       1\ni 1 20 02       11.00       2\ni 1 22 02       11.00       3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vco/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/vco/#credits","title":"Credits","text":"<p>Author: Hans Mikelson December 1998</p> <p>New in Csound version 3.50</p> <p>November 2002. Corrected the documentation for the kpw parameter thanks to Luis Jure and Hans Mikelson.</p>"},{"location":"opcodes/vco2/","title":"Vco2","text":""},{"location":"opcodes/vco2/#vco2","title":"vco2","text":"<p>Implementation of a band-limited oscillator using pre-calculated tables.</p> <p>vco2 is similar to vco. But the implementation uses pre-calculated tables of band-limited waveforms (see also GEN30) rather than integrating impulses. This opcode can be faster than vco (especially if a low control-rate is used) and also allows better sound quality. Additionally, there are more waveforms and oscillator phase can be modulated at k-rate. The disadvantage is increased memory usage. For more details about vco2 tables, see also vco2init and vco2ft.</p>"},{"location":"opcodes/vco2/#syntax","title":"Syntax","text":"<pre><code>ares vco2 kamp, kcps [, imode] [, kpw] [, kphs] [, inyx]\n</code></pre>"},{"location":"opcodes/vco2/#initialization","title":"Initialization","text":"<p>imode (optional, default=0) -- a sum of values representing the waveform and its control values.</p> <p>One may use any of the following values for imode:</p> <ul> <li>16: enable k-rate phase control (if set, kphs is a required k-rate parameter that allows phase modulation)</li> <li>1: skip initialization</li> </ul> <p>One may use exactly one of these imode values to select the waveform to be generated:</p> <ul> <li>14: user defined waveform -1 (requires using the vco2init opcode)</li> <li>12: triangle (no ramp, faster)</li> <li>10: square wave (no PWM, faster)</li> <li>8: 4 * x * (1 - x) (i.e. integrated sawtooth)</li> <li>6: pulse (not normalized)</li> <li>4: sawtooth / triangle / ramp</li> <li>2: square / PWM</li> <li>0: sawtooth</li> </ul> <p>The default value for imode is zero, which means a sawtooth wave with no k-rate phase control.</p> <p>inyx (optional, default=0.5) -- bandwidth of the generated waveform, as percentage (0 to 1) of the sample rate. The expected range is 0 to 0.5 (i.e. up to sr/2), other values are limited to the allowed range.</p> <p>Setting inyx to 0.25 (sr/4), or 0.3333 (sr/3) can produce a \u201cfatter\u201d sound in some cases, although it is more likely to reduce quality.</p>"},{"location":"opcodes/vco2/#performance","title":"Performance","text":"<p>ares -- the output audio signal.</p> <p>kamp -- amplitude scale. In the case of a imode waveform value of 6 (a pulse waveform), the actual output level can be a lot higher than this value.</p> <p>kcps -- frequency in Hz (should be in the range -sr/2 to sr/2).</p> <p>kpw (optional) -- the pulse width of the square wave (imode waveform=2) or the ramp characteristics of the triangle wave (imode waveform=4). It is required only by these waveforms and ignored in all other cases. The expected range is 0 to 1, any other value is wrapped to the allowed range.</p> <p> Warning</p> <p>kpw must not be an exact integer value (e.g. 0 or 1) if a sawtooth / triangle / ramp (imode waveform=4) is generated. In this case, the recommended range is about 0.01 to 0.99. There is no such limitation for a square/PWM waveform. </p> <p>kphs (optional) -- oscillator phase (depending on imode, this can be either an optional i-rate parameter that defaults to zero or required k-rate). Similarly to kpw, the expected range is 0 to 1.</p> <p> Note</p> <p>When a low control-rate is used, pulse width (kpw) and phase (kphs) modulation is internally converted to frequency modulation. This allows for faster processing and reduced artifacts. But in the case of very long notes and continuous fast changes in kpw or kphs, the phase may drift away from the requested value. In most cases, the phase error is at most 0.037 per hour (assuming a sample rate of 44100 Hz).</p> <p>This is a problem mainly in the case of pulse width (kpw), where it may result in various artifacts. While future releases of vco2 may fix such errors, the following work-arounds may also be of some help:</p> <ul> <li>Use kpw values only in the range 0.05 to 0.95. (There are more artifacts around integer values)</li> <li>Try to avoid modulating kpw by asymmetrical waveforms like a sawtooth wave. Relatively slow (&lt;= 20 Hz) symmetrical modulation (e.g. sine or triangle), random splines (also slow), or a fixed pulse width is a lot less likely to cause synchronization problems.</li> <li>In some cases, adding random jitter (for example: random splines with an amplitude of about 0.01) to kpw may also fix the problem.</li> </ul>"},{"location":"opcodes/vco2/#examples","title":"Examples","text":"<p>Here is an example of the vco2 opcode. It uses the file vco2.csd.</p> Example of the vco2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o vco2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =  44100\nksmps   =  10\nnchnls  =  1\n\n; user defined waveform -1: trapezoid wave with default parameters (can be\n; accessed at ftables starting from 10000)\nitmp    ftgen 1, 0, 16384, 7, 0, 2048, 1, 4096, 1, 4096, -1, 4096, -1, 2048, 0\nift     vco2init -1, 10000, 0, 0, 0, 1\n; user defined waveform -2: fixed table size (4096), number of partials\n; multiplier is 1.02 (~238 tables)\nitmp    ftgen 2, 0, 16384, 7, 1, 4095, 1, 1, -1, 4095, -1, 1, 0, 8192, 0\nift     vco2init -2, ift, 1.02, 4096, 4096, 2\n\n        instr 1\nkcps    expon p4, p3, p5                ; instr 1: basic vco2 example\na1      vco2 12000, kcps                ; (sawtooth wave with default\n        out a1                          ; parameters)\n        endin\n\n        instr 2\nkcps    expon p4, p3, p5                        ; instr 2:\nkpw     linseg 0.1, p3/2, 0.9, p3/2, 0.1        ; PWM example\na1      vco2 10000, kcps, 2, kpw\n        out a1\n        endin\n\n        instr 3\nkcps    expon p4, p3, p5                ; instr 3: vco2 with user\na1      vco2 14000, kcps, 14            ; defined waveform (-1)\naenv    linseg 1, p3 - 0.1, 1, 0.1, 0   ; de-click envelope\n        out a1 * aenv\n        endin\n\n        instr 4\nkcps    expon p4, p3, p5                ; instr 4: vco2ft example,\nkfn     vco2ft kcps, -2, 0.25           ; with user defined waveform\na1      oscilikt 12000, kcps, kfn       ; (-2), and sr/4 bandwidth\n        out a1\n        endin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1  0 3 20 2000\ni 2  4 2 200 400\ni 3  7 3 400 20\ni 4 11 2 100 200\n\nf 0 14\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vco2/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/vco2/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/vco2ft/","title":"Vco2ft","text":""},{"location":"opcodes/vco2ft/#vco2ft","title":"vco2ft","text":"<p>Returns a table number at k-time for a given oscillator frequency and wavform.</p> <p>vco2ft returns the function table number to be used for generating the specified waveform at a given frequency. This function table number can be used by any Csound opcode that generates a signal by reading function tables (like oscilikt). The tables must be calculated by vco2init before vco2ft is called and shared as Csound ftables (ibasfn).</p>"},{"location":"opcodes/vco2ft/#syntax","title":"Syntax","text":"<pre><code>kfn vco2ft kcps, iwave [, inyx]\n</code></pre>"},{"location":"opcodes/vco2ft/#initialization","title":"Initialization","text":"<p>iwave -- the waveform for which table number is to be selected. Allowed values are:</p> <ul> <li>0: sawtooth</li> <li>1: 4 * x * (1 - x)   (integrated sawtooth)</li> <li>2: pulse (not normalized)</li> <li>3: square wave</li> <li>4: triangle</li> </ul> <p>Additionally, negative iwave values select user defined waveforms (see also vco2init).</p> <p>inyx (optional, default=0.5) -- bandwidth of the generated waveform, as percentage (0 to 1) of the sample rate. The expected range is 0 to 0.5 (i.e. up to sr/2), other values are limited to the allowed range.</p> <p>Setting inyx to 0.25 (sr/4), or 0.3333 (sr/3) can produce a \u201cfatter\u201d sound in some cases, although it is more likely to reduce quality.</p>"},{"location":"opcodes/vco2ft/#performance","title":"Performance","text":"<p>kfn -- the ftable number, returned at k-rate.</p> <p>kcps -- frequency in Hz, returned at k-rate. Zero and negative values are allowed. However, if the absolute value exceeds sr/2 (or sr * inyx), the selected table will contain silence.</p>"},{"location":"opcodes/vco2ft/#examples","title":"Examples","text":"<p>See the example for the vco2 opcode.</p>"},{"location":"opcodes/vco2ft/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/vco2ft/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/vco2ift/","title":"Vco2ift","text":""},{"location":"opcodes/vco2ift/#vco2ift","title":"vco2ift","text":"<p>Returns a table number at i-time for a given oscillator frequency and wavform.</p> <p>vco2ift is the same as vco2ft, but works at i-time. It is suitable for use with opcodes that expect an i-rate table number (for example, oscili).</p>"},{"location":"opcodes/vco2ift/#syntax","title":"Syntax","text":"<pre><code>ifn vco2ift icps, iwave [, inyx]\n</code></pre>"},{"location":"opcodes/vco2ift/#initialization","title":"Initialization","text":"<p>ifn -- the ftable number.</p> <p>icps --  frequency in Hz. Zero and negative values are allowed. However, if the absolute value exceeds sr/2 (or sr * inyx), the selected table will contain silence.</p> <p>iwave -- the waveform for which table number is to be selected. Allowed values are:</p> <ul> <li>0: sawtooth</li> <li>1: 4 * x * (1 - x)   (integrated sawtooth)</li> <li>2: pulse (not normalized)</li> <li>3: square wave</li> <li>4: triangle</li> </ul> <p>Additionally, negative iwave values select user defined waveforms (see also vco2init).</p> <p>inyx (optional, default=0.5) -- bandwidth of the generated waveform, as percentage (0 to 1) of the sample rate. The expected range is 0 to 0.5 (i.e. up to sr/2), other values are limited to the allowed range.</p> <p>Setting inyx to 0.25 (sr/4), or 0.3333 (sr/3) can produce a \u201cfatter\u201d sound in some cases, although it is more likely to reduce quality.</p>"},{"location":"opcodes/vco2ift/#examples","title":"Examples","text":"<p>Here is an example of the vco2ift opcode. It uses the file vco2ift.csd.</p> Example of the vco2ift opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vco2ift.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; user defined waveform -2: fixed table size (64), number of partials\n; multiplier is 1.4\nitmp    ftgen 2, 0, 64, 5, 1, 2, 120, 60, 1, 1, 0.001, 1\nift     vco2init -2, 3, 1.4, 4096, 4096, 2\n\n\ninstr 1\n\nicps = p4\nifn  vco2ift icps, -2, 0.5    ;with user defined waveform\nprint ifn\nasig oscili 1, 220, ifn       ;(-2), and sr/2 bandwidth\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 20\ni 1 3 2 2000\ni 1 6 2 20000\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like these:</p> <pre><code>instr 1:  ifn = 22.000\ninstr 1:  ifn = 8.000\ninstr 1:  ifn = 3.000\n</code></pre> <p>See the example for the vco2 opcode too.</p>"},{"location":"opcodes/vco2ift/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/vco2ift/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/vco2init/","title":"Vco2init","text":""},{"location":"opcodes/vco2init/#vco2init","title":"vco2init","text":"<p>Calculates tables for use by vco2 opcode.</p> <p>vco2init calculates tables for use by vco2 opcode. Optionally, it is also possible to access these tables as standard Csound function tables. In this case, vco2ft can be used to find the correct table number for a given oscillator frequency.</p> <p>In most cases, this opcode is called from the orchestra header. Using vco2init in instruments is possible but not recommended. This is because replacing tables during performance can result in a Csound crash if other opcodes are accessing the tables at the same time.</p> <p>Note that vco2init is not required for vco2 to work (tables are automatically allocated by the first vco2 call, if not done yet), however it can be useful in some cases:</p> <ul> <li>Pre-calculate tables at orchestra load time. This is useful to avoid generating the tables during performance, which could interrupt real-time processing.</li> <li>Share the tables as Csound ftables. By default, the tables can be accessed only by vco2.</li> <li>Change the default parameters of tables (e.g. size) or use an user-defined waveform specified in a function table.</li> </ul>"},{"location":"opcodes/vco2init/#syntax","title":"Syntax","text":"<pre><code>ifn vco2init iwave [, ibasfn] [, ipmul] [, iminsiz] [, imaxsiz] [, isrcft]\n</code></pre>"},{"location":"opcodes/vco2init/#initialization","title":"Initialization","text":"<p>ifn -- the first free ftable number after the allocated tables. If ibasfn was not specified, -1 is returned.</p> <p>iwave -- sum of the following values selecting which waveforms are to be calculated:</p> <ul> <li>16: triangle</li> <li>8: square wave</li> <li>4: pulse (not normalized)</li> <li>2: 4 * x * (1 - x)   (integrated sawtooth)</li> <li>1: sawtooth</li> </ul> <p>Alternatively, iwave can be set to a negative integer that selects an user-defined waveform. This also requires the isrcft parameter to be specified. vco2 can access waveform number -1. However, other user-defined waveforms are usable only with vco2ft or vco2ift.</p> <p>ibasfn (optional, default=-1) -- ftable number from which the table set(s) can be accessed by opcodes other than vco2. This is required by user defined waveforms, with the exception of -1. If this value is less than 1, it is not possible to access the tables calculated by vco2init as Csound function tables.</p> <p>ipmul (optional, default=1.05) -- multiplier value for number of harmonic partials. If one table has n partials, the next one will have n * ipmul (at least n + 1). The allowed range for ipmul is 1.01 to 2. Zero or negative values select the default (1.05).</p> <p>iminsiz (optional, default=-1) -- minimum table size.</p> <p>imaxsiz (optional, default=-1) -- maximum table size.</p> <p>The actual table size is calculated by multiplying the square root of the number of harmonic partials by iminsiz, rounding up the result to the next power of two, and limiting this not to be greater than imaxsiz.</p> <p>Both parameters, iminsiz and imaxsiz, must be power of two, and in the allowed range. The allowed range is 16 to 262144 for iminsiz to up to 16777216 for imaxsiz. Zero or negative values select the default settings:</p> <ul> <li>The minimum size is 128 for all waveforms except pulse (iwave=4). Its minimum size is 256.</li> <li>The default maximum size is usually the minimum size multiplied by 64, but not more than 16384 if possible. It is always at least the minimum size.</li> </ul> <p>isrcft (optional, default=-1) -- source ftable number for user-defined waveforms (if iwave &lt; 0). isrcft should point to a function table containing the waveform to be used for generating the table array. The table size is recommended to be at least imaxsiz points. If iwave is not negative (built-in waveforms are used), isrcft is ignored.</p> <p> Warning</p> <p>The number and size of tables is not fixed. Orchestras should not depend on these parameters, as they are subject to changes between releases.</p> <p>If the selected table set already exists, it is replaced. If any opcode is accessing the tables at the same time, it is very likely that a crash will occur. This is why it is recommended to use vco2init only in the orchestra header.</p> <p>These tables should not be replaced/overwritten by GEN routines or the ftgen opcode. Otherwise, unpredictable behavior or a Csound crash may occur if vco2 is used. The first free ftable after the table array(s) is returned in ifn.</p>"},{"location":"opcodes/vco2init/#examples","title":"Examples","text":"<p>Here is an example of the vco2init opcode. It uses the file vco2init.csd.</p> Example of the vco2init opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vco2init.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=1\nnchnls=2\n\n; create waveform with discontinuities, so it has a lot of high freq content\ngitable ftgen 0, 0, 2^16+1, 7, -1, 2^14, 1, 0, -1, 2^14, 1, 0, -1, 2^15, 1\n; make bandlimited tables of the waveform\ngi_nextfree vco2init -gitable, gitable+1, 1.05, 128, 2^16, gitable\ngitable_bl = -gitable\n\ninstr 1\n\nkfreq  expon 14000, p3, 500\nkfn    vco2ft kfreq, gitable_bl\nasig   oscilikt 5000, kfreq, kfn\nprintk 0.1, kfn\n\n; remove semicolon on next line to hear original waveform, demonstrating\n; the aliasing\n;asig   oscili 5000, kfreq, gitable\n       outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like these:</p> <pre><code>i   1 time     0.00002:   103.00000\ni   1 time     0.10000:   103.00000\ni   1 time     0.20000:   103.00000\ni   1 time     0.30002:   103.00000\ni   1 time     0.40000:   104.00000\ni   1 time     0.50000:   104.00000\n.......\n......\ni   1 time     4.80002:   135.00000\ni   1 time     4.90000:   136.00000\ni   1 time     5.00000:   138.00000\n</code></pre> <p>See the example for the vco2 opcode too.</p>"},{"location":"opcodes/vco2init/#see-also","title":"See Also","text":"<p>Dynamic Spectrum Oscillators</p>"},{"location":"opcodes/vco2init/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.22</p>"},{"location":"opcodes/vcomb/","title":"Vcomb","text":""},{"location":"opcodes/vcomb/#vcomb","title":"vcomb","text":"<p>Variably reverberates an input signal with a \u201ccolored\u201d frequency response.</p>"},{"location":"opcodes/vcomb/#syntax","title":"Syntax","text":"<pre><code>ares vcomb asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]\n</code></pre>"},{"location":"opcodes/vcomb/#initialization","title":"Initialization","text":"<p>imaxlpt -- maximum loop time for klpt</p> <p>iskip (optional, default=0) -- initial disposition of delay-loop data space (cf. reson). The default value is 0.</p> <p>insmps (optional, default=0) -- delay amount, as a number of samples.</p>"},{"location":"opcodes/vcomb/#performance","title":"Performance","text":"<p>krvt -- the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude).</p> <p>xlpt -- variable loop time in seconds, same as ilpt in comb.  Loop time can be as large as imaxlpt.</p> <p>This filter reiterates input with an echo density determined by loop time xlpt. The attenuation rate is independent and is determined by krvt, the reverberation time (defined as the time in seconds for a signal to decay to 1/1000, or 60dB down from its original amplitude). Output will appear only after ilpt seconds.</p>"},{"location":"opcodes/vcomb/#examples","title":"Examples","text":"<p>Here is an example of the vcomb opcode. It uses the file vcomb.csd.</p> Example of the vcomb opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc       -M0 ;;;RT audio I/O with MIDI in\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Example by Jonathan Murphy and Charles Gran 2007\n  sr        =  44100\n  ksmps     =  10\n  nchnls    =  2\n\n        ; new, and important. Make sure that midi note events are only\n        ; received by instruments that actually need them.\n\n        ; turn default midi routing off\n        massign         0, 0\n        ; route note events on channel 1 to instr 1\n        massign         1, 1\n\n; Define your midi controllers\n#define C1 #21#\n#define C2 #22#\n#define C3 #23#\n\n; Initialize MIDI controllers\n            initc7    1, $C1, 0.5                 ;delay send\n            initc7    1, $C2, 0.5                 ;delay: time to zero\n            initc7    1, $C3, 0.5                 ;delay: rate \n\n  gaosc     init      0\n\n; Define an opcode to \"smooth\" the MIDI controller signal\n    opcode smooth, k, k\n  kin       xin\n  kport     linseg    0, 0.0001, 0.01, 1, 0.01\n  kin       portk     kin, kport\n            xout      kin\n    endop\n\ninstr   1  \n ; Generate a sine wave at the frequency of the MIDI note that triggered the intrument\n  ifqc      cpsmidi\n  iamp      ampmidi   10000\n  aenv      linenr    iamp, .01, .1, .01          ;envelope\n  a1        oscil     aenv, ifqc, 1\n; All sound goes to the global variable gaosc\n  gaosc     =  gaosc + a1\n    endin\n\n    instr     198 ; ECHO\n  kcmbsnd   ctrl7     1, $C1, 0, 1                ;delay send\n  ktime     ctrl7     1, $C2, 0.01, 6             ;time loop fades out\n  kloop     ctrl7     1, $C3, 0.01, 1             ;loop speed\n; Receive MIDI controller values and then smooth them\n  kcmbsnd   smooth    kcmbsnd\n  ktime     smooth    ktime\n  kloop     smooth    kloop\n  imaxlpt   =  1                                  ;max loop time\n; Create a variable reverberation (delay) of the gaosc signal\n  acomb     vcomb     gaosc, ktime, kloop, imaxlpt, 1\n  aout      =  (acomb * kcmbsnd) + gaosc * (1 - kcmbsnd)\n            outs      aout, aout\n  gaosc     =  0\n    endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf1 0 16384 10 1\ni198 0 10000\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vcomb/#see-also","title":"See also","text":"<p>Reverberation</p>"},{"location":"opcodes/vcomb/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss University of Texas at Austin Austin, Texas USA January 2002</p>"},{"location":"opcodes/vdelay/","title":"Vdelay","text":""},{"location":"opcodes/vdelay/#vdelay","title":"vdelay","text":"<p>An interpolating variable time delay.</p> <p>It is not very different from the existing implementation (deltapi), it is only easier to use.</p>"},{"location":"opcodes/vdelay/#syntax","title":"Syntax","text":"<pre><code>ares vdelay asig, adel, imaxdel [, iskip]\n</code></pre>"},{"location":"opcodes/vdelay/#initialization","title":"Initialization","text":"<p>imaxdel -- Maximum value of delay in milliseconds. If adel gains a value greater than imaxdel it is folded around imaxdel. This should not happen.</p> <p>iskip -- Skip initialization if present and non-zero</p>"},{"location":"opcodes/vdelay/#performance","title":"Performance","text":"<p>With this unit generator it is possible to do Doppler effects or chorusing and flanging.</p> <p>asig -- Input signal.</p> <p>adel -- Current value of delay in milliseconds. Note that linear functions have no pitch change effects. Fast changing values of adel will cause discontinuities in the waveform resulting noise.</p>"},{"location":"opcodes/vdelay/#examples","title":"Examples","text":"<p>Here is an example of the vdelay opcode. It uses the file vdelay.csd.</p> Example of the vdelay opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelay.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr   = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  = 100                              ;maximum delay time in msec\naout poscil .8, 220, 1                  ;make a signal\na2   poscil3 ims/2, 1/p3, 1             ;make an LFO\na2   = a2 + ims/2                       ;offset the LFO so that it is positive\nasig vdelay aout, a2, ims               ;use the LFO to control delay time\n     outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1 ;sine wave\n\ni 1 0 5 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Two important points here. First, the delay time must be always positive. And second, even though the delay time can be controlled in k-rate, it is not advised to do so, since sudden time changes will create clicks.</p>"},{"location":"opcodes/vdelay/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelay/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/vdelay3/","title":"Vdelay3","text":""},{"location":"opcodes/vdelay3/#vdelay3","title":"vdelay3","text":"<p>A variable time delay with cubic interpolation.</p> <p>vdelay3 is experimental. It is the same as vdelay except that it uses cubic interpolation. (New in Version 3.50.)</p>"},{"location":"opcodes/vdelay3/#syntax","title":"Syntax","text":"<pre><code>ares vdelay3 asig, adel, imaxdel [, iskip]\n</code></pre>"},{"location":"opcodes/vdelay3/#initialization","title":"Initialization","text":"<p>imaxdel -- Maximum value of delay in milliseconds. If adel gains a value greater than imaxdel it is folded around imaxdel. This should not happen.</p> <p>iskip (optional) -- Skip initialization if present and non-zero.</p>"},{"location":"opcodes/vdelay3/#performance","title":"Performance","text":"<p>With this unit generator it is possible to do Doppler effects or chorusing and flanging.</p> <p>asig -- Input signal.</p> <p>adel -- Current value of delay in milliseconds. Note that linear functions have no pitch change effects. Fast changing values of adel will cause discontinuities in the waveform resulting noise.</p>"},{"location":"opcodes/vdelay3/#examples","title":"Examples","text":"<p>Here is an example of the vdelay3 opcode. It uses the file vdelay3.csd.</p> Example of the vdelay3 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelay3.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  = 100                      ;maximum delay time in msec\naout poscil .8, 220, 1          ;make a signal\na2   poscil ims/2, 1/p3, 1      ;make an LFO\na2   = a2 + ims/2               ;offset the LFO so that it is positive\nasig vdelay3 aout, a2, ims      ;use the LFO to control delay time\n     outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 5 \n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Two important points here. First, the delay time must be always positive. And second, even though the delay time can be controlled in k-rate, it is not advised to do so, since sudden time changes will create clicks.</p>"},{"location":"opcodes/vdelay3/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelay3/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/vdelayx/","title":"Vdelayx","text":""},{"location":"opcodes/vdelayx/#vdelayx","title":"vdelayx","text":"<p>A variable delay opcode with high quality interpolation.</p>"},{"location":"opcodes/vdelayx/#syntax","title":"Syntax","text":"<pre><code>aout vdelayx ain, adl, imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayx/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayx/#performance","title":"Performance","text":"<p>aout -- output audio signal</p> <p>ain -- input audio signal</p> <p>adl -- delay time in seconds</p> <p>This opcode uses high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayx/#examples","title":"Examples","text":"<p>Here is an example of the use of the vdelayx opcode. It uses the file vdelayx.csd.</p> Example of the _vdelayx_ opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayx.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  =  .5                              ;maximum delay time in seconds\niws  =  1024                            ;window size\nadl  =  .5                              ;delay time\nasig diskin2 \"fox.wav\", 1, 0, 1         ;loop fox.wav\na2   poscil .2, .2, 1                   ;make an LFO\nadl  = a2 + ims/2                       ;offset the LFO so that it is positive\naout vdelayx asig, adl, ims, iws        ;use the LFO to control delay time\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/vdelayx/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelayxq/","title":"Vdelayxq","text":""},{"location":"opcodes/vdelayxq/#vdelayxq","title":"vdelayxq","text":"<p>A 4-channel variable delay opcode with high quality interpolation.</p>"},{"location":"opcodes/vdelayxq/#syntax","title":"Syntax","text":"<pre><code>aout1, aout2, aout3, aout4 vdelayxq ain1, ain2, ain3, ain4, adl, imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayxq/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayxq/#performance","title":"Performance","text":"<p>aout1, aout2, aout3, aout4 -- output audio signals.</p> <p>ain1, ain2, ain3, ain4 -- input audio signals.</p> <p>adl -- delay time in seconds</p> <p>This opcode uses high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p>The multichannel opcodes (eg. vdelayxq) allow delaying 2 or 4 variables at once (stereo or quad signals); this is much more efficient than using separate opcodes for each channel.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayxq/#examples","title":"Examples","text":"<p>Here is an example of the vdelayxq opcode. It uses the file vdelayxq.csd.</p> Example of the vdelayxq opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayxq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1 \n\nims   = .5                                              ;maximum delay time in seconds\niws   = 1024                                            ;window size\nadl   = .5\naout1  diskin2 \"drumsMlp.wav\", 1, 0, 1                  ;loop drumsMlp.wav\naout2  diskin2 \"fox.wav\", 1, 0, 1                       ;loop fox.wav\naout3  diskin2 \"Church.wav\", 1, 0, 1                    ;loop Church.wav\naout4  diskin2 \"flute.aiff\", 1, 0, 1                    ;loop flute.aiff\na2    poscil .1, .5, 1                                  ;make an LFO, 1 cycle per 2 seconds\nadl   = a2 + ims/2                                      ;offset the LFO so that it is positive\naout1, aout2, aout3, aout4 vdelayxq aout1, aout2, aout3, aout4, adl, ims, iws; Use the LFO to control delay time\n      outq aout1, aout2, aout3, aout4\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 10 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Two important points here. First, the delay time must be always positive. And second, even though the delay time can be controlled in k-rate, it is not advised to do so, since sudden time changes will create clicks.</p>"},{"location":"opcodes/vdelayxq/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelayxs/","title":"Vdelayxs","text":""},{"location":"opcodes/vdelayxs/#vdelayxs","title":"vdelayxs","text":"<p>A stereo variable delay opcode with high quality interpolation.</p>"},{"location":"opcodes/vdelayxs/#syntax","title":"Syntax","text":"<pre><code>aout1, aout2 vdelayxs ain1, ain2, adl, imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayxs/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayxs/#performance","title":"Performance","text":"<p>aout1, aout2 -- output audio signals</p> <p>ain1, ain2 -- input audio signals</p> <p>adl -- delay time in seconds</p> <p>This opcode uses high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p>The multichannel opcodes (eg. vdelayxq) allow delaying 2 or 4 variables at once (stereo or quad signals); this is much more efficient than using separate opcodes for each channel.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayxs/#examples","title":"Examples","text":"<p>Here is an example of the use of the vdelayxs opcode. It uses the file vdelayxs.csd.</p> Example of the _vdelayxs_ opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayxs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  =  .5                                              ;maximum delay time in seconds\niws  =  1024                                            ;window size\nadl  =  .5                                              ;delay time\nasig1, asig2 diskin2 \"drumsSlp.wav\", 1, 0, 1            ;loop stereo file\na2   poscil .25, .1, 1                                  ;make an LFO, 1 cycle per 2 seconds\nadl  = a2 + ims/2                                       ;offset the LFO so that it is positive\naoutL, aoutR vdelayxs asig1, asig2, adl, ims, iws       ;use the LFO to control delay time\n     outs aoutL, aoutR\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/vdelayxs/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelayxw/","title":"Vdelayxw","text":""},{"location":"opcodes/vdelayxw/#vdelayxw","title":"vdelayxw","text":"<p>Variable delay opcodes with high quality interpolation.</p>"},{"location":"opcodes/vdelayxw/#syntax","title":"Syntax","text":"<pre><code>aout vdelayxw ain, adl, imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayxw/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayxw/#performance","title":"Performance","text":"<p>aout -- output audio signal</p> <p>ain -- input audio signal</p> <p>adl -- delay time in seconds</p> <p>These opcodes use high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p>The vdelayxw opcodes change the position of the write tap in the delay line (unlike all other delay ugens that move the read tap), and are most useful for implementing Doppler effects where the position of the listener is fixed, and the sound source is moving.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayxw/#examples","title":"Examples","text":"<p>Here is an example of the use of the vdelayxw opcode. It uses the file vdelayxw.csd.</p> Example of the _vdelayxw_ opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayxw.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  =  .5                              ;maximum delay time in seconds\niws  =  1024                            ;best quality\nadl  =  .5                              ;delay time\nasig diskin2 \"flute.aiff\", .5, 0, 1     ;loop flute.aiff at half speed\na2   poscil3 .2, .1, 1                  ;make an LFO, 1 cycle per 2 seconds\nadl  = a2 + ims/2                       ;offset the LFO so that it is positive\naout vdelayxw asig, adl, ims, iws       ;use the LFO to control delay time\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/vdelayxw/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelayxwq/","title":"Vdelayxwq","text":""},{"location":"opcodes/vdelayxwq/#vdelayxwq","title":"vdelayxwq","text":"<p>Variable delay opcodes with high quality interpolation.</p>"},{"location":"opcodes/vdelayxwq/#syntax","title":"Syntax","text":"<pre><code>aout1, aout2, aout3, aout4 vdelayxwq ain1, ain2, ain3, ain4, adl, \\\n                           imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayxwq/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayxwq/#performance","title":"Performance","text":"<p>ain1, ain2, ain3, ain4 -- input audio signals</p> <p>aout1, aout2, aout3, aout4 -- output audio signals</p> <p>adl -- delay time in seconds</p> <p>These opcodes use high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p>The vdelayxw opcodes change the position of the write tap in the delay line (unlike all other delay ugens that move the read tap), and are most useful for implementing Doppler effects where the position of the listener is fixed, and the sound source is moving.</p> <p>The multichannel opcodes (eg. vdelayxq) allow delaying 2 or 4 variables at once (stereo or quad signals); this is much more efficient than using separate opcodes for each channel.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayxwq/#examples","title":"Examples","text":"<p>Here is an example of the use of the vdelayxwq opcode. It uses the file vdelayxwq.csd.</p> Example of the _vdelayxwq_ opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayxwq.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 4\n0dbfs  = 1\n\ninstr 1 \n\nims  =  .5                              ;maximum delay time in seconds\niws  =  1024                            ;best quality\nadl  =  .5                              ;delay time\naout1  diskin2 \"drumsMlp.wav\", 1, 0, 1  ;loop drumsMlp.wav\naout2  diskin2 \"fox.wav\", 1, 0, 1       ;loop fox.wav\naout3  diskin2 \"Church.wav\", 1, 0, 1    ;loop Church.wav\naout4  diskin2 \"flute.aiff\", 1, 0, 1    ;loop flute.aiff\na2   poscil3 .2, .1, 1                  ;make an LFO, 1 cycle per 2 seconds\nadl  = a2 + ims/2                       ;offset the LFO so that it is positive\naout1, aout2, aout3, aout4 vdelayxwq aout1, aout2, aout3, aout4, adl, ims, iws  ;use the LFO to control delay time\n     outq aout1, aout2, aout3, aout4\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/vdelayxwq/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/vdelayxws/","title":"Vdelayxws","text":""},{"location":"opcodes/vdelayxws/#vdelayxws","title":"vdelayxws","text":"<p>Variable delay opcodes with high quality interpolation.</p>"},{"location":"opcodes/vdelayxws/#syntax","title":"Syntax","text":"<pre><code>aout1, aout2 vdelayxws ain1, ain2, adl, imd, iws [, ist]\n</code></pre>"},{"location":"opcodes/vdelayxws/#initialization","title":"Initialization","text":"<p>imd -- max. delay time (seconds)</p> <p>iws -- interpolation window size (see below)</p> <p>ist (optional) -- skip initialization if not zero</p>"},{"location":"opcodes/vdelayxws/#performance","title":"Performance","text":"<p>ain1, ain2 -- input audio signals</p> <p>aout1, aout2 -- output audio signals</p> <p>adl -- delay time in seconds</p> <p>These opcodes use high quality (and slow) interpolation, that is much more accurate than the currently available linear and cubic interpolation. The iws parameter sets the number of input samples used for calculating one output sample (allowed values are any integer multiply of 4 in the range 4 - 1024); higher values mean better quality and slower speed.</p> <p>The vdelayxw opcodes change the position of the write tap in the delay line (unlike all other delay ugens that move the read tap), and are most useful for implementing Doppler effects where the position of the listener is fixed, and the sound source is moving.</p> <p>The multichannel opcodes (eg. vdelayxq) allow delaying 2 or 4 variables at once (stereo or quad signals); this is much more efficient than using separate opcodes for each channel.</p> <p> Notes</p> <ul> <li>Delay time is measured in seconds (unlike in vdelay and vdelay3), and must be a-rate.</li> <li>The minimum allowed delay is iws/2 samples.</li> <li>Using the same variables as input and output is allowed in these opcodes.</li> <li>In vdelayxw*, changing the delay time has some effects on output volume: <pre><code>a = 1 / (1 + dt)\n</code></pre>  where a is the output gain, and dt is the change of delay time per seconds.</li> <li>These opcodes are best used in the double-precision version of Csound.</li> </ul>"},{"location":"opcodes/vdelayxws/#examples","title":"Examples","text":"<p>Here is an example of the use of the vdelayxws opcode. It uses the file vdelayxws.csd.</p> Example of the _vdelayxws_ opcode.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vdelayxws.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2022\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nims  =  .5                                              ;maximum delay time in seconds\niws  =  512                                             ;window size\nadl  =  .5                                              ;delay time\nasig1, asig2 diskin2 \"drumsSlp.wav\", 1, 0, 1            ;loop stereo file drumsSlp.wav\na2   poscil .2, .25                                     ;make an LFO, 4 cycle per 10 seconds\nadl  = a2 + ims/2                                       ;offset the LFO so that it is positive\naoutL, aoutR vdelayxws asig1, asig2, adl, ims, iws      ;use the LFO to control delay time\n     outs aoutL * .8, aoutR * .8\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 8192 10 1\n\ni 1 0 11\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"opcodes/vdelayxws/#see-also","title":"See also","text":"<p>Delay</p>"},{"location":"opcodes/veloc/","title":"Veloc","text":""},{"location":"opcodes/veloc/#veloc","title":"veloc","text":"<p>Get the velocity from a MIDI event.</p>"},{"location":"opcodes/veloc/#syntax","title":"Syntax","text":"<pre><code>ival veloc [ilow] [, ihigh]\n</code></pre>"},{"location":"opcodes/veloc/#initialization","title":"Initialization","text":"<p>ilow, ihigh -- low and hi ranges for mapping</p>"},{"location":"opcodes/veloc/#performance","title":"Performance","text":"<p>Get the MIDI byte value (0 - 127) denoting the velocity of the current event.</p>"},{"location":"opcodes/veloc/#examples","title":"Examples","text":"<p>Here is an example of the veloc opcode. It uses the files veloc.csd and midiChords.mid.</p> Example of the veloc opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  -m0d --midi-key-cps=4  -F midiChords.mid\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel - 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; midiChords.mid can be found in examples folder\n\ninstr 1\n\nivel veloc 0, 1                 ;re-scale velocity to 0 - 1\nprint ivel                              ;print velocity\nasig vco2 .1*ivel, p4   ;\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1 0 35     ;midi file = 35 seconds\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/veloc/#see-also","title":"See also","text":"<p>MIDI input and Initialization</p>"},{"location":"opcodes/veloc/#credits","title":"Credits","text":"<p>Author: Barry L. Vercoe - Mike Berry MIT - Mills May 1997</p>"},{"location":"opcodes/vibes/","title":"Vibes","text":""},{"location":"opcodes/vibes/#vibes","title":"vibes","text":"<p>Physical model related to the striking of a metal block as found in a vibraphone.</p> <p>The method is a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/vibes/#syntax","title":"Syntax","text":"<pre><code>ares vibes kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec\n</code></pre>"},{"location":"opcodes/vibes/#initialization","title":"Initialization","text":"<p>ihrd -- the hardness of the stick used in the strike. A range of 0 to 1 is used. 0.5 is a suitable value.</p> <p>ipos -- where the block is hit, in the range 0 to 1.</p> <p>imp -- a table of the strike impulses. The file marmstk1.wav is a suitable function from measurements and can be loaded with a GEN01 table. It is also available at ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p> <p>ivfn -- shape of tremolo, usually a sine table, created by a function</p> <p>idec --  time before end of note when damping is introduced</p>"},{"location":"opcodes/vibes/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kvibf -- frequency of tremolo in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the tremolo</p>"},{"location":"opcodes/vibes/#examples","title":"Examples","text":"<p>Here is an example of the vibes opcode. It uses the file vibes.csd, and marmstk1.wav.</p> Example of the vibes opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o vibes.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 2\n\n; Instrument #1.\ninstr 1\n  ; kamp = 20000\n  ; kfreq = 440\n  ; ihrd = 0.5\n  ; ipos = p4\n  ; imp = 1\n  ; kvibf = 6.0\n  ; kvamp = 0.05\n  ; ivibfn = 2\n  ; idec = 0.1\nasig    vibes   20000, 440, .5, p4 , 1, 6.0, 0.05, 2, .1\n        outs            asig, asig\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, the \"marmstk1.wav\" audio file.\nf 1 0 256 1 \"marmstk1.wav\" 0 0 0\n; Table #2, a sine wave for the vibrato.\nf 2 0 128 10 1\n\n; Play Instrument #1 for four seconds.\ni 1 0 4 0.561\ni 1 + 4 1\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>A musical example featuring the vibes opcode: Vibes_Pena.csd, by luis Antunes Pena.</p>"},{"location":"opcodes/vibes/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/vibes/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/vibr/","title":"Vibr","text":""},{"location":"opcodes/vibr/#vibr","title":"vibr","text":"<p>Easier-to-use user-controllable vibrato.</p>"},{"location":"opcodes/vibr/#syntax","title":"Syntax","text":"<pre><code>kout vibr kAverageAmp, kAverageFreq, ifn\n</code></pre>"},{"location":"opcodes/vibr/#initialization","title":"Initialization","text":"<p>ifn -- Number of vibrato table. It normally contains a sine or a triangle wave.</p>"},{"location":"opcodes/vibr/#performance","title":"Performance","text":"<p>kAverageAmp -- Average amplitude value of vibrato</p> <p>kAverageFreq -- Average frequency value of vibrato (in cps)</p> <p>vibr is an easier-to-use version of vibrato. It has the same generation-engine of vibrato, but the parameters corresponding to missing input arguments are hard-coded to default values.</p>"},{"location":"opcodes/vibr/#examples","title":"Examples","text":"<p>Here is an example of the vibr opcode. It uses the file vibr.csd.</p> Example of the vibr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vibr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkaverageamp  init 500\nkaveragefreq init 4\nkvib vibr kaverageamp, kaveragefreq, 1\nasig poscil .8, 220+kvib, 1             ;add vibrato\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1       ;sine wave\n\ni 1 0 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vibr/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/vibr/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.15</p>"},{"location":"opcodes/vibrato/","title":"Vibrato","text":""},{"location":"opcodes/vibrato/#vibrato","title":"vibrato","text":"<p>Generates a natural-sounding user-controllable vibrato.</p>"},{"location":"opcodes/vibrato/#syntax","title":"Syntax","text":"<pre><code>kout vibrato kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq, \\\n             kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs]\n</code></pre>"},{"location":"opcodes/vibrato/#initialization","title":"Initialization","text":"<p>ifn -- Number of vibrato table. It normally contains a sine or a triangle wave.</p> <p>iphs -- (optional) Initial phase of table, expressed as a fraction of a cycle (0 to 1). A negative value will cause phase initialization to be skipped. The default value is 0.</p>"},{"location":"opcodes/vibrato/#performance","title":"Performance","text":"<p>kAverageAmp -- Average amplitude value of vibrato</p> <p>kAverageFreq -- Average frequency value of vibrato (in cps)</p> <p>kRandAmountAmp -- Amount of random amplitude deviation</p> <p>kRandAmountFreq -- Amount of random frequency deviation</p> <p>kAmpMinRate -- Minimum frequency of random amplitude deviation segments (in cps)</p> <p>kAmpMaxRate -- Maximum frequency of random amplitude deviation segments (in cps)</p> <p>kcpsMinRate -- Minimum frequency of random frequency deviation segments (in cps)</p> <p>kcpsMaxRate -- Maximum frequency of random frequency deviation segments (in cps)</p> <p>vibrato outputs a natural-sounding user-controllable vibrato. The concept is to randomly vary both frequency and amplitude of the oscillator generating the vibrato, in order to simulate the irregularities of a real vibrato.</p> <p>In order to have a total control of these random variations, several input arguments are present. Random variations are obtained by two separated segmented lines, the first controlling amplitude deviations, the second the frequency deviations. Average duration of each segment of each line can be shortened or enlarged by the arguments kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, and the deviation from the average amplitude and frequency values can be independently adjusted by means of kRandAmountAmp and kRandAmountFreq.</p>"},{"location":"opcodes/vibrato/#examples","title":"Examples","text":"<p>Here is an example of the vibrato opcode. It uses the file vibrato.csd.</p> Example of the vibrato opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vibrato.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkaverageamp     init .5\nkaveragefreq    init 5\nkrandamountamp  line p4, p3, p5           ;increase random amplitude of vibrato\nkrandamountfreq init .3\nkampminrate init 3\nkampmaxrate init 5\nkcpsminrate init 3\nkcpsmaxrate init 5\nkvib vibrato kaverageamp, kaveragefreq, krandamountamp, krandamountfreq, \\\n             kampminrate, kampmaxrate, kcpsminrate, kcpsmaxrate, 1\nasig poscil .8, 220+kvib, 1               ;add vibrato\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1       ;sine wave\n\ni 1 0 15 .01 20\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vibrato/#see-also","title":"See also","text":"<p>Basic Oscillators</p>"},{"location":"opcodes/vibrato/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Version 4.15</p>"},{"location":"opcodes/vincr/","title":"Vincr","text":""},{"location":"opcodes/vincr/#vincr","title":"vincr","text":"<p>Increments one audio variable with another signal, i.e. it accumulates output.</p>"},{"location":"opcodes/vincr/#syntax","title":"Syntax","text":"<pre><code>vincr accum, aincr\n</code></pre>"},{"location":"opcodes/vincr/#performance","title":"Performance","text":"<p>accum -- audio-rate accumulator variable to be incremented</p> <p>aincr -- incrementing signal</p> <p>vincr (variable increment) and clear are intended to be used together. vincr stores the result of the sum of two audio variables into the first variable itself (which is intended to be used as an accumulator in polyphony). The accumulator is typically a global variable that is used to combine signals from several sources (different instruments or instrument instances) for further processing (for example, via a global effect that reads the accumulator) or for outputting the combined signal by some means other than one of the out opcodes (eg. via the fout opcode). After the accumulator is used, the accumulator variable should be set to zero by means of the clear opcode (or it will explode).</p>"},{"location":"opcodes/vincr/#examples","title":"Examples","text":"<p>The following example uses the vincr opcode. It uses the file vincr.csd.</p> Example of the vincr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vincr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngaReverb init 0\n\ninstr 1\n\nidur    = p3\nkpitch  = p4\na1      diskin2 \"fox.wav\", kpitch\na1      = a1*.5                 ;reduce volume\n        vincr   gaReverb, a1\nendin\n\ninstr 99 ; global reverb                \nal, ar  reverbsc gaReverb, gaReverb, .8, 10000\n        outs    gaReverb+al, gaReverb+ar\n        clear   gaReverb\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni1  0 3 1\ni99 0 5\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is another example uses the vincr opcode. It uses the file vincr-complex.csd.</p> <pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vincr-complex.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngaReverbSend init 0\n\ninstr 1\n\niamp   = p4\nifreq  = p5\naenv   linseg  0.0, 0.1*p3, iamp, 0.6*p3, iamp, 0.3*p3, 0.0\naosc   poscil aenv, ifreq, 1\n       vincr   gaReverbSend, aosc\nendin\n\n\ninstr 2 ; global reverb instrument\n\nal, ar reverbsc gaReverbSend, gaReverbSend, 0.85, 12000\n       outs     gaReverbSend+al, gaReverbSend+ar\n       clear    gaReverbSend\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1\n\n{ 4 CNT\n  { 8 PARTIAL\n      ;   start time     duration            amplitude          frequency     \n      i1  [0.5 * $CNT.]  [1 + ($CNT * 0.2)]  [.04 + (~ * .02)]  [800 + (200 * $CNT.) + ($PARTIAL. * 20)]\n  }\n}\n\ni2 0 6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vincr/#see-also","title":"See also","text":"<p>File Input and Output</p> <p>Comparators and Accumulators</p>"},{"location":"opcodes/vincr/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy 1999</p> <p>New in Csound version 3.56</p>"},{"location":"opcodes/vlowres/","title":"Vlowres","text":""},{"location":"opcodes/vlowres/#vlowres","title":"vlowres","text":"<p>A bank of filters in which the cutoff frequency can be separated under user control.</p>"},{"location":"opcodes/vlowres/#syntax","title":"Syntax","text":"<pre><code>ares vlowres asig, kfco, kres, iord, ksep\n</code></pre>"},{"location":"opcodes/vlowres/#initialization","title":"Initialization","text":"<p>iord -- total number of filters (1 to 10)</p>"},{"location":"opcodes/vlowres/#performance","title":"Performance","text":"<p>asig -- input signal</p> <p>kfco -- frequency cutoff (not in Hz)</p> <p>kres -- resonance amount</p> <p>ksep -- frequency cutoff separation for each filter: the first filter has a kfreq cutoff, the second has a kfreq + ksep and the third  kfreq + 2*ksep and so on, depending on the number of filters.</p> <p>vlowres (variable resonant lowpass filter) allows a variable response curve in resonant filters. It can be thought of as a bank of lowpass resonant filters, each with the same resonance, serially connected. The frequency cutoff of each filter can vary with the kcfo and ksep parameters.</p>"},{"location":"opcodes/vlowres/#examples","title":"Examples","text":"<p>Here is an example of the vlowres opcode. It uses the file vlowres.csd.</p> Example of the vlowres opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o vlowres.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n\ninstr 1\n\nkamp init p4\nasig vco2  kamp, 110                    ;saw wave\nkfco line 30, p3, 300                   ;vary the cutoff frequency from 30 to 300 Hz.\nkres = 20       \nksep = p5                               ;different resonance values\niord = p6                               ;and different number of filters\naout vlowres asig, kfco, kres, iord, ksep\naclp clip aout, 1, 1                    ;avoid distortion\n     outs aclp, aclp\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine\n\ns\ni 1 0 10 .1 5  2        ;compensate volume and \ni 1 + 10 .1 25 2        ;number of filters = 2\ns\ni 1 0 10 .01 5  6       ;compensate volume and \ni 1 + 10 .04 15 6       ;number of filters = 6\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vlowres/#see-also","title":"See also","text":"<p>Standard Filters: Resonant Low-pass filters</p>"},{"location":"opcodes/vlowres/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/voice/","title":"Voice","text":""},{"location":"opcodes/voice/#voice","title":"voice","text":"<p>An emulation of a human voice.</p>"},{"location":"opcodes/voice/#syntax","title":"Syntax","text":"<pre><code>ares voice kamp, kfreq, kphoneme, kform, kvibf, kvamp, ifn, ivfn\n</code></pre>"},{"location":"opcodes/voice/#initialization","title":"Initialization","text":"<p>ifn, ivfn -- two table numbers containing the carrier waveform and the vibrato waveform. The files impuls20.aiff, ahh.aiff, eee.aiff, or ooo.aiff are suitable for the first of these, and a sine wave for the second. These files are available from ftp://ftp.cs.bath.ac.uk/pub/dream/documentation/sounds/modelling/.</p>"},{"location":"opcodes/voice/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played. It can be varied in performance.</p> <p>kphoneme -- an integer in the range 0 to 16, which select the formants for the sounds:</p> <ul> <li>\u201ceee\u201d, \u201cihh\u201d, \u201cehh\u201d, \u201caaa\u201d,</li> <li>\u201cahh\u201d, \u201caww\u201d, \u201cohh\u201d, \u201cuhh\u201d,</li> <li>\u201cuuu\u201d, \u201cooo\u201d, \u201crrr\u201d, \u201clll\u201d,</li> <li>\u201cmmm\u201d, \u201cnnn\u201d, \u201cnng\u201d, \u201cngg\u201d.</li> </ul> <p>At present the phonemes</p> <ul> <li>\u201cfff\u201d, \u201csss\u201d, \u201cthh\u201d, \u201cshh\u201d,</li> <li>\u201cxxx\u201d, \u201chee\u201d, \u201choo\u201d, \u201chah\u201d,</li> <li>\u201cbbb\u201d, \u201cddd\u201d, \u201cjjj\u201d, \u201cggg\u201d,</li> <li>\u201cvvv\u201d, \u201czzz\u201d, \u201cthz\u201d, \u201czhh\u201d</li> </ul> <p>are not available (!)</p> <p>kform -- Gain on the phoneme. values 0.0 to 1.2 recommended.</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/voice/#examples","title":"Examples","text":"<p>Here is an example of the voice opcode. It uses the file voice.csd, and impuls20.aiff.</p> Example of the voice opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o voice.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp  = p4\nkphon = p5\nasig  voice kamp, 200, kphon, 0.488, 0, 1, 1, 2\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 256 1 \"impuls20.aiff\" 0 0 0       ;audio file for the carrier waveform\nf 2 0 256 10 1                          ;sine wave for the vibrato waveform\n\n;       ampl phoneme\ni 1 0 2 0.8    1\ni 1 + . 0.6    2\ni 1 + . 1.8    3\ni 1 + . 15.0   4\ni 1 + . 0.05   5\ni 1 + . 0.06   6\ni 1 + . 0.03   7\ni 1 + . 0.0002 8\ni 1 + . 0.1    9\ni 1 + . 0.5   10\ni 1 + . 100   11\ni 1 + . 0.03  12\ni 1 + . 0.04  13\ni 1 + . 0.04  14\ni 1 + . 0.04  15\ni 1 + . 0.05  16\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/voice/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"opcodes/voice/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/vosim/","title":"Vosim","text":""},{"location":"opcodes/vosim/#vosim","title":"vosim","text":"<p>Simple vocal simulation based on glottal pulses with formant characteristics.</p> <p>Output is a series of sound events, where each event is composed of a burst of squared sine pulses followed by silence. The VOSIM (VOcal SIMulation) synthesis method was developed by Kaegi and Tempelaars in the 1970's.</p>"},{"location":"opcodes/vosim/#syntax","title":"Syntax","text":"<pre><code>ar vosim kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip]\n</code></pre> <p>Intialization</p> <p>ifn - a sound table, normally containing half a period of a sinewave, squared (see notes below).</p> <p>iskip - (optional) Skip initialization, for tied notes.</p>"},{"location":"opcodes/vosim/#performance","title":"Performance","text":"<p>ar - output signal. Note that the output is usually unipolar - positive only.</p> <p>kamp - output amplitude, the peak amplitude of the first pulse in each burst.</p> <p>kFund - fundamental pitch, in Herz. Each event is 1/kFund seconds long.</p> <p>kForm - formant center frequency. Length of each pulse in the burst is 1/kForm seconds.</p> <p>kDecay - a dampening factor from pulse to pulse. This is subtracted from amplitude on each new pulse.</p> <p>kPulseCount - number of pulses in the burst part of each event.</p> <p>kPulseFactor - the pulse width is multiplied by this value at each new pulse. This results in formant sweeping. If factor is  &lt; 1.0, the formant sweeps up, if &gt; 1.0 each new pulse is longer, so the formant sweeps down. The final pitch of the formant is kForm * pow(kPulseFactor, kPulseCount)</p> <p>The output of vosim is a series of sound events, where each event is composed of a burst of squared sine pulses followed by silence. The total duration of the events determines fundamental frequency. The length of each single pulse in the squared-sine bursts produce a formant frequency band. The width of the formant is determined by rate of silence to pulses (see below). The final result is also shaped by the dampening factor from pulse to pulse.</p> <p>A small practical problem in using this opcode is that no GEN function will create a squared sine wave out of the box. Something like the following can be used to create the appropriate table from the score.</p> <pre><code>; use GEN09 to create half a sine in table 17\nf 17 time size 9  0.5  1 0\n\n; run instr 101 on table 17 for a single init-pass\ni 101 0 0 17\n</code></pre> <p>It can also be done with an instrument writing to an f-table in the orchestra:</p> <pre><code>; square each point in table #p4. This should be run as init-only,\n; just once in the performance.\n\ninstr 101\n    index tableng p4\n    index = index - 1  ; start from last point\nloop:\n    ival table index, p4\n    ival = ival * ival\n    tableiw ival, index, p4\n    index = index - 1\n    if index &lt; 0 igoto endloop\n        igoto loop\nendloop:\nendin\n</code></pre> <p> Parameter Limits</p> <p>The count of pulses multiplied by pulse width should fit in the event length (1/kFund). If this is not fulfilled, the algorithm does not break, we just do not start any pulses that would outlast the event. This might introduce a silence at end of event even if none was intended. In consequence, kForm should be higher than kFund, otherwise only silence is output.</p> <p>Vosim was created to emulate voice sounds using a model of glottal pulse. Rich sounds can be created by combining several instances of vosim with different parameters. One drawback is that the signal is not band-limited. But as the authors point out, attenuation of high-pitch components is -60 dB at 6 times the fundamental frequency. The signal can also be changed by changing the source signal in the lookup table. The technique has historical interest, and can produce rich sound very cheaply (each sample requires only a table lookup and a single multiplication for attenuation).</p> <p>As stated, formant bandwidth depends on the ratio between pulse burst and silence in an event. But this is not an independent parameter: The fundamental decides event length, and formant center defines the pulse length. It is therefore impossible to guarantee a specific burst/silence ratio, since the burst length has to be an integer multiple of pulse length. The decay of pulses can be used to smooth the transition from N to N+/-1 pulses, but there will still be steps in the spectral profile of output. The example code below shows one approach to this.</p> <p>All input parameters are k-rate. The input parameters are only used to set up each new event (or grain). Event amplitude is fixed for each event at initialization. In normal parameter ranges, when ksmps &lt;500, the k-rate parameters are updated more often than events are created. In any case, no wide-band noise will be injected in the system due to k-rate inputs being updated less often than they are read, but some other artefacts could be created.</p> <p>The opcode should behave reasonably in the face of all user inputs. Some details:</p> <ol> <li>kFund &lt; 0: This is forced to positive - no point in \"reversed\" events.</li> <li>kFund == 0: This leads to \"infinite\" length event, ie a pulse burst followed by very long indefinite silence.</li> <li>kForm == 0: This leads to infinite length pulse, so no pulses are generated (i.e. silence).</li> <li>kForm &lt; 0: Table is read backward. If table is symmetric, kform and -kform should give bit-identical outputs.</li> <li>kPulseFactor == 0: Second pulse onwards is zero. See (3).</li> <li>kPulseFactor &lt; 0: Pulses alternately read table forward and reversed.</li> </ol> <p>With asymmetric pulse table there may be some use for negative kForm or negative kPulseFactor.</p>"},{"location":"opcodes/vosim/#examples","title":"Examples","text":"<p>Here is an example of the vosim opcode. It uses the file vosim.csd.</p> Example of the vosim opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n;-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n -o vosim.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr     = 44100\nksmps  = 100\nnchnls = 1\n\n;#################################################\n; By Rasmus Ekman 2008\n\n; Square each point in table #p4. This should only be run once in the performance.\ninstr 10\n\n        index tableng p4\n        index = index - 1  ; start from last point\nloop:\n        ival table index, p4\n        ival = ival * ival\n        tableiw ival, index, p4\n        index = index - 1\n        if index &lt; 0 igoto endloop\n                igoto loop\nendloop: \nendin\n\n;#################################################\n\n; vosim instrument. Sweeps kfund and kform between start-end values.\n; Attempts to smooth spectral transitions as pulse count changes\n; p4:     amp\n; p5, p6: fund beg-end\n; p7, p8: form beg-end\n; p9:     amp decay (ignored)\n; p10:    pulse count (ignored - calc internally)\n; p11:    pulse length mod\n; p12:    skip (for tied events)\n; p13:    don't fade out (if followed by tied note)\ninstr 1\n    kamp  init  p4\n    ; freq start, end\n    kfund  line  p5, p3, p6\n    ; formant start, end\n    kform  line  p7, p3, p8\n\n        ; Get many pulses as we can fit\n        kPulseCount  = (kform / kfund)  ;init p10\n\n        ; Attempt to smooth steps between formant bandwidth,\n        ; matching decay to the current pulse count and remaining silent part\n        kPulseREM = kPulseCount - int(kPulseCount) ; Pulse remainder (empty samples after last pulse)\n        kDroprate = kPulseREM / (kPulseCount-1)   ; Decay per pulse (after the 1st)\n        kDecay = kamp - kDroprate\n        ; Guard against kamp going negative (since kDecay is subtracted from each pulse)\n        if (kDecay * (kPulseCount-1)) &gt; kamp then\n                kDecay = kamp / kPulseCount\n        endif\n\n        ; Try this to get more bumpy spectral changes when pulse count changes\n        ;kDecay = p9\n\n        kPulseFactor init p11\n\n;  ar   vosim   kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip]\n    ar1 vosim   kamp, kfund, kform, kDecay, kPulseCount, kPulseFactor, 17, p12\n\n    ; scale amplitude for 16-bit files, with quick fade out\n    amp init 20000\n    if (p13 != 0) goto nofade\n        amp linseg 20000, p3-.02, 20000, .02, 0\nnofade:\n        out ar1 * amp\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf1       0  32768    9  1    1  0   ; sine wave\nf17      0  32768    9  0.5  1  0   ; half sine wave\ni10 0 0 17 ; init run only, square table 17\n\n; Vosim score\n\n; Picking some formants from the table in Csound manual\n\n;      p4=amp  fund     form      decay pulses pulsemod [skip] nofade\n; tenor a -&gt; e\ni1 0  .5  .5   280 240  650  400   .03   5      1      0      0\ni1 .  .   .3   .   .    1080 1700  .03   5      .      .      .\ni1 .  .   .2   .   .    2650 2600  .03   5      .      .      .\ni1 .  .   .15  .   .    2900 3200  .03   5      .      .      .\n\n; tenor a -&gt; o\ni1 0.6 .2  .5  300 210  650  400   .03   5      1      0      1\ni1 .   .   .3  .   .    1080 800   .03   5      .      .      .\ni1 .   .   .2  .   .    2650 2600  .03   5      .      .      .\ni1 .   .   .15 .   .    2900 2800  .03   5      .      .      .\n; tenor o -&gt; aah\ni1 .8  .3  .5  210 180  400  650   .03   5      1      1      1\ni1 .   .   .3  .   .    800  1080  .03   5      .      .      .\ni1 .   .   .2  .   .    2600 2650  .03   5      .      .      .\ni1 .   .   .15 .   .    2800 2900  .03   5      .      .      .\n; tenor aa -&gt; i\ni1 1.1 .2  .5  180 250  650  290   .03   5      1      1      1\ni1 .   .   .3  .   .    1080 1870  .03   5      .      .      .\ni1 .   .   .2  .   .    2650 2800  .03   5      .      .      .\ni1 .   .   .15 .   .    2900 3250  .03   5      .      .      .\n; tenor i -&gt; u\ni1 1.3 .3  .5  250 270  290  350   .03   5      1      1      0\ni1 .   .   .3  .   .    1870 600   .03   5      .      .      .\ni1 .   .   .2  .   .    2800 2700  .03   5      .      .      .\ni1 .   .   .15 .   .    3250 2900  .03   5      .      .      .\n\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vosim/#see-also","title":"See Also","text":"<p>Granular Synthesis</p>"},{"location":"opcodes/vosim/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman March 2008</p>"},{"location":"opcodes/vphaseseg/","title":"Vphaseseg","text":""},{"location":"opcodes/vphaseseg/#vphaseseg","title":"vphaseseg","text":"<p>Allows one-dimensional HVS (Hyper-Vectorial Synthesis).</p>"},{"location":"opcodes/vphaseseg/#syntax","title":"Syntax","text":"<pre><code>vphaseseg kphase, ioutab, ielems, itab1,idist1,itab2 \\\n          [,idist2,itab3, ... ,idistN-1,itabN]\n</code></pre>"},{"location":"opcodes/vphaseseg/#initialization","title":"Initialization","text":"<p>ioutab - number of output table.</p> <p>ielem - number of elements to process</p> <p>itab1,...,itabN - breakpoint table numbers</p> <p>idist1,...,idistN-1 -  distances between breakpoints in percentage values</p>"},{"location":"opcodes/vphaseseg/#performance","title":"Performance","text":"<p>kphase - phase pointer</p> <p>vphaseseg returns the coordinates of section points of an N-dimensional space path. The coordinates of section points are stored into an output table. The number of dimensions of the N-dimensional space is determined by the ielem argument that is equal to N and can be set to any number. To define the path, user have to provide a set of points of the N-dimensional space, called break-points. Coordinates of each break-point must be contained by a different table. The number of coordinates to insert in each break-point table must obviously equal to ielem argument. There can be any number of break-point tables filled by the user.</p> <p>Hyper-Vectorial Synthesis actually deals with two kinds of spaces. The first space is the N-dimensional space in which the path is defined, this space is called time-variant parameter space (or SPACE A). The path belonging to this space is covered by moving a point into the second space that normally has a number of dimensions smaller than the first. Actually, the point in motion is the projection of corresponding point of the N-dimensional space (could also be considered a section of the path). The second space is called user-pointer-motion space (or SPACE B) and, in the case of vphaseseg opcode, has only ONE DIMENSION. Space B is covered by means of kphase argument (that is a sort of path pointer), and its range is 0 to 1. The output corresponding to current pointer value is stored in ioutab table, whose data can be afterwards used to control any syntesis parameters.</p> <p>In vphaseseg, each break-point is separated from the other by a distance expressed in percentage, where all the path length is equal to the sum of all distances. So distances between breakpoints can be different, differently from kinds of HVS in which space B has more than one dimension, in these cases distance between break-points MUST be THE SAME for all intervals.</p>"},{"location":"opcodes/vphaseseg/#see-also","title":"See also","text":"<p>Hyper Vectorial Synthesis</p>"},{"location":"opcodes/vphaseseg/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in version 5.06</p>"},{"location":"opcodes/vps/","title":"Vps","text":""},{"location":"opcodes/vps/#vps","title":"vps","text":"<p>Shapes a phase signal according to a two-dimensional vector.</p> <p>Vector phase shaping modifies a phase input value by mapping an input, in the range [0, 1) according to a non-linear function consisting of two piecewise linear segments joined at an inflection point. This is defined by the vector [kd, kv], where kd is in the range [0, 1) and kv can have any value.</p>"},{"location":"opcodes/vps/#syntax","title":"Syntax","text":"<pre><code>avp vps aph,kd,kv\n</code></pre>"},{"location":"opcodes/vps/#performance","title":"Performance","text":"<p>avp -- output phase.</p> <p>aph -- input phase (as produced by phasor).</p> <p>kd -- horizontal vector component.</p> <p>aph -- vertical vector component.</p>"},{"location":"opcodes/vps/#examples","title":"Examples","text":"<p>Here is an example of the use of the vps opcode. It uses the file vps.csd.</p> Example of the _vps_ opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac -d\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\nnchnls=1\nksmps = 1\n\ninstr 1\n kd = oscili:k(0.5,2) + 0.5\n kv = oscili:k(0.5,1.5) + 0.5\n aph = vps(phasor(p5),kd,kv)\n asig = p4*tablei:a(aph,-1,1,0.25,1)\n out(linenr(asig,0.1,0.1,0.01))\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 10 0.5 110 \n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/vps/#see-also","title":"See also","text":"<p>Phase Distortion</p>"},{"location":"opcodes/vps/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini July  2020</p>"},{"location":"opcodes/waveset/","title":"Waveset","text":""},{"location":"opcodes/waveset/#waveset","title":"waveset","text":"<p>A simple time stretch by repeating cycles.</p>"},{"location":"opcodes/waveset/#syntax","title":"Syntax","text":"<pre><code>ares waveset ain, krep [, ilen]\n</code></pre>"},{"location":"opcodes/waveset/#initialization","title":"Initialization","text":"<p>ilen (optional, default=0) -- the length (in samples) of the audio signal. If ilen is set to 0, it defaults to half the given note length (p3).</p>"},{"location":"opcodes/waveset/#performance","title":"Performance","text":"<p>ain -- the input audio signal.</p> <p>krep -- the number of times the cycle is repeated.</p> <p>The input is read and each complete cycle (two zero-crossings) is repeated krep times.</p> <p>There is an internal buffer as the output is clearly slower that the input.  Some care is taken if the buffer is too short, but there may be strange effects.</p>"},{"location":"opcodes/waveset/#examples","title":"Examples","text":"<p>Here is an example of the waveset opcode. It uses the file waveset.csd.</p> Example of the waveset opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o waveset.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs   =1\n\ninstr 1\n\nkrep init p4\nasig soundin \"flute.aiff\"\naout waveset asig, krep\n     outs aout, aout\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 3 1       ;no repetitions\ni 1 + 10 3      ;stretching 3 times\ni 1 + 14 6      ;6 times\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/waveset/#see-also","title":"See also","text":"<p>Sample Playback</p>"},{"location":"opcodes/waveset/#credits","title":"Credits","text":"<p>Author: John ffitch February 2001</p> <p>New in version 4.11</p>"},{"location":"opcodes/websocket/","title":"Websocket","text":""},{"location":"opcodes/websocket/#websocket","title":"websocket","text":"<p>Read and write signals and arrays using a websocket connection.</p> <p>Plugin opcode in websocketIO. This opcode is part of the plugin repository and has to be installed separately. The plugin repository can be found here: https://github.com/csound/plugins</p> <p>websocket reads and writes N signals and arrays using a websocket connection.</p>"},{"location":"opcodes/websocket/#syntax","title":"Syntax","text":"<pre><code>xout1[, xout2, xout3, ..., xoutN] websocket iport, xin\n</code></pre>"},{"location":"opcodes/websocket/#initialization","title":"Initialization","text":"<p>iport the local web port to read/write data.</p>"},{"location":"opcodes/websocket/#performance","title":"Performance","text":"<p>xout1,... xoutN -- The output variables which contain data received from a websocket. On the web side the websocket must send data using a protocol name that matches the output variable name e.g. \"ksignal\" for a k-rate variable. If an array is intended to be received from a websocket it must be first initialised before being used as an output to the opcode. Otherwise the opcode does not know what size data to expect from the websocket. When sending data to a websocket from the web page it must be sent as a 32 or 64 bit array, depending on the build of Csound that is being used.</p> <p>xin -- The input variable which contains data to be sent to a websocket. On the web side the websocket receives data using a protocol name that matches the input variable name e.g. \"ksignal\" for a k-rate variable. When receiving data from a websocket on the web page it must be read as a 32 or 64 bit array, depending on the build of Csound that is being used.</p> <p> Note</p> <p>The total number of input and output arguments is limited to 20.</p>"},{"location":"opcodes/websocket/#data-formatting","title":"Data Formatting","text":"<p>A-rate variables must be send and received as arrays that are ksmps samples large. A-rate arrays similarly are sent and received as ksmps by the number of elements in the array. K-rate variables are sent and received as a single element array. K-rate arrays are sent and received as arrays with matching numbers of elements.</p>"},{"location":"opcodes/websocket/#examples","title":"Examples","text":"<p>Here is a simple example of the websocket opcode. It uses the file websocket.csd and websocket.html.</p> Example of the websocket opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\n0dbfs = 1\nksmps = 256\nsr = 44100\n\nschedule 1, 0, -1\n\ninstr 1\n    klfo lfo 1, 1\n    iport init 8888\n    kinput websocket iport, klfo\n    printk2 kinput\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/websocket/#see-also","title":"See also","text":"<p>Signal Input</p> <p>Signal Output</p>"},{"location":"opcodes/websocket/#credits","title":"Credits","text":"<p>Author: Edward Costello; NUIM, 2015</p> <p>New in version 6.06</p>"},{"location":"opcodes/weibull/","title":"Weibull","text":""},{"location":"opcodes/weibull/#weibull","title":"weibull","text":"<p>Weibull distribution random number generator (positive values only).</p> <p>This is an x-class noise generator</p>"},{"location":"opcodes/weibull/#syntax","title":"Syntax","text":"<pre><code>ares weibull ksigma, ktau\nires weibull ksigma, ktau\nkres weibull ksigma, ktau\n</code></pre>"},{"location":"opcodes/weibull/#performance","title":"Performance","text":"<p>ksigma -- scales the spread of the distribution.</p> <p>ktau -- if greater than one, numbers near ksigma are favored. If smaller than one, small values are favored. If t equals 1, the distribution is exponential. Outputs only positive numbers.</p> <p>For more detailed explanation of these distributions, see:</p> <ol> <li>C. Dodge - T.A. Jerse 1985. Computer music. Schirmer books. pp.265 - 286</li> <li>D. Lorrain. A panoply of stochastic cannons. In C. Roads, ed. 1989. Music machine. Cambridge, Massachusetts: MIT press, pp. 351 - 379.</li> </ol>"},{"location":"opcodes/weibull/#examples","title":"Examples","text":"<p>Here is an example of the weibull opcode. It uses the file weibull.csd.</p> Example of the weibull opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o weibull.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1         ; every run time same values\n\nktri    weibull 100, 1\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 2         ; every run time different values\n\n        seed 0\nktri    weibull 100, 1\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n\ninstr 3         ; every run time different values\n\n        seed 0\nktri    weibull 100, 10                 ; closer to ksigma..\n        printk .2, ktri                 ; look \naout    oscili 0.8, 440+ktri, 1         ; &amp; listen\n        outs    aout, aout\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; sine wave\nf 1 0 16384 10 1\n\ni 1 0 2\ni 2 3 2\ni 3 6 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include a line like these:</p> <pre><code>i   1 time     0.00073:   168.59070\ni   1 time     0.20027:    98.72078\ni   1 time     0.40054:    48.57351\ni   1 time     0.60009:   171.46941\ni   1 time     0.80036:    50.20434\ni   1 time     1.00063:    50.84775\ni   1 time     1.20018:    18.16301\ni   1 time     1.40045:    44.41001\ni   1 time     1.60000:     0.98506\ni   1 time     1.80027:    36.19192\n\nWARNING: Seeding from current time 2444541554\n\ni   2 time     3.00045:    20.81653\ni   2 time     3.20000:   116.17060\ni   2 time     3.40027:     9.23891\ni   2 time     3.59982:    95.67111\ni   2 time     3.80009:   296.52851\ni   2 time     4.00036:    39.28636\ni   2 time     4.19991:    13.54326\ni   2 time     4.40018:    54.92388\ni   2 time     4.59973:   268.05584\ni   2 time     4.80000:    95.27069\ni   2 time     5.00027:    91.62076\n\nWARNING: Seeding from current time 2447542341\n\ni   3 time     6.00091:    94.40902\ni   3 time     6.20045:   111.10193\ni   3 time     6.40073:    99.38797\ni   3 time     6.60027:    98.54267\ni   3 time     6.80054:   106.53899\ni   3 time     7.00082:   106.30752\ni   3 time     7.20036:    88.75486\ni   3 time     7.40063:   106.45703\ni   3 time     7.60091:    84.59854\ni   3 time     7.80045:   106.76515\n</code></pre>"},{"location":"opcodes/weibull/#see-also","title":"See also","text":"<p>Random (Noise) Generators</p>"},{"location":"opcodes/weibull/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p>"},{"location":"opcodes/wgbow/","title":"Wgbow","text":""},{"location":"opcodes/wgbow/#wgbow","title":"wgbow","text":"<p>Creates a tone similar to a bowed string.</p> <p>It uses a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/wgbow/#syntax","title":"Syntax","text":"<pre><code>ares wgbow kamp, kfreq, kpres, krat, kvibf, kvamp [, ifn] [, iminfreq]\n</code></pre>"},{"location":"opcodes/wgbow/#initialization","title":"Initialization","text":"<p>ifn -- optional table of shape of vibrato, defaults to a sine table.</p> <p>iminfreq (optional) -- lowest frequency at which the instrument will play. If it is omitted it is taken to be the same as the initial kfreq. If iminfreq is negative, initialization will be skipped.</p>"},{"location":"opcodes/wgbow/#performance","title":"Performance","text":"<p>A note is played on a string-like instrument, with the arguments as below.</p> <p>kamp -- amplitude of note.</p> <p>kfreq -- frequency of note played.</p> <p>kpres -- a parameter controlling the pressure of the bow on the string. Values should be about 3. The useful range is approximately 1 to 5.</p> <p>krat -- the position of the bow along the string. Usual playing is about 0.127236. The suggested range is 0.025 to 0.23.</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/wgbow/#examples","title":"Examples","text":"<p>Here is an example of the wgbow opcode. It uses the file wgbow.csd.</p> Example of the wgbow opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wgbow.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkpres = p4                                                      ;pressure value\nkrat = p5                                                       ;position along string\nkvibf = 6.12723\n\nkvib  linseg 0, 0.5, 0, 1, 1, p3-0.5, 1                         ; amplitude envelope for the vibrato.           \nkvamp = kvib * 0.01\nasig  wgbow .7, 55, kpres, krat, kvibf, kvamp, 1\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 2048 10 1 ;sine wave\n\ni 1 0 3 3 0.127236\ni 1 + 3 5 0.127236\ni 1 + 3 5 0.23\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgbow/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgbow/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p> <p>ifn optional in version 6.06</p>"},{"location":"opcodes/wgbowedbar/","title":"Wgbowedbar","text":""},{"location":"opcodes/wgbowedbar/#wgbowedbar","title":"wgbowedbar","text":"<p>A physical model of a bowed bar.</p> <p>It belongs to the Perry Cook family of waveguide instruments.</p>"},{"location":"opcodes/wgbowedbar/#syntax","title":"Syntax","text":"<pre><code>ares wgbowedbar kamp, kfreq, kpos, kbowpres, kgain [, iconst] [, itvel] \\\n                [, ibowpos] [, ilow]\n</code></pre>"},{"location":"opcodes/wgbowedbar/#initialization","title":"Initialization","text":"<p>iconst (optional, default=0) -- an integration constant. Default is zero.</p> <p>itvel (optional, default=0) -- either 0 or 1. When itvel = 0, the bow velocity follows an ADSR style trajectory. When itvel = 1, the value of the bow velocity decays in an exponentially.</p> <p>ibowpos (optional, default=0) -- the position on the bow, which affects the bow velocity trajectory.</p> <p>ilow (optional, default=0) -- lowest frequency required</p>"},{"location":"opcodes/wgbowedbar/#performance","title":"Performance","text":"<p>kamp -- amplitude of signal</p> <p>kfreq -- frequency of signal</p> <p>kpos -- position of the bow on the bar, in the range 0 to 1</p> <p>kbowpres -- pressure of the bow (as in wgbowed)</p> <p>kgain -- gain of filter. A value of about 0.809 is suggested.</p>"},{"location":"opcodes/wgbowedbar/#examples","title":"Examples","text":"<p>Here is an example of the wgbowedbar opcode. It uses the file wgbowedbar.csd.</p> Example of the wgbowedbar opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wgbowedbar.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkp   = p6\nasig wgbowedbar p4, cpspch(p5), 1, kp, 0.995\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 0 .5 .5 7.00 .1      ;short sound\ni1 + .  .3 8.00 .1\ni1 + .  .5 9.00 .1\ns\ni1 0 .5 .5 7.00  1      ;longer sound\ni1 + .  .3 8.00  1\ni1 + .  .5 9.00  1\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgbowedbar/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgbowedbar/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 4.07</p>"},{"location":"opcodes/wgbrass/","title":"Wgbrass","text":""},{"location":"opcodes/wgbrass/#wgbrass","title":"wgbrass","text":"<p>Creates a tone related to a brass instrument.</p> <p>It uses a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/wgbrass/#syntax","title":"Syntax","text":"<pre><code>ares wgbrass kamp, kfreq, ktens, iatt, kvibf, kvamp [, ifn] [, iminfreq]\n</code></pre>"},{"location":"opcodes/wgbrass/#initialization","title":"Initialization","text":"<p>iatt -- time taken to reach full pressure</p> <p>ifn -- optional table of shape of vibrato, defaults to a sine table.</p> <p>iminfreq -- lowest frequency at which the instrument will play. If it is omitted it is taken to be the same as the initial kfreq. If iminfreq is negative, initialization will be skipped.</p>"},{"location":"opcodes/wgbrass/#performance","title":"Performance","text":"<p>A note is played on a brass-like instrument, with the arguments as below.</p> <p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>ktens -- lip tension of the player. Suggested value is about 0.4</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p> <p> NOTE</p> <p>This is rather poor, and at present uncontrolled. Needs revision, and possibly more parameters.</p>"},{"location":"opcodes/wgbrass/#examples","title":"Examples","text":"<p>Here is an example of the wgbrass opcode. It uses the file wgbrass.csd.</p> Example of the wgbrass opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o wgbrass.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 1\n0dbfs = 1\n\n; Instrument #1.\ninstr 1\n  kamp = 0.7\n  kfreq = p4\n  ktens = p5\n  iatt = p6\n  kvibf = p7\n  ifn = 1\n\n  ; Create an amplitude envelope for the vibrato.\n  kvamp line 0, p3, 0.5\n\n  a1 wgbrass kamp, kfreq, ktens, iatt, kvibf, kvamp, ifn\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 1024 10 1\n\n;        freq   tens  att  vibf\ni 1 0 4  440    0.4   0.1  6.137\ni 1 4 4  440    0.4   0.01 0.137\ni 1 8 4  880    0.4   0.1  6.137\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgbrass/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgbrass/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p> <p>ifn optional in 6.06</p>"},{"location":"opcodes/wgclar/","title":"Wgclar","text":""},{"location":"opcodes/wgclar/#wgclar","title":"wgclar","text":"<p>Creates a tone similar to a clarinet.</p> <p>It uses a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/wgclar/#syntax","title":"Syntax","text":"<pre><code>ares wgclar kamp, kfreq, kstiff, iatt, idetk, kngain, kvibf, kvamp \\\n            [, ifn] [, iminfreq]\n</code></pre>"},{"location":"opcodes/wgclar/#initialization","title":"Initialization","text":"<p>iatt -- time in seconds to reach full blowing pressure. 0.1 seems to correspond to reasonable playing. A longer time gives a definite initial wind sound.</p> <p>idetk -- time in seconds taken to stop blowing. 0.1 is a smooth ending</p> <p>ifn (optional) -- table of shape of vibrato, defaults yo te usual sine table.</p> <p>iminfreq (optional) -- lowest frequency at which the instrument will play. If it is omitted it is taken to be the same as the initial kfreq. If iminfreq is negative, initialization will be skipped.</p>"},{"location":"opcodes/wgclar/#performance","title":"Performance","text":"<p>A note is played on a clarinet-like instrument, with the arguments as below.</p> <p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played.</p> <p>kstiff -- a stiffness parameter for the reed. Values should be negative, and about -0.3. The useful range is approximately -0.44 to -0.18.</p> <p>kngain -- amplitude of the noise component, about 0 to 0.5</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/wgclar/#examples","title":"Examples","text":"<p>Here is an example of the wgclar opcode. It uses the file wgclar.csd.</p> Example of the wgclar opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wgclar.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 330\nkstiff = -0.3\niatt = 0.1\nidetk = 0.1\nkngain init p4          ;vary breath\nkvibf = 5.735\nkvamp = 0.1\n\nasig wgclar .9, kfreq, kstiff, iatt, idetk, kngain, kvibf, kvamp, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n\ni 1 0 2 0.2\ni 1 + 2 0.5             ;more breath\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgclar/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgclar/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p> <p>ifn optional in 6.06</p>"},{"location":"opcodes/wgflute/","title":"Wgflute","text":""},{"location":"opcodes/wgflute/#wgflute","title":"wgflute","text":"<p>Creates a tone similar to a flute.</p> <p>It uses a physical model developed from Perry Cook, but re-coded for Csound.</p>"},{"location":"opcodes/wgflute/#syntax","title":"Syntax","text":"<pre><code>ares wgflute kamp, kfreq, kjet, iatt, idetk, kngain, kvibf, kvamp [, ifn] \\\n             [, iminfreq] [, ijetrf] [, iendrf]\n</code></pre>"},{"location":"opcodes/wgflute/#initialization","title":"Initialization","text":"<p>iatt -- time in seconds to reach full blowing pressure. 0.1 seems to correspond to reasonable playing.</p> <p>idetk -- time in seconds taken to stop blowing. 0.1 is a smooth ending</p> <p>ifn (optional) -- table of shape of vibrato, defaults to the usual sine table.</p> <p>iminfreq (optional) -- lowest frequency at which the instrument will play. If it is omitted it is taken to be the same as the initial kfreq. If iminfreq is negative, initialization will be skipped.</p> <p>ijetrf (optional, default=0.5) -- amount of reflection in the breath jet that powers the flute. Default value is 0.5.</p> <p>iendrf (optional, default=0.5) -- reflection coefficient of the breath jet. Default value is 0.5. Both ijetrf and iendrf are used in the calculation of the pressure differential.</p>"},{"location":"opcodes/wgflute/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kfreq -- Frequency of note played. While it can be varied in performance, I have not tried it.</p> <p>kjet -- a parameter controlling the air jet. Values should be positive, and about 0.3. The useful range is approximately 0.08 to 0.56.</p> <p>kngain -- amplitude of the noise component, about 0 to 0.5</p> <p>kvibf -- frequency of vibrato in Hertz. Suggested range is 0 to 12</p> <p>kvamp -- amplitude of the vibrato</p>"},{"location":"opcodes/wgflute/#examples","title":"Examples","text":"<p>Here is an example of the wgflute opcode. It uses the file wgflute.csd.</p> Example of the wgflute opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wgflute.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkfreq = 440\nkjet init p4                    ;vary air jet\niatt = 0.1\nidetk = 0.1\nkngain = 0.15\nkvibf = 5.925\nkvamp = 0.05\n\nasig wgflute .8, kfreq, kjet, iatt, idetk, kngain, kvibf, kvamp, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1                ;sine wave\n\ni 1 0 2 0.02                    ;more air jet\ni 1 + 2 0.32\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgflute/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgflute/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p> <p>ifn optional in 6.06</p>"},{"location":"opcodes/wgpluck/","title":"Wgpluck","text":""},{"location":"opcodes/wgpluck/#wgpluck","title":"wgpluck","text":"<p>A high fidelity simulation of a plucked string, using interpolating delay-lines.</p>"},{"location":"opcodes/wgpluck/#syntax","title":"Syntax","text":"<pre><code>ares wgpluck icps, iamp, kpick, iplk, idamp, ifilt, axcite\n</code></pre>"},{"location":"opcodes/wgpluck/#initialization","title":"Initialization","text":"<p>icps -- frequency of plucked string</p> <p>iamp -- amplitude of string pluck</p> <p>iplk -- point along the string, where it is plucked, in the range of 0 to 1. 0 = no pluck</p> <p>idamp -- damping of the note. This controls the overall decay of the string. The greater the value of idamp, the faster the decay. Negative values will cause an increase in output over time.</p> <p>ifilt -- control the attenuation of the filter at the bridge. Higher values cause the higher harmonics to decay faster.</p>"},{"location":"opcodes/wgpluck/#performance","title":"Performance","text":"<p>kpick -- proportion of the way along the point to sample the output.</p> <p>axcite -- a signal which excites the string.</p> <p>A string of frequency icps is plucked with amplitude iamp at point iplk. The decay of the virtual string is controlled by idamp and ifilt which simulate the bridge. The oscillation is sampled at the point kpick, and excited by the signal axcite.</p>"},{"location":"opcodes/wgpluck/#examples","title":"Examples","text":"<p>Here is an example of the wgpluck opcode. It uses the file wgpluck.csd.</p> An example of the wgpluck opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o wgpluck.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nicps = 220\niamp = 1\nkpick = 0.5\niplk = 0\nidamp = p4\nifilt = p5\nichoice = p6\n\nif ichoice == 1 then\n    axcite =    0                   ; no exciter signal\nelse\n    axcite diskin2  \"fox.wav\", 1    ; use the fox as exciter\n    axcite *=   .15                 ; but lower amplitude\nendif\n\napluck wgpluck icps, iamp, kpick, iplk, idamp, ifilt, axcite\napluck  dcblock2    apluck          ; gets rid of DC offset\nouts apluck, apluck\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ; sine wave.\ns\n;          damp     filter  choice           \ni 1 0 8     10      1000      1\ni 1 + 8     30      10        1\ns\ni 1 0 8     10      1000      2\ni 1 + 8     30      10        2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgpluck/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgpluck/#credits","title":"Credits","text":"<p>Author: Michael A. Casey M.I.T. Cambridge, Mass. 1997</p> <p>New in Version 3.47</p>"},{"location":"opcodes/wgpluck2/","title":"Wgpluck2","text":""},{"location":"opcodes/wgpluck2/#wgpluck2","title":"wgpluck2","text":"<p>Physical model of the plucked string.</p> <p>It has control over the pluck point, the pickup point and the filter. Based on the Karplus-Strong algorithm.</p>"},{"location":"opcodes/wgpluck2/#syntax","title":"Syntax","text":"<pre><code>ares wgpluck2 iplk, kamp, icps, kpick, krefl\n</code></pre>"},{"location":"opcodes/wgpluck2/#initialization","title":"Initialization","text":"<p>iplk -- The point of pluck is iplk, which is a fraction of the way up the string (0 to 1). A pluck point of zero means no initial pluck.</p> <p>icps  -- The string plays at icps pitch.</p>"},{"location":"opcodes/wgpluck2/#performance","title":"Performance","text":"<p>kamp -- Amplitude of note.</p> <p>kpick -- Proportion of the way along the string to sample the output.</p> <p>krefl -- the coefficient of reflection, indicating the lossiness and the rate of decay. It must be strictly between 0 and 1 (it will complain about both 0 and 1).</p>"},{"location":"opcodes/wgpluck2/#examples","title":"Examples","text":"<p>Here is an example of the wgpluck2 opcode. It uses the file wgpluck2.csd.</p> Example of the wgpluck2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o wgpluck2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\niplk = p4\nkamp = .7\nicps = 220\nkpick = 0.75\nkrefl = p5\n\napluck wgpluck2 iplk, kamp, icps, kpick, krefl\napluck  dcblock2    apluck\nouts apluck, apluck\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;         pluck   reflection\ni 1 0 1     0       0.9\ni 1 + 1     &lt;       .\ni 1 + 1     &lt;       .\ni 1 + 1     1       . \n\ni 1 5 5     .75     0.7 \ni 1 + 5     .05     0.7 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wgpluck2/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p>"},{"location":"opcodes/wgpluck2/#credits","title":"Credits","text":"<p>Author: John ffitch (after Perry Cook) University of Bath, Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/wguide1/","title":"Wguide1","text":""},{"location":"opcodes/wguide1/#wguide1","title":"wguide1","text":"<p>A simple waveguide model consisting of one delay-line and one first-order lowpass filter.</p>"},{"location":"opcodes/wguide1/#syntax","title":"Syntax","text":"<pre><code>ares wguide1 asig, xfreq, kcutoff, kfeedback\n</code></pre>"},{"location":"opcodes/wguide1/#performance","title":"Performance","text":"<p>asig -- the input of excitation noise.</p> <p>xfreq -- the frequency (i.e. the inverse of delay time) Changed to x-rate in Csound version 3.59.</p> <p>kcutoff -- the filter cutoff frequency in Hz.</p> <p>kfeedback -- the feedback factor.</p> <p>wguide1 is the most elemental waveguide model, consisting of one delay-line and one first-order lowpass filter.</p> <p>Implementing waveguide algorithms as opcodes, instead of orc instruments, allows the user to set kr different than sr, allowing better performance particulary when using real-time.</p> wguide1."},{"location":"opcodes/wguide1/#examples","title":"Examples","text":"<p>Here is an example of the wguide1 opcode. It uses the file wguide1.csd.</p> Example of the wguide1 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac             ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o wguide1.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Kevin Conder\n; additions by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1     ; Generate some noise.\n\nasig noise .5, 0.5\nouts asig, asig\n\nendin\n\ninstr 2     \n\nasig noise .5, 0.5                          ; Generate some noise.\nkfreq line p4, p3, 100                      ; Run it through a wave-guide model.\nkcutoff init 3000\nkfeedback init 0.8\nawg1 wguide1 asig, kfreq, kcutoff, kfeedback\nouts awg1, awg1\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 2\n;           freq\ni 2 2 5     2000    ; falling frequency\ni 2 8 3     100     ; static\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wguide1/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p> <p>Waveguides</p>"},{"location":"opcodes/wguide1/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/wguide2/","title":"Wguide2","text":""},{"location":"opcodes/wguide2/#wguide2","title":"wguide2","text":"<p>A model of beaten plate consisting of two parallel delay-lines and two first-order lowpass filters.</p>"},{"location":"opcodes/wguide2/#syntax","title":"Syntax","text":"<pre><code>ares wguide2 asig, xfreq1, xfreq2, kcutoff1, kcutoff2, kfeedback1, kfeedback2\n</code></pre>"},{"location":"opcodes/wguide2/#performance","title":"Performance","text":"<p>asig -- the input of excitation noise</p> <p>xfreq1, xfreq2 -- the frequency (i.e. the inverse of delay time) Changed to x-rate in Csound version 3.59.</p> <p>kcutoff1, kcutoff2 -- the filter cutoff frequency in Hz.</p> <p>kfeedback1, kfeedback2 -- the feedback factor</p> <p>wguide2 is a model of beaten plate consisting of two parallel delay-lines and two first-order lowpass filters. The two feedback lines are mixed and sent to the delay again each cycle.</p> <p>Implementing waveguide algorithms as opcodes, instead of orc instruments, allows the user to set kr different than sr, allowing better performance particulary when using real-time.</p> wguide2. <p> Note</p> <p>As a rule of thumb, to avoid making wguide2 unstable, the sum of the two feedback values should be below 0.5.</p>"},{"location":"opcodes/wguide2/#examples","title":"Examples","text":"<p>Here is an example of the wguide2 opcode. It uses the file wguide2.csd.</p> Example of the wguide2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wguide2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr   1\n\naout diskin2 \"drumsMlp.wav\", 1, 0, 1                            ;in signal\nafreq1 line 100, p3, 2000                                               \nafreq2 line 1200, p3, p4                                        ;vary second frequency in the score     \nkcutoff1   = 3000\nkcutoff2   = 1500\nkfeedback1 = 0.25                                               ;the sum of the two feedback\nkfeedback2 = 0.25                                               ;values should not exceed  0.5\nasig wguide2 aout, afreq1, afreq2, kcutoff1, kcutoff2, kfeedback1, kfeedback2\nasig dcblock2 asig                                              ;get rid of DC\n      outs asig, asig \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 8 1200    ;freqency of afreq2 remains the same\ni 1 9 8 100     ;freqency of afreq2 gets lower\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wguide2/#see-also","title":"See also","text":"<p>Waveguide Physical Modeling</p> <p>Waveguides</p>"},{"location":"opcodes/wguide2/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy October 1998</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/while/","title":"While","text":""},{"location":"opcodes/while/#while","title":"while","text":"<p>A syntactic looping construction.</p>"},{"location":"opcodes/while/#syntax","title":"Syntax","text":"<pre><code>while condition do\n... od\n</code></pre>"},{"location":"opcodes/while/#performance","title":"Performance","text":"<p>The statements between the do and od form the body of a loop which is obeyed while the conditional remains true.</p>"},{"location":"opcodes/while/#examples","title":"Examples","text":"<p>Here is an example of the while construction. It uses the file while.csd.</p> Example of the while opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o ifthen.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\ninstr 1\nlab99:\nif p4&lt;0 goto lab100\n  p4 = p4-1\n  print p4\n  goto lab99\nlab100:\nendin\n\ninstr 2\n  while p4&gt;=0 do\n    p4 = p4-1\n    print p4\n  od\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 1 1 4\ni 2 2 1 4\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like this:</p> <pre><code>B  0.000 ..  1.000 T  1.000 TT  1.000 M:      0.0\nnew alloc for instr 1:\ninstr 1:  p4 = 3.000\ninstr 1:  p4 = 2.000\ninstr 1:  p4 = 1.000\ninstr 1:  p4 = 0.000\ninstr 1:  p4 = -1.000\nB  1.000 ..  2.000 T  2.000 TT  2.000 M:      0.0\nnew alloc for instr 2:\ninstr 2:  p4 = 3.000\ninstr 2:  p4 = 2.000\ninstr 2:  p4 = 1.000\ninstr 2:  p4 = 0.000\ninstr 2:  p4 = -1.000\nB  2.000 ..  3.000 T  3.000 TT  3.000 M:      0.0\n</code></pre>"},{"location":"opcodes/while/#see-also","title":"See also","text":"<p>Program Flow Control: Looping Constructions</p>"},{"location":"opcodes/while/#credits","title":"Credits","text":"<p>John ffitch.</p> <p>New in Csound version 6.04</p>"},{"location":"opcodes/wrap/","title":"Wrap","text":""},{"location":"opcodes/wrap/#wrap","title":"wrap","text":"<p>Wraps-around the signal that exceeds the low and high thresholds.</p>"},{"location":"opcodes/wrap/#syntax","title":"Syntax","text":"<pre><code>ares wrap asig, klow, khigh\nires wrap isig, ilow, ihigh\nkres wrap ksig, klow, khigh\n</code></pre>"},{"location":"opcodes/wrap/#initialization","title":"Initialization","text":"<p>isig -- input signal</p> <p>ilow -- low threshold</p> <p>ihigh -- high threshold</p>"},{"location":"opcodes/wrap/#performance","title":"Performance","text":"<p>xsig -- input signal</p> <p>klow -- low threshold</p> <p>khigh -- high threshold</p> <p>wrap wraps-around the signal that exceeds the low and high thresholds.</p> <p>This opcode is useful in several situations, such as table indexing or for clipping and modeling a-rate, i-rate or k-rate signals. wrap is also useful for wrap-around of table data when the maximum index is not a power of two (see table and tablei). Another use of wrap is in cyclical event repeating, with arbitrary cycle length.</p>"},{"location":"opcodes/wrap/#examples","title":"Examples","text":"<p>Here is an example of the wrap opcode. It uses the file wrap.csd.</p> Example of the wrap opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o wrap.wav -W  ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 2\n\ninstr    1 ; Limit / Mirror / Wrap\n\nigain    = p4                           ;gain\nilevl1   = p5                           ; + level\nilevl2   = p6                           ; - level\nimode    = p7                           ;1 = limit, 2 = mirror, 3 = wrap\n\nain   soundin  \"fox.wav\"\nain   = ain*igain\n\nif    imode = 1 goto limit\nif    imode = 2 goto mirror\n\nasig  wrap  ain, ilevl2, ilevl1\ngoto  outsignal\n\nlimit:\nasig  limit  ain, ilevl2, ilevl1\ngoto  outsignal\n\nmirror:\nasig  mirror  ain, ilevl2, ilevl1\noutsignal:\n\nouts  asig*.5, asig*.5                  ;mind your speakers\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n;           Gain  +Levl -Levl Mode\ni1  0  3    4.00  .25  -1.00   1        ;limit\ni1  4  3    4.00  .25  -1.00   2        ;mirror\ni1  8  3    4.00  .25  -1.00   3        ;wrap\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wrap/#see-also","title":"See also","text":"<p>Signal Limiters</p>"},{"location":"opcodes/wrap/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy</p> <p>New in Csound version 3.49</p>"},{"location":"opcodes/wterrain/","title":"Wterrain","text":""},{"location":"opcodes/wterrain/#wterrain","title":"wterrain","text":"<p>A simple wave-terrain synthesis opcode.</p>"},{"location":"opcodes/wterrain/#syntax","title":"Syntax","text":"<pre><code>aout wterrain kamp, kpch, k_xcenter, k_ycenter, k_xradius, k_yradius, \\\n              itabx, itaby\n</code></pre>"},{"location":"opcodes/wterrain/#initialization","title":"Initialization","text":"<p>itabx, itaby -- The two tables that define the terrain.</p>"},{"location":"opcodes/wterrain/#performance","title":"Performance","text":"<p>The output is the result of drawing an ellipse with axes k_xradius and k_yradius centered at (k_xcenter, k_ycenter), and traversing it at frequency kpch.</p>"},{"location":"opcodes/wterrain/#examples","title":"Examples","text":"<p>Here is an example of the wterrain opcode. It uses the file wterrain.csd.</p> Example of the wterrain opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   No messages\n-odac           -d     ;;;RT audio out\n; For Non-realtime ouput leave only the line below:\n; -o wterrain.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkdclk   linseg  0, 0.01, 1, p3-0.02, 1, 0.01, 0\nkcx     line    0.1, p3, 1.9\nkrx     linseg  0.1, p3/2, 0.5, p3/2, 0.1\nkpch    line    cpspch(p4), p3, p5 * cpspch(p4)\na1      wterrain    .5, kpch, kcx, kcx, -krx, krx, p6, p7\na1      dcblock a1\nouts    a1*kdclk, a1*kdclk\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1      0       8192    10      1 0 0.33 0 0.2 0 0.14 0 0.11\nf2      0       4096    10      1\n\ni1      0       4       7.00 1 1 1\ni1      4       4       6.07 1 1 2\ni1      8       8       6.00 1 2 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wterrain/#see-also","title":"See Also","text":"<p>Wave Terrain Synthesis</p>"},{"location":"opcodes/wterrain/#credits","title":"Credits","text":"<p>Author: Matthew Gillard New in version 4.19</p>"},{"location":"opcodes/wterrain2/","title":"Wterrain2","text":""},{"location":"opcodes/wterrain2/#wterrain2","title":"wterrain2","text":"<p>A wave-terrain synthesis opcode using different curves</p> <p>It enhances the wterrain opcode by providing some more curves, krate table parameters and a parameter for rotating the curve.</p>"},{"location":"opcodes/wterrain2/#syntax","title":"Syntax","text":"<pre><code>aout wterrain2 kamp, kcps, kx, ky, krx, kry, krot, ktab0, ktab1, \\\n               kcurve, kcurveparam\n</code></pre>"},{"location":"opcodes/wterrain2/#performance","title":"Performance","text":"<p>ktabx, ktaby -- The two tables that define the terrain - they can be changed at krate.</p> <p>The output is the result of traversing at frequency kcps the curve kcurve with the parameter kcurveparam (see below), scaled with krx and kry and centered at kx, ky on the terrain and rotated around the center with krot radians.</p> <p>kcurve=0: ellipse as in the wterrain opcode but with a special extension. kcurveparam controls a speed change of the traversing point. The formula is:</p> <pre><code>fx(t) = kx + krx * sin( t + kcurveparam * sin(t) )\nfy(t) = ky + kry * cos( t + kcurveparam * sin(t) )\n</code></pre> <p>kcurve=1: lemniskate - this is a simple 8. here also the kcurveparam controls a speed change of the traversing point. The formula is:</p> <pre><code>fx(t) = kx + krx * cos( t + kcurveparam * sin(t) )\nfy(t) = ky + kry * sin( t + kcurveparam * sin(t) )  * cos( t + kcurveparam * sin(t) )\n</code></pre> <p>kcurve=2: limacon</p> <pre><code>fx(t) = kx + krx * sin(t) * (cos(t) + kcurveparam);\nfy(t) = ky + kry * cos(t) * (cos(t) + kcurveparam);\n</code></pre> limacon curve with different parameters <p>kcurve=3: cornoid</p> <pre><code>fx(t) = kx + krx * cos(t) * cos(2*t)\nfy(t) = ky + kry * sin(t) * (kcurveparam + cos(2*t))\n</code></pre> cornoid with different parameters <p>kcurve=4: trisectrix (Ceva)</p> <pre><code>fx(t) = kx + krx * cos(t) * (1+kcurveparam*sin(2*t));\nfy(t) = ky + kry * sin(t) * (1+kcurveparam*sin(2*t));\n</code></pre> trisectrix curve with different parameters <p>kcurve=5: scarabeus</p> <pre><code>fx(t) = kx + krx * cos(t) * (1+kcurveparam*sin(2*t));\nfy(t) = ky + kry * sin(t) * (1+kcurveparam*sin(2*t));\n</code></pre> scarabeus curve with different parameters <p>kcurve=6: folium</p> <pre><code>fx(t) = kx + krx * cos(t) * cos(t) * (sin(t)*sin(t) - kcurveparam);\nfy(t) = ky + kry * sin(t) * cos(t) * (sin(t)*sin(t) - kcurveparam);\n</code></pre> folium with different parameters <p>kcurve=7: Talbot curve</p> <pre><code>fx(t) = kx + krx * cos(t) * (1 + kcurveparam * sin(t)*sin(t));\nfy(t) = ky + kry * sin(t) * (1 - kcurveparam - kcurveparam*cos(t)*cos(t));\n</code></pre> Talbot curve with different parameters"},{"location":"opcodes/wterrain2/#examples","title":"Examples","text":"<p>Here is an example of the wterrain2 opcode. It uses the file wterrain2_1.csd.</p> Example of the wterrain2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr     = 48000\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 0,0,2^12,10,1\ngScurves[] fillarray \"ELLIPSE \", \"LEMNISKATE \", \"LIMACON \",\"CORNOID \",\"TRISEXTIC \",\"SCARABEUS \",\"FOLIUM \",\"TALBOT \"\n\ninstr 1 \nprints gScurves[p4]\nkdclk init 0\nkdclk   linsegr  0, 0.1, 1, p3-0.02, 1, 0.9, 0\nkparam init 0\nkrot init 0\nkrot linseg 0,p3,6.28 ; ROTATE THE CURVE SLOWLY\nkparam linseg 0,p3,4 ; INCREASE CURVEPARAMETER\n\nasigL wterrain2 0.5, 110, 0.5, 0.5, 0.8, 0.4, krot, gisine, gisine, p4, kparam\n; LET THE POINT FOR RIGHT RUNNING BACKWARDS FOR A LITTLE STEREO EFFECT\nasigR wterrain2 0.5, -110, 0.5, 0.5, 0.8, 0.4, krot, gisine, gisine, p4, kparam\nasigR dcblock asigL\nasigL dcblock asigR\nasigL*=kdclk\nasigR*=kdclk\naL,aR reverbsc asigL, asigR, 0.6, 15000, 44100, 0.5, 1\nouts aL,aR\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni 1 0 40 0 ; ELLIPSE\ni 1 41 40 1; LEMNSIKATE\ni 1 82 40 2; LIMACON\ni 1 123 40 3; CORNOID\ni 1 164 40 4; TRISEXTIC\ni 1 205 40 5; SCARABEUS\ni 1 246 40 6; FOLIUM\ni 1 287 40 7; TALBOT\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an other example of the wterrain2 - a sound fugue. It uses the file wterrain2_2.csd.</p> Another Example of the wterrain2 opcode - a sound fugue<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac -d\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\nsr     = 48000\nksmps  = 32\nnchnls = 2\n0dbfs  = 1\n\ngisine ftgen 0,0,2^12,10,1\n\ninstr 1\n\nkamp adsr 0.1,0.01,1,10\n\n; THE MODULATION PARAMETERS \nkrot linseg 0,p3,6.28 ; ROTATE\nkparam randc 2.5,0.1,0.993 ; CONTROL CURVEPARAMETER WITH CUBIC RANDOM \nkx linseg 0,p3/2,1,p3/2,0 ; MOVE HORIZONTAL THROUGH THE TERRAIN\nky linseg 0,p3,1 ; MOVE VERTICAL THROUGH THE TERRAIN\n\n; TRY THE OTHER CURVES AS WELL \nasigL wterrain2 0.2, 55*p4, kx, ky, 0.5, 0.4, krot, gisine, gisine, 5, kparam\nasigR wterrain2 0.2, -55*p4, kx, ky, 0.5, 0.4, krot, gisine, gisine, 5, kparam\n\nasigR dcblock asigL\nasigL dcblock asigR\nasigL butterlp asigL,9000\nasigR butterlp asigR,9000\naL,aR reverbsc asigL, asigR, 0.7, 15000, 44100, 0.5, 1\nouts aL*kamp*p5,aR*kamp*p5\n\nendin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\ni 1 0 300 1 1\ni 1 1 300 7 0.4\ni 1 2 299 [9/2] 0.4\ni 1 3.1 296.9 [16/3] 0.45\ni 1 4.3 295.7 [27/4] 0.5\ni 1 6.9 292.1 6 0.5 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/wterrain2/#see-also","title":"See Also","text":"<p>Wave Terrain Synthesis</p>"},{"location":"opcodes/wterrain2/#credits","title":"Credits","text":"<p>Author: Christian Bacher New in version 6.15</p>"},{"location":"opcodes/xadsr/","title":"Xadsr","text":""},{"location":"opcodes/xadsr/#xadsr","title":"xadsr","text":"<p>Calculates the classical ADSR envelope.</p>"},{"location":"opcodes/xadsr/#syntax","title":"Syntax","text":"<pre><code>ares xadsr iatt, idec, islev, irel [, idel]\nkres xadsr iatt, idec, islev, irel [, idel]\n</code></pre>"},{"location":"opcodes/xadsr/#initialization","title":"Initialization","text":"<p>iatt -- duration of attack phase</p> <p>idec -- duration of decay</p> <p>islev -- level for sustain phase</p> <p>irel -- duration of release phase</p> <p>idel -- period of zero before the envelope starts</p>"},{"location":"opcodes/xadsr/#performance","title":"Performance","text":"<p>The envelope generated is the range 0 to 1 and may need to be scaled further, depending on the amplitude required. If using 0dbfs = 1, scaling down will probably be required since playing more than one note might result in clipping. If not using 0dbfs, scaling to a large amplitude (e.g. 32000) might be required.</p> <p>The envelope may be described as:</p> Picture of an exponential ADSR envelope. <p>The length of the sustain is calculated from the length of the note. This means xadsr is not suitable for use with MIDI events, use mxadsr instead. The opcode xadsr is identical to adsr except it uses exponential, rather than linear, line segments.</p>"},{"location":"opcodes/xadsr/#examples","title":"Examples","text":"<p>Here is an example of the xadsr opcode. It uses the file xadsr.csd.</p> Example of the xadsr opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o xadsr.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n\niatt  = p5\nidec  = p6  \nislev = p7\nirel  = p8\n\nkenv    xadsr iatt, idec, islev, irel\nkcps =  cpspch(p4)        ;frequency\n\nasig    vco2  kenv * 0.8, kcps\n        outs  asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1  0  1  7.00  .0001  1  .01  .001 ; short attack\ni 1  2  1  7.02  1  .5  .01  .001    ; long attack\ni 1  4  2  6.09  .0001  1 .1  .7     ; long release\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is an example for the adsr-group, comparing the different adsr opcodes. It uses the file adsr-group.csd.</p> Example of the adsr group.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac    ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o adsr-group.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel - 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; both amplitude and filter use same ADSR curves \ninstr 1                  \nkenv    adsr    .01, .5, .5, p4         ; linear envelope \nasig    vco2    kenv, 110                       ; A+D+S+R = p3  \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig       \nendin\n\ninstr 2 ; midi behavior                  \nkenv    madsr   .01, .5, .5, p4         ; linear envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage                \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled  \n                outs    asig, asig                      \nendin\n\ninstr 3                  \nkenv    xadsr   .01, .5 , .5, p4    ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S+R = p3   \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig\nendin\n\ninstr 4 ; midi behavior          \nkenv    mxadsr  .01, .5 , .5, p4        ; exponential envelope\nasig    vco2    kenv, 110                       ; A+D+S = p3, then go into Release stage         \nasig    rezzy   asig, 500+(kenv*1000), 10       ; same curve but scaled \n                outs    asig, asig                      \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni1 1 2 .01      ; same notes for everyone!\ni1 5 . .5\ni1 9 . 1.5\ns\ni2 1 2 .01\ni2 5 . .5\ni2 9 . 1.5\ns\ni3 1 2 .01\ni3 5 . .5\ni3 9 . 1.5\ns\ni4 1 2 .01\ni4 5 . .5\ni4 9 . 1.5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/xadsr/#see-also","title":"See Also","text":"<p>Envelope Generators</p>"},{"location":"opcodes/xadsr/#credits","title":"Credits","text":"<p>Author: John ffitch xadsr is new in Csound version 3.51.</p>"},{"location":"opcodes/xtratim/","title":"Xtratim","text":""},{"location":"opcodes/xtratim/#xtratim","title":"xtratim","text":"<p>Extend the duration of real-time generated events and handle their extra life (Usually for usage along with release instead of linenr, linsegr, etc).</p>"},{"location":"opcodes/xtratim/#syntax","title":"Syntax","text":"<pre><code>xtratim iextradur\n</code></pre>"},{"location":"opcodes/xtratim/#initialization","title":"Initialization","text":"<p>iextradur -- additional duration of current instrument instance</p>"},{"location":"opcodes/xtratim/#performance","title":"Performance","text":"<p>xtratim extends current MIDI-activated note duration by iextradur seconds after the corresponding noteoff message has deactivated the current note itself. It is usually used in conjunction with release. This opcode has no output arguments.</p> <p>This opcode is useful for implementing complex release-oriented envelopes, whose duration is not known when the envelope starts (e.g. for real-time MIDI generated events).</p>"},{"location":"opcodes/xtratim/#examples","title":"Examples","text":"<p>Here is a simple example of the xtratim opcode. It uses the file xtratim.csd.</p> Example of the xtratim opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent  MIDI in\n-odac           -iadc     -d       -M0  ;;;realtime I/O\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n;Simple usage of the xtratim opcode\nsr = 44100\nksmps = 10\nnchnls = 2\n\n; sine wave for oscillators\ngisin       ftgen     1, 0, 4096, 10, 1\n\ninstr 1\n\n  inum notnum\n  icps cpsmidi\n  iamp ampmidi 4000\n ;\n ;------- complex envelope block ------\n  xtratim 1 ;extra-time, i.e. release dur\n  krel init 0\n  krel release ;outputs release-stage flag (0 or 1 values)\n  if (krel == 1) kgoto rel ;if in release-stage goto release section\n ;\n ;************ attack and sustain section ***********\n  kmp1 linseg 0, .03, 1, .05, 1, .07, 0, .08, .5, 4, 1, 50, 1\n  kmp = kmp1*iamp\n   kgoto done\n ;\n ;--------- release section --------\n   rel:\n  kmp2 linseg 1, .3, .2, .7, 0\n  kmp = kmp1*kmp2*iamp\n  done:\n ;------\n  a1 oscili kmp, icps, gisin\n  outs a1, a1\n endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf 0 3600 ;dummy table to wait for realtime MIDI events\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>Here is a more elaborate example of the xtratim opcode. It uses the file xtratim-2.csd.</p> <p>This example shows how to generate a release segment for an ADSR envelope after a MIDI noteoff is received, extending the duration with xtratim and using release to check whether the note is on the release phase. Two envelopes are generated simultaneously for the left and right channels.</p> More complex example of the xtratim opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    Silent  MIDI in\n-odac           -iadc     -d       -M0  ;;;realtime I/O\n&lt;/CsOptions&gt;\n\n&lt;CsInstruments&gt;\n;xtratim example by Jonathan Murphy Dec. 2006\nsr = 44100\nksmps = 10\nnchnls = 2\n\n            ; sine wave for oscillators\ngisin       ftgen     1, 0, 4096, 10, 1\n            ; set volume initially to midpoint\n            ctrlinit  1, 7,64\n\n;;; simple two oscil, two envelope synth\n    instr 1\n\n            ; frequency\n  kcps      cpsmidib\n            ; initial velocity (noteon)\n  ivel      veloc\n\n            ; master volume\n  kamp      ctrl7     1, 7, 0, 127\n  kamp      =  kamp * ivel\n\n            ; parameters for aenv1\n  iatt1     =  0.03     \n  idec1     =  1\n  isus1     =  0.25     \n  irel1     =  1\n            ; parameters for aenv2\n  iatt2     =  0.06     \n  idec2     =  2        \n  isus2     =  0.5\n  irel2     =  2\n\n            ; extra (release) time allocated\n            xtratim   (irel1&gt;irel2 ? irel1 : irel2)\n            ; krel is used to trigger envelope release\n  krel      init      0\n  krel      release\n            ; if noteoff received, krel == 1, otherwise krel == 0\nif (krel == 1) kgoto rel\n\n            ; attack, decay, sustain segments\n  atmp1     linseg    0, iatt1, 1, idec1, isus1 , 1, isus1\n  atmp2     linseg    0, iatt2, 1, idec2, isus2 , 1, isus2\n  aenv1     =  atmp1\n  aenv2     =  atmp2\n            kgoto     done\n\n            ; release segment\nrel:\n  atmp3     linseg    1, irel1, 0, 1, 0\n  atmp4     linseg    1, irel2, 0, 1, 0\n  aenv1     =  atmp1 * atmp3  ;to go from the current value (in case\n  aenv2     =  atmp2 * atmp4  ;the attack hasn't finished) to the release.\n\n            ; control oscillator amplitude using envelopes\ndone:\n  aosc1     oscil     aenv1, kcps, gisin\n  aosc2     oscil     aenv2, kcps * 1.5, gisin\n  aosc1     =  aosc1 * kamp\n  aosc2     =  aosc2 * kamp\n\n            ; send aosc1 to left channel, aosc2 to right,\n            ; release times are noticably different\n\n            outs      aosc1, aosc2\n\n    endin\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\nf 0 3600 ;dummy table to wait for realtime MIDI events\n\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/xtratim/#see-also","title":"See also","text":"<p>Event Extenders</p>"},{"location":"opcodes/xtratim/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>Italy</p> <p>Examples by Gabriel Maldonado and Jonathan Murphy</p> <p>New in Csound version 3.47</p>"},{"location":"opcodes/xyin/","title":"Xyin","text":""},{"location":"opcodes/xyin/#xyin","title":"xyin","text":"<p>Sense the cursor position in an output window</p> <p>When xyin is called the position of the mouse within the output window is used to reply to the request.  This simple mechanism does mean that only one xyin can be used accurately at once.  The position of the mouse is reported in the output window.</p>"},{"location":"opcodes/xyin/#syntax","title":"Syntax","text":"<pre><code>kx, ky xyin iprd, ixmin, ixmax, iymin, iymax [, ixinit] [, iyinit]\n</code></pre>"},{"location":"opcodes/xyin/#initialization","title":"Initialization","text":"<p>iprd -- period of cursor sensing (in seconds). Typically .1 seconds.</p> <p>xmin, xmax, ymin, ymax -- edge values for the x-y coordinates of a cursor in the input window.</p> <p>ixinit, iyinit (optional) -- initial x-y coordinates reported; the default values are 0,0. If these values are not within the given min-max range, they will be coerced into that range.</p>"},{"location":"opcodes/xyin/#performance","title":"Performance","text":"<p>xyin samples the cursor x-y position in an input window every iprd seconds. Output values are repeated (not interpolated) at the k-rate, and remain fixed until a new change is registered in the window. There may be any number of input windows. This unit is useful for real-time control, but continuous motion should be avoided if iprd is unusually small.</p> <p> Note</p> <p>Depending on your platform and distribution, you might need to enable displays using the --displays command line flag.</p>"},{"location":"opcodes/xyin/#examples","title":"Examples","text":"<p>Here is an example of the xyin opcode. It uses the file xyin.csd.</p> Example of the xyin opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     --displays ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o xyin.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 2\n\n; Instrument #1.\ninstr 1\n  ; Print and capture values every 0.1 seconds.\n  iprd = 0.1\n  ; The x values are from 1 to 30.\n  ixmin = 1\n  ixmax = 30\n  ; The y values are from 1 to 30.\n  iymin = 1\n  iymax = 30\n  ; The initial values for X and Y are both 15.\n  ixinit = 15\n  iyinit = 15\n\n  ; Get the values kx and ky using the xyin opcode.\n  kx, ky xyin iprd, ixmin, ixmax, iymin, iymax, ixinit, iyinit\n\n  ; Print out the values of kx and ky.\n  printks \"kx=%f, ky=%f\\\\n\", iprd, kx, ky\n\n  ; Play an oscillator, use the x values for amplitude and\n  ; the y values for frequency.\n  kamp = kx * 1000\n  kcps = ky * 220\n  a1 poscil kamp, kcps, 1\n\n  outs a1, a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; Play Instrument #1 for 30 seconds.\ni 1 0 30\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>As the values of kx and ky change, they will be printed out like this:</p> <pre><code>kx=8.612036, ky=22.677933\nkx=10.765685, ky=15.644135\n</code></pre>"},{"location":"opcodes/xyin/#see-also","title":"See also","text":"<p>Sensing and Control: Keyboard and mouse sensing</p>"},{"location":"opcodes/xyin/#credits","title":"Credits","text":"<p>Example written by Kevin Conder.</p>"},{"location":"opcodes/xyscale/","title":"Xyscale","text":""},{"location":"opcodes/xyscale/#xyscale","title":"xyscale","text":"<p>2D linear interpolation.</p> <p>Plugin opcode in emugens.</p> <p>2D linear interpolation between 4 points at (0,0), (1,0), (0,1), (1,1)</p>"},{"location":"opcodes/xyscale/#syntax","title":"Syntax","text":"<pre><code>kout xyscale kx, ky, k00, k10, k01, k11\n</code></pre>"},{"location":"opcodes/xyscale/#performance","title":"Performance","text":"<p>kx, ky -- Coordinates to evaluate the interpolation. Value between 0-1, where:</p> <p>k00 -- Value of point at coord (x=0, y=0)</p> <p>k10 -- Value of point at coord (x=1, y=0)</p> <p>k01 -- Value of point at coord (x=0, y=1)</p> <p>k11 -- Value of point at coord (x=1, y=1)</p> <pre><code>(0,1)      (1,1)\n\n(0,0)      (1,0)\n</code></pre> <p>Given 4 values placed at the corners of a square, find the interpolated value at point (x, y), where x and y are defined between 0-1.</p>"},{"location":"opcodes/xyscale/#examples","title":"Examples","text":"<p>Here is an example of the xyscale opcode. It uses the file xyscale.csd.</p> Example of the xyscale opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;RT audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o xyscale.wav -W ;;; for file output any platform\n\n; By Stefano Cucchi 2020\n\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n; In the instr 1  using f1 and f2 you reach the 4 corners (values)\nk00 = p4\nk10 = p5\nk01 = p6\nk11 = p7\n\nkx oscil 1, p8, p9\nky oscil 1, p10, p11\n\nkout1 xyscale kx, ky, k00, k10, k01, k11 \nkout2 xyscale kx, ky, k00*3/2, k10*4/3, k01*5/4, k11*6/5\n\na1 buzz 0.2, kout1, 8, 3\na2 buzz 0.2, kout2, 4, 3\n\nouts a1, a2\n\nendin\n\ninstr 2\n; In the instr 2 setting the first value to 0 or 1 (p8 &amp; p9) you can start from the corner  (value) you want\n\nk00 = p4\nk10 = p5\nk01 = p6\nk11 = p7\n\nkx randomh 0, 1, 2, 2, p8 ; p8 is the X starting value\nky randomh 0, 1, 2, 2, p9 ; p9 is the Y starting value\n\nkout1 xyscale kx, ky, k00, k10, k01, k11 \nkout2 xyscale kx, ky, k00*3/2, k10*4/3, k01*5/4, k11*6/5\n\na1 buzz 0.2, kout1, 8, 3\na2 buzz 0.2, kout2, 4, 3\n\nouts a1, a2\n\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\nf1 0 1024 -7 0 400 0 100 1 400 1 124 0\nf2 0 1024 -7 0 200 0 100 1 400 1 100 0 224 1\nf3 0 1024 10 1 \n\ni1 0 10 300 400 500 600 0.3 1 0.2 2\ni2 10 10 300 410 520 630 0 0\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of the xyscale opcode. It uses the file xyscale-FLTK.csd.</p> Advanced example of the xyscale opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nksmps=128\nnchnls=2\n\ngiwidth = 400\ngiheight = 300\nFLpanel \"FLmouse\", giwidth, giheight, 10, 10\nFLpanelEnd\n\nFLrun\n\n0dbfs = 1\n\ninstr 1\n  ; We define four chords for bottom-left, bottom-right, top-left and top-right\n  ; Use the mouse to interpolate between them\n  ibl[] fillarray ntom:i(\"4C\"), ntom:i(\"4Eb\"), ntom:i(\"4G\")\n  itl[] fillarray ntom:i(\"4E\"), ntom:i(\"4G#\"), ntom:i(\"4B\")\n  ibr[] fillarray ntom:i(\"4G\"), ntom:i(\"4A\"), ntom:i(\"4B\")\n  itr[] fillarray ntom:i(\"4Eb\"), ntom:i(\"4Eb+\"), ntom:i(\"4F\")\n\n  kmousex, kmousey, kb1, kb2, kb3    FLmouse 2\n  kx = limit(kmousex/giwidth, 0, 1)\n  ky = 1 - limit(kmousey/giheight, 0, 1)\n\n  printf \"x: %f   y: %f \\n\", changed(kx, ky), kx, ky\n\n  iamp = 0.1\n  a0 oscili iamp, mtof(xyscale(kx, ky, ibl[0], itl[0], ibr[0], itr[0]))\n  a1 oscili iamp, mtof(xyscale(kx, ky, ibl[1], itl[1], ibr[1], itr[1]))\n  a2 oscili iamp, mtof(xyscale(kx, ky, ibl[2], itl[2], ibr[2], itr[2]))\n  aout = sum(a0, a1, a2)\n  outs aout, aout  \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni 1 0 120\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/xyscale/#see-also","title":"See also","text":"<p>Linear and Exponential Generators</p>"},{"location":"opcodes/xyscale/#credits","title":"Credits","text":"<p>By: Eduardo Moguillansky 2017</p>"},{"location":"opcodes/zdf_1pole/","title":"Zdf 1pole","text":""},{"location":"opcodes/zdf_1pole/#zdf_1pole","title":"zdf_1pole","text":"<p>Zero-delay feedback implementation of a 1 pole (6 dB/oct) filter.</p> <p>Offers low-pass (default), high-pass, and allpass output modes.</p>"},{"location":"opcodes/zdf_1pole/#syntax","title":"Syntax","text":"<pre><code>asig zdf_1pole ain, xcf [, kmode, istor]\n</code></pre>"},{"location":"opcodes/zdf_1pole/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/zdf_1pole/#performance","title":"Performance","text":"<p>asig -- high-pass output signal.</p> <p>asig -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>kmode -- filter output type. The default value is 0. The output mode may be one of the following.</p> <ul> <li>0 - low-pass</li> <li>1 - high-pass</li> <li>2 - allpass</li> </ul>"},{"location":"opcodes/zdf_1pole/#examples","title":"Examples","text":"<p>Here is an example of the zdf_1pole opcode. It uses the file zdf_1pole.csd.</p> Example of the zdf_1pole opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\ninstr 1 \n  asig = random:a(-1.0, 1.0) \n  asig = zdf_1pole(asig, line(220, p3, 10000), p4)\n  outc(asig, asig)\nendin\n\ninstr 2 \n  asig = vco2(0.5, 220)\n  asig = zdf_1pole(asig, line(220, p3, 10000), p4)\n  outc(asig, asig)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 4 0\ni1 5 4 1\ni1 10 4 2\ni2 15 4 0\ni2 20 4 1\ni2 25 4 2 \n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zdf_1pole/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-4:\u00a0Virtual Analog (VA) Filter Implementation. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/zdf_1pole/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/zdf_1pole/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/zdf_1pole_mode/","title":"Zdf 1pole mode","text":""},{"location":"opcodes/zdf_1pole_mode/#zdf_1pole_mode","title":"zdf_1pole_mode","text":"<p>Zero-delay feedback implementation of 1 pole (6 dB/oct) filter with multimode output.</p> <p>Offers low-pass and high-pass output.</p>"},{"location":"opcodes/zdf_1pole_mode/#syntax","title":"Syntax","text":"<pre><code>alp, ahp zdf_1pole_mode ain, xcf [, istor]\n</code></pre>"},{"location":"opcodes/zdf_1pole_mode/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/zdf_1pole_mode/#performance","title":"Performance","text":"<p>alp -- low-pass output signal.</p> <p>ahp -- high-pass output signal.</p> <p>asig -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p>"},{"location":"opcodes/zdf_1pole_mode/#examples","title":"Examples","text":"<p>Here is an example of the zdf_1pole_mode opcode. It uses the file zdf_1pole_mode.csd.</p> Example of the zdf_1pole_mode opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\ninstr 1 \n  asig = random:a(-1.0, 1.0) \n  alp, ahp zdf_1pole_mode asig, line(220, p3, 10000)\n  asig = (p4 == 0) ? alp : ahp\n  outc(asig, asig)\nendin\n\ninstr 2 \n  asig = vco2(0.5, 220)\n  alp, ahp zdf_1pole_mode asig, line(220, p3, 10000)\n  asig = (p4 == 0) ? alp : ahp\n  outc(asig, asig)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 4 0\ni1 5 4 1\ni2 10 4 0\ni2 15 4 1\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zdf_1pole_mode/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-4:\u00a0Virtual Analog (VA) Filter Implementation. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/zdf_1pole_mode/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/zdf_1pole_mode/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/zdf_2pole/","title":"Zdf 2pole","text":""},{"location":"opcodes/zdf_2pole/#zdf_2pole","title":"zdf_2pole","text":"<p>Zero-delay feedback implementation of a 2 pole (12 dB/oct) filter.</p> <p>Offers low-pass (default), high-pass, and allpass output modes.</p>"},{"location":"opcodes/zdf_2pole/#syntax","title":"Syntax","text":"<pre><code>asig zdf_2pole ain, xcf, xQ [, kmode, istor]\n</code></pre>"},{"location":"opcodes/zdf_2pole/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/zdf_2pole/#performance","title":"Performance","text":"<p>asig -- output signal.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>xQ -- filter Q value (i-, k-, or a-rate). Range 0.5-25.0.</p> <p>kmode -- filter output type. The default value is 0. The output mode may be one of the following.</p> <ul> <li>0 - low-pass</li> <li>1 - high-pass</li> <li>2 - band-pass</li> <li>3 - unity-gain band-pass</li> <li>4 - notch</li> <li>5 - allpass</li> <li>6 - peak</li> </ul>"},{"location":"opcodes/zdf_2pole/#examples","title":"Examples","text":"<p>Here is an example of the zdf_2pole opcode. It uses the file zdf_2pole.csd.</p> Example of the zdf_2pole opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      = 44100 \nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\ninstr 1 \n  asig = random:a(-1.0, 1.0) \n  asig = zdf_2pole(asig, line(20, p3, 10000), 4, p4)\n\n  outc(asig, asig)\nendin\n\ninstr 2 \n  asig = vco2(0.5, 220) \n  asig = zdf_2pole(asig, line(20, p3, 10000), 4, p4)\n  outc(asig, asig)\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 4 0\ni1 5 4 1 \ni1 10 4 2\ni1 15 4 3\ni1 20 4 4\ni1 25 4 5\ni1 30 4 6\n\ni2 40 4 0\ni2 45 4 1 \ni2 50 4 2\ni2 55 4 3\ni2 60 4 4\ni2 65 4 5\ni2 70 4 6\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zdf_2pole/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-4:\u00a0Virtual Analog (VA) Filter Implementation. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/zdf_2pole/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/zdf_2pole/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/zdf_2pole_mode/","title":"Zdf 2pole mode","text":""},{"location":"opcodes/zdf_2pole_mode/#zdf_2pole_mode","title":"zdf_2pole_mode","text":"<p>Zero-delay feedback implementation of 2 pole (12 dB/oct) filter with multimode output.</p> <p>Offers low-pass, band-pass, and high-pass output.</p>"},{"location":"opcodes/zdf_2pole_mode/#syntax","title":"Syntax","text":"<pre><code>alp, abp, ahp zdf_2pole_mode ain, xcf, Q [, istor]\n</code></pre>"},{"location":"opcodes/zdf_2pole_mode/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/zdf_2pole_mode/#performance","title":"Performance","text":"<p>alp -- low-pass output signal.</p> <p>abp -- band-pass output signal.</p> <p>ahp -- high-pass output signal.</p> <p>ain -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>Q -- filter Q value (i-, k-, or a-rate). Range 0.5-25.0.</p>"},{"location":"opcodes/zdf_2pole_mode/#examples","title":"Examples","text":"<p>Here is an example of the zdf_2pole_mode opcode. It uses the file zdf_2pole_mode.csd.</p> Example of the zdf_2pole_mode opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      = 44100 \nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\ninstr 1 \n  asig = random:a(-1.0, 1.0) \n  asigs[] init 3\n  asigs[0], asigs[1], asigs[2] zdf_2pole_mode asig, line(20, p3, 10000), 4 \n\n  asig = asigs[p4]\n  outc(asig, asig)\nendin\n\ninstr 2 \n  asig = vco2(0.5, 220) \n  asigs[] init 3\n  asigs[0], asigs[1], asigs[2] zdf_2pole_mode asig, line(20, p3, 10000), 4 \n  outc(asigs[p4], asigs[p4])\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 4 0\ni1 5 4 1\ni1 10 4 2\n\ni2 15 4 0\ni2 20 4 1\ni2 25 4 2\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zdf_2pole_mode/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-4:\u00a0Virtual Analog (VA) Filter Implementation. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/zdf_2pole_mode/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/zdf_2pole_mode/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/zdf_ladder/","title":"Zdf ladder","text":""},{"location":"opcodes/zdf_ladder/#zdf_ladder","title":"zdf_ladder","text":"<p>Zero-delay feedback implementation of a 4 pole (24 dB/oct) low-pass filter based on the Moog ladder filter.</p>"},{"location":"opcodes/zdf_ladder/#syntax","title":"Syntax","text":"<pre><code>asig zdf_ladder ain, xcf, xQ [, istor]\n</code></pre>"},{"location":"opcodes/zdf_ladder/#initialization","title":"Initialization","text":"<p>istor --initial disposition of internal data space. Since filtering incorporates a feedback loop of previous output, the initial status of the storage space used is significant.  A zero value will clear the space; a non-zero value will allow previous information to remain. The default value is 0.</p>"},{"location":"opcodes/zdf_ladder/#performance","title":"Performance","text":"<p>asig -- output signal.</p> <p>asig -- input signal.</p> <p>xcf -- filter cutoff frequency (i-, k-, or a-rate).</p> <p>xQ -- filter Q value (i-, k-, or a-rate). Range 0.5-25.0. Self-oscillation occurs at 25.0.</p>"},{"location":"opcodes/zdf_ladder/#examples","title":"Examples","text":"<p>Here is an example of the zdf_ladder opcode. It uses the file zdf_ladder.csd.</p> Example of the zdf_ladder opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr      =       48000\nksmps   =       1\nnchnls  =       2\n0dbfs   =       1\n\ninstr 1 \n  asig = random:a(-1.0, 1.0) \n  asig = zdf_ladder(asig, expon(220, p3, 5000), p4)\n  outc(asig, asig)\nendin\n\ninstr 2 \n  asig = vco2(0.5, 220)\n  asig = zdf_ladder(asig, expon(220, p3, 5000), p4)\n  outc(asig, asig)\nendin\n\ninstr 3 \n  asig = vco2(0.5, p4)\n  asig = zdf_ladder(asig, expon(5000, p3, 200), 0.5 + p5* 24)\n  asig *= madsr(0.05, 0, 1, 0.25)\n  outc(asig, asig)\nendin\n\n\ninstr play_instr3\n  schedule(3, 0, 0.25, mtof(48 + (p4 % 2) * 12), p4 / 16)\n\n  if(p4 &lt; 16) then \n    schedule(\"play_instr3\", 0.25, 0.25, p4 + 1)\n  else\n    event_i(\"e\", 0.5,0)\n  endif \n  turnoff\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0 2 0.5\ni1 + . 1 \ni1 + . 4 \ni1 + . 10 \ni1 + . 18 \ni1 + . 24.5 \ni2 12 2 0.5\ni2 + . 1 \ni2 + . 4 \ni2 + . 10 \ni2 + . 18 \ni2 + . 24.5 \n\ns\ni \"play_instr3\" 0 0.25 0 \nf0 60\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zdf_ladder/#references","title":"References","text":"<p>This filter is based on the work of Will Pirkle that employs Vadim Zavalishin's work with bilinear tranforms to create topology-preserving transform (TPT) implementations of analog filters.</p> <ol> <li>Pirkle, Will. Designing Software Synthesizer Plug-ins in C++: For RackAFX, VST3, and Audio Units. CRC Press, 2014.</li> <li>Pirkle, Will. AN-4:\u00a0Virtual Analog (VA) Filter Implementation. 2013.</li> <li>Zavalishin, Vadim. \"The Art of VA filter design.\" Native Instruments, 2012.</li> </ol>"},{"location":"opcodes/zdf_ladder/#see-also","title":"See also","text":"<p>Standard filters: Zero-delay Feedback Filters (Virtual Analog)</p>"},{"location":"opcodes/zdf_ladder/#credits","title":"Credits","text":"<p>Author: Steven Yi April 2017</p> <p>New in Csound 6.09.0</p>"},{"location":"opcodes/zfilter2/","title":"Zfilter2","text":""},{"location":"opcodes/zfilter2/#zfilter2","title":"zfilter2","text":"<p>Performs filtering using a transposed form-II digital filter lattice with radial pole-shearing and angular pole-warping.</p> <p>General purpose custom filter with time-varying pole control. The filter coefficients implement the following difference equation:</p> \\[ (1) y(n) = b_0 x[n] + b_1 x[n-1] + ... + b_M x[n-M] - a_1 y[n-1] - ... - a_N y[n-N] \\] <p>the system function for which is represented by:</p> \\[ H(z) = \\frac{B(z)}{A(z)} = \\frac{b_0 + b_1 z^{-1} + ... + b_M z^{-M}}{1 + a_1 z^{-1} + ... + a_N z^{-N}} \\]"},{"location":"opcodes/zfilter2/#syntax","title":"Syntax","text":"<pre><code>ares zfilter2 asig, kdamp, kfreq, iM, iN, ib0, ib1, ..., ibM, ia1,ia2, ..., iaN\n</code></pre>"},{"location":"opcodes/zfilter2/#initialization","title":"Initialization","text":"<p>At initialization the number of zeros and poles of the filter are specified along with the corresponding zero and pole coefficients. The coefficients must be obtained by an external filter-design application such as Matlab or Octave (GPL) and specified directly or loaded into a table via GEN01. With zfilter2, the roots of the characteristic polynomials are solved at initialization so that the pole-control operations can be implemented efficiently.</p>"},{"location":"opcodes/zfilter2/#performance","title":"Performance","text":"<p>The filter2 opcodes perform filtering using a transposed form-II digital filter lattice with no time-varying control. zfilter2 uses the additional operations of radial pole-shearing and angular pole-warping in the Z plane.</p> <p>Pole shearing increases the magnitude of poles along radial lines in the Z-plane. This has the affect of altering filter ring times. The k-rate variable kdamp is the damping parameter. Positive values (0.01 to 0.99) increase the ring-time of the filter (hi-Q), negative values (-0.01 to -0.99) decrease the ring-time of the filter, (lo-Q).</p> <p>Pole warping changes the frequency of poles by moving them along angular paths in the Z plane. This operation leaves the shape of the magnitude response unchanged but alters the frequencies by a constant factor (preserving 0 and p). The k-rate variable kfreq determines the frequency warp factor. Positive values (0.01 to 0.99) increase frequencies toward p and negative values (-0.01 to -0.99) decrease frequencies toward 0.</p> <p>Since filter2 implements generalized recursive filters, it can be used to specify a large range of general DSP algorithms. For example, a digital waveguide can be implemented for musical instrument modeling using a pair of delayr and delayw opcodes in conjunction with the filter2 opcode.</p>"},{"location":"opcodes/zfilter2/#examples","title":"Examples","text":"<p>A controllable second-order IIR filter operating on an a-rate signal:</p> <pre><code>a1 zfilter2 asig, kdamp, kfreq, 1, 2, 1, ia1, ia2 ;; controllable a-rate IIR filter\n</code></pre> <p>Here is an example of the zfilter2 opcode. It uses the files zfilter2.csd.</p> Example of the zfilter2 opcode.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o zfilter2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; By Stefano Cucchi 2020\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nkdamp linseg p5, p3, p6 \nkfreq linseg p7, p3, p8                                                                     \nkcps  init cpspch(p4)\nasig1 vco2 .2, kcps                     \nasaw zfilter2 asig1, kdamp, kfreq, 2, 2, 0.81, 0.713, 0.0001, 0.99      \n\nacompare oscil 0.2, 440 ; signal comparator for volume \nasaw balance asaw, acompare ; adjust the volume. Volume can have big variation due to filter.\n      outs asaw, asaw\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 5 6.00 0.6 0.99 0.006 0.006 ; varying ringing time (from 0.6 to 0.99)\ni 1 6 5 6.00 0.3 0.3 0.01 -0.8    ; varying frequency warp factor (from 0.01 to -0.8)\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"opcodes/zfilter2/#see-also","title":"See also","text":"<p>Specialized Filters: Other filters</p>"},{"location":"opcodes/zfilter2/#credits","title":"Credits","text":"<p>Author: Michael A. Casey M.I.T. Cambridge, Mass. 1997</p> <p>New in Version 3.47</p>"},{"location":"pitch/funcs/","title":"Functions","text":"<p>Opcodes that provide common pitch functions are:</p> <ul> <li>cent</li> <li>cpsmidinn</li> <li>cpsoct</li> <li>cpspch</li> <li>ftom</li> <li>mtof</li> <li>mton</li> <li>ntom</li> <li>ntof</li> <li>pchtom</li> <li>octave</li> <li>octcps</li> <li>octmidinn</li> <li>octpch</li> <li>pchmidinn</li> <li>pchoct</li> <li>semitone</li> </ul>"},{"location":"pitch/tuning/","title":"Tuning Opcodes","text":"<p>Opcodes that provide tuning functions are:</p> <ul> <li>cps2pch</li> <li>cpsxpch</li> <li>cpstun</li> <li>cpstuni</li> </ul>"},{"location":"score/eval/","title":"Expressions","text":"<p>just take https://csound.com/manual/ScoreEval.html</p>"},{"location":"score/genroutines/","title":"GEN Routines","text":"<p>GEN routines are used as data generators for function tables. When a function table is created using the f score statement, the GEN function is given as its fourth argument. A negative GEN number implies that the function is not rescaled, and maintains its original values.</p>"},{"location":"score/genroutines/#sinecosine-generators","title":"Sine/Cosine Generators:","text":"<ul> <li>GEN09 - Composite waveforms made up of weighted sums of simple sinusoids.</li> <li>GEN10 - Composite waveforms made up of weighted sums of simple sinusoids.</li> <li>GEN11 - Additive set of cosine partials.</li> <li>GEN19 - Composite waveforms made up of weighted sums of simple sinusoids.</li> <li>GEN30 - Generates harmonic partials by analyzing an existing table.</li> <li>GEN33 - Generate composite waveforms by mixing simple sinusoids.</li> <li>GEN34 - Generate composite waveforms by mixing simple sinusoids.</li> </ul>"},{"location":"score/genroutines/#lineexponential-segment-generators","title":"Line/Exponential Segment Generators:","text":"<ul> <li>GEN05 - Constructs functions from segments of exponential curves.</li> <li>GEN06 - Generates a function comprised of segments of cubic polynomials.</li> <li>GEN07 - Constructs functions from segments of straight lines.</li> <li>GEN08 - Generate a piecewise cubic spline curve.</li> <li>GEN16 - Creates a table from a starting value to an ending value.</li> <li>GEN25 - Construct functions from segments of exponential curves in breakpoint fashion.</li> <li>GEN27 - Construct functions from segments of straight lines in breakpoint fashion.</li> </ul>"},{"location":"score/genroutines/#file-access-gen-routines","title":"File Access GEN Routines:","text":"<ul> <li>GEN01 -  Transfers data from a soundfile into a function table.</li> <li>GEN23 - Reads numeric values from a text file.</li> <li>GEN28 -  Reads a text file which contains a time-tagged trajectory.</li> <li>GEN43 - Loads a PVOCEX file containing a PV analysis.</li> <li>GEN49 - Transfers data from an MP3 soundfile into a function table.</li> </ul>"},{"location":"score/genroutines/#numeric-value-access-gen-routines","title":"Numeric Value Access GEN Routines","text":"<ul> <li>GEN02 -  Transfers data from immediate pfields into a function table.</li> <li>GEN17 - Creates a step function from given x-y pairs.</li> <li>GEN44 - Creates a stifness matrix for scan/scanu.</li> <li>GEN52 - Creates an interleaved multichannel table from the specified source tables, in the format expected by the ftconv opcode.</li> </ul>"},{"location":"score/genroutines/#window-function-gen-routines","title":"Window Function GEN Routines","text":"<ul> <li>GEN20 -  Generates functions of different windows.</li> </ul>"},{"location":"score/genroutines/#random-function-gen-routines","title":"Random Function GEN Routines","text":"<ul> <li>GEN21 -  Generates tables of different random distributions.</li> <li>GEN40 - Generates a random distribution using a distribution histogram.</li> <li>GEN41 -  Generates a random list of numerical pairs.</li> <li>GEN42 - Generates a random distribution of discrete ranges of values.</li> </ul>"},{"location":"score/genroutines/#waveshaping-gen-routines","title":"Waveshaping GEN Routines","text":"<ul> <li>GEN03 -  Generates a stored function table by evaluating a polynomial.</li> <li>GEN13 - Stores a polynomial whose coefficients derive from the Chebyshev polynomials of the first kind.</li> <li>GEN14 -  Stores a polynomial whose coefficients derive from Chebyshevs of the second kind.</li> <li>GEN15 - Creates two tables of stored polynomial functions.</li> </ul>"},{"location":"score/genroutines/#amplitude-scaling-gen-routines","title":"Amplitude Scaling GEN Routines","text":"<ul> <li>GEN04 -  Generates a normalizing function.</li> <li>GEN12 - Generates the log of a modified Bessel function of the second kind.</li> <li>GEN24 -  Reads numeric values from another allocated function-table and rescales them.</li> </ul>"},{"location":"score/genroutines/#mixing-gen-routines","title":"Mixing GEN Routines","text":"<ul> <li>GEN18 -  Writes composite waveforms made up of pre-existing waveforms.</li> <li>GEN31 - Mixes any waveform specified in an existing table.</li> <li>GEN32 -   Mixes any waveform, resampled with either FFT or linear interpolation.</li> </ul>"},{"location":"score/genroutines/#pitch-and-tuning-gen-routines","title":"Pitch and Tuning GEN Routines","text":"<ul> <li>GEN51 - fills a table with a fully customized micro-tuning scale, in the manner of Csound opcodes cpstun, cpstuni and cpstmid.</li> </ul>"},{"location":"score/genroutines/#named-gen-routines","title":"Named GEN Routines","text":"<p>Csound's GEN routines can be extended with GEN function plugins. There is currently a simple GEN plugin that provides exponential and hyperbolic tangent functions, and the sone function. There is also a generator called farey for the Farey sequence operations, and a B\u00e9zier curve generator. These GEN functions are not called by number, but by name.</p> <ul> <li>\"tanh\" - fills a table from a hyperbolic tangent formula.</li> <li>\"exp\" - fills a table from an exponential formula.</li> <li>\"sone\" - fills a table from a sone function formula.</li> <li>\"farey\" - fills a table from a Farey sequence.</li> <li>\"quadbezier\" - fills a table with a quadratic B\u00e9zier curve.</li> <li>\"wave\" - fills a table from a wavelet transform.</li> <li>\"padsynth\" - fills a table using the padsynth algorithm.</li> </ul>"},{"location":"score/macros/","title":"Macros","text":"<p>this can be taken from https://csound.com/manual/ScoreMacros.html --- i would only avoid the subtitles which are taken from the manual page template.</p>"},{"location":"score/mult/","title":"Included files","text":"<p>https://csound.com/manual/ScoreMult.html can be used with some small edits and avoiding the manual page template</p>"},{"location":"score/note-durations/","title":"Durations in Instrument Events","text":"<p>The third parameter field in an instrument event (accessible as <code>p3</code> in the called instrument) sets the duration of the instrument instance. However, there are some notable cases and features.</p>"},{"location":"score/note-durations/#duration-in-score-vs-realtime-events-beats-vs-seconds","title":"Duration in Score vs. Realtime Events: Beats vs. Seconds","text":""},{"location":"score/note-durations/#instrument-events-given-in-the-standard-numeric-score","title":"Instrument Events Given in the Standard Numeric Score","text":"<p>If an instrument is called via the score, both <code>p2</code> (start time) and <code>p3</code> (duration) are measured in beats. Per default, one beat is in tempo 60 beats per minute, so one second. But it is affected by the tempo statement which can be given via the <code>t</code> statement. So without any tempo statement this score will result in one second performance of instrument 1, then one second pause, and thene again one second performance:</p> <pre><code>&lt;CsScore&gt;\ni 1 0 1\ni 1 2 1\n&lt;/CsScore&gt;\n</code></pre> <p>Setting the tempo to 120 bpm, instrument 1 will play for 0.5 seconds, followed by a pause of 0.5 seconds, and then again 0.5 seconds performance of instrument 1:</p> <pre><code>&lt;CsScore&gt;\nt 0 120\ni 1 0 1\ni 1 2 1\n&lt;/CsScore&gt;\n</code></pre>"},{"location":"score/note-durations/#instrument-events-given-in-the-orchestra-code","title":"Instrument Events Given in the Orchestra Code","text":"<p>If an instrument is called via an opcode in the Csound orchestra (typically <code>schedule</code> or <code>schedulek</code>), both <code>p2</code> and <code>p3</code> are not affected by any tempo statement in the score. They always measure time in seconds. So this code will always result in one second performance, one second pause, one second performance whatever the tempo be in the score:</p> <pre><code>&lt;CsInstruments&gt;\nschedule(1,0,1)\nschedule(1,2,1)\n&lt;/CsInstruments&gt;\n</code></pre>"},{"location":"score/note-durations/#overwriting-the-duration-in-the-instrument","title":"Overwriting the Duration in the Instrument","text":"<p>This is a simple but versatile feature. Any duration given by the note event can be overwritten inside the instrument:</p> <pre><code>instr 1\n  p3 = 2\n  aSig = oscili:a(.2,300)\n  outall(aSig)\nendin\nschedule(1,0,100)\n</code></pre>"},{"location":"score/note-durations/#zero-duration","title":"Zero Duration","text":"<p>Calling an instrument with duration zero means that only the inilialization pass is executed.</p> <pre><code>instr 1\n  // this will be printed\n  prints(\"i-rate\\n\")\n  // this will not be printed\n  printks(\"k-rate\\n\",0)\nendin\nschedule(1,0,0)\n</code></pre>"},{"location":"score/note-durations/#negative-duration","title":"Negative Duration","text":""},{"location":"score/note-durations/#legato-or-tied-notes","title":"Legato or Tied Notes","text":"<p>Basically, negative duration (usually <code>-1</code>) was introduced into Csound as feature for tied notes. If one instance is called with a negative duration, the next call will continue this instance rather than invoking a new instance.</p> <pre><code>instr 1\n  aSig = poscil:a(0.2,p4)\n  outall(aSig)\nendin\nschedule(1,0,-1,400)\nschedule(1,1.1,-1,500)\nschedule(1,2.2,1,444)\n</code></pre>"},{"location":"score/note-durations/#allowing-more-than-one-instance","title":"Allowing More Than One Instance","text":"<p>It is possible to run several instances called by negative duration at the same time when these instances are called with different fractional numbers.</p> <pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n-odac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \ninstr 1\n  aSig = poscil:a(0dbfs/5,p4)\n  outall(aSig)\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\n// normal behaviour: only one instance\ni 1 0 -1 400\ni 1 1 -1 500\ni 1 2  1 444\ns\n// explicit instances: simultaneous instances\ni 1.01 1 -1 400\ni 1.02 2 -1 500\ni 1.03 3  1 444\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"score/note-durations/#one-single-negative-duration","title":"One Single Negative Duration","text":"<p>If there is only one negative duration, the called instrument instance will play for an indefinite duration; in other words: as long as Csound is running.</p> <pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n-odac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \ninstr 1\n  aSig = poscil:a(0dbfs/5,400)\n  outall(aSig)\nendin\nschedule(1,0,-1)\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>This code runs \"endlessly\" because the score section is empty. Putting the note event in the score will terminate Csound immediately as -1 is no duration and the last score event defines the overall duration of Csound's performance.</p> <pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n-odac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \ninstr 1\n  aSig = poscil:a(0dbfs/5,400)\n  outall(aSig)\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\ni 1 0 -1\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>There must be a <code>e</code> or <code>f0</code> statement followed by a positive duration to prevent this termination.</p> <pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n-odac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \ninstr 1\n  aSig = poscil:a(0dbfs/5,400)\n  outall(aSig)\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\ni 1 0 -1\ne 10\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"score/note-durations/#summary","title":"Summary","text":"<ol> <li>If an instrument is called twice with negative duration, the second call will terminate the first instance.  </li> <li>Only if fractional instrument numbers are used. several instances can be run simultaneously.  </li> <li>One single instance will run as long as Csound runs.</li> </ol>"},{"location":"score/parameter-fields/","title":"Parameter Fields","text":"<p>The standard numeric score consists of lines where each line represents a single statement. Each statement begins with a character denoting the type of statement, followed by a number of parameters specifying this statement. Parameters are separated by spaces or tabs. The parameter fields (p-fields) are numbered and abbreviated as p1, p2, p3, ...</p> Char p1 p2 p3 p4 p5 p6 Type of statement i 1 0 3 - - - instrument call f 1 0 1025 10 1 - function table creation a 0 0 80 - - - advances score time e 60 - - - - - ends score execution <p>The p-fields have different meanings in the different statements. In the example above, p1 means the instrument number for the i-statement, the function table number for the f-statement, is without any meaning for the a-statement, and signifies the time for the e-statement.</p>"},{"location":"score/parameter-fields/#p-fields-in-instrument-events","title":"P-Fields in Instrument Events","text":"<p>Instrument events starting with the character i are by far the most important score statements. In fact, the score is a collection of instrument calls plus some extra statements to ease the control and overview for larger scores.</p> <p>For each instrument event, the first three parameters are mandatory and carry a fixed meaning:</p> <ul> <li>p1 is the instrument number or name  </li> <li>p2 is the time to start the instrument instance  </li> <li>p3 is the duration of the instrument instance to run</li> </ul> <p>The meaning of the optional parameters p4, p5, ... is given by the instrument definition. All score parameters are accessible in the instrument definition as <code>p1</code>, <code>p2</code> etc.</p> <pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n-odac\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \ninstr 1\n  print(p1,p2,p3)\n  amp:i = p4*0dbfs\n  freq:i = p5\n  aSig = poscil:a(amp,freq)\n  outall(aSig)\nendin\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt;\ni 1 0 3 0.2 400\n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre>"},{"location":"score/preproc/","title":"Preprocessing","text":"<p>i think this can be a copy of the \"Preprocessing\" section in https://csound.com/manual/ScoreTop.html#ScorePreproc.</p> <p>Also integrate https://csound.com/manual/ScoreNextp.html and https://csound.com/manual/ScoreRamping.html</p>"},{"location":"score/scripts/","title":"Scripts","text":"<p>see this</p> <p>is there another source in the manual?  also point to the manual page of CsBeats</p>"},{"location":"score/statemnt/","title":"Score Statements","text":"<p>The statements used in scores are:</p> <ul> <li>a - Advance score time by a specified amount</li> <li>b - Resets the clock</li> <li>B - Accumulate clock adjustment</li> <li>C - Toggles carry facility</li> <li>d - Deletes an infinite instrument</li> <li>e - Marks the end of the last section of the score</li> <li>f - Causes a GEN subroutine to place values in a stored function table</li> <li>i - Makes an instrument active at a specific time and for a certain duration</li> <li>m - Sets a named mark in the score</li> <li>n - Repeats a section</li> <li>q - Used to quiet an instrument</li> <li>r - Starts a repeated section</li> <li>s - Marks the end of a section</li> <li>t - Sets the tempo</li> <li>v - Provides for locally variable time warping of score events</li> <li>x - Skip the rest of the current section</li> <li>y - Set seed for random numbers, either from p1 or, if omitted, the clock</li> <li>{ - Begins a non-sectional, nestable loop.</li> <li>} - Ends a non-sectional, nestable loop.</li> </ul> <p>Comments are denoted by semicolon (;), double slash (//) or the character c and last until a newline. Also C-style comments /* ... */ are allowed.</p>"},{"location":"scoregens/C/","title":"C","text":""},{"location":"scoregens/C/#c-statement","title":"C Statement","text":"<p>This statement switches automatic carrying of arguments on or off.</p>"},{"location":"scoregens/C/#syntax","title":"Syntax","text":"<pre><code>C p1\n</code></pre>"},{"location":"scoregens/C/#performance","title":"Performance","text":"<p>p1 -- Specifies whether to switch off (value 0) or on (non-zero).</p>"},{"location":"scoregens/C/#examples","title":"Examples","text":"<p>Here is an example of the C statement. It uses the file C.csd.</p> Example of the C statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n  -o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ninstr 1\nii pcount\nprint ii\n  a1  oscil 0.5,A4\n  out a1\n  endin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\n\ni1   0    .5     100\ni .  +\ni .  .    .      !\ni\n\ns\ni1   0    .5     100\ni .  +    .\nC    0\ni .  .    .\ni .  .\ni .\n\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/C/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/C/#credits","title":"Credits","text":"<p>Author: John ffitch Alta Sounds Bath, UK 2016</p> <p>New in version 6.08</p>"},{"location":"scoregens/a/","title":"A","text":""},{"location":"scoregens/a/#a-statement-or-advance-statement","title":"a Statement (or Advance Statement)","text":"<p>Advance score time by a specified amount without producing sound samples.</p>"},{"location":"scoregens/a/#syntax","title":"Syntax","text":"<pre><code>a p1  p2  p3\n</code></pre>"},{"location":"scoregens/a/#performance","title":"Performance","text":"<pre><code>p1    Carries no meaning. Usually zero.\np2    Action time, in beats, at which advance is to begin.\np3    Number of beats to advance without producing sound.\np4    |\np5    |    These carry no meaning.\np6    |\n.\n.\n</code></pre>"},{"location":"scoregens/a/#special-considerations","title":"Special Considerations","text":"<p>This statement allows the beat count within a score section to be advanced without generating intervening sound samples. This can be of use when a score section is incomplete (the beginning or middle is missing) and the user does not wish to generate and listen to a lot of silence.</p> <p>p2, action time, and p3, number of beats, are treated as in i statements, with respect to sorting and modification by t statements.</p> <p>An a statement will be temporarily inserted in the score by the Score Extract feature when the extracted segment begins later than the start of a Section. The purpose of this is to preserve the beat count and time count of the original score for the benefit of the peak amplitude messages which are reported on the user console.</p> <p>Whenever an a statement is encountered by a performing orchestra, its presence and effect will be reported on the user's console.</p>"},{"location":"scoregens/a/#examples","title":"Examples","text":"<p>Here is an example of the a statement. It uses the file a.csd.</p> Example of the a statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o a.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n;two sections\ns\na 0 0 6         ;advance score 6 seconds\ni 1 0 2 110     ;these first 2 notes\ni 1 3 2 220     ;will not sound\ni 1 6 2 440\ni 1 9 2 880\ns\na 0 3 6         ;advance score 6 seconds, but do this after 3 seconds\ni 1 0 2 110     ;this will sound, because action time (p2) from a statement = 3\ni 1 3 2 220     ;so these 2 notes\ni 1 6 2 440     ;will not sound\ni 1 9 2 880     ;and this one will\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/a/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/b/","title":"B","text":""},{"location":"scoregens/b/#b-statement","title":"b Statement","text":"<p>This statement resets the clock.</p>"},{"location":"scoregens/b/#syntax","title":"Syntax","text":"<pre><code>b p1\n</code></pre>"},{"location":"scoregens/b/#performance","title":"Performance","text":"<p>p1 -- Specifies how the clock is to be set.</p>"},{"location":"scoregens/b/#special-considerations","title":"Special Considerations","text":"<p>p1 is the number of beats by which p2 values of subsequent i statements are modified. If p1 is positive, the clock is reset forward, and subsequent notes appear later, the number of beats specified by p1 being added to the note's p2. If p1 is negative, the clock is reset backward, and subsequent notes appear earlier, the number of beats specified by p1 being subtracted from the note's p2. There is no cumulative affect. The clock is reset with each b statement. If p1 = 0, the clock is returned to its original position, and subsequent notes appear at their specified p2.</p>"},{"location":"scoregens/b/#examples","title":"Examples","text":"<pre><code>i1     0      2\ni1     10     888       \n\nb 5                           ; set the clock \"forward\"\ni2     1      1     440       ; start time = 6\ni2     2      1     480       ; start time = 7\n\nb -1                          ; set the clock back\ni3     3      2     3.1415    ; start time = 2\ni3     5.5    1     1.1111    ; start time = 4.5\n\nb 0                           ; reset clock to normal\ni4     10     200   7         ; start time = 10\n</code></pre>"},{"location":"scoregens/b/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/b/#credits","title":"Credits","text":"<p>Explanation suggested and example provided by Paul Winkler. (Csound Version 4.07)</p>"},{"location":"scoregens/capB/","title":"capB","text":""},{"location":"scoregens/capB/#b-statement","title":"B Statement","text":"<p>This statement adjusts the clock accumultively.</p>"},{"location":"scoregens/capB/#syntax","title":"Syntax","text":"<pre><code>B p1\n</code></pre>"},{"location":"scoregens/capB/#performance","title":"Performance","text":"<p>p1 -- Specifies how the clock is to be set.</p>"},{"location":"scoregens/capB/#special-considerations","title":"Special Considerations","text":"<p>p1 is the number of beats by which p2 values of subsequent i statements are modified. If p1 is positive, the clock is reset forward, and subsequent notes appear later, the number of beats specified by p1 being added to the note's p2. If p1 is negative, the clock is reset backward, and subsequent notes appear earlier, the number of beats specified by p1 being subtracted from the note's p2. The clock is incremented by p1 for subsequent notes.</p>"},{"location":"scoregens/capB/#examples","title":"Examples","text":"<p>Here is an example of the B statement. It uses the file capB.csd.</p> Example of the B statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o b.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .4*aenv, 220, 1\n     outs asig, asig\n\nendin\n\ninstr 2\n\nasig pluck 0.7, p4, 220, 0, 1\n     outs asig, asig\n\nendin\n\ninstr 3\n\nasig loscil .8, 1, 2, 1\n     outs asig, asig\n\nendin\n\ninstr 4\nasig  bamboo .8, 0.01\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1                ;sine wave\nf 2 0 0 1 \"fox.wav\" 0 0 0       ;sample\n\ni1  0 2\ni1  10 2\n\nb 5                     ; set the clock \"forward\"\ni2 1 2 220              ; start time = 6\ni2 2 2 110              ; start time = 7\n\nB -6                    ; move clock back\ni3 3   2                ; start time = 2\ni3 5.5 1                ; start time = 4.5\n\n\nb 0                     ; reset clock to normal\ni4 10 2                 ; start time = 10\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/capB/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/capB/#credits","title":"Credits","text":"<p>New in Csound 6.15.</p>"},{"location":"scoregens/d/","title":"D","text":""},{"location":"scoregens/d/#d-statement-de-note-statement","title":"d Statement (De Note Statement)","text":"<p>Removes an active instrument at a specific time.</p> <p>This statement calls for an instrument that has been held to be removed at a specific time.</p>"},{"location":"scoregens/d/#syntax","title":"Syntax","text":"<pre><code>i  p1  p2  p3  p4\n</code></pre>"},{"location":"scoregens/d/#initialization","title":"Initialization","text":"<p>p1 -- Instrument number. An optional fractional part can provide an additional tag for specifying ties between particular notes of consecutive clusters.</p> <p>p2 -- Starting time in arbitrary units called beats.</p> <p>p3 -- ignored but required.  Usually zero.</p>"},{"location":"scoregens/d/#performance","title":"Performance","text":"<p>Beats are evaluated as seconds, unless there is a t statement in this score section or a -t flag in the command-line.</p> <p>Action times are relative to the beginning of a section ( see s statement), which is assigned time 0.</p> <p>Note statements within a section may be placed in any order. Before being sent to an orchestra, unordered score statements must first be processed by Sorter, which will reorder them by ascending p2 value. Notes with the same p2 value will be ordered by ascending p1; if the same p1, then by ascending p3.</p>"},{"location":"scoregens/d/#examples","title":"Examples","text":"<p>Here is an example of the d statement. It uses the file d_statement.csd.</p> Example of the d statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n  -o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\ninstr 1\n  a1  oscil 10000, 440\n      out   a1\nendin\ninstr sound\n  a1  oscil 10000, 440\n      out   a1\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\nf 0 10\ni 1 0 -1\nd 1 1 0\n\ni \"sound\" 3 -1\ni \"-sound\" 4 0\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/d/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/d/#credits","title":"Credits","text":"<p>Author: John ffitch, new in version 6.09.</p>"},{"location":"scoregens/e/","title":"E","text":""},{"location":"scoregens/e/#e-statement","title":"e Statement","text":"<p>This statement may be used to mark the end of the last section of the score.</p>"},{"location":"scoregens/e/#syntax","title":"Syntax","text":"<pre><code>e [0 time]\n</code></pre>"},{"location":"scoregens/e/#performance","title":"Performance","text":"<p>The second p-field time is optional and if present determines the end time (length in beats) of the final section of the score.  This time must be after the end of the last event otherwise it will have no effect. \"Always on\" instruments will end at the given time. Extending the section in this way is useful to avoid prematurely cutting off reverb tails or other effects.</p>"},{"location":"scoregens/e/#special-considerations","title":"Special Considerations","text":"<p>The e statement is contextually identical to an s statement. Additionally, the e statement terminates all signal generation (including indefinite performance) and closes all input and output files.</p> <p>If an e statement occurs before the end of a score, all subsequent score lines will be ignored.</p> <p>The e statement is optional in a score file yet to be sorted. If a score file has no e statement, then Sort processing will supply one.</p>"},{"location":"scoregens/e/#examples","title":"Examples","text":"<p>Here is an example of the e statement. It uses the file e.csd.</p> Example of the e statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o e.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nga1 init 0\n\ninstr 1\n\naenv expseg .01, p3*0.1, 1, p3*0.9, 0.01\nga1  poscil3 .5*aenv, cpspch(p4), 1\n     outs ga1,ga1\nendin\n\ninstr 99\n\naL, aR  reverbsc ga1, ga1, 0.85, 12000, sr, 0.5, 1\nouts aL,aR\n\nga1 = 0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 128 10 1          ;sine wave\n\ni 1 1 0.1 8.00\ni 1 2 0.1 8.02\ni 1 3 0.1 8.04\ni 1 4 0.1 9.06\n\ni 99 0 6                ;remains active for 6 seconds\n\ne10\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/e/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/f/","title":"F","text":""},{"location":"scoregens/f/#f-statement-or-function-table-statement","title":"f Statement (or Function Table Statement)","text":"<p>Causes a GEN subroutine to place values in a stored function table for use by instruments.</p>"},{"location":"scoregens/f/#syntax","title":"Syntax","text":"<pre><code>f p1  p2  p3  p4  p5 ... PMAX\n</code></pre>"},{"location":"scoregens/f/#performance","title":"Performance","text":"<p>p1 -- Table number by which the stored function will be known. A negative number requests that the table be destroyed.</p> <p>p2 -- Action time of function generation (or destruction) in beats.</p> <p>p3 -- Size of function table (i.e.  number of points). Some GEN routines allow the table size to be set dynamically according to routine inputs (e.g. file size), in a process called deferred-size allocation. In this case, we can set the table size to 0 to take advantage of this mechanism. Maximum fixed table size is 16777216 (2<sup>24</sup>) points, but larger tables can be created with deferred-size allocation.</p> <p>p4 -- Number of the GEN routine to be called (see GEN Routines). A negative value will cause rescaling to be omitted.</p> <p>p5 ... PMAX -- Parameters whose meaning is determined by the particular GEN routine.</p>"},{"location":"scoregens/f/#special-considerations","title":"Special Considerations","text":"<p>Function tables are arrays of floating-point values. You can create a simple sine wave using the line:</p> <pre><code>f 1 0 1024 10 1\n</code></pre> <p>This table uses GEN10 to fill the table.</p> <p>Historically, due to older platform constraints, Csound could only accept tables whose size was a power of two. This limitation has been removed in recent versions, and you can freely create tables of any size.</p> <p> Note</p> <p>All opcodes will accept tables whose size is not a power of two; however some of them will use a more optimised phase update code if a power-of-two size is used. So we would recommend using power-of-two sizes if possible.</p> <p>Space allocation always provides for the set number of points plus an additional guard point, used for linear interpolation. By default, this point contains a copy of the first position on the table, which is the expected for wrap-around (looping) lookup (e.g. an oscillator reading a function table).</p> <p>For situations where the lookup is expected to end at the last point of the table (e.g. envelope segments), then the correct guard point setting should be to extend the table for one more point (according to the GEN employed). This is called an extended guard point. To request this, special codes are used:</p> <ul> <li> <p>Power-of-two size tables: users should set the size to the required size + 1. For example, a 1024-size table should be set to 1025. To bypass this request and instead create a non-power-of-two size, use a negative size: -1025 produces a 1025-size table with default guard point.</p> </li> <li> <p>Non power-of-two size tables: users should set the size to the required size + 0.1 (or any other fractional value between 0 and 1). For example, a 1000-size table should be set as 1000.1.</p> </li> </ul> <p>Table space is allocated in primary memory, along with instrument data space. The maximum table number used to be 200. This has been changed to be limited by memory only. (Currently there is an internal soft limit of 300, this is automatically extended as required.)</p> <p>An existing function table can be removed by an f statement containing a negative p1 and an appropriate action time. A function table can also be removed by the generation of another table with the same p1. Functions are not automatically erased at the end of a score section.</p> <p>p2 action time is treated in the same way as in i statement_s with respect to sorting and modification by _t statement_s. If an _f statement and an i statement have the same p2, the sorter gives the f statement precedence so that the function table will be available during note initialization.</p> <p> Warning</p> <p>The maximum number of p-fields accepted in the score is determined by PMAX (a compilation time varible). PMAX is currently set to 1000. This may discard values entered when using GEN02. To overcome this, use GEN23 or GEN28 to read the values from a file.</p> <p>An f 0 statement (zero p1, positive p2) may be used to create an action time with no associated action. Such time markers are useful for padding out a score section (see s statement) and for letting Csound run from realtime events only (e.g. using only MIDI input without score events). The time given is the number of seconds Csound will run. If you want Csound to run for 10 hours, use:</p> <pre><code>f0 36000\n</code></pre> <p>The simplest way to fill a table (f1) with 0's is:</p> <pre><code>f1 0 xx 2 0\n</code></pre> <p>where xx = table size.</p> <p>The simplest way to fill a table (f1) with any single value is:</p> <pre><code>f1 0 xx -7 yy xx yy\n</code></pre> <p>where xx = table size and yy = any single value</p> <p>In both of the above examples, table size (p3) must be a power of 2 or power-of-2 plus 1.</p>"},{"location":"scoregens/f/#see-also","title":"See also","text":"<p>GEN Routines</p> <p>Score Statements</p>"},{"location":"scoregens/f/#credits","title":"Credits","text":"<p>Updated August 2024 for Csound 7.</p>"},{"location":"scoregens/gen01/","title":"Gen01","text":""},{"location":"scoregens/gen01/#gen01","title":"GEN01","text":"<p>Transfers data from a soundfile into a function table.</p>"},{"location":"scoregens/gen01/#syntax","title":"Syntax","text":"<pre><code>f#  time  size  1  filcod  skiptime  format  channel\n</code></pre>"},{"location":"scoregens/gen01/#performance","title":"Performance","text":"<p>size -- number of points in the table. Ordinarily a power of 2 or a power-of-2 plus 1 (see f statement); the maximum tablesize is 16777216 (2<sup>24</sup>) points. The allocation of table memory can be deferred by setting this parameter to 0; the size allocated is then the number of points in the file (probably not a power-of-2), and the table is not usable by normal oscillators, but it is usable by a loscil unit. The soundfile can also be mono or stereo.</p> <p>filcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.filcod ; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR. See also soundin.</p> <p>skiptime -- begin reading at skiptime seconds into the file.</p> <p>channel -- channel number to read in. 0 denotes read all channels.</p> <p>format -- if positive it is ignored, but if negative specifies the audio format of a raw file.</p> <pre><code>-1 - 8-bit signed character\n-2 - 8-bit A-law bytes\n-3 - 8-bit U-law bytes\n-4 - 16-bit short integers\n-5 - 32-bit long integers\n-6 - 32-bit floats\n-7 - 8-bit unsigned character\n-8 - 24-bit integers\n-9 - 64-bit doubles\n</code></pre> <p> Note</p> <p>This list is not the same as in diskin2</p> <p>If format = 0 the sample format is taken from the soundfile header.</p> <p> Note</p> <ul> <li>Reading stops at end-of-file or when the table is full. Table locations not filled will contain zeros.</li> <li>If p4 is positive, the table will be post-normalised (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</li> <li>GEN01 also works with WAV and OGG and a dozen and more other sound formats; these file formats depend on libsndfile, see http://www.mega-nerd.com/libsndfile/</li> </ul>"},{"location":"scoregens/gen01/#examples","title":"Examples","text":"<p>Here is an example of the GEN01 routine. It uses the files gen01.csd and several sound files.</p> An example of the GEN01 routine.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too \n; For Non-realtime ouput leave only the line below: \n; -o gen01.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1 ;plays deferred and non-deferred sounds with loscil\n\nifn = p4\nibas = 1\n\nasig loscil 1, 1, ifn, ibas\n     outs asig, asig\n\nendin\n\ninstr 2 ;plays only non-deffered sound            \n\nisnd  = p4\naread line   sr*p3, p3, 0                               ;play this backward\nasig  tablei aread, isnd                                ;use table 1\n      outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 131072 1 \"drumsMlp.wav\" 0 0 0                     ;non-deferred sound\nf 2 0    0   1 \"flute.aiff\" 0 0 0                       ;&amp; deferred sounds in \nf 3 0    0   1 \"drumsMlp.ogg\" 0 0 0                     ;different formats                                      \n\ni 1 0 1 1\ni 1 + 1 2\ni 1 + 1 3\n\ni 2 4 2 1       ;non-deffered sound for instr. 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN01 routines, as used in the example:</p> f 1 0 131072 1 \"drumsMlp.wav\" 0 0 0 - non-deferred sound f 2 0 0 1 \"flute.aiff\" 0 0 0 - deferred sound f 3 0 0 1 \"drumsMlp.ogg\" 0 0 0 - deferred sound"},{"location":"scoregens/gen01/#credits","title":"Credits","text":"<p>September 2003. Thanks goes to Dr. Richard Boulanger for pointing out the references to the AIFF file format.</p> <p>Revised in v6.11 and v6.12 to clarify status of headers and raw files, and to add three more sample formats.</p>"},{"location":"scoregens/gen02/","title":"Gen02","text":""},{"location":"scoregens/gen02/#gen02","title":"GEN02","text":"<p>Transfers data from immediate pfields into a function table.</p>"},{"location":"scoregens/gen02/#syntax","title":"Syntax","text":"<pre><code>f # time size 2 v1 v2 v3 ...\n</code></pre>"},{"location":"scoregens/gen02/#initialization","title":"Initialization","text":"<p>size -- number of points in the table.</p> <p>The maximum tablesize is 16777216 (2<sup>24</sup>) points. The value may be given as zero, in which case the number of values decides the table length.</p> <p>v1, v2, v3, etc. -- values to be copied directly into the table space. The values copied may include the table guard point; any table locations not filled will contain zeros.</p> <p> Note</p> <p>If p4 (the GEN routine number) is positive, the table will be post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped. You will usually want to use -2 with this GEN function, so that your values are not normalized.</p>"},{"location":"scoregens/gen02/#examples","title":"Examples","text":"<p>Here is an example of the GEN02 routine. It uses the files gen02.csd.</p> Example of the GEN02 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen02.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\nifn  = p4                               ;choose different tables of GEN02\nkcps init 1/p3                          ;index over the length of entire note\nkndx phasor kcps\nixmode = 1                              ;normalize index data\nkamp tablei kndx, ifn, ixmode\nasig poscil kamp, 440, 1                ;use GEN02 as envelope for amplitude\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1 ;sine wave\nf 2 0 5 2 0 2 0\nf 3 0 5 2 0 2 10 0\nf 4 0 9 2 0 2 10 100 0\n\ni 1 0 2 2\ni 1 3 2 3\ni 1 6 2 4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN02 routines, as used in the example:</p> f 2 0 5 2 0 2 0 f 3 0 5 2 0 2 10 0 f 4 0 9 2 0 2 10 100 0"},{"location":"scoregens/gen02/#see-also","title":"See Also","text":"<p>GEN17</p>"},{"location":"scoregens/gen02/#credits","title":"Credits","text":"<p>December 2002. Thanks to Rasmus Ekman, corrected the limit of the PMAX variable.</p> <p>Use of length zero new in version 6.12</p>"},{"location":"scoregens/gen03/","title":"Gen03","text":""},{"location":"scoregens/gen03/#gen03","title":"GEN03","text":"<p>Generates a stored function table by evaluating a polynomial in x over a fixed interval and with specified coefficients.</p>"},{"location":"scoregens/gen03/#syntax","title":"Syntax","text":"<pre><code>f  #  time  size  3  xval1  xval2  c0  c1  c2  ...  cn\n</code></pre>"},{"location":"scoregens/gen03/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1.</p> <p>xval1, xval2 -- left and right values of the x interval over which the polynomial is defined (xval1 &lt; xval2). These will produce the 1st stored value and the (power-of-2 plus l)th stored value respectively in the generated function table.</p> <p>c0, c1, c2, ..., cn -- coefficients of the nth-order polynomial</p> <p>C<sub>0</sub> + C<sub>1</sub>x + C<sub>2</sub>x<sup>2</sup> + . . . + C<sub>n</sub>x<sup>n</sup></p> <p>Coefficients may be positive or negative real numbers; a zero denotes a missing term in the polynomial. The coefficient list begins in p7, providing a current upper limit of 144 terms.</p> <p> Note</p> <ul> <li>The defined segment [fn(xval1), fn(xval2)] is evenly distributed. Thus a 512-point table over the interval [-1,1] will have its origin at location 257 (at the start of the 2nd half). Provided the extended guard point is requested, both fn(-1) and fn(1) will exist in the table.</li> <li>GEN03 is useful in conjunction with table or tablei for audio waveshaping (sound modification by non-linear distortion). Coefficients to produce a particular formant from a sinusoidal lookup index of known amplitude can be determined at preprocessing time using algorithms such as Chebyshev formulae. See also GEN13.</li> </ul>"},{"location":"scoregens/gen03/#examples","title":"Examples","text":"<p>Here is an example of the GEN03 generator. It uses the file gen03.csd.</p> Example of the GEN03 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen03.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1\n;example by Russell Pinkston - Univ. of Texas  (but slightly modified)\n\ngisine   ftgen 1, 0, 16384, 10, 1                                               ;sine wave\n\ninstr   1\n\nihertz = cpspch(p4)\nipkamp = p5\niwsfn  = p6                                                                     ;waveshaping function\ninmfn  = p7                                                                     ;normalization function\naenv    linen  1, .01, p3, .1                                                   ;overall amp envelope\nactrl   linen  1, 2, p3, 2                                                      ;waveshaping index control\naindex  poscil actrl/2, ihertz, gisine                                          ;sine wave to be distorted\nasignal tablei .5+aindex, iwsfn, 1                                              ;waveshaping\nanormal tablei actrl, inmfn,1                                                   ;amplitude normalization\nasig    =      asignal*anormal*ipkamp*aenv      \nasig    dcblock2  asig                                                          ;get rid of possible DC                                         \n        outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; first four notes are specific Chebyshev polynomials using gen03. The values were obtained from Dodge page 147\n\nf4 0 513 3 -1 1 0 1                     ; First-order Chebyshev: x\nf5 0 257 4 4 1                          ; Normalizing function for fn4\n\nf6 0 513 3 -1 1 -1 0 2                  ; Second-order Chebyshev: 2x2 - 1\nf7 0 257 4 6 1                          ; Normalizing function for fn6\n\nf8 0 513 3 -1 1 0 -3 0 4                ; Third-order Chebyshev: 4x3 - 3x\nf9 0 257 4 8 1                          ; Normalizing function for fn8\n\nf10 0 513 3 -1 10 0 -7 0 56 0 -112 0 64 ; Seventh-order Chebyshev: 64x7 - 112x5 + 56x3 - 7x\nf11 0 257 4 10 1                        ; Normalizing function for fn10\n\nf12 0 513 3 -1 1 5 4 3 2 2 1            ; a 4th order polynomial function over the x-interval -1 to 1\nf13 0 257 4 12 1                        ; Normalizing function for fn12\n\n; five notes with same fundamental, different waveshape &amp; normalizing functions\n;        pch     amp    wsfn    nmfn\ni1 0  3 8.00     .7      4       5\ni1 +  .  .       .       6       7    \ni1 +  .  .       .       8       9     \ni1 +  .  .       .       10      11   \ni1 +  .  .       .       12      13 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN03 routines, as used in the example:</p> f4 0 513 3 1 1 0 1 - first-order Chebyshev: x f6 0 513 3 -1 1 -1 0 2 - second-order Chebyshev: 2x2 - 1 f8 0 513 3 -1 1 0 -3 0 4 - third-order Chebyshev: 4x3 - 3x f10 0 513 3 -1 10 0 -7 0 56 0 -112 0 64 - seventh-order Chebyshev: 64x7 - 112x5 + 56x3 - 7x f12 0 513 3 -1 1 5 4 3 2 2 1 - a 4th order polynomial function over the x-interval -1 to 1"},{"location":"scoregens/gen03/#see-also","title":"See Also","text":"<p>GEN13, GEN14, and GEN15.</p> <p>Information about the Chebyshev polynomials on Wikipedia: http://en.wikipedia.org/wiki/Chebyshev_polynomials</p>"},{"location":"scoregens/gen04/","title":"Gen04","text":""},{"location":"scoregens/gen04/#gen04","title":"GEN04","text":"<p>Generates a normalizing function by examining the contents of an existing table.</p>"},{"location":"scoregens/gen04/#syntax","title":"Syntax","text":"<pre><code>f  #  time  size  4  source#  sourcemode\n</code></pre>"},{"location":"scoregens/gen04/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Should be power-of-2 plus 1. Must not exceed (except by 1) the size of the source table being examined; limited to just half that size if the sourcemode is of type offset (see below).</p> <p>source # -- table number of stored function to be examined.</p> <p>sourcemode -- a coded value, specifying how the source table is to be scanned to obtain the normalizing function. Zero indicates that the source is to be scanned from left to right. Non-zero indicates that the source has a bipolar structure; scanning will begin at the mid-point and progress outwards, looking at pairs of points equidistant from the center.</p> <p> Note</p> <ul> <li>The normalizing function derives from the progressive absolute maxima of the source table being scanned. The new table is created left-to-right, with stored values equal to 1/(absolute maximum so far scanned). Stored values will thus begin with 1/(first value scanned), then get progressively smaller as new maxima are encountered. For a source table which is normalized (values &lt;= 1), the derived values will range from 1/(first value scanned) down to 1. If the first value scanned is zero, that inverse will be set to 1.</li> <li>The normalizing function from GEN04 is not itself normalized.</li> <li>GEN04 is useful for scaling a table-derived signal so that it has a consistent peak amplitude. A particular application occurs in waveshaping when the carrier (or indexing) signal is less than full amplitude.</li> </ul>"},{"location":"scoregens/gen04/#examples","title":"Examples","text":"<p>Here is a simple example of the GEN04 routine. It uses the files gen04.csd.</p> An example of the GEN04 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen04.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngisine   ftgen 0, 0, 16384, 10, 1                                               ;sine wave\n\ninstr   1\n\nihertz = cpspch(p4)\nipkamp = p5\niwsfn  = p6                                                                     ;waveshaping function   \ninmfn  = p7                                                                     ;normalization function                                                                 \nagate   linen   1, .01, p3, .1                                                  ;overall amp envelope\nkctrl   linen   .9, 2, p3, 2                                                    ;waveshaping index control\naindex  poscil  kctrl/2, ihertz, gisine                                         ;sine wave to be distorted\nasignal tablei  .5+aindex, iwsfn, 1                                             ;waveshaping\nknormal tablei  1/kctrl, inmfn , 1                                              ;amplitude normalization\n        outs    asignal*knormal*ipkamp*agate, asignal*knormal*ipkamp*agate\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 64 21 6    ;Gaussian (random) distribution\nf2 0 33 4 1 1   ;normalizing function with midpoint bipolar offset\n\ns\n;       st      dur     pch     amp   wsfn inmfn\ni1      0       4      6.00    .7      1     2\ni1      4       .      7.00    .\ni1      8       .      8.00    .\n;-------------------------------------------------------------------------------------\nf3 0 1025 13 1 1 0 5 0 5 0 10   ;Chebyshev algorithm\nf4 0 513 4 3 1                  ;normalizing function with midpoint bipolar offset\ns\n;       st      dur     pch     amp   wsfn inmfn\ni1      0       4      6.00    .9      3     4\ni1      4       .      7.00    .\ni1      8       .      8.00    .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN04 routines, as used in the example:</p> f1 0 64 21 6 - Gaussian (random) distribution f2 0 33 4 1 1 - AND its normalizing function with midpoint bipolar offset f3 0 1025 13 1 1 0 5 0 5 0 10 - Chebyshev algorithm f4 0 513 4 3 1 - AND its normalizing function with midpoint bipolar offset"},{"location":"scoregens/gen05/","title":"Gen05","text":""},{"location":"scoregens/gen05/#gen05","title":"GEN05","text":"<p>Constructs functions from segments of exponential curves.</p>"},{"location":"scoregens/gen05/#syntax","title":"Syntax","text":"<pre><code>f # time size 5 a n1 b n2 c ...\n</code></pre>"},{"location":"scoregens/gen05/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>a, b, c, etc. -- ordinate values, in odd-numbered pfields p5, p7, p9, . . . These must be nonzero and must be alike in sign.</p> <p>n1, n2, etc. -- length of segment (no. of storage locations), in even-numbered pfields. Cannot be negative, but a zero is meaningful for specifying discontinuous waveforms. The sum n1 + n2 + .... will normally equal size for fully specified functions. If the sum is smaller, the function locations not included will be set to zero; if the sum is greater, only the first size locations will be stored.  Note that the values are rounded to integers before use.</p> <p> Note</p> <ul> <li>If p4 is positive, functions are post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</li> <li>Discrete-point linear interpolation implies an increase or decrease along a segment by equal differences between adjacent locations; exponential interpolation implies that the progression is by equal ratio. In both forms the interpolation from a to b is such as to assume that the value b will be attained in the n + 1th location. For discontinuous functions, and for the segment encompassing the end location, this value will not actually be reached, although it may eventually appear as a result of final scaling.</li> </ul>"},{"location":"scoregens/gen05/#examples","title":"Examples","text":"<p>Here is a simple example of the GEN05 routine. It uses the files gen05.csd.</p> An example of the GEN05 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen05.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\nifn = p4                                        ;choose different tables for GEN05\nkcps init 1/p3                                  ;index over the length of  entire note\nkndx phasor kcps\nixmode = 1                                      ;normalize index data\nkamp tablei kndx, ifn, ixmode\nasig poscil kamp, 440, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1 ;sine wave\nf 2 0 129 5    1   100 0.0001 29                ;short attack\nf 3 0 129 5 0.00001 87    1   22 .5 20 0.0001   ;long attack\n\n\ni 1 0 2 2\ni 1 3 2 3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN05 routines, as used in the example:</p> f 2 0 129 5 1 100 0.0001 29 - waveform that goes over 100 points from 1 to 0.0001, stay there for 29 points f 3 0 129 5 0.00001 87 1 22 .5 20 0.0001 - waveform that goes from 0.00001 to 1 in 87 points, then from 1 to .5 in 22 points and then from .5 to 0.0001 in 20 points"},{"location":"scoregens/gen05/#see-also","title":"See Also","text":"<p>GEN06, GEN07, and GEN08</p>"},{"location":"scoregens/gen06/","title":"Gen06","text":""},{"location":"scoregens/gen06/#gen06","title":"GEN06","text":"<p>Generates function comprised of segments of cubic polynomials, spanning specified points just three at a time.</p>"},{"location":"scoregens/gen06/#syntax","title":"Syntax","text":"<pre><code>f  #   time   size   6   a   n1   b   n2   c   n3   d ...\n</code></pre>"},{"location":"scoregens/gen06/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power off or power-of-2 plus 1 (see f statement).</p> <p>a, c, e, ... -- local maxima or minima of successive segments, depending on the relation of these points to adjacent inflexions. May be either positive or negative.</p> <p>b, d, f, ... -- ordinate values of points of inflexion at the ends of successive curved segments. May be positive or negative.</p> <p>n1, n2, n3 ... -- number of stored values between specified points. Cannot be negative, but a zero is meaningful for specifying discontinuities. The sum n1 + n2 + ... will normally equal size for fully specified functions. (for details, see GEN05).</p> <p> Note</p> <p>GEN06 constructs a stored function from segments of cubic polynomial functions. Segments link ordinate values in groups of 3: point of inflexion, maximum/minimum, point of inflexion. The first complete segment encompasses b, c, d and has length n2 + n3, the next encompasses d, e, f and has length n4 + n5, etc. The first segment (a, b with length n1) is partial with only one inflexion; the last segment may be partial too. Although the inflexion points b, d, f ... each figure in two segments (to the left and right), the slope of the two segments remains independent at that common point (i.e. the 1st derivative will likely be discontinuous). When a, c, e... are alternately maximum and minimum, the inflexion joins will be relatively smooth; for successive maxima or successive minima the inflexions will be comb-like. </p>"},{"location":"scoregens/gen06/#examples","title":"Examples","text":"<p>Here is an example of the GEN06 routine. It uses the files gen06.csd.</p> An example of the GEN06 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen06.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn  = p4                               ;choose between tables\nkcps init 1/p3                          ;create index over duration of note.\nkndx phasor kcps\nixmode = 1\nkval table kndx, ifn, ixmode            ;normalize mode\n\nkfreq = kval * 30                       ;scale frequency to emphasixe effect\nasig  poscil .7, 220 + kfreq, 1         ;add to frequency\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1 ;sine wave.\nf 2 0 513 6 1 128 -1 128 1 64 -.5 64 .5 16 -.5 8 1 16 -.5 8 1 16 -.5 84 1 16 -.5 8 .1 16 -.1 17 0\nf 3 0 513 6 0 128 0.5 128 1 128 0 129 -1\n\ni 1 0 3 2\ni 1 4 3 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN06 routines, as used in the example:</p> f 2 0 513 6 1 128 -1 128 1 64 -.5 64 .5 16 -.5 8 1 16 -.5 8 1 16 -.5 84 1 16 -.5 8 .1 16 -.1 17 0 - a not-so-smooth curve f 3 0 513 6 0 128 0.5 128 1 128 0 129 -1 - a curve running 0 to 1 to -1, with a minimum, maximum and minimum at these values respectively. Inflexions are at .5 and 0 and are relatively smooth"},{"location":"scoregens/gen06/#see-also","title":"See Also","text":"<p>GEN05, GEN07, and GEN08</p>"},{"location":"scoregens/gen07/","title":"Gen07","text":""},{"location":"scoregens/gen07/#gen07","title":"GEN07","text":"<p>Constructs functions from segments of straight lines.</p>"},{"location":"scoregens/gen07/#syntax","title":"Syntax","text":"<pre><code>f  #    time    size   7   a   n1   b   n2   c  ...\n</code></pre>"},{"location":"scoregens/gen07/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>a, b, c, etc. -- ordinate values, in odd-numbered pfields p5, p7, p9, . . .</p> <p>n1, n2, etc. -- length of segment (no. of storage locations), in even-numbered pfields. Cannot be negative, but a zero is meaningful for specifying discontinuous waveforms (e.g. in the example below). The sum n1 + n2 + .... will normally equal size for fully specified functions. If the sum is smaller, the function locations not included will be set to zero; if the sum is greater, only the first size locations will be stored.</p> <p> Note</p> <ul> <li>If p4 is positive, functions are post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</li> <li>Discrete-point linear interpolation implies an increase or decrease along a segment by equal differences between adjacent locations; exponential interpolation implies that the progression is by equal ratio. In both forms the interpolation from a to b is such as to assume that the value b will be attained in the n + 1th location. For discontinuous functions, and for the segment encompassing the end location, this value will not actually be reached, although it may eventually appear as a result of final scaling.</li> </ul>"},{"location":"scoregens/gen07/#examples","title":"Examples","text":"<p>Here is an example of the GEN07 routine. It uses the files gen07.csd.</p> An example of the GEN07 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen07.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1 ;use GEN07 to alter frequency\n\nifn  = p4                                               ;use different GEN07 tables\nkcps init 10/p3                                         ;index ftable 10 times over the duration of entire note\nkndx phasor kcps\nixmode = 1                                              ;normalize index data\nkfrq tablei kndx, ifn, ixmode\nkfrq = kfrq*1000                                        ;scale\nasig poscil .8, 1220+kfrq, 1                            ;add to frequency\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1                         ;sine wave\nf 2 0 1024 7 0 512 1 0 -1 512 0         ;sawtooth up and down\nf 3 0 1024 7 1 512 1 0 -1 512 -1        ;square\nf 4 0 1024 7 1 1024 -1                  ;saw down\n\ni 1 0 2 2\ni 1 + 2 3\ni 1 + 1 4\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN07 routines, as used in the example:</p> f 2 0 1024 7 0 512 1 0 -1 512 0 - sawtooth up and down, starting and ending at 0 f 3 0 1024 7 1 512 1 0 -1 512 -1 - a square from positive to negative f 4 0 1024 7 1 1024 -1 - sawtooth down, a straight line from positive to negative"},{"location":"scoregens/gen07/#see-also","title":"See Also","text":"<p>GEN05, GEN06, and GEN08</p>"},{"location":"scoregens/gen08/","title":"Gen08","text":""},{"location":"scoregens/gen08/#gen08","title":"GEN08","text":"<p>Generate a piecewise cubic spline curve, the smoothest possible through all specified points.</p>"},{"location":"scoregens/gen08/#syntax","title":"Syntax","text":"<pre><code>f # time size 8 a n1 b n2 c n3 d ...\n</code></pre>"},{"location":"scoregens/gen08/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>a, b, c, etc. -- ordinate values of the function.</p> <p>n1, n2, n3 ... _ -- length of each segment measured in stored values. May not be zero, but may be fractional. A particular segment may or may not actually store any values; stored values will be generated at integral points from the beginning of the function. The sum _n1 + n2 + ... will normally equal size for fully specified functions.</p> <p> Note</p> <ul> <li>GEN08 constructs a stored table from segments of cubic polynomial functions. Each segment runs between two specified points but depends as well on their neighbors on each side. Neighboring segments will agree in both value and slope at their common point. (The common slope is that of a parabola through that point and its two neighbors). The slope at the two ends of the function is constrained to be zero (flat).</li> <li>Hint: to make a discontinuity in slope or value in the function as stored, arrange a series of points in the interval between two stored values; likewise for a non-zero boundary slope.</li> </ul>"},{"location":"scoregens/gen08/#examples","title":"Examples","text":"<p>Here is an example of the GEN08 routine. It uses the files gen08.csd.</p> An example of the GEN08 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen08.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn  = p4                               ;choose between tables\nkcps init 1/p3                          ;create index over duration of note.\nkndx phasor kcps\nixmode = 1\nkval table kndx, 2, ixmode              ;normalize index data\n\nibasefreq = 440\nkfreq = kval * 100                      ;scale\nasig  poscil .7, ibasefreq + kfreq, 1   ;and add to frequency\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave.\nf 2 0 65 8 0 16 1 16 1 16 0 17 0\nf 3 0 65 8 -1 32 1 2 0 14 0 17 0\n\ni 1 0 2 1\ni 1 3 2 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN08 routines, as used in the example:</p> f 2 0 65 8 0 16 1 16 1 16 0 17 0 - a curve with a smooth hump in the middle, going briefly negative outside the hump then flat at its ends f 3 0 65 8 -1 32 1 2 0 14 0 17 0 - from a negative value,a curve with a smooth hump, going negative creating a small hump then flat at its ends"},{"location":"scoregens/gen08/#see-also","title":"See Also","text":"<p>GEN05, GEN06, and GEN07</p>"},{"location":"scoregens/gen09/","title":"Gen09","text":""},{"location":"scoregens/gen09/#gen09","title":"GEN09","text":"<p>Generate composite waveforms made up of weighted sums of simple sinusoids.</p> <p>The specification of each contributing partial requires 3 p-fields using GEN09.</p>"},{"location":"scoregens/gen09/#syntax","title":"Syntax","text":"<pre><code>f # time size 9 pna stra phsa pnb strb phsb ...\n</code></pre>"},{"location":"scoregens/gen09/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>pna, pnb, etc. -- partial no. (relative to a fundamental that would occupy size locations per cycle) of sinusoid a, sinusoid b, etc. Must be positive, but need not be a whole number, i.e., non-harmonic partials are permitted. Partials may be in any order.</p> <p>stra, strb, etc. -- strength of partials pna, pnb, etc. These are relative strengths, since the composite waveform may be rescaled later. Negative values are permitted and imply a 180 degree phase shift.</p> <p>phsa, phsb, etc. -- initial phase of partials pna, pnb, etc., expressed in degrees (0-360).</p> <p> Note</p> <ul> <li>These subroutines generate stored functions as sums of sinusoids of different frequencies. The two major restrictions on GEN10 that the partials be harmonic and in phase do not apply to GEN09 or GEN19. </li> <li>In each case the composite wave, once drawn, is then rescaled to unity if p4 was positive. A negative p4 will cause rescaling to be skipped.</li> </ul>"},{"location":"scoregens/gen09/#examples","title":"Examples","text":"<p>Here is an example of the GEN09 routine. It uses the files gen09.csd.</p> Example of the GEN09 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen09.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngi1 ftgen 1,0,2^10,9,  1,3,0,   3,1,0, 9,0.333,180              ;an approximation of a square wave\ngi2 ftgen 2,0,2^10,9,  1,3,180, 3,1,0, 9,0.333,0                ;same values as gi1, except some phase values\ngi3 ftgen 3,0,2^10,9,  1, .4, 0,   2.2, .5, 0,   3.8, 1, 0      ;inharmonic, but does not sound well --&gt; wave does not end at same point as where it begins --&gt; artefacts\ngi4 ftgen 4,0,2^10,9,  10, .4, 0,   22, .5, 0,   38, 1, 0       ;the same proportions, but value of partial number is multiplied 10 times --&gt;the sound is much clearer,\n                                                                ;because the sudden \"jump\" like the one in gi3 will pop up only once in 10 repetitions\n\ninstr 1\n\nkamp = .6\nkcps = 220\nifn  = p4\n\nasig poscil kamp, kcps*p5, ifn\n     outs   asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 1 1     ;subtle difference between table 1 and 2\ni 1 3 2 2 1\ni 1 7 2 3 1     ;big difference between table 3 and 4\ni 1 10 2 4 .1   ;p5 has to compensate for the 10 repetitions of gi4 as opposed to gi3 to get the same pitch\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN09 routines, as used in the example:</p> gi1 ftgen 1,0,2^10,9,  1,3,0,   3,1,0, 9,0.333,180 - approximation of a square wave gi2 ftgen 2,0,2^10,9,  1,3,180,   3,1,0, 9,0.333,0 - same values as gi1, except phase value gi3 ftgen 3,0,2^10,9,  1,2,0,   3,2,0, 9,0.333,180 - inharmonic partials, but with distortion due to the sudden jump in ending and beginning of the wave gi4 ftgen 4,0,2^10,9,  1,2,180,   3,2,0, 9,0.333,0 - same ratio as gi3, except with less artefacts"},{"location":"scoregens/gen09/#see-also","title":"See Also","text":"<p>GEN10, GEN19</p>"},{"location":"scoregens/gen10/","title":"Gen10","text":""},{"location":"scoregens/gen10/#gen10","title":"GEN10","text":"<p>Generate composite waveforms made up of weighted sums of simple sinusoids.</p> <p>The specification of each contributing partial requires 1 pfield using GEN10.</p>"},{"location":"scoregens/gen10/#syntax","title":"Syntax","text":"<pre><code>f # time size 10 str1 str2 str3 str4 ...\n</code></pre>"},{"location":"scoregens/gen10/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>str1, str2, str3, etc. -- relative strengths of the fixed harmonic partial numbers 1, 2, 3, etc., beginning in p5. Partials not required should be given a strength of zero.</p> <p> Note</p> <ul> <li>These subroutines generate stored functions as sums of sinusoids of different frequencies. The two major restrictions on GEN10 that the partials be harmonic and in phase do not apply to GEN09 or GEN19.</li> <li>In each case the composite wave, once drawn, is then rescaled to unity if p4 was positive. A negative p4 will cause rescaling to be skipped.</li> </ul>"},{"location":"scoregens/gen10/#examples","title":"Examples","text":"<p>Here is an example of the GEN10 routine. It uses the files gen10.csd.</p> An example of the GEN10 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen10.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nkamp = .6\nkcps = 440\nifn  = p4\n\nasig oscil kamp, kcps, ifn\n     outs asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 16384 10 1                                          ; Sine\nf2 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111   ; Sawtooth\nf3 0 16384 10 1 0   0.3 0    0.2 0     0.14 0     .111   ; Square\nf4 0 16384 10 1 1   1   1    0.7 0.5   0.3  0.1          ; Pulse\n\ni 1 0 2 1\ni 1 3 2 2\ni 1 6 2 3\ni 1 9 2 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN10 routines, as used in the example:</p> f 1 0 16384 10 1 - sine wave with only the fundamental frequency f 2 0 16384 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111 - sawtooth, with a fundamental and 8 harmonics  f 3 0 16384 10 1 0 0.3 0 0.2 0 0.14 0 .111 - square wave, with a fundamental and 8 harmonics but 4 have 0 strength f 4 0 16384 10 1 1 1 1 0.7 0.5 0.3 0.1 - pulse wave, with a fundamental and 8 harmonics"},{"location":"scoregens/gen10/#see-also","title":"See Also","text":"<p>GEN09, GEN11, and GEN19.</p>"},{"location":"scoregens/gen11/","title":"Gen11","text":""},{"location":"scoregens/gen11/#gen11","title":"GEN11","text":"<p>Generates an additive set of cosine partials in the manner of Csound generators buzz and gbuzz.</p>"},{"location":"scoregens/gen11/#syntax","title":"Syntax","text":"<pre><code>f # time size 11 nh [lh] [r]\n</code></pre>"},{"location":"scoregens/gen11/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>nh -- number of harmonics requested. Must be positive.</p> <p>lh(optional) -- lowest harmonic partial present. Can be positive, zero or negative. The set of partials can begin at any partial number and proceeds upwards; if lh is negative, all partials below zero will reflect in zero to produce positive partials without phase change (since cosine is an even function), and will add constructively to any positive partials in the set. The default value is 1</p> <p>r(optional) -- multiplier in an amplitude coefficient series. This is a power series: if the lh_th partial has a strength coefficient of A the (_lh + n)th partial will have a coefficient of A * r<sup>n</sup>, i.e. strength values trace an exponential curve. r may be positive, zero or negative, and is not restricted to integers. The default value is 1.</p> <p> Note</p> <ul> <li>This subroutine is a non-time-varying version of the CSound buzzand gbuzz generators, and is similarly useful as a complex sound source in subtractive synthesis. With lh and r present it parallels gbuzz; with both absent or equal to 1 it reduces to the simpler buzz (i.e. nh equal-strength harmonic partials beginning with the fundamental).</li> <li>Sampling the stored waveform with an oscillator is more efficient than using the dynamic buzz units. However, the spectral content is invariant and care is necessary, lest the higher partials exceed the Nyquist during sampling to produce fold-over.</li> </ul>"},{"location":"scoregens/gen11/#examples","title":"Examples","text":"<p>Here is an example of the GEN11 routine. It uses the files gen11.csd.</p> An example of the GEN11 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen11.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\nifn  = p4\nasig oscil .8, 220, ifn\n     outs asig,asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 11 1 1      ;number of harmonics = 1\nf 2 0 16384 11 10 1 .7  ;number of harmonics = 10\nf 3 0 16384 11 10 5 2   ;number of harmonics = 10, 5th harmonic is amplified 2 times\n\n\ni 1 0 2 1\ni 1 + 2 2\ni 1 + 2 3\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN11 routines, as used in the example:</p> f 1 0 16384 11 1 1 f 2 0 16384 11 10 1 .7 f 3 0 16384 11 10 5 2"},{"location":"scoregens/gen11/#see-also","title":"See Also","text":"<p>GEN10</p>"},{"location":"scoregens/gen12/","title":"Gen12","text":""},{"location":"scoregens/gen12/#gen12","title":"GEN12","text":"<p>Generates the log of a modified Bessel function of the second kind, order 0, suitable for use in amplitude-modulated FM.</p>"},{"location":"scoregens/gen12/#syntax","title":"Syntax","text":"<pre><code>f # time size 12 xint\n</code></pre>"},{"location":"scoregens/gen12/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p>xint -- specifies the x interval [0 to +xint] over which the function is defined.</p> <p> Note</p> <ul> <li>This subroutine draws the natural log of a modified Bessel function of the second kind, order 0 (commonly written as I subscript 0), over the x-interval requested. The call should have rescaling inhibited.</li> <li>The function is useful as an amplitude scaling factor in cycle-synchronous amplitude-modulated FM. (See Palamin &amp; Palamin, J. Audio Eng. Soc., 36/9, Sept. 1988, pp.671-684.) The algorithm is interesting because it permits the normally symmetric FM spectrum to be made asymmetric around a frequency other than the carrier, and is thereby useful for formant positioning. By using a table lookup index of I(r - 1/r), where I is the FM modulation index and r is an exponential parameter affecting partial strengths, the Palamin algorithm becomes relatively efficient, requiring only oscil's, table lookups, and a single exp call.</li> </ul>"},{"location":"scoregens/gen12/#examples","title":"Examples","text":"<p>Here is an example of the GEN12 generator. It uses the file gen12.csd.</p> Example of the GEN12 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen12.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example from the Csound Book, page 87\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidur    =       p3\niamp    =       p4\nicarfrq =       p5\nimodfrq =       p6          \naenv    expseg  .01, idur*.1, iamp, idur*.8, iamp*.75, idur*.1, .01\ni1      =       p7*imodfrq                      ;p7=modulation index start\ni2      =       p8*imodfrq                      ;p8=modulation index end\nadev    line    i1, idur, i2                    ;modulation frequency\naindex  line    p7, idur, p8                    ;modulation index\n\nar      linseg  1, .1, p9, p3-.2, p10, .1, 1    ; r value envelope: p9-p10 =exp. partial strength parameter start and end\namp1    =       (aindex*(ar+(1/ar)))/2\nafmod   oscili  amp1, imodfrq, 1                ;FM modulator (sine)\natab    =       (aindex*(ar-(1/ar)))/2          ;index to table\nalook   tablei  atab, 37                        ;table lookup to GEN12\naamod   oscili  atab, adev, 2                   ;am modulator (cosine)\naamod   =       (exp(alook+aamod))*aenv\nacar    oscili  aamod, afmod+icarfrq, 1         ;AFM (carrier)\nasig    balance acar, aenv\n        outs    asig, asig\n\nendin       \n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1     0   8192    10  1               \nf 2     0   8192    9   1 1 90          \nf37 0   1024    -12 40          ;Bessel function-defined from 0 to 40\n\ni 1  0  2  .2  800  800    1    6   .1   2\ni 1  +  .  .   1900 147    8    1    4   .2\ni 1  .  .  .   1100 380    2    9   .5   2\ni 1  .  10 .   100  100    11   3   .2   5\ns\ni 1  0  1 .1   200 100     1    6   .1   2\ni 1  +  .  &lt;   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  .  .   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  .  .   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  .  .   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  .  .   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  .  .   &lt;    &lt;      &lt;    &lt;   &lt;    &lt;\ni 1  +  10 .2  800  800    9    1   .9   6\ns\ni 1  0  11 .25 50   51     1    6   .1   2\ni 1  1  9  .05 700  401    1    6   .1   2\ni 1  2  8  .   900  147    8    1    4   .2\ni 1  3  7  .   1100 381    2    9   .5   2\ni 1  4  6  .   200  102    11   3   .2   5\ni 1  5  6  .   800  803    9    1   .9   6\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN12 routines, as used in the example:</p> f 37 0 1024 -12 40 - Bessel function-defined from 0 to 40"},{"location":"scoregens/gen12/#credits","title":"Credits","text":"<p>Example is, with minor modifications, taken from The Csound Book (page 87).</p>"},{"location":"scoregens/gen13/","title":"Gen13","text":""},{"location":"scoregens/gen13/#gen13","title":"GEN13","text":"<p>Stores a polynomial whose coefficients derive from the Chebyshev polynomials of the first kind.</p> <p>Uses Chebyshev coefficients to generate stored polynomial functions which, under waveshaping, can be used to split a sinusoid into harmonic partials having a pre-definable spectrum.</p>"},{"location":"scoregens/gen13/#syntax","title":"Syntax","text":"<pre><code>f # time size 13 xint xamp h0 h1 h2 ...\n</code></pre>"},{"location":"scoregens/gen13/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p>xint -- provides the left and right values [-xint, +xint] of the x interval over which the polynomial is to be drawn. These subroutines both call GEN03 to draw their functions; the p5 value here is therefor expanded to a negative-positive p5, p6 pair before GEN03 is actually called. The normal value is 1.</p> <p>xamp -- amplitude scaling factor of the sinusoid input that is expected to produce the following spectrum.</p> <p>h0, h1, h2, etc. -- relative strength of partials 0 (DC), 1 (fundamental), 2 ... that will result when a sinusoid of amplitude</p> <pre><code>xamp * int(size/2)/xint\n</code></pre> <p>is waveshaped using this function table. These values thus describe a frequency spectrum associated with a particular factor xamp of the input signal.</p> <p>GEN13 is the function generator normally employed in standard waveshaping. It stores a polynomial whose coefficients derive from the Chebyshev polynomials of the first kind, so that a driving sinusoid of strength xamp will exhibit the specified spectrum at output. Note that the evolution of this spectrum is generally not linear with varying xamp. However, it is bandlimited (the only partials to appear will be those specified at generation time); and the partials will tend to occur and to develop in ascending order (the lower partials dominating at low xamp, and the spectral richness increasing for higher values of xamp). A negative hn value implies a 180 degree phase shift of that partial; the requested full-amplitude spectrum will not be affected by this shift, although the evolution of several of its component partials may be. The pattern +,+,-,-,+,+,... for h0,h1,h2... will minimize the normalization problem for low xamp values (see above), but does not necessarily provide the smoothest pattern of evolution.</p>"},{"location":"scoregens/gen13/#examples","title":"Examples","text":"<p>Here is an example of the GEN13 generator. It uses the file gen13.csd.</p> Example of the GEN13 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen13.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n;example by Russell Pinkston - Univ. of Texas  (but slightly modified)\n\ngisine   ftgen 0, 0, 16384, 10, 1                                                       ;sine wave\n\ninstr   1\n\nihertz = cpspch(p4)\nipkamp = p5\niwsfn  = p6                                                                             ;waveshaping function\ninmfn  = p7                                                                             ;normalization function\nagate   linen  1, .01, p3, .1                                                           ;overall amp envelope\nkctrl   linen  .99, 2, p3, 2                                                            ;waveshaping index control\naindex  poscil kctrl/2, ihertz, gisine                                                  ;sine wave to be distorted\nasignal tablei .5+aindex, iwsfn, 1                                                      ;waveshaping\nknormal tablei kctrl, inmfn, 1                                                          ;amplitude normalization\nasig    =      asignal*knormal*ipkamp*agate\n        outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; This proves the statement in Dodge (p. 147) that Chebyshev polynomials\n; of order K have \"only the kth harmonic.\" This is only true when the \n; waveshaping index is at the maximum - i.e., when the entire transfer\n; function is being accessed. RP.\n;--------------------------------------------------------------------------------------------------------------------------------------------\n; quasi sawtooth transfer function: \n;                h0   h1   h2   h3   h4   h5   h6    h7   h8   h9   h10   h11   h12   h13    h14    h15    h16    h17    h18    h19    h20\nf1 0 513 13 1 1  0   100  -50  -33   25   20 -16.7 -14.2 12.5 11.1 -10  -9.09  8.333  7.69  -7.14  -6.67  6.25    5.88  -5.55  -5.26    5               \nf2 0 257 4 1 1   ; normalizing function with midpoint bipolar offset\n\n;       st      dur     pch     amp     wsfn    nmfn\ni1      0       4      6.00    .7        1       2\ni1      4       .      7.00    .\ni1      8       .      8.00    .\n;--------------------------------------------------------------------------------------------------------------------------------------------   \n; quasi square wave transfer function: \n;                h0   h1   h2   h3   h4   h5   h6    h7   h8   h9   h10   h11   h12   h13    h14    h15    h16    h17    h18    h19\nf3 0 513 13 1 1  0   100   0   -33   0    20   0   -14.2  0   11.1   0  -9.09    0   7.69     0    -6.67    0    5.88     0    -5.26\nf4 0 257 4 3 1   ; normalizing function with midpoint bipolar offset\n\n;       st      dur     pch     amp     wsfn    nmfn\ni1      16       4     6.00     .7       3       4\ni1      20       .     7.00     .\ni1      24       .     8.00     .\n;--------------------------------------------------------------------------------------------------------------------------------------------   \n; quasi triangle wave transfer function: \n;                h0   h1   h2   h3   h4   h5   h6    h7   h8   h9   h10   h11   h12   h13    h14    h15    h16    h17    h18    h19\nf5 0 513 13 1 1  0   100   0  -11.11 0    4    0   -2.04  0   1.23  0   -.826   0    .59      0    -.444    0    .346     0   -.277     \nf6 0 257 4 5 1   ; normalizing function with midpoint bipolar offset\n;       st      dur     pch     amp     wsfn    nmfn\ni1      32       4     6.00     .7       5       6\ni1      36       .     7.00     .\ni1      40       .     8.00     .\n;--------------------------------------------------------------------------------------------------------------------------------------------\n; transfer function1:  h0 h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16\nf7 0 513 13 1 1        0  1 -.8 0 .6  0  0  0 .4  0  0   0   0   .1 -.2 -.3  .5\nf8 0 257 4 7 1         ; normalizing function with midpoint bipolar offset\n;       st      dur     pch     amp     wsfn    nmfn\ni1      48       4     5.00     .7       7       8\ni1      52       .     6.00     .\ni1      56       .     7.00     .\n;--------------------------------------------------------------------------------------------------------------------------------------------\n;=========================================================================;\n; This demonstrates the use of high partials, sometimes without a         ;\n; fundamental, to get quasi-inharmonic spectra from waveshaping.          ;\n;=========================================================================;\n; transfer function2:  h0 h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16\nf9 0 513 13 1 1        0  0  0 -.1  0 .3  0 -.5 0 .7  0 -.9  0   1   0  -1   0\nf10 0 257 4 9 1        ; normalizing function with midpoint bipolar offset\n;       st      dur     pch     amp     wsfn    nmfn\ni1      64       4       5.00   .7       9      10\ni1      68       .       6.00    .\ni1      72       .       7.00    .\n;--------------------------------------------------------------------------------------------------------------------------------------------\n; transfer function3: h0   h1   h2   h3   h4   h5   h6    h7   h8   h9   h10   h11      h12   h13    h14    h15    h16    h17    h18    h19    h17   h18   h19   h20\nf11 0 513 13 1 1      0    0    0    0    0    0    0     -1   0    1     0     0       -.1    0     .1      0     -.2    .3      0     -.7     0    .2     0    -.1                        \nf12 0 257 4 11 1      ; normalizing function with midpoint bipolar offset\n\n;       st      dur     pch     amp     wsfn    nmfn\ni1      80       4     5.00     .7       11     12\ni1      84       .     5.06     .\ni1      88       .     6.00     .\n;--------------------------------------------------------------------------------------------------------------------------------------------\n;=========================================================================;\n; split a sinusoid into 3 odd-harmonic partials of relative strength 5:3:1\n;=========================================================================;\n;--------------------------------------------------------------------------------------------------------------------------------------------\n; transfer function4: h0   h1   h2   h3   h4   h5\nf13 0 513 13 1 1      0    5    0    3    0    1        \nf14 0 257 4 13 1      ; normalizing function with midpoint bipolar offset\n\n;       st      dur     pch     amp     wsfn    nmfn\ni1      96      4     5.00     .7        13     14\ni1      100     .     5.06     .\ni1      104     .     6.00     .\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN13 routines, as used in the example:</p> f1 0 513 13 1 1 0 100 -50 -33 25 20 -16.7 -14.2 12.5 11.1 -10 -9.09 8.333 7.69 -7.14 -6.67 6.25 5.88 -5.55 -5.26 5 -  quasi sawtooth transfer function f3 0 513 13 1 1 0 100 0 -33 0 20 0 -14.2 0 11.1 0 -9.09 0 7.69 0 -6.67 0 5.88 0 -5.26 - quasi square wave transfer function f5 0 513 13 1 1 0 100 0 -11.11 0 4 0 -2.04 0 1.23 0 -.826 0 .59 0 -.444 0 .346 0 -.277 - quasi triangle wave transfer function f7 0 513 13 1 1 0 1 -.8 0 .6 0 0 0 .4 0 0 0 0 .1 -.2 -.3 .5 - transfer function 1 f9 0 513 13 1 1 0 0 0 -.1 0 .3 0 -.5 0 .7 0 -.9 0 1 0 -1 0 - transfer function 2 f11 0 513 13 1 1 0 0 0 0 0 0 0 -1 0 1 0 0 -.1 0 .1 0 -.2 .3 0 -.7 0 .2 0 -.1  - transfer function 3 f13 0 513 13 1 1 0 5 0 3 0 1 - split a sinusoid into 3 odd-harmonic partials of relative strength 5:3:1"},{"location":"scoregens/gen13/#see-also","title":"See Also","text":"<p>GEN03, GEN14, and GEN15.</p> <p>Information about the Chebyshev polynomials on Wikipedia: http://en.wikipedia.org/wiki/Chebyshev_polynomials</p>"},{"location":"scoregens/gen14/","title":"Gen14","text":""},{"location":"scoregens/gen14/#gen14","title":"GEN14","text":"<p>Stores a polynomial whose coefficients derive from Chebyshevs of the second kind.</p> <p>Uses Chebyshev coefficients to generate stored polynomial functions which, under waveshaping, can be used to split a sinusoid into harmonic partials having a pre-definable spectrum.</p>"},{"location":"scoregens/gen14/#syntax","title":"Syntax","text":"<pre><code>f # time size 14 xint xamp h0 h1 h2 ...\n</code></pre>"},{"location":"scoregens/gen14/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p>xint -- provides the left and right values [-xint, +xint] of the x interval over which the polynomial is to be drawn. These subroutines both call GEN03 to draw their functions; the p5 value here is therefore expanded to a negative-positive p5, p6 pair before GEN03 is actually called. The normal value is 1.</p> <p>xamp -- amplitude scaling factor of the sinusoid input that is expected to produce the following spectrum.</p> <p>h0, h1, h2, etc. -- relative strength of partials 0 (DC), 1 (fundamental), 2 ... that will result when a sinusoid of amplitude</p> <pre><code>xamp * int(size/2)/xint\n</code></pre> <p>is waveshaped using this function table. These values thus describe a frequency spectrum associated with a particular factor xamp of the input signal.</p> <p> Note</p> <ul> <li>GEN13 is the function generator normally employed in standard waveshaping. It stores a polynomial whose coefficients derive from the Chebyshev polynomials of the first kind, so that a driving sinusoid of strength xamp will exhibit the specified spectrum at output. Note that the evolution of this spectrum is generally not linear with varying xamp. However, it is bandlimited (the only partials to appear will be those specified at generation time); and the partials will tend to occur and to develop in ascending order (the lower partials dominating at low xamp, and the spectral richness increasing for higher values of xamp). A negative hn value implies a 180 degree phase shift of that partial; the requested full-amplitude spectrum will not be affected by this shift, although the evolution of several of its component partials may be. The pattern +,+,-,-,+,+,... for h0,h1,h2... will minimize the normalization problem for low xamp values (see above), but does not necessarily provide the smoothest pattern of evolution.</li> <li>GEN14 stores a polynomial whose coefficients derive from Chebyshevs of the second kind.</li> </ul>"},{"location":"scoregens/gen14/#examples","title":"Examples","text":"<p>Here is an example of the GEN14 generator. It uses the file gen14.csd.</p> Example of the GEN14 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen14.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n;after the example from The Csound Book, page 83\n\ninstr 1 ;compare results from GEN13 &amp; GEN14\n\niwshpfn = p6    \ninrmfn  = p7    \naswp    linseg  0.01, p3*.5, .49, p3*.5, 0.01           ;index sweep function\naindex  poscil  aswp, p5, 2                             ;sound to waveshape\natable  tablei  aindex, iwshpfn, 1, .5                  ;waveshape index\nanrm    tablei  aswp*2, inrmfn, 1                       ;normalization \naenv    linen   p4, .01, p3, .02                        ;amplitude envelope\nasig    = (atable*anrm)*aenv                            ;normalize and impose envelope\nasig    dcblock2 asig                                   ;get rid of DC\n        outs    asig, asig\n\nendin           \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 2 0 8192 10 1                 ;sine wave\n\nf 28  0   4097 13  1 1 1 0 .8 0 .5 0 .2         ;waveshaping function: GEN13 - odd harmonics\nf 280 0   2049 4   28 1                         ;normalization function for f28\nf 29  0   4097 14  1 1 1 0 .8 0 .5 0 .2         ;waveshaping function: GEN14 - same harmonics\nf 290 0   2049 4   29 1                         ;normalization function for f29\n\n\nf 30  0   4097 13  1 1 0 1 0 .6 0 .4 0 .1       ;waveshaping function: GEN13 - even harmonics\nf 301 0   2049 4   30 1                         ;normalization function for f30\nf 31  0   4097 14  1 1 0 1 0 .6 0 .4 0 .1       ;waveshaping function: GEN13 - even harmonics\nf 310 0   2049 4   31 1                         ;normalization function for 31\ns\ni1 0   3   .7   440 28  280 \ni1 4   .   .7    .  29  290\ni1 8   .   .7    .  30  301\ni1 12  3   .7    .  31  310\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN14 routines, as used in the example:</p> f28 0 4097 13  1 1 1 0 .8 0 .5 0 .2 - waveshaping function: GEN13, odd harmonics f29 0 4097 14  1 1 1 0 .8 0 .5 0 .2 - waveshaping function: GEN14, the same odd harmonics f30 0 4097 13  1 1 0 1 0 .6 0 .4 0 .1 - waveshaping function: GEN13, even harmonics f31 0 4097 14  1 1 0 1 0 .6 0 .4 0 .1 - waveshaping function: GEN14, the same even harmonics"},{"location":"scoregens/gen14/#see-also","title":"See Also","text":"<p>GEN03, GEN13, and GEN15.</p> <p>Information about the Chebyshev polynomials on Wikipedia: http://en.wikipedia.org/wiki/Chebyshev_polynomials</p>"},{"location":"scoregens/gen15/","title":"Gen15","text":""},{"location":"scoregens/gen15/#gen15","title":"GEN15","text":"<p>Creates two tables of stored polynomial functions, suitable for use in phase quadrature operations.</p>"},{"location":"scoregens/gen15/#syntax","title":"Syntax","text":"<pre><code>f # time size 15 xint xamp h0 phs0 h1 phs1 h2 phs2 ...\n</code></pre>"},{"location":"scoregens/gen15/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p>xint -- provides the left and right values [-xint, +xint] of the x interval over which the polynomial is to be drawn. This subroutine will eventually call GEN03 to draw both functions; this p5 value is therefor expanded to a negative-positive p5, p6 pair before GEN03 is actually called. The normal value is 1.</p> <p>xamp -- amplitude scaling factor of the sinusoid input that is expected to produce the following spectrum.</p> <p>h0, h1, h2, ... hn -- relative strength of partials 0 (DC), 1 (fundamental), 2 ... that will result when a sinusoid of amplitude</p> <pre><code>xamp * int(size/2)/xint\n</code></pre> <p>is waveshaped using this function table. These values thus describe a frequency spectrum associated with a particular factor xamp of the input signal.</p> <p>phs0, phs1, ... -- phase in degrees of desired harmonics h0, h1, ... when the two functions of GEN15 are used with phase quadrature.</p> <p> Notes</p> <p>GEN15 creates two tables of equal size, labeled f# and f # + 1. Table # will contain a Chebyshev function of the first kind, drawn using GEN13 with partial strengths h0cos(phs0), h1cos(phs1), ... Table #+1 will contain a Chebyshev function of the 2nd kind by calling GEN14 with partials h1sin(phs1), h2sin(phs2),... (note the harmonic displacement). The two tables can be used in conjunction in a waveshaping network that exploits phase quadrature.</p> <p>Before version 5.16 there was a bug (pointed out by Menno Knevel and fixed by Fran\u00e7ois Pinot) on the number of pfields transmitted to gen13 and gen14 by gen15. The consequence is that all the csd, or orc and sco files that used gen15 before this bug was fixed, are likely to sound different now.</p>"},{"location":"scoregens/gen15/#examples","title":"Examples","text":"<p>Here is an example of the GEN15 routine. It uses the files gen15.csd.</p> An example of the GEN15 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen15.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n;example from the Csound Book, page 85\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nidur  = p3\niamp  = p4\nifrq  = cpspch(p5)        ;pitch\niswp1 = p6\niswp2 = p7\nkswp  line   iswp1, p3, iswp2      ;amplitude sweep values\nacosi oscili kswp*.5, ifrq, 2      ;f2=cosine wave\nasine oscili kswp, ifrq, 1         ;f1=sine wave\natab1 tablei acosi, 33, 1, .5      ;tables a1 to GEN13\natab2 tablei acosi, 34, 1, .5      ;tables a1 to GEN14\nknrm1 tablei kswp, 35, 1           ;normalizing f35\nknrm2 tablei kswp, 36, 1           ;normalizing f36\nanrm1 = atab1*knrm1                ;normalize GEN13 signal\nanrm2 = atab2*knrm2*asine          ;normalize GEN14 signal\namix  = anrm1+anrm2                ;mix GEN13 and GEN14\nkenv  expseg .001, idur*.1, iamp, idur*.1, iamp*.8, idur*.8, .001  \nasig  = amix*kenv  \n      outs   asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8193 10  1        ;sine wave\nf 2 0 8193  9  1 1 90   ;cosine wave\n\n; Note that all the f33 tables in the following sections are defined with p4=-15,\n; which means that tables 33 and 34 will not be normalized. Thus if we display\n; tables when running this example, we'll get correct diagrams even if one table\n; has very small values instead of 0 values, due to cpu approximations in processing\n; sin(180), as in sections 2, 4, and 5. This has no consequence on the audio result,\n; because of the use of amp normalization (tables 35 and 36).\n\nf 33 0 8193 -15 1 1 1 0 1 180 .8 45 .6 270 .5 90 .4 225 .2 135 .1 315  ;makes function tables 33 and 34\nf 35 0 4097  4  33 1    ;amp normalization for f33\nf 36 0 4097  4  34 1    ;amp normalization for f34\ni 1 0 5  .6  8.00 0   1\ni 1 + .  .6  8.00 1   0\ns\n;even harmonics with no phase shift, odd harmonics with phase shift\nf 33 0 8193 -15 1 1 1 0 1 0 1 180 1 180 1 0 1 0 1 180 1 180 1 0 1 0 1 180 1 180\nf 35 0 4097  4  33 1    ;amp normalization for f33\nf 36 0 4097  4  34 1    ;amp normalization for f34\ni 1 0  5 .6  8.00 0   1\ni 1 +  . .6  8.00 1   0\ns\n;different harmonic strenghts and phases\nf 33 0 8193 -15 1 1 1 0 1 0 .9 180 .5 270 .75 90 .4 45 .2 225 .1 0\nf 35 0 4097  4  33 1    ;amp normalization for f33\nf 36 0 4097  4  34 1    ;amp normalization for f34\ni 1 0 5 .6  8.00 0  1\ni 1 + . .6  8.00 1  0\ns\n;lower harmonics no phase shift, upper harmonics with phase shift\nf 33 0 8193 -15 1  1  1 0 1 0 .5 0 .9 0 .3 0 .75 0 .2 180 .6 180 .15 180 .5 180 .1 180  \nf 35 0 4097  4  33 1    ;amp normalization for f33\nf 36 0 4097  4  34 1    ;amp normalization for f34\ni 1 0 5 .6  8.00 0   1\ni 1 + . .6  8.00 1   0\n\ns\n;lower harmonics with phase shift, upper harmonics no phase shift\nf 33 0 8193 -15 1 1 1 180 1 180 .5 180 .9 180 .3 180 .75 180 .2 0 .6 0 .15 0 .5 0 .1 0  \nf 35 0 4097 4 33 1    ;amp normalization for f33\nf 36 0 4097 4 34 1    ;amp normalization for f34\ni 1 0 5 .6  8.00 0  1\ni 1 + . .6  8.00 1  0\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN15 routine, as used in the example (in each diagram, the curve in blue is for ftable 33 and the curve in green is for table 34):</p> f 33 0 8193 -15 1 1 1 0 1 180 .8 45 .6 270 .5 90 .4 225 .2 135 .1 315 f 33 0 8193 -15 1 1 1 0 1 0 1 180 1 180 1 0 1 0 1 180 1 180 1 0 1 0 1 180 1 180 f 33 0 8193 -15 1 1 1 0 1 0 .9 180 .5 270 .75 90 .4 45 .2 225 .1 0 f 33 0 8193 -15 1  1  1 0 1 0 .5 0 .9 0 .3 0 .75 0 .2 180 .6 180 .15 180 .5 180 .1 180 f 33 0 8193 -15 1 1 1 180 1 180 .5 180 .9 180 .3 180 .75 180 .2 0 .6 0 .15 0 .5 0 .1 0"},{"location":"scoregens/gen15/#see-also","title":"See Also","text":"<p>GEN13, and GEN14.</p>"},{"location":"scoregens/gen16/","title":"Gen16","text":""},{"location":"scoregens/gen16/#gen16","title":"GEN16","text":"<p>Creates a table from a starting value to an ending value.</p>"},{"location":"scoregens/gen16/#syntax","title":"Syntax","text":"<pre><code>f # time size 16 val1 dur1 type1 val2 [dur2 type2 val3 ... typeX valN]\n</code></pre>"},{"location":"scoregens/gen16/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p> Note</p> <p>The end value is only reached  when the table length is power-of-2 plus 1. (This length is crucial for use with the tab generator.)</p> <p>beg -- starting value</p> <p>dur -- number of segments</p> <p>type -- if 0, a straight line is produced. If non-zero, then GEN16 creates the following curve, for dur steps:</p> <pre><code>beg + (end - beg) * (1 - exp( i*type/(dur-1) )) / (1 - exp(type))\n</code></pre> <p>end -- value after dur segments</p> <p>Here are some examples of the curves generated for different values of type:</p> Tables generated by GEN16 for different values of type. <p> Note</p> <p>If type &gt; 0, there is a slowly rising (concave) or slowly decaying (convex) curve, while if itype &lt; 0, the curve is fast rising (convex) or fast decaying (concave). See also transeg.</p> A simple example of the GEN16 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o gen16.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 128\nnchnls = 1\n\ninstr 1\n  kcps init 1/p3\n  kndx phasor kcps\n\n  ifn = p4\n  ixmode = 1\n  kval table kndx, ifn, ixmode\n\n  ibasefreq = 440\n  kfreq = kval * ibasefreq\n  a1 oscil 20000, ibasefreq + kfreq, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n\nf 1 0 16384 10 1\n\nf 2 0 1024 16 1 1024 1 0\nf 3 0 1024 16 1 1024 2 0\nf 4 0 1024 16 1 1024 10 0\nf 5 0 1024 16 1 1024 -1 0\nf 6 0 1024 16 1 1024 -2 0\nf 7 0 1024 16 1 1024 -10 0\n\ni 1 0 2 2\ni 1 + . 3\ni 1 + . 4\ni 1 + . 5\ni 1 + . 6\ni 1 + . 7\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen16/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath, Codemist. Ltd. Bath, UK October, 2000</p> <p>New in Csound version 4.09</p>"},{"location":"scoregens/gen17/","title":"Gen17","text":""},{"location":"scoregens/gen17/#gen17","title":"GEN17","text":"<p>Creates a step function from given x-y pairs.</p>"},{"location":"scoregens/gen17/#syntax","title":"Syntax","text":"<pre><code>f # time size 17 x1 a x2 b x3 c  ...\n</code></pre>"},{"location":"scoregens/gen17/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or a power-of-2 plus 1 (see f statement). The normal value is power-of-2 plus 1.</p> <p>x1, x2, x3, etc. -- x-ordinate values, in ascending order, 0 first.</p> <p>a, b, c, etc. -- y-values at those x-ordinates, held until the next x-ordinate.</p> <p> Note</p> <p>This subroutine creates a step function of x-y pairs whose y-values are held to the right. The right-most y-value is then held to the end of the table. The function is useful for mapping one set of data values onto another, such as MIDI note numbers onto sampled sound ftable numbers ( see loscil).</p>"},{"location":"scoregens/gen17/#examples","title":"Examples","text":"<pre><code>f_  1  0  128  -17   0  1   12  2   24  3   36  4   48  5  60  6   72  7   84  8\n</code></pre> <p>This describes a step function with 8 successively increasing levels, each 12 locations wide except the last which extends its value to the end of the table. Rescaling is inhibited. Indexing into this table with a MIDI note-number would retrieve a different value every octave up to the eighth, above which the value returned would remain the same.</p> <p>Here is a complete example of the GEN17 routine. It uses the files gen17.csd.</p> An example of the GEN17 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen17.wav -W ;;; for file output any platform\n; By Stefano Cucchi &amp; Menno Knevel - 2021\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr     =    44100\nksmps  =    32\nnchnls =    2\n0dbfs =     1\n\ninstr 1 \ngisqre ftgen 2, 0, 16384, 10, 1, 0 , .33, 0, .2 , 0, .14, 0 , .11, 0, .09 ;odd harmonics\n\nknoteleft oscil 1, 0.5, 10       ; index to table 10 - gen 17 - every 2 seconds reads all the values in the table n. 10\nprintks2 \"note left  = %d\\n\", knoteleft\nknoteright oscil 1, 1, 10        ; index to table 10 - gen 17 - every  second reads all the values in the table n. 10\nprintks2 \"note right = %d\\n\", knoteright\n\nixmode =    1\nixoff =     0\niwrap =     1\naphasor1 phasor knoteleft        ; the values in table 10 become the frequency of the oscillator\nasig1 tablei aphasor1, gisqre, ixmode, ixoff, iwrap ; oscillator generating sound in the left channel (table 10 every 2 seconds)\naphasor2 phasor knoteright       ; the values in table 10 become the frequency of the oscillator\nasig2 tablei aphasor2, gisqre, ixmode, ixoff, iwrap ; oscillator generating sound in the right channel (table 10 every second)\nkgenenv linseg 0, 0.3, 0.4, p3-0.6, 0.4, 0.3, 0     ; envelope\n         outs asig1 * kgenenv, asig2 * kgenenv\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; table with gen17 - At point 0 pitch 300 Hz, at point 12 pitch 350 Hz, etc...\nf  10  0  128  -17   0  300   12  350   20  400   41  434   48  563  67  589   72  632   79  678  100 712 120 789\n\ni1 0 10 \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen17/#see-also","title":"See Also","text":"<p>GEN02</p>"},{"location":"scoregens/gen18/","title":"Gen18","text":""},{"location":"scoregens/gen18/#gen18","title":"GEN18","text":"<p>Writes composite waveforms made up of pre-existing waveforms.</p> <p>Each contributing waveform requires 4 pfields and can overlap with other waveforms.</p>"},{"location":"scoregens/gen18/#syntax","title":"Syntax","text":"<pre><code>f # time size 18 fna ampa starta finisha fnb ampb startb finishb ...\n</code></pre>"},{"location":"scoregens/gen18/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power-of-2 (see f statement).</p> <p>fna, fnb, etc. -- pre-existing table number to be written into the table.</p> <p>ampa, ampb, etc. -- strength of wavefoms. These are relative strengths, since the composite waveform may be rescaled later. Negative values are permitted and imply a 180 degree phase shift.</p> <p>starta, startb, etc. -- where to start writing the fn into the table.</p> <p>finisha, finishb, etc. -- where to stop writing the fn into the table. The last available location is the power of two - 1.</p>"},{"location":"scoregens/gen18/#examples","title":"Examples","text":"<pre><code>f 1  0  4096  10  1\nf 2  0  1024  18  1  1  0  511  1  1  512  1023\n</code></pre> <p>f2 consists of two copies of f1 written in to locations 0-511 and 512-1023.</p> <p>Here is an example of the GEN18 routine. It uses the files gen18.csd.</p> An example of the GEN18 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen18.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn   = p4  \nilen  = ftlen(ifn)\naphase  phasor 220 \nasig    tablei aphase*ilen, ifn\n        outs   asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\nf 1 0 4096 10 1                                         ;sine\nf 2 0 4096 10 1 0.5 0.3 0.25 0.2 0.167 0.14 0.125 .111  ;sawtooth\nf 3 0 4096 11 10 5 2                                    ;cosine partials\n\nf 11 0 8192  18 1 1 0 4095 2 1 4096 8191    ;sine+sawtooth\nf 12 0 8192  18 1 1 0 4095 3 1 4096 8191    ;sine+cosine partials\nf 13 0 1024  18 1 0.7 0 767 3 0.7 512 1023  ;sine+cosine partials overlapped, shorter table\n\ni 1 0 2 2    ;play sawtooth \ni 1 + 2 3    ;then cosine partials\ni 1 5 2 11   ;now sine+sawtooth\ni 1 + 2 12   ;and sine+cosine partials\ni 1 + 2 13   ;and sine+cosine partials overlapped, shorter table\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms generated by GEN18, as used in the example:</p> f 11 0 8193 18 1 1 0 4096 2 1 4097 8192 - composite waveform made up of a sine wave and a sawtooth f 12 0 8192  18 1 1 0 4096 3 1 4097 8192 - composite waveform made up of a sine wave and a wave of cosine partials f 13 0 1024  18 1 0.7 0 767 3 0.7 512 1023 - sine+cosine partials overlapped, also shorter table than f12"},{"location":"scoregens/gen18/#deprecated-names","title":"Deprecated Names","text":"<p>GEN18 was called GEN22 in version 4.18. The name was changed due to a conflict with DirectCsound.</p>"},{"location":"scoregens/gen18/#credits","title":"Credits","text":"<p>Author: William \u201cPete\u201d Moss University of Texas at Austin Austin, Texas USA January 2002</p> <p>New in version 4.18, changed in version 4.19</p>"},{"location":"scoregens/gen19/","title":"Gen19","text":""},{"location":"scoregens/gen19/#gen19","title":"GEN19","text":"<p>Generate composite waveforms made up of weighted sums of simple sinusoids.</p> <p>The specification of each contributing partial requires 4 p-fields using GEN19.</p>"},{"location":"scoregens/gen19/#syntax","title":"Syntax","text":"<pre><code>f # time size  19  pna   stra  phsa  dcoa  pnb strb  phsb  dcob  ...\n</code></pre>"},{"location":"scoregens/gen19/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>pna, pnb, etc. -- partial no. (relative to a fundamental that would occupy size locations per cycle) of sinusoid a, sinusoid b, etc. Must be positive, but need not be a whole number, i.e., non-harmonic partials are permitted. Partials may be in any order.</p> <p>stra, strb, etc. -- strength of partials pna, pnb, etc. These are relative strengths, since the composite waveform may be rescaled later. Negative values are permitted and imply a 180 degree phase shift.</p> <p>phsa, phsb, etc. -- initial phase of partials pna, pnb, etc., expressed in degrees.</p> <p>dcoa, dcob, etc. -- DC offset of partials pna, pnb, etc. This is applied after strength scaling, i.e. a value of 2 will lift a 2-strength sinusoid from range [-2,2] to range [0,4] (before later rescaling).</p> <p> Note</p> <ul> <li>These subroutines generate stored functions as sums of sinusoids of different frequencies. The two major restrictions on GEN10 that the partials be harmonic and in phase do not apply to GEN09 or GEN19.</li> <li>In each case the composite wave, once drawn, is then rescaled to unity if p4 was positive. A negative p4 will cause rescaling to be skipped.</li> </ul>"},{"location":"scoregens/gen19/#examples","title":"Examples","text":"<p>Here is an example of the GEN19 routine. It uses the files gen19.csd.</p> An example of the GEN19 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen19.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\n;p4 = transposition factor\n;p5 = speed factor\n;p6 = function table for grain data\ni1    = sr/ftlen(1)                                                     ;scaling to reflect sample rate and table length\na1    phasor i1*p5                                                      ;index for speed\nasigl fog    .5, 15, p4, a1, 1, 0, .01, .5, .01, 30, 1, 2, p3           ;left channel\nasigr fog    .4, 25, p4+.2, a1, 1, 0, .01, .5, .01, 30, 1, 2, p3, .5    ;right channel\n      outs   asigl, asigr\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 131072 1 \"fox.wav\" 0 0 0\nf 2 0 1024 19 .5 .5 270 .5\n\ni 1 0 10 .7  .1\ni 1 + 4  1.2  2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN19 routines, as used in the example:</p> f 2 0 1024 19 .5 .5 270 .5 - a rising sigmoid"},{"location":"scoregens/gen19/#see-also","title":"See Also","text":"<p>GEN09 and GEN10</p>"},{"location":"scoregens/gen20/","title":"Gen20","text":""},{"location":"scoregens/gen20/#gen20","title":"GEN20","text":"<p>Generates functions of different windows.</p> <p>These windows are usually used for spectrum analysis or for grain envelopes.</p>"},{"location":"scoregens/gen20/#syntax","title":"Syntax","text":"<pre><code>f # time size 20 window max [opt]\n</code></pre>"},{"location":"scoregens/gen20/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 ( + 1).</p> <p>window -- Type of window to generate:</p> <ul> <li>1 = Hamming</li> <li>2 = Hanning</li> <li>3 = Bartlett ( triangle)</li> <li>4 = Blackman ( 3-term)</li> <li>5 = Blackman - Harris ( 4-term)</li> <li>6 = Gaussian</li> <li>7 = Kaiser</li> <li>8 = Rectangle</li> <li>9 = Sinc</li> </ul> <p>max -- For negative p4 this will be the absolute value at window peak point. If p4 is positive or p4 is negative and p6 is missing the table will be post-rescaled to a maximum value of 1.</p> <p>opt -- Optional argument required by the Gaussian window, the Kaiser window and the Sinc window.</p>"},{"location":"scoregens/gen20/#examples","title":"Examples","text":"<pre><code>f   1   0   1024   20    5\n</code></pre> <p>This creates a function which contains a 4 - term Blackman - Harris window with maximum value of 1.</p> <pre><code>f   1   0   1024   -20   2   456\n</code></pre> <p>This creates a function that contains a Hanning window with a maximum value of 456.</p> <pre><code>f   1   0   1024   -20   1\n</code></pre> <p>This creates a function that contains a Hamming window with a maximum value of 1.</p> <pre><code>f   1   0   1024   20    7   1   2\n</code></pre> <p>This creates a function that contains a Kaiser window with a maximum value of 1. The extra argument specifies how \"open\" the window is, for example a value of 0 results in a rectangular window and a value of 10 in a Hamming like window.</p> <pre><code>f   1   0   1024   20    6   1   2\n</code></pre> <p>This creates a function that contains a Gaussian window with a maximum value of 1.  The extra argument specifies how broad the window is, as the standard deviation of the curve; in this example the s.d. is 2.  The default value is 1.</p> <pre><code>f   1   0   1024   20    9   1   3\n</code></pre> <p>This creates a function that contains a Sinc window with a maximum value of 1.  The extra argument specifies the range of the function as multiple of \u03c0.  The default value is 1.</p> <p>For all diagrams, see Window Functions</p> <p>Here is an example of the GEN20 routine. It uses the file gen20.csd.</p> Example of the GEN20 routine.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out \n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too \n; For Non-realtime ouput leave only the line below: \n; -o gen20.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1 \n\ninsnd   = 10                            ;\"marimba.aif\"\nibasfrq = 44100 / ftlen(insnd)          ;use original sample rate of insnd file \n\nkamp   expseg .001, p3/2, .7, p3/2, .8  ;envelope\nkpitch line ibasfrq, p3, ibasfrq * .8 \nkdens  line 600, p3, 10 \nkaoff  line 0, p3, .1\nkpoff  line 0, p3, ibasfrq * .5 \nkgdur  line .04, p3, .001               ;shorten duration of grain during note\nimaxgdur =  .5 \nigfn = p4                               ;different windows\nasigL  grain kamp, kpitch, kdens, kaoff, kpoff, kgdur, insnd, igfn, imaxgdur, 0.0 \nasigR  grain kamp, kpitch, kdens, kaoff, kpoff, kgdur, insnd, igfn, imaxgdur, 0.0 \n       outs asigL, asigR\n\nendin \n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \nf1  0 512  20 2         ;Hanning window \nf2  0 512  20 6 1       ;Gaussian window \nf10 0 16384 1 \"marimba.aif\" 0 0 0 \n\ni1 0 5 1                ;use Hanning window \ni1 + 5 2                ;use Gaussian window\ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt; \n</code></pre> <p>These are the diagrams of the waveforms of the GEN20 routines, as used in the example:</p>   f 1  0 512 20 2 - Hanning window   f 2  0 512 20 6 1 - Gaussian window"},{"location":"scoregens/gen20/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.2</p> <p>Optional argument to Gaussian added in 5.10</p>"},{"location":"scoregens/gen21/","title":"Gen21","text":""},{"location":"scoregens/gen21/#gen21","title":"GEN21","text":"<p>Generates tables of different random distributions.</p> <p>(See also betarand, bexprnd, cauchy, exprand, gauss, linrand, pcauchy, poisson, trirand, unirand, and weibull)</p>"},{"location":"scoregens/gen21/#syntax","title":"Syntax","text":"<pre><code>f # time size 21 type level [arg1  [arg2]]\n</code></pre>"},{"location":"scoregens/gen21/#initialization","title":"Initialization","text":"<p>time and size are the usual GEN function arguments. level defines the amplitude. Note that GEN21 is not self-normalizing as are most other GEN functions. type defines the distribution to be used as follow:</p> <ul> <li>1 = Uniform (positive numbers only)</li> <li>2 = Linear (positive numbers only)</li> <li>3 = Triangular (positive and negative numbers)</li> <li>4 = Exponential (positive numbers only)</li> <li>5 = Biexponential (positive and negative numbers)</li> <li>6 = Gaussian (positive and negative numbers)</li> <li>7 = Cauchy (positive and negative numbers)</li> <li>8 = Positive Cauchy (positive numbers only)</li> <li>9 = Beta (positive numbers only)</li> <li>10 = Weibull (positive numbers only)</li> <li>11 = Poisson (positive numbers only)</li> </ul> <p>Of all these cases only 9 (Beta) and 10 (Weibull) need extra arguments. Beta needs two arguments and Weibull one.</p> <p>If type = 6, the random numbers in the ftable follow a normal distribution centered around 0.0 (mu = 0.0) with a variance (sigma) of level / 3.83. Thus more than 99.99% of the random values generated are in the range -level to +level. The default value for level is 1 (sigma = 0.261). If a mean value different of 0.0 is desired, this mean value has to be added to the generated numbers.</p>"},{"location":"scoregens/gen21/#examples","title":"Examples","text":"<pre><code>f1 0 1024 21 1       ; Uniform (white noise)\nf1 0 1024 21 6       ; Gaussian (mu=0.0, sigma=1/3.83=0.261)\nf1 0 1024 21 6 5.745 ; Gaussian (mu=0.0, sigma=5.745/3.83=1.5)\nf1 0 1024 21 9 1 1 2 ; Beta (note that level precedes arguments)\nf1 0 1024 21 10 1 2  ; Weibull\n</code></pre> <p>All of the above additions were designed by the author between May and December 1994, under the supervision of Dr. Richard Boulanger.</p> <p>Here is a complete example of the GEN21 routine. It uses the file gen21.csd.</p> Example of the GEN21 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen21.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn    = p4\nisize  = ftlen(ifn) \nprints \"TABLE NUMBER: %d\\n\", ifn   \nprints \"Index\\tValue\\n\"\n\niindex = 0                              ;start loop\nbegin_loop:\n     ivalue tab_i iindex, ifn\n     prints \"%d:\\t%f\\n\", iindex, ivalue\n     iindex = iindex + 1\n  if (iindex &lt; isize) igoto begin_loop\n\n;produce sound - and repeat it 10 times so you can hear the patterns:   \naphase phasor 10/10                     ;play all 32 values 10x over 10 seconds\naphase = aphase*isize                   ;step through table\nafrq   table aphase, p4                 ;read table number\nasig   poscil .5, (afrq*500)+1000,10    ;scale values of table 500 times, add 1000 Hz\n       outs asig , asig                 ;so we can distinguish the different tables \nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 32 21 1            ;Uniform (white noise)\nf2 0 32 21 6            ;Gaussian (mu=0.0, sigma=1/3.83=0.261)\nf3 0 32 21 6 5.745      ;Gaussian (mu=0.0, sigma=5.745/3.83=1.5)\nf4 0 32 21 9 1 1 2      ;Beta (note that level precedes arguments)\nf5 0 32 21 10 1 2       ;Weibull\nf10 0 8192 10 1         ;Sine wave\n\ni 1  0 10 1\ni 1 11 10 2\ni 1 22 10 3\ni 1 33 10 4\ni 1 44 10 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN21 routines, as used in the example:</p> f 1 0 32 21 1 - positive numbers only f 2 0 32 21 6 f 3 0 32 21 6 5.745 f 4 0 32 21 9 1 1 2 - positive numbers only f 5 0 32 21 10 1 2 - positive numbers only"},{"location":"scoregens/gen21/#credits","title":"Credits","text":"<p>Author: Paris Smaragdis MIT, Cambridge 1995</p> <p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK</p> <p>Precisions about mu and sigma added by Fran\u00e7ois Pinot after a discussion with Joachim Heintz on the Csound List, December 2010.</p> <p>New in Csound version 3.2</p>"},{"location":"scoregens/gen23/","title":"Gen23","text":""},{"location":"scoregens/gen23/#gen23","title":"GEN23","text":"<p>Reads numeric values from an external ASCII file.</p>"},{"location":"scoregens/gen23/#syntax","title":"Syntax","text":"<pre><code>f # time size -23 &amp;quot;filename.txt&amp;quot;\n</code></pre>"},{"location":"scoregens/gen23/#initialization","title":"Initialization","text":"<p>\"filename.txt\" -- numeric values contained in \"filename.txt\" (which indicates the complete pathname of the character file to be read), can be separated by spaces, tabs, newline characters or commas.</p> <p>size -- number of points in the table. Must be a power of 2 , power of 2 + 1, or zero.  If size = 0, table size is determined by the number of numeric values in filename.txt. (New in Csound version 3.57)</p> <p> Note</p> <p>All characters following ';', '#' (comment) or '&lt;' (XML tag from version 6.04) are ignored until next line (numbers too).</p>"},{"location":"scoregens/gen23/#examples","title":"Examples","text":"<p>Here is an example of the GEN23 generator. It uses the file gen23.csd and spectrum.txt.</p> Example of the GEN23 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen23.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n;\"spectrum.txt\" is created by the spectrum plotter of Audacity (set at size 128), using \"fox.wav\".\n\ninstr 1 ;performs additive synthesis based on spectrum.txt\n\nindx =0                                         ;start reading at first value\nloop:\nifreq tab_i indx, 2                             ;take odd values of list (= frequency)\niamp tab_i indx+1, 2                            ;take even values of list (= amplitude)\nevent_i \"i\", 10, 0, p3, iamp, ifreq             ;use \"event_i\" to trigger instr. 10 \n    loop_lt indx, 2, 126, loop                  ;use all 126 frequency and amplitude values\n\nendin\n\ninstr 10 ;generate sound\n\niamp  = p4\nifreq = p5\nasig  poscil ampdb(iamp), ifreq, 1\nasig  linen asig, .01, p3, p2\n      outs  asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1                ;sine wave\nf 2 0 128 -23 \"spectrum.txt\"    ;\"spectrum.txt\" can be found in /manual/examples\n\ni1 0 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN23 routine, as used in the example:</p> f 2 0 128 -23 \"spectrum.txt\" - not normalized"},{"location":"scoregens/gen23/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado Italy February, 1998</p> <p>New in Csound version 3.47. Comments starting with '#' are ignored from Csound version 5.12.</p>"},{"location":"scoregens/gen24/","title":"Gen24","text":""},{"location":"scoregens/gen24/#gen24","title":"GEN24","text":"<p>Reads numeric values from another allocated function-table and rescales them according to the max and min values given by the user.</p>"},{"location":"scoregens/gen24/#syntax","title":"Syntax","text":"<pre><code>f # time size -24 ftable min max\n</code></pre>"},{"location":"scoregens/gen24/#initialization","title":"Initialization","text":"<p>#, time, size -- the usual GEN parameters. See f statement.</p> <p>ftable -- ftable must be an already allocated table with the same size as this function.</p> <p>min, max -- the rescaling range.</p> <p> Note</p> <p>This GEN is useful, for example, to eliminate the starting offset in exponential segments allowing a real starting from zero.</p>"},{"location":"scoregens/gen24/#examples","title":"Examples","text":"<p>Here is an example of the GEN24 opcode. It uses the file gen24.csd.</p> Example of the GEN24 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen24.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nifn  = p4                               ;choose between tables\nkcps init 1/p3                          ;create index over duration of note.\nkndx phasor kcps\nixmode = 1                              ;normalize to 0-1\nkval table kndx, ifn, ixmode\nasig poscil .7, 440 + kval, 1           ;add to frequency\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\nf 10 0 16384 -24 1 0 400;scale sine wave from table 1 from 0 to 400\nf 11 0 16384 -24 1 0 50 ;and from 0 to 50\n\ni 1 0 3 10\ni 1 4 3 11\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen24/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 4.16</p>"},{"location":"scoregens/gen25/","title":"Gen25","text":""},{"location":"scoregens/gen25/#gen25","title":"GEN25","text":"<p>Construct functions from segments of exponential curves in breakpoint fashion.</p>"},{"location":"scoregens/gen25/#syntax","title":"Syntax","text":"<pre><code>f # time size 25 x1 y1 x2 y2 x3  ...\n</code></pre>"},{"location":"scoregens/gen25/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>x1, x2, x3, etc. -- locations in table at which to attain the following y value. Must be in increasing order. If the last value is less than size, then the rest will be set to zero. Should not be negative but can be zero.</p> <p>y1, y2, y3,, etc. -- Breakpoint values attained at the location specified by the preceding x value. These must be non-zero and must be alike in sign.</p> <p> Note</p> <p>If p4 is positive, functions are post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</p>"},{"location":"scoregens/gen25/#examples","title":"Examples","text":"<p>Here is an example of the GEN25 generator. It uses the file gen25.csd.</p> Example of the GEN25 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen25.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisin ftgen 1, 0, 32768, 10, 1\ngienv ftgen 2, 0, 1025, 25, 0, 0.01, 200, 1, 400, 1, 513, 0.01  ; y value must be &gt;= 0\n\n\ninstr 1\n\nkcps init 3/p3                  ;play 3x over duration of note\nkndx phasor kcps\nixmode = 1                      ;normalize to 0-1\nkval table kndx, gienv, ixmode\nkval =kval*100                  ;scale up to 0-100\nasig poscil 1, 220+kval, gisin  ;use table for amplitude\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN25 routine, as used in the example:</p> f 2 0 1025 25 0 0.01 200 1 400 1 513 0.01 - a function which begins at 0.01, rises to 1 at the 200th table location, makes a straight line to the 400th location, and returns to 0.01 by the end of the table"},{"location":"scoregens/gen25/#see-also","title":"See Also","text":"<p>f statement, GEN27</p>"},{"location":"scoregens/gen25/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.49</p>"},{"location":"scoregens/gen27/","title":"Gen27","text":""},{"location":"scoregens/gen27/#gen27","title":"GEN27","text":"<p>Construct functions from segments of straight lines in breakpoint fashion.</p>"},{"location":"scoregens/gen27/#syntax","title":"Syntax","text":"<pre><code>f # time size 27 x1  y1 x2 y2 x3 ...\n</code></pre>"},{"location":"scoregens/gen27/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>x1, x2, x3, etc. -- locations in table at which to attain the following y value. Must be in increasing order. If the last value is less than size, then the rest will be set to zero. Should not be negative but can be zero.</p> <p>y1, y2, y3,, etc. -- Breakpoint values attained at the location specified by the preceding x value.</p> <p> Note</p> <p>If p4 is positive, functions are post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</p>"},{"location":"scoregens/gen27/#examples","title":"Examples","text":"<p>Here is an example of the GEN27 generator. It uses the file gen27.csd.</p> Example of the GEN27 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen27.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngisin ftgen 1, 0, 32768, 10, 1\ngienv ftgen 2, 0, 1025, 27, 0, 0,200, 1, 400, -1, 513, 0\n\ninstr 1\n\nkcps init 3/p3                  ;play 3x over duration of note\nkndx phasor kcps\nixmode = 1                      ;normalize to 0-1\nkval table kndx, gienv, ixmode\nkval = kval*100                 ;scale 0-100\nasig poscil 1, 220+kval, 1      ;add to 220 Hz\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 4\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN27 routine, as used in the example:</p> f 2 0 1025 27 0 0 200 1 400 -1 513 0 - a function which begins at 0, rises to 1 at the 200th table location, falls to -1, by the 400th location, and returns to 0 by the end of the table. The interpolation is linear"},{"location":"scoregens/gen27/#see-also","title":"See Also","text":"<p>f statement, GEN25</p>"},{"location":"scoregens/gen27/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK</p> <p>New in Csound version 3.49</p>"},{"location":"scoregens/gen28/","title":"Gen28","text":""},{"location":"scoregens/gen28/#gen28","title":"GEN28","text":"<p>Reads a text file which contains a time-tagged trajectory.</p> <p>The text file contains sets of three values representing the xy coordinates and a time-tag for when the signal should be placed at that location, allowing the user to define a time-tagged trajectory. The file format is in the form:</p> <pre><code>time1    X1      Y1\ntime2    X2      Y2\ntime3    X3      Y3\n</code></pre> <p>The configuration of the xy coordinates in space places the signal in the following way:</p> <ul> <li>a1 is -1, 1</li> <li>a2 is 1, 1</li> <li>a3 is -1, -1</li> <li>a4 is 1, -1</li> </ul> <p>This assumes a loudspeaker set up as a1 is left front, a2 is right front, a3 is left back, a4 is right back. Values greater than 1 will result in sounds being attenuated as if in the distance. GEN28 creates values to 10 milliseconds of resolution.</p>"},{"location":"scoregens/gen28/#syntax","title":"Syntax","text":"<pre><code>f # time size 28 ifilcod\n</code></pre>"},{"location":"scoregens/gen28/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be 0. GEN28 takes 0 as the size and automatically allocates memory.</p> <p>ifilcod -- character-string denoting the source file name. A character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the named file is sought in the current directory.</p>"},{"location":"scoregens/gen28/#examples","title":"Examples","text":"<pre><code>f_1 0 0 28 &amp;quot;move&amp;quot;\n</code></pre> <p>The file \"move\" should look like:</p> <pre><code>0       -1       1\n1        1       1\n2        4       4\n2.1     -4      -4\n3        10     -10\n5       -40      0\n</code></pre> <p>Since GEN28 creates values to 10 milliseconds of resolution, there will be 500 values created by interpolating X1 to X2 to X3 and so on, and Y1 to Y2 to Y3 and so on, over the appropriate number of values that are stored in the function table. The sound will begin in the left front, over 1 second it will move to the right front, over another second it move further into the distance but still in the right front, then in just 1/10th of a second it moves to the left rear, a bit distant. Finally over the last .9 seconds the sound will move to the right rear, moderately distant, and it comes to rest between the two left channels (due west!), quite distant.</p> <p>Here is an example of the GEN28 routine. It uses the file gen28.csd.</p> Example of the gen28 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen28.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \n0dbfs  = 1 \nnchnls = 4\n\nga1     init    0\nga2     init    0\nga3     init    0\nga4     init    0\n\ninstr 1 ;uses GEN28 file \"move\", as found in /manual/examples\n\nkx    init 0\nky    init 0\nktime line  0, 5, 5                             ;same time as in table 1 (=\"move\")\nasig  diskin2 \"drumsMlp.wav\", 1, 0, 1           ;sound source is looped\na1, a2, a3, a4 space asig, 1, ktime, .1, kx, ky ;use table 1 = GEN28\nar1, ar2, ar3, ar4 spsend                       ;send to reverb\n\nga1  = ga1+ar1\nga2  = ga2+ar2\nga3  = ga3+ar3\nga4  = ga4+ar4\n     outq a1, a2, a3, a4\n\nendin\n\ninstr 99 ; reverb instrument\n\na1 reverb2 ga1, 2.5, .5\na2 reverb2 ga2, 2.5, .5\na3 reverb2 ga3, 2.5, .5\na4 reverb2 ga4, 2.5, .5\n   outq a1, a2, a3, a4\n\nga1=0   \nga2=0\nga3=0\nga4=0\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 0 28 \"move\"\n\ni1 0 5          ;same time as ktime\ni 99 0 10       ;keep reverb active\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen28/#credits","title":"Credits","text":"<p>Author: Richard Karpen Seattle, Wash 1998</p> <p>New in Csound version 3.48</p>"},{"location":"scoregens/gen30/","title":"Gen30","text":""},{"location":"scoregens/gen30/#gen30","title":"GEN30","text":"<p>Extracts a range of harmonic partials from an existing waveform.</p>"},{"location":"scoregens/gen30/#syntax","title":"Syntax","text":"<pre><code>f # time size  30  src  minh maxh [ref_sr] [interp]\n</code></pre>"},{"location":"scoregens/gen30/#performance","title":"Performance","text":"<p>src -- source ftable</p> <p>minh -- lowest harmonic number</p> <p>maxh -- highest harmonic number</p> <p>ref_sr (optional) -- maxh is scaled by (sr / ref_sr). The default value of ref_sr is sr. If ref_sr is zero or negative, it is now ignored.</p> <p>interp (optional) -- if non-zero, allows changing the amplitude of the lowest and highest harmonic partial depending on the fractional part of minh and maxh. For example, if maxh is 11.3 then the 12th harmonic partial is added with 0.3 amplitude. This parameter is zero by default.</p> <p>GEN30 does not support tables with an extended guard point (ie. table size = power of two + 1). Although such tables will work both for input and output, when reading source table(s), the guard point is ignored, and when writing the output table, guard point is simply copied from the first sample (table index = 0).</p> <p>The reason of this limitation is that GEN30 uses FFT, which requires power of two table size.  GEN32 allows using linear interpolation for resampling and phase shifting, which makes it possible to use any table size (however, for partials calculated with FFT, the power of two limitation still exists).</p>"},{"location":"scoregens/gen30/#examples","title":"Examples","text":"<p>Here is an example of the GEN30 routine. It uses the files gen30.csd.</p> Example of the GEN30 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac     ;;;realtime audio out\n; For Non-realtime ouput leave only the line below:\n; -o gen30.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n;a simplified example of Istvan Varga\nsr =  44100\nksmps =  32\nnchnls =  2\n0dbfs   = 1\n\nisaw    ftgen 1, 0, 16384, 7, 1, 16384, -1                                              ;sawtooth wave \niFM     ftgen 3, 0, 4096, 7, 0, 512, 0.25, 512, 1, 512, 0.25, 512,      \\\n                             0, 512, -0.25, 512, -1, 512, -0.25, 512, 0                 ;FM waveform\niAM     ftgen 4, 0, 4096, 5, 1, 4096, 0.01                                              ;AM waveform\niEQ     ftgen 5, 0, 1024, 5, 1, 512, 32, 512, 1                                         ;FM to EQ\nisine   ftgen 6, 0, 1024, 10, 1                                                         ;sine wave\n\n/* generate bandlimited sawtooth waves */\ni0      =  0\nloop1:\nimaxh   =  sr / (2 * 440.0 * exp(log(2.0) * (i0 - 69) / 12))\ni_      ftgen i0 + 10, 0, 4096, -30, 1, 1, imaxh                                        ;use gen 30\ni0      =  i0 + 1\n        if (i0 &lt; 127.5) igoto loop1\n\ninstr 1\n\nkcps    =  440.0 * exp(log(2.0) * (p4 - 69) / 12)                                       ;note frequency\nklpmaxf limit p5 * kcps, 1000.0, 12000.0                                                ;lowpass max. frequency\n\nkfmd1   =  0.03 * kcps                                                                  ;FM depth in Hz\nkamfr   =  kcps * 0.02                                                                  ;AM frequency\nkamfr2  =  kcps * 0.1\n\nkfnum   =  (10 + 69 + 0.5 + 12 * log(kcps / 440.0) / log(2.0))                          ;table number\naenv    linseg 0, p3*0.25, 1, p3*0.75, 0                                                ;amp. envelope\n\nasig    oscbnk kcps, 0.0, kfmd1, 0.0, 40, 200, 0.1, 0.2, 0, 0, 144,           \\\n                0.0, klpmaxf, 0.0, 0.0, 1.5, 1.5, 2, kfnum, 3, 0, 5, 5, 5\nasig    = asig * aenv*.03\nouts asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ns\ni 1 0 6 41 10\ni 1 0 6 60\ni 1 0 6 65\ni 1 0 6 69\ns\ni 1 0 6 41 64\ni 1 0 6 60\ni 1 0 6 65\ni 1 0 6 69\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen30/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.16</p>"},{"location":"scoregens/gen31/","title":"Gen31","text":""},{"location":"scoregens/gen31/#gen31","title":"GEN31","text":"<p>Mixes any waveform specified in an existing table.</p> <p>This routine is similar to GEN09, but allows mixing any waveform specified in an existing table.</p>"},{"location":"scoregens/gen31/#syntax","title":"Syntax","text":"<pre><code>f # time size  31  src  pna stra phsa  pnb strb phsb  ...\n</code></pre>"},{"location":"scoregens/gen31/#performance","title":"Performance","text":"<p>src -- source table number</p> <p>pna, pnb, ... -- partial number, must be a positive integer</p> <p>stra, strb, ... -- amplitude scale</p> <p>phsa, phsb, ... -- start phase (0 to 1)</p> <p>GEN31 does not support tables with an extended guard point (ie. table size = power of two + 1). Although such tables will work both for input and output, when reading source table(s), the guard point is ignored, and when writing the output table, guard point is simply copied from the first sample (table index = 0).</p> <p>The reason of this limitation is that GEN31 uses FFT, which requires power of two table size.  GEN32 allows using linear interpolation for resampling and phase shifting, which makes it possible to use any table size (however, for partials calculated with FFT, the power of two limitation still exists).</p>"},{"location":"scoregens/gen31/#examples","title":"Examples","text":"<p>Here is an example of the GEN31 routine. It uses the files gen31.csd.</p> Example of the GEN31 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n  -o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n0dbfs = 1\n\ngisine  ftgen  0,0,4096,10,1\ngi31    ftgen  0,0,4096,31,gisine, 1,1,0, 2,1,0, 3,1,0, 4,1,0, 5,1,0, 6,1,0\n\ninstr 1\n  aa  oscil3  0.6, 440, gi31\n      out     aa\nendin\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\ni1 0 5\ne\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen31/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p> <p>New in version 4.15</p>"},{"location":"scoregens/gen32/","title":"Gen32","text":""},{"location":"scoregens/gen32/#gen32","title":"GEN32","text":"<p>Mixes any waveform, resampled with either FFT or linear interpolation.</p> <p>This routine is similar to GEN31, but allows specifying source ftable for each partial. Tables can be resampled either with FFT, or linear interpolation.</p>"},{"location":"scoregens/gen32/#syntax","title":"Syntax","text":"<pre><code>f # time size  32  srca  pna stra phsa  srcb pnb strb phsb  ...\n</code></pre>"},{"location":"scoregens/gen32/#performance","title":"Performance","text":"<p>srca, srcb -- source table number. A negative value can be used to read the table with linear interpolation (by default, the source waveform is transposed and phase shifted using FFT); this is less accurate, but faster, and allows non-integer and negative partial numbers.</p> <p>pna, pnb, ... -- partial number, must be a positive integer if source table number is positive (i.e. resample with FFT).</p> <p>stra, strb, ... -- amplitude scale</p> <p>phsa, phsb, ... -- start phase (0 to 1)</p>"},{"location":"scoregens/gen32/#examples","title":"Examples","text":"<p>Here is an example of the GEN32 routine. It uses the file gen32.csd.</p> Example of the gen32 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen32.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\nitmp    ftgen 1, 0, 16384, 7, 1, 16384, -1              ; sawtooth\nitmp    ftgen 2, 0, 8192, 10, 1                         ; sine\nitmp    ftgen 5, 0, 4096, -32, -2, 1.5, 1.0, 0.25, 1, 2, 0.5, 0, 1, 3, -0.25, 0.5       ; mix tables\nitmp    ftgen 6, 0, 16384, 20, 3, 1                     ; window\n; generate band-limited waveforms\ninote   =  0\nloop0:\nicps    =  440 * exp(log(2) * (inote - 69) / 12)        ; one table for\ninumh   =  sr / (2 * icps)                              ; each MIDI note number\nift     =  int(inote + 256.5)\nitmp    ftgen ift, 0, 4096, -30, 5, 1, inumh\ninote   =  inote + 1\n        if (inote &lt; 127.5) igoto loop0\n\ninstr 1\n\nkcps    expon 20, p3, 16000\nkft     =  int(256.5 + 69 + 12 * log(kcps / 440) / log(2))\nkft     =  (kft &gt; 383 ? 383 : kft)\na1      phasor kcps\na1      tableikt a1, kft, 1, 0, 1\n        outs a1*.5, a1*.5\nendin\n\ninstr 2\n\nkcps    expon 20, p3, 16000\nkft     =  int(256.5 + 69 + 12 * log(kcps / 440) / log(2))\nkft     =  (kft &gt; 383 ? 383 : kft)\nkgdur   limit 10 / kcps, 0.1, 1\na1      grain2 kcps, 0.02, kgdur, 30, kft, 6, -0.5\n        outs a1*.08, a1*.08\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nt 0 60\n\ni 1 0 10\ni 2 12 10\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen32/#credits","title":"Credits","text":"<p>Author: Rasmus Ekman</p> <p>Programmer: Istvan Varga</p> <p>New in version 4.17</p>"},{"location":"scoregens/gen33/","title":"Gen33","text":""},{"location":"scoregens/gen33/#gen33","title":"GEN33","text":"<p>Generate composite waveforms by mixing simple sinusoids.</p> <p>It works similarly to GEN09, but the parameters of the partials are specified in an already existing table, which makes it possible to calculate any number of partials in the orchestra.</p> <p>The difference between GEN33 and GEN34 is that GEN33 uses inverse FFT to generate output, while GEN34 is based on the algorithm used in oscils opcode. GEN33 allows integer partials only, and does not support power of two plus 1 table size, but may be significantly faster with a large number of partials. On the other hand, with GEN34, it is possible to use non-integer partial numbers and extended guard point, and this routine may be faster if there is only a small number of partials (note that GEN34 is also several times faster than GEN09, although the latter may be more accurate).</p>"},{"location":"scoregens/gen33/#syntax","title":"Syntax","text":"<pre><code>f # time size  33  src nh scl [fmode]\n</code></pre>"},{"location":"scoregens/gen33/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be power of two and at least 4.</p> <p>src -- source table number. This table contains the parameters of each partial in the following format:</p> <pre><code>stra, pna, phsa, strb, pnb, phsb, ...\n</code></pre> <p>the parameters are:</p> <ul> <li>stra, strb, etc.: relative strength of partials. The actual amplitude depends on the value of scl, or normalization (if enabled).</li> <li>pna, pnb, etc.:   partial number, or frequency, depending on fmode (see below); zero and negative values are allowed, however, if the absolute value of the partial number exceeds (size / 2), the partial will not be rendered. With GEN33, partial number is rounded to the nearest integer.</li> <li>phsa, phsb, etc.: initial phase, in the range 0 to 1.</li> </ul> <p>Table length (not including the guard point) should be at least 3 * nh. If the table is too short, the number of partials (nh) is reduced to (table length) / 3, rounded towards zero.</p> <p>nh -- number of partials. Zero or negative values are allowed, and result in an empty table (silence). The actual number may be reduced if the source table (src) is too short, or some partials have too high frequency.</p> <p>scl -- amplitude scale.</p> <p>fmode (optional, default = 0) -- a non-zero value can be used to set frequency in Hz instead of partial numbers in the source table.  The sample rate is assumed to be fmode if it is positive, or -(sr * fmode) if any negative value is specified.</p>"},{"location":"scoregens/gen33/#examples","title":"Examples","text":"<p>Here is an example of the GEN33 routine. It uses the file gen33.csd.</p> Example of the gen33 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen33.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; partials 1, 4, 7, 10, 13, 16, etc. with base frequency of 400 Hz\n\nibsfrq  =  400                                                                          \ninumh   =  int(1.5 + sr * 0.5 / (3 * ibsfrq))                                   ; estimate number of partials                   \nisrcln  =  int(0.5 + exp(log(2) * int(1.01 + log(inumh * 3) / log(2))))         ; source table length\nitmp    ftgen 1, 0, isrcln, -2, 0                                               ; create empty source table\nifpos   =  0\nifrq    =  ibsfrq\ninumh   =  0\nl1:\n        tableiw ibsfrq / ifrq, ifpos, 1                                         ; amplitude\n        tableiw ifrq, ifpos + 1, 1                                              ; frequency\n        tableiw 0, ifpos + 2, 1                                                 ; phase\nifpos   =  ifpos + 3\nifrq    =  ifrq + ibsfrq * 3\ninumh   =  inumh + 1\n        if (ifrq &lt; (sr * 0.5)) igoto l1\n\nitemp   ftgen 2, 0, 262144, -33, 1, inumh, 1, -1                                ; store output in ftable 2 (size = 262144)\nasig    poscil .5, ibsfrq, itemp\n        outs asig, asig \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform generated by GEN33, as used in the example:</p> f 2 0 262144 -33 1 inumh 1 -1"},{"location":"scoregens/gen33/#see-also","title":"See Also","text":"<p>GEN09, GEN34</p>"},{"location":"scoregens/gen33/#credits","title":"Credits","text":"<p>Programmer: Istvan Varga March 2002</p> <p>New in version 4.19</p>"},{"location":"scoregens/gen34/","title":"Gen34","text":""},{"location":"scoregens/gen34/#gen34","title":"GEN34","text":"<p>Generate composite waveforms by mixing simple sinusoids.</p> <p>It works similarly to GEN09, but the parameters of the partials are specified in an already existing table, which makes it possible to calculate any number of partials in the orchestra.</p> <p>The difference between GEN33 and GEN34 is that GEN33 uses inverse FFT to generate output, while GEN34 is based on the algorithm used in oscils opcode. GEN33 allows integer partials only, and does not support power of two plus 1 table size, but may be significantly faster with a large number of partials. On the other hand, with GEN34, it is possible to use non-integer partial numbers and extended guard point, and this routine may be faster if there is only a small number of partials (note that GEN34 is also several times faster than GEN09, although the latter may be more accurate).</p>"},{"location":"scoregens/gen34/#syntax","title":"Syntax","text":"<pre><code>f # time size  34  src nh scl [fmode]\n</code></pre>"},{"location":"scoregens/gen34/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be power of two or a power of two plus 1.</p> <p>src -- source table number. This table contains the parameters of each partial in the following format:</p> <pre><code>stra, pna, phsa, strb, pnb, phsb, ...\n</code></pre> <p>the parameters are:</p> <ul> <li>stra, strb, etc.: relative strength of partials. The actual amplitude depends on the value of scl, or normalization (if enabled).</li> <li>pna, pnb, etc.:   partial number, or frequency, depending on fmode (see below); zero and negative values are allowed, however, if the absolute value of the partial number exceeds (size / 2), the partial will not be rendered.</li> <li>phsa, phsb, etc.: initial phase, in the range 0 to 1.</li> </ul> <p>Table length (not including the guard point) should be at least 3 * nh. If the table is too short, the number of partials (nh) is reduced to (table length) / 3, rounded towards zero.</p> <p>nh -- number of partials. Zero or negative values are allowed, and result in an empty table (silence). The actual number may be reduced if the source table (src) is too short, or some partials have too high frequency.</p> <p>scl -- amplitude scale.</p> <p>fmode (optional, default = 0) -- a non-zero value can be used to set frequency in Hz instead of partial numbers in the source table.  The sample rate is assumed to be fmode if it is positive, or -(sr * fmode) if any negative value is specified.</p>"},{"location":"scoregens/gen34/#examples","title":"Examples","text":"<p>Here is an example of the GEN34 routine. It uses the file gen34.csd.</p> Example of the gen34 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen34.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; partials 1, 4, 7, 10, 13, 16, etc. with base frequency of 400 Hz\n\nibsfrq  =  400                                                                          \ninumh   =  int(1.5 + sr * 0.5 / (3 * ibsfrq))                                   ; estimate number of partials                   \nisrcln  =  int(0.5 + exp(log(2) * int(1.01 + log(inumh * 3) / log(2))))         ; source table length\nitmp    ftgen 1, 0, isrcln, -2, 0                                               ; create empty source table\nifpos   =  0\nifrq    =  ibsfrq\ninumh   =  0\nl1:\n        tableiw ibsfrq / ifrq, ifpos, 1                                         ; amplitude\n        tableiw ifrq, ifpos + 1, 1                                              ; frequency\n        tableiw 0, ifpos + 2, 1                                                 ; phase\nifpos   =  ifpos + 3\nifrq    =  ifrq + ibsfrq * 3\ninumh   =  inumh + 1\n        if (ifrq &lt; (sr * 0.5)) igoto l1\n\nitmp    ftgen 2, 0, 262144, -34, 1, inumh, 1, -1                                ; store output in ftable 2 (size = 262144)\nasig    poscil .5, ibsfrq, itmp\n        outs asig, asig \n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 2 \n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform generated by GEN34, as used in the example:</p> f 2 0 262144 -34 1 inumh 1 -1"},{"location":"scoregens/gen34/#see-also","title":"See Also","text":"<p>GEN09, GEN33</p>"},{"location":"scoregens/gen34/#credits","title":"Credits","text":"<p>Programmer: Istvan Varga March 2002</p> <p>New in version 4.19</p>"},{"location":"scoregens/gen40/","title":"Gen40","text":""},{"location":"scoregens/gen40/#gen40","title":"GEN40","text":"<p>Generates a continuous random distribution function starting from the shape of a user-defined distribution histogram.</p>"},{"location":"scoregens/gen40/#syntax","title":"Syntax","text":"<pre><code>f # time size 40 shapetab\n</code></pre>"},{"location":"scoregens/gen40/#performance","title":"Performance","text":"<p>The shape of histogram must be stored in a previously defined table, in fact shapetab argument must be filled with the number of such table.</p> <p>Histogram shape can be generated with any other GEN routines. Since no interpolation is used when GEN40 processes the translation, it is suggested that the size of the table containing the histogram shape to be reasonably big, in order to obtain more precision (however after the processing the shaping-table can be destroyed in order to re-gain memory). </p> <p>This subroutine is designed to be used together with cuserrnd opcode (see cuserrnd for more information).</p>"},{"location":"scoregens/gen40/#examples","title":"Examples","text":"Example of the GEN40 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o GEN40.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; every run time same values\n\nkuser cuserrnd 0, 100, 1\n      printk .2, kuser\nasig  poscil .5, 220+kuser, 3\n      outs asig, asig\nendin\n\ninstr 2 ; every run time different values\n\n      seed 0\nkuser cuserrnd 0, 100, 1\n      printk .2, kuser\nasig  poscil .5, 220+kuser, 3\n      outs asig, asig\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16 -7 1 4 0 8 0 4 1       ;distrubution using GEN07\nf 2 0 16384 40 1                ;GEN40 is to be used with cuserrnd\nf 3 0 8192 10 1                 ;sine\n\ni 1 0 2\ni 2 3 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00067:    53.14918\ni   1 time     0.20067:     0.00000\ni   1 time     0.40067:     0.00000\ni   1 time     0.60067:    96.80406\ni   1 time     0.80067:    94.20729\ni   1 time     1.00000:     0.00000\ni   1 time     1.20067:    86.13032\ni   1 time     1.40067:    31.37096\ni   1 time     1.60067:    70.35889\ni   1 time     1.80000:     0.00000\ni   1 time     2.00000:    49.18914\n\nWARNING: Seeding from current time 2006647442\n\ni   2 time     3.00067:    21.45002\ni   2 time     3.20067:    44.32333\ni   2 time     3.40067:    46.05420\ni   2 time     3.60000:     0.00000\ni   2 time     3.80067:    41.32175\ni   2 time     4.00000:     0.00000\ni   2 time     4.20000:    63.72019\ni   2 time     4.40067:     0.00000\ni   2 time     4.60067:     0.00000\ni   2 time     4.80067:     0.00000\ni   2 time     5.00000:    74.49330\n</code></pre> <p>This is the diagram of the waveform of the GEN40 routine, as used in the example:</p> f 2 0 16384 40 1"},{"location":"scoregens/gen40/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"scoregens/gen41/","title":"Gen41","text":""},{"location":"scoregens/gen41/#gen41","title":"GEN41","text":"<p>Generates a discrete random distribution function by giving a list of numerical pairs.</p>"},{"location":"scoregens/gen41/#syntax","title":"Syntax","text":"<pre><code>f # time size -41 value1 prob1 value2 prob2 value3 prob3 ... valueN probN\n</code></pre>"},{"location":"scoregens/gen41/#performance","title":"Performance","text":"<p>The first number of each pair is a value, and the second is the probability of that value to be chosen by a random algorithm. Even if any number can be assigned to the probability element of each pair, it is suggested to give it a percent value, in order to make it clearer for the user.</p> <p>This subroutine is designed to be used together with duserrnd and urd opcodes (see duserrnd for more information).</p>"},{"location":"scoregens/gen41/#examples","title":"Examples","text":"<p>Here is an example of the GEN41 generator. It uses the file gen41.csd.</p> Example of the GEN41 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o GEN41.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\nk1   duserrnd 1\n     printk 0, k1\nasig poscil .5, 220*k1, 2\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 -20 -41  2 .1 8 .9 ;choose 2 at 10% probability, 8 at 90%\n\nf2 0 8192 10 1\n\ni1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i   1 time     0.00067:     8.00000\ni   1 time     0.00133:     8.00000\ni   1 time     0.00200:     8.00000\ni   1 time     0.00267:     8.00000\ni   1 time     0.00333:     2.00000\ni   1 time     0.00400:     8.00000\ni   1 time     0.00533:     8.00000\ni   1 time     0.00600:     8.00000\n..........\n</code></pre> <p>This is the diagram of the waveform of the GEN41 routine, as used in the example:</p> f 1 0 -20 -41  2 .1 8 .9"},{"location":"scoregens/gen41/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"scoregens/gen42/","title":"Gen42","text":""},{"location":"scoregens/gen42/#gen42","title":"GEN42","text":"<p>Generates a random distribution function of discrete ranges of values by giving a list of groups of three numbers.</p>"},{"location":"scoregens/gen42/#syntax","title":"Syntax","text":"<pre><code>f # time size -42  min1 max1 prob1 min2 max2 prob2 min3 max3 prob3 ...  minN maxN probN\n</code></pre>"},{"location":"scoregens/gen42/#performance","title":"Performance","text":"<p>The first number of each group is a the minimum value of the range, the second is the maximum value and the third is the probability of that an element belonging to that range of values can be chosen by a random algorithm. Probabilities for a range should be a fraction of 1, and the sum of the probabilities for all the ranges should total 1.0.</p> <p>This subroutine is designed to be used together with duserrnd and urd opcodes (see duserrnd for more information). Since both duserrnd and urd do not use any interpolation, it is suggested to give a size reasonably big.</p>"},{"location":"scoregens/gen42/#examples","title":"Examples","text":"<p>Here is an example of the GEN42 generator. It uses the file gen42.csd.</p> Example of the GEN42 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac   ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o GEN42.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 \n\nktab  = 1                       ;ftable 1\nkurd  = urd(ktab) \nktrig metro 5                   ;triggers 5 times per second\nkres  samphold kurd, ktrig      ;sample and hold value of kurd\n      printk2 kres              ;print it\nasig  poscil .5, 220+kres, 2\n      outs asig, asig\nendin\n\ninstr 2\n\nseed 0  ;every run new values\n\nktab  = 1                       ;ftable 1\nkurd  = urd(ktab) \nktrig metro 5                   ;triggers 5 times per second\nkres  samphold kurd, ktrig      ;sample and hold value of kurd\n      printk2 kres              ;print it\nasig  poscil .5, 220+kres, 2\n      outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 -20 -42  10 20 .3 100 200 .7 ;30% choose between 10 and 20 and 70% between 100 and 200\nf2 0 8192 10 1                    ;sine wave\n\ni 1 0 5\ni 2 6 5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Its output should include lines like these:</p> <pre><code>i1   184.61538\ni1   130.76923\ni1   169.23077\ni1    12.00000\n.......\n\nWARNING: Seeding from current time 3751086165\n\ni2   138.46154\ni2    12.00000\ni2   123.07692\ni2   161.53846\ni2   123.07692\ni2   153.84615\n......\n</code></pre> <p>This is the diagram of the waveform of the GEN42 routine, as used in the example:</p>   f 1 0 -20 -42  10 20 .3 100 200 .7"},{"location":"scoregens/gen42/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"scoregens/gen43/","title":"Gen43","text":""},{"location":"scoregens/gen43/#gen43","title":"GEN43","text":"<p>Loads a PVOCEX file containing a PV analysis.</p> <p>This subroutine loads a PVOCEX file containing the PV analysis (amp-freq) of a soundfile and calculates the average magnitudes of all analysis frames of one or all audio channels. It then creates a table with these magnitudes for each PV bin.</p>"},{"location":"scoregens/gen43/#syntax","title":"Syntax","text":"<pre><code>f # time size 43 filecod channel\n</code></pre> <p>Initialisation</p> <p>size -- number of points in the table, power-of-two or power-of-two plus 1. GEN 43 does not make any distinction between these two sizes, but it requires the table to be at least the fftsize/2. PV bins cover the positive spectrum from 0Hz (table index 0) to the Nyquist (table index fftsize/2+1) in equal-size frequency increments (of size sr/fftsize).</p> <p>filcod -- a pvocex file (which can be generated by pvanal).</p> <p>channel -- audio channel number from which the magnitudes will be extracted; a 0 will average the magnitudes from all channels.</p> <p>Reading stops at the end of the file.</p> <p> Note</p> <p>if p4 is positive, the table will be post-normalised. A negative p4 will cause post-normalisation to be skipped.</p>"},{"location":"scoregens/gen43/#examples","title":"Examples","text":"<p>Here is an example of the GEN43 routine. It uses the files gen43.csd.</p> <p>Note: In this example, the .csd uses the \u2018system_i\u2019 opcode to launch and run the pvanal utility and analyze a section from the sound file, finneganswake1.flac, where we find a bit of reverb and noise. The \u2018reverbnoise\u2019 selection has a duration of 0.8 seconds (-d0.8) which we find after 1.04 seconds of the source (-b1.04) and thus pvanal creates the pvocex file that we use in instrument 3 to remove this noise and reverb from the original with the pvstencil opcode.</p> An example of the GEN43 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o GEN43.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; by Menno Knevel 2021\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; Audacity shows the selection of reverb and noise- see image above\n\ninstr 1 ; analyze this selection and output result to pvx file\nires system_i 1,{{     \n    pvanal -b1.04 -d0.8 finneganswake1.flac reverbnoise.pvx\n        }}\nendin\n\ninstr 2 ; untreated signal, contains some reverb and noise\nasig    diskin2   \"finneganswake1.flac\", 1\nouts    asig, asig\nendin\n\ninstr 3 ; use .pvx file from instr. 1 to remove reverb and noise\n; pvanal created 1 frame of size 1024, so size of table for GEN 43 = 512 (fftsize/2)\nipvx    ftgen 1, 0, 512, -43, \"reverbnoise.pvx\", 0    ; can be found in examples folder\nasig    diskin2   \"finneganswake1.flac\", 1  \nfsig    pvsanal   asig, 1024, 256, 1024, 1\nfclean  pvstencil fsig, 0, 1, ipvx ; maximum cleaning\naclean  pvsynth   fclean\nouts    aclean, aclean\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\ni1 0   2       ; first analyze\ni2 5  12.7     ; untreated signal\ni3 20 12.7     ; denoised gignal\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These tables can be used as a masking table for pvstencil and pvsmaska.</p> <pre><code>f1 0 512   43  \"viola.pvx\" 1\nf1 0 -1024 -43 \"noiseprint.pvx\" 0\n</code></pre> <p>The first example uses a 1024-point FFT phase vocoder analysis file from which the first channel is used. The second uses all channels of a 2048-point file, without post-normalisation. For noise reduction applications with pvstencil, it is easiest to skip table normalisation (negative GEN code).</p>"},{"location":"scoregens/gen43/#credits","title":"Credits","text":"<p>Author: Victor Lazzarini</p>"},{"location":"scoregens/gen44/","title":"Gen44","text":""},{"location":"scoregens/gen44/#gen44","title":"GEN44","text":"<p>Generates a stiffness (connection) matrix for use in scanu/scanu2.</p> <p>The matrix is generated from a text file of triple numbers. </p>"},{"location":"scoregens/gen44/#syntax","title":"Syntax","text":"<pre><code>f # time size -44  \"filename\"\nf # time size -44  num\n</code></pre>"},{"location":"scoregens/gen44/#performance","title":"Performance","text":"<p>The file named in version 1 or the file stiff.num in the second case is read to create the matrix.</p> <p>Matrix Format</p> <p>The first line of the file should be \u201c &lt;MATRIX size=integer&gt; \u201d and it creates a square matrix of the indicated size.  This is followed by lines of two or three numbers, the first two denoting a connection from the first to the second. The third number is a weight; a weight of 2 is like having two links so more information gets distributed, while a zero weight means no link. If this third number is omitted it is taken as value 1.  The list is terminated by a \u201c &lt;/MATRIX&gt; \u201d line or end of file.</p> <p>Example of this matrix format:</p> <pre><code>&lt;MATRIX size=16&gt;\n1 2  2\n2 3  1\n3 4  3\n4 5  1\n5 6  4\n6 7  1\n7 8  5\n8 9  6\n9 10  7\n10 11 6\n11 12 5\n12 13 4\n13 14 3\n14 15 2\n15 16 1\n16 1  9\n14 13 2\n10 3  6\n6 4  2\n2 14  7\n&lt;/MATRIX&gt;\n</code></pre> <p>can be given as zero in which case a size*size table is created. If the size in the gen statememt is too small for the matrix then space is re-allocated to the required size.</p> <p>Note: to avoid confusion with other matrix formats, it is best to save this matrix format file using the extension file.matrxT.</p>"},{"location":"scoregens/gen44/#examples","title":"Examples","text":"<p>Here is an example of the GEN44 generator. It uses the file gen44.csd.</p> Example of the GEN44 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen44.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 1\n0dbfs  = 1\n\ninstr scan\n\na0 init 0\n\nirate = .01\n\nkmass line 2,p3,5\nkstiff line 30,p3,45\nkcenter line .08,p3,.01\nkdamp line .01,p3,.08\nkpos line 0,p3,16\nkdisplace line 0,p3,.5\n\n;scanu2 init,irate,ifndisplace,ifnmass,ifnmatrix,ifncentr,ifndamp,kmass,kmtrxstiff,\n; kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2 -1, irate, 6, 2, 3, 4, 5, kmass, kstiff, kcenter, kdamp, .2, .7, kpos, kdisplace, a0, 1, 2\n\n;ar scans kamp, kfreq, ifntraj, id\na1 scans ampdbfs(p4), cpspch(p5), 7, 2\na1 dcblock2 a1\nout a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; Initial displacement condition\nf1 0 16 10 1         ; sine hammer\nf2 0 16 -7 1 16 1    ; Masses\nf3 0 0 -44 \"string_with_extras-16.matrxT\"   ; Spring matrices\nf4 0 16 -7 1 16 1    ; Centering force, uniform initial centering\nf5 0 16 -7 1 16 1    ; Damping, uniform damping\n; Initial displacement - (displacement, vel, and acceleration\n; Acceleration is from stiffness matrix pos effect - increases acceleration\nf6 0 16 -7 .01 16 .01 ; uniform initial velocity-displacement\nf7 0 16 -5 .001 16 16 ; Trajectories\n\ni\"scan\" 0 2 -6 7.00\ni\"scan\" 2 2 -6 5.00\ni\"scan\" 4 2 -6 6.00\ni\"scan\" 6 2 -6 8.00\ni\"scan\" 8 2 -6 10.00\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is another example of GEN44. It uses the file gen44-2.csd. The matrix file has 1024 masses.</p> Second example of the GEN44 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  --limiter=0.95 ;;;realtime audio out &amp; and limit loud sounds\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen44-2.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; by Menno Knevel 2024\n\ninstr 1                                                     ; move the grain table\n\ninitial ftgenonce 1, 0, 1024, 10, 1                         ; initial position = sine wave\nidispl  ftgenonce 2, 0, 1024, -7, .01, 1024, .01            ; displace\nimass   ftgenonce 3, 0, 1024, -7, 5, 1024, 5                ; masses\nicent   ftgenonce 4, 0, 1024, -7, .01, 1024, .1             ; centering\nidamp   ftgenonce 5, 0, 1024, -7, -.1, 1024, -.21           ; damping\nitraj   ftgenonce 6, 0, 1024, -7, 0, 1024, 1024             ; trajectory\niw      ftgenonce 7, 0, 1024, 20, 2                         ; Hanning window for GEN20\n\na0 = 0                                                      ; no audio injection\nkline line .07, p3, 0                                       ; simple envelope\n;scanu2 init, irate, ifndisplace, ifnmass, imatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2   1,   .003,     2,          3,       100,       4,       5,      10,      6,       0.1,    .9,     .5,    .1,     0,      0,     a0,    0,   -1\naL grain2 p4, p4, 2, 25, 1, 7\naR grain2 p4, p4, 2, 25, 1, 7\naL  dcblock aL \naR  dcblock aR \nouts aL * kline, aR * kline\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf100 0  0   -44  \"circularstring_1024.matrxT\"    ; text matrix, to be found in manual/examples\n\ni1  0  20  466.16376098248423   \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/gen44/#see-also","title":"See also","text":"<p>Scanned Synthesis</p> <p>More information on the Scanned Synthesis opcodes: Working with Scanned Synthesis, written by Steven Yi, and some tutorials by Richard Boulanger.</p>"},{"location":"scoregens/gen44/#credits","title":"Credits","text":"<p>Author: John ffitch;</p> <p>New in Version 6.16</p> <p>June 2021</p>"},{"location":"scoregens/gen49/","title":"Gen49","text":""},{"location":"scoregens/gen49/#gen49","title":"GEN49","text":"<p>Transfers data from an MP3 soundfile into a function table.</p>"},{"location":"scoregens/gen49/#syntax","title":"Syntax","text":"<pre><code>f#  time  size  49  filcod  skiptime  format\n</code></pre>"},{"location":"scoregens/gen49/#performance","title":"Performance","text":"<p>size -- number of points in the table. Ordinarily a power of 2 or a power-of-2 plus 1 (see f statement); the maximum tablesize is 16777216 (2<sup>24</sup>) points. The allocation of table memory can be deferred by setting this parameter to 0; the size allocated is then the number of points in the file (probably not a power-of-2), and the table is not usable by normal oscillators, but it is usable by a loscil unit. The soundfile can also be mono or stereo.</p> <p>filcod -- integer or character-string denoting the source soundfile name. An integer denotes the file soundin.filcod ; a character-string (in double quotes, spaces permitted) gives the filename itself, optionally a full pathname. If not a full path, the file is sought first in the current directory, then in that given by the environment variable SSDIR (if defined) then by SFDIR. See also soundin.</p> <p>skiptime -- begin reading at skiptime seconds into the file.</p> <p>format -- specifies the audio data-file format required:</p> <pre><code>1 - Mono file                 3 - First channel (left)\n2 - Stereo file               4 - Second channel (right)\n</code></pre> <p>If format = 0 the sample format is taken from the soundfile header.</p> <p> Note</p> <ul> <li>Reading stops at end-of-file or when the table is full. Table locations not filled will contain zeros.</li> <li>If p4 is positive, the table will be post-normalized (rescaled to a maximum absolute value of 1 after generation). A negative p4 will cause rescaling to be skipped.</li> </ul>"},{"location":"scoregens/gen49/#examples","title":"Examples","text":"<p>Here is an example of the GEN49 routine. It uses the files gen49.csd.</p> An example of the GEN49 routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac      ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen49.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\nkcps = sr/ftlen(1)\nasig oscil .8, kcps, 1\n   outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 131072 49 \"beats.mp3\" 0 1 ;read an audio file (using GEN49).\n\ni 1 0 2\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveforms of the GEN49 routine, as used in the example:</p> f 1 0 131072 49 \"beats.mp3\" 0 1"},{"location":"scoregens/gen49/#credits","title":"Credits","text":"<p>Written by John ffitch</p> <p>February 2009.</p>"},{"location":"scoregens/gen51/","title":"Gen51","text":""},{"location":"scoregens/gen51/#gen51","title":"GEN51","text":"<p>This subroutine fills a table with a fully customized micro-tuning scale, in the manner of Csound opcodes cpstun, cpstuni et cpstmid.</p>"},{"location":"scoregens/gen51/#syntax","title":"Syntax","text":"<pre><code>f # time size -51 numgrades interval basefreq basekey tuningRatio1 \\\n                  tuningRatio2  .... tuningRationN\n</code></pre>"},{"location":"scoregens/gen51/#performance","title":"Performance","text":"<p>The first four parameters (i.e. p5, p6, p7 and p8) define the following generation directives:</p> <p>p5 (numgrades) -- the number of grades of the micro-tuning scale</p> <p>p6 (interval) -- the frequency range covered before repeating the grade ratios, for example 2 for one octave, 1.5 for a fifth etcetera</p> <p>p7 (basefreq) -- the base frequency of the scale in cps</p> <p>p8 (basekey) -- the integer index of the scale to which to assign basefreq unmodified</p> <p>The other parameters define the ratios of the scale:</p> <p>p9...pN (tuningRatio1...etc.) -- the tuning ratios of the scale</p> <p>For example, for a standard 12-grade scale with the base-frequency of 261 cps assigned to the key-number 60, the corresponding f-statement in the score to generate the table should be:</p> <pre><code>;             numgrades        basefreq           tuning-ratios  (eq.temp) .......\n;                     interval         basekey\nf1 0 64 -51     12       2      261      60        1   1.059463 1.12246 1.18920 ;..etc...\n</code></pre> <p>After the gen has been processed, the table f1 is filled with 64 different frequency values. The 60th element is filled with the frequency value of 261, and all other elements (preceding and subsequents) of the table are filled according to the tuning ratios</p> <p>Another example with a 24-grade scale with a base frequency of 440 assigned to the key-number 48, and a repetition interval of 1.5:</p> <pre><code>;;            numgrades       basefreq            tuning-ratios .....\n;                     interval         basekey\nf1 0 64 -51     24      1.5     440      48        1   1.01  1.02  1.03  ;..etc...\n</code></pre>"},{"location":"scoregens/gen51/#examples","title":"Examples","text":"<p>Here is an example of the GEN51 routine. It uses the files gen51.csd.</p> An example of the GEN51 routine.<pre><code>&lt;CsoundSynthesizer&gt; \n&lt;CsOptions&gt; \n; Select audio/midi flags here according to platform \n-odac     ;;;realtime audio out and midi input\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too \n; For Non-realtime ouput leave only the line below: \n; -o gen51.wav -W ;;; for file output any platform \n&lt;/CsOptions&gt; \n&lt;CsInstruments&gt; \n;example by Iain McCurdy\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ngiEqTmp12       ftgen   1,0,128,-51,12,2,cpsoct(8),60,1,2^(1/12),2^(2/12),2^(3/12),2^(4/12),2^(5/12),2^(6/12),2^(7/12),2^(8/12),2^(9/12),2^(10/12),2^(11/12),2^(12/12)\ngiEqTmp10       ftgen   2,0,128,-51,10,2,cpsoct(8),60,1,2^(1/10),2^(2/10),2^(3/10),2^(4/10),2^(5/10),2^(6/10),2^(7/10),2^(8/10),2^(9/10),2^(10/10)\ngiEqTmp24       ftgen   3,0,128,-51,24,2,cpsoct(8),60,1,2^(1/24),2^(2/24),2^(3/24),2^(4/24),2^(5/24),2^(6/24),2^(7/24),2^(8/24),2^(9/24),2^(10/24),2^(11/24), \\\n                       2^(12/24),2^(13/24),2^(14/24),2^(15/24),2^(16/24),2^(17/24),2^(18/24),2^(19/24),2^(20/24),2^(21/24),2^(22/24),2^(23/24),2^(24/24)\n\ninstr   1       ;midi input instrument\n        /*USE PITCH BEND TO MODULATE NOTE NUMBER UP OR DOWN ONE STEP - ACTUAL INTERVAL IT WILL MODULATE BY WILL BE DEPENDENT UPON THE GEN51 SCALE USED*/\n        ;kbend  pchbend 0,2\n\n        /*ALTERNATIVELY IF USING VIRTUAL MIDI DEVICE OR A KEYBOARD WITH NO PITCH BEND WHEEL, USE CONTROLLERS 1 AND 2 TO MODULATE PITCH UP OR DOWN 1 STEP*/\nkup     ctrl7   1, 1, 0, 1\nkdown   ctrl7   1, 2, 0, -1\nkbend   =       kup+kdown\n\ninum    notnum\nkcps    tablei  inum+kbend, giEqTmp24   ;read cps values from GEN51, scale table using a combination of note played and pitch bend/controllers 1 and 2\na1      vco2    0.2, kcps, 4, 0.5\n        outs    a1, a1\nendin\n\ninstr   2       ;score input instrument\n\nknum    line    p4, p3, p5              ;gliss using a straight line bewteen p4 and p5 for the entire note duration\nkcps    tablei  knum, giEqTmp24         ;read cps values from GEN51 scale table\na1      vco2    0.2, kcps, 4, 0.5       \n        outs    a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 0 3600\n\n;instr 2. Score input. Gliss from step number p4 to step number p5\n;p4 - starting note number\n;p5 - ending note number\ni 2 0 2 60    61\ni 2 + 2 70    58\ni 2 + 2 66    66.5\ni 2 + 2 71.25 71\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GEN51 routines, as used in the example:</p> f 1 0 128 -51 12 2 cpsoct(8) 60 1 2^(1/12) 2^(2/12) 2^(3/12) 2^(4/12) 2^(5/12) 2^(6/12) 2^(7/12) 2^(8/12) 2^(9/12) 2^(10/12) 2^(11/12) 2^(12/12) f 2 0 128 -51 10 2 cpsoct(8) 60 1 2^(1/10) 2^(2/10) 2^(3/10) 2^(4/10) 2^(5/10) 2^(6/10) 2^(7/10) 2^(8/10) 2^(9/10) 2^(10/10) f 3 0 128 -51 24 2 cpsoct(8) 60 1 2^(1/24) 2^(2/24) 2^(3/24) 2^(4/24) 2^(5/24) 2^(6/24) 2^(7/24) 2^(8/24) 2^(9/24) 2^(10/24) 2^(11/24) 2^(12/24) 2^(13/24) 2^(14/24) 2^(15/24) 2^(16/24) 2^(17/24) 2^(18/24) 2^(19/24) 2^(20/24) 2^(21/24) 2^(22/24) 2^(23/24) 2^(24/24)"},{"location":"scoregens/gen51/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p>"},{"location":"scoregens/gen52/","title":"Gen52","text":""},{"location":"scoregens/gen52/#gen52","title":"GEN52","text":"<p>Creates an interleaved multichannel table from the specified source tables, in the format expected by the ftconv opcode.</p> <p>It can also be used to extract a channel from a multichannel table and store it in a normal mono table, copy tables with skipping some samples, adding delay, or store in reverse order, etc.</p> <p>Three parameters must be given for each channel to be processed. fsrc declares the source f-table number. The parameter offset specifies an offset for the source file. If different to 0, the source file is not read from the beginning, but the  offset number of values are skipped. The offset is used to determine the channel number to be read from interleaved f-tables, e.g. for channel 2, offset must be 1. It can also be used to set a read offset on the source table. This parameter gives absolute values, so if a skip of 20 sample frames for a 2 channel f-table is desired, offset must be set to 40. The srcchnls parameter is used to declare the number of channels in the source f-table. This parameter sets the skip size when reading the source f-table.</p> <p>When more than one channel (nchannels &gt; 1) is given, source f-tables are interleaved in the newly created table.</p> <p>If the source f-table is finished before the destination f-table is full, the remaining values are set to 0.</p>"},{"location":"scoregens/gen52/#syntax","title":"Syntax","text":"<pre><code>f # time size 52 nchannels fsrc1 offset1 srcchnls1 \\\n                [fsrc2 offset2 srcchnls2 ... fsrcN offsetN srcchnlsN]\n</code></pre> <p>Example</p> <pre><code>; source tables\nf 1 0 16384 10 1\nf 2 0 16384 10 0 1\n; create 2 channel interleaved table\nf 3 0 32768 -52 2 1 0 1 2 0 1\n; extract first channel from table 3\nf 4 0 16384 -52 1 3 0 2\n; extract second channel from table 3\nf 5 0 16384 -52 1 3 1 2\n</code></pre> <p>Here is a complete example of the GEN52 generator. It uses the file gen52.csd.</p> Example of the GEN52 generator.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gen52.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ngarvb   init 0\ngaW     init 0\ngaX     init 0\ngaY     init 0\n\nitmp    ftgen  1, 0, 64, -2, 2, 40, -1, -1, -1, 123,           \\\n               1, 13.000, 0.05, 0.85, 20000.0, 0.0, 0.50, 2,   \\\n               1,  2.000, 0.05, 0.85, 20000.0, 0.0, 0.25, 2,   \\\n               1, 16.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1,  9.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1, 12.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2,   \\\n               1,  8.000, 0.05, 0.85, 20000.0, 0.0, 0.35, 2\n\nitmp    ftgen 2, 0, 262144, -2, 0\n        spat3dt 2, -0.2, 1, 0, 1, 1, 2, 0.005\n\nitmp    ftgen 3, 0, 262144, -52, 3, 2, 0, 4, 2, 1, 4, 2, 2, 4\n\ninstr 1\n\na1      vco2 1, 440, 10\nkfrq    port 100, 0.008, 20000\na1      butterlp a1, kfrq\na2      linseg 0, 0.003, 1, 0.01, 0.7, 0.005, 0, 1, 0\na1      =  a1 * a2 * 2\n        denorm a1\n        vincr garvb, a1\naw, ax, ay, az  spat3di a1, p4, p5, p6, 1, 1, 2\n        vincr gaW, aw\n        vincr gaX, ax\n        vincr gaY, ay\n\nendin\n\ninstr 2\n\n       denorm garvb\n; skip as many samples as possible without truncating the IR\narW, arX, arY   ftconv garvb, 3, 2048, 2048, (65536 - 2048)\naW      =  gaW + arW\naX      =  gaX + arX\naY      =  gaY + arY\ngarvb   =  0\ngaW     =  0\ngaX     =  0\ngaY     =  0\n\naWre, aWim      hilbert aW\naXre, aXim      hilbert aX\naYre, aYim      hilbert aY\naWXr    =  0.0928*aXre + 0.4699*aWre\naWXiYr  =  0.2550*aXim - 0.1710*aWim + 0.3277*aYre\naL      =  aWXr + aWXiYr\naR      =  aWXr - aWXiYr\n\n       outs aL, aR\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ni 1 0 0.5  0.0  2.0 -0.8\ni 1 1 0.5  1.4  1.4 -0.6\ni 1 2 0.5  2.0  0.0 -0.4\ni 1 3 0.5  1.4 -1.4 -0.2\ni 1 4 0.5  0.0 -2.0  0.0\ni 1 5 0.5 -1.4 -1.4  0.2\ni 1 6 0.5 -2.0  0.0  0.4\ni 1 7 0.5 -1.4  1.4  0.6\ni 1 8 0.5  0.0  2.0  0.8\ni 2 0 10\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveform of the GEN52 routine, as used in the example:</p> f 3 0 262144 -52 3 2 0 4 2 1 4 2 2 4"},{"location":"scoregens/gen52/#credits","title":"Credits","text":"<p>Author: Istvan Varga</p>"},{"location":"scoregens/genexp/","title":"Genexp","text":""},{"location":"scoregens/genexp/#genexp","title":"GENexp","text":"<p>Generate a table with values on the exp function.</p>"},{"location":"scoregens/genexp/#syntax","title":"Syntax","text":"<pre><code>f # time size \"exp\" start end rescale\n</code></pre>"},{"location":"scoregens/genexp/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>start, end -- first and last value to be stored; the GEN draws a curve that goes from start to end: exp(start) .... exp(end). The points stored are uniformly spaced between these to the table size</p> <p>rescale -- if not zero the table is not rescaled</p>"},{"location":"scoregens/genexp/#examples","title":"Examples","text":"<p>Here is a simple example of the GENexp routine. It uses the file genexp.csd.</p> Example of the GENexp routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o genexp.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\naswp    linseg  0.01, p3*.5, .49, p3*.5, 0.01           ;index sweep function\naindex  poscil  aswp, 110, 1                            ;sound to waveshape\natable  tablei  aindex, p4, 1, .5                       ;waveshape index\naenv    linen   0.8, .01, p3, .02                       ;amplitude envelope\nasig    = (atable*aenv)*p5                              ;impose envelope and scale\nasig    dcblock2 asig                                   ;get rid of DC\n        outs    asig, asig\n\nendin           \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1 ;sine wave\nf 2 0 8192 \"exp\" 0 15 0\nf 3 0 8192 \"exp\" 0 3 0\n\ni1 0 3 2 2\ni1 + 3 3 3\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GENexp routines, as used in the example:</p>   f 2 0 8192 \"exp\" 0 15 0   f 3 0 8192 \"exp\" 0 3 0"},{"location":"scoregens/genexp/#see-also","title":"See Also","text":"<p>GENsone.</p> <p>More information on this routine: http://www.csoundjournal.com/issue11/distortionSynthesis.html, written by Victor Lazzarini</p>"},{"location":"scoregens/genexp/#credits","title":"Credits","text":"<p>Written by Victor Lazzarini</p>"},{"location":"scoregens/genfarey/","title":"Genfarey","text":""},{"location":"scoregens/genfarey/#genfarey","title":"GENfarey","text":"<p>Fills a table with the Farey Sequence F<sub>n</sub> of the integer n.</p> <p>Plugin gen in fareygen.</p> <p>A Farey Sequence F<sub>n</sub> of order n is a list of fractions in their lowest terms between 0 and 1 and in ascending order. Their denominators do not exceed n. This means a fraction a/b belongs to F<sub>n</sub> if 0 \u2264 a \u2264 b \u2264 n. The numerator and denominator of each fraction are always coprime. 0 and 1 are included in F<sub>n</sub> as the fractions 0/1 and 1/1. For example F<sub>5</sub> = {0/1, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1/1} Some properties of the Farey Sequence:</p> <ul> <li>If a/b and c/d are two successive terms of F<sub>n</sub>, then bc - ad = 1.</li> <li>If a/b, c/d, e/f are three successive terms of F<sub>n</sub>, then: c/d = (a+e) / (b+f). In this case c/d is called the mediant fraction between a/b and e/f.</li> <li>If n &gt; 1, then no two successive terms ofF<sub>n</sub> have the same denominator.</li> </ul> <p>The length of any Farey Sequence F<sub>n</sub> is determined by |F<sub>n</sub>| = 1 + SUM over n (phi(m)) where phi(m) is Euler's totient function, which gives the number of integers \u2264 m that are coprime to m.</p> <p>Some values for the length of F<sub>n</sub> given n:</p> n F 1 2 2 3 3 5 4 7 5 11 6 13 7 19 8 23 9 29 10 33 11 43 12 47 13 59 14 65 15 73 16 81 17 97 18 103 19 121 20 129"},{"location":"scoregens/genfarey/#syntax","title":"Syntax","text":"<pre><code>f # time size \"farey\" fareynum mode\n</code></pre>"},{"location":"scoregens/genfarey/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>fareynum -- the integer n for generating Farey Sequence F<sub>n</sub></p> <p>mode -- integer to trigger a specific output to be written into the table:</p> <ol> <li>outputs floating point numbers representing the elements of F<sub>n</sub>.</li> <li>outputs delta values of successive elements of F<sub>n</sub>, useful for generating note durations for example.</li> <li>outputs only the denominators of the integer ratios, useful for indexing other tables or instruments for example.</li> <li>same as mode 2 but with normalised output.</li> <li>same as mode 0 but with 1 added to each number, useful for generating tables for tuning opcodes, for example cps2pch.</li> </ol>"},{"location":"scoregens/genfarey/#examples","title":"Examples","text":"<pre><code>f1 0 -23 \"farey\" 8 0\n</code></pre> <p>Generates generates Farey Sequence F<sub>8</sub>. The table contains all 23 elements of F<sub>8</sub> as floating point numbers.</p> <pre><code>f1 0 -18 \"farey\" 7 1\n</code></pre> <p>This generates Farey Sequence F<sub>7</sub>. The table contains 18 delta values of F<sub>7</sub>, i.e. the difference between r<sub>i+1</sub> - r<sub>i</sub>, where r is the ith element of F<sub>n</sub>.</p> <pre><code>f1 0 -43 \"farey\" 11 2\n</code></pre> <p>This generates Farey Sequence F<sub>11</sub>. The table contains the denominators of all 43 fractions in F<sub>11</sub>.</p> <pre><code>f1 0 -43 \"farey\" 11 3\n</code></pre> <p>This generates Farey Sequence F<sub>11</sub>. The table contains the denominators of all 43 fractions in F<sub>11</sub>, each of those divided by 11, i.e. normalised.</p> <pre><code>f1 0 -18 \"farey\" 7 4\n</code></pre> <p>This generates Farey Sequence F<sub>7</sub>. The table contains all fractions of F<sub>7</sub>, same as mode 0, but this time '1' is added to each table element.</p> A simple example of the GENfarey routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr=44100\nksmps=10\nnchnls=1\n\ninstr 4\n      kndx init 0 ; read out elements of F_8 one by one and print to file\n      if (kndx &lt; 23) then    \n         kelem tab kndx, 1\n         fprintks \"farey8table.txt\", \"%2.6f\\\\n\", kelem\n         kndx = kndx+1\n      endif\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; initialise integer for Farey Sequence F_8\nf1 0 -23 \"farey\" 8 0\n      ; if mode=0 then the table stores all elements of the Farey Sequence\n      ; as fractions in the range [0,1]\ni4      0     1\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Here is a complete example of the GENfarey routine. It uses the files genfarey-2.csd.</p> Another example of the GENfarey routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc for RT audio input as well \n; For Non-realtime ouput leave only the line below:\n; -o genfarey.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\n; GENfarey creates table gidelta. \n; The table contains the delta values of Farey Sequence 7 (p5=7).\n; They are used as Inter Onset Intervals (IOIs) or event durations.\n; If p6 is set to 1 for IOI output then the length of the table (p3=-18) is -(|F_7| - 1)\n; Remember that a negative sign is for non-power-of-2 table lengths.\n; The negative sign in front of the GEN number prevents post-normalisation of its values.\n\ngidelta ftgen 0,0,-18,\"farey\",7,1\n\n; Use GENfarey with p6 set to 2 to generate the denominators of fractions of F_7 \n; this is used in this example as factors to create a series of pitches:\ngimult ftgen 0,0,-18,\"farey\",7,2\n\n;-------- loop and trigger instrument 901 using a Farey Sequence polyrhythm\n          instr 1\nkindx init 0\nkindx2 init 0\nktrigger init 0\nktime_unit init p6\nkstart init p4\nkloop init p5\nkinitndx init 0\nkfn_times init gidelta\nknote init 60\nkbasenote init p8\nifundam init p7\nktrigger seqtime ktime_unit, kstart, kloop, kinitndx, kfn_times\n  if (ktrigger &gt; 0 ) then\n     kpitch = cpspch(ifundam)\n     kmult tab kindx2, gimult\n     kpitch = kpitch * kmult\n     knote = kbasenote + kmult\n     event \"i\", 901,   0,   .4, .10, kpitch, kpitch * .9, 0.4,  5,   .75, .8,  1.0, .15, .0,  .125, .125, .25, .5,  1.0, .0, .0,  .0,  .0,  .125, .25, .25, .25, knote\n     kindx = kindx + 1\n     kindx = kindx % kloop\n     kindx2 = kindx2 + 1\n     kindx2 = kindx2 % kloop\n  endif\nendin\n\n;------ basic 2 Operators FM algorithm ----------------\n        instr 901\ninotedur        =               p3\nimaxamp         =               p4 ;ampdb(p4)\nicarrfreq       =               p5\nimodfreq        =               p6\nilowndx         =               p7\nindxdiff        =               p8-p7\nknote           =               p27\naampenv         linseg  p9, p14*p3, p10, p15*p3, p11, p16*p3, p12, p17*p3, p13 \nadevenv         linseg  p18, p23*p3, p19, p24*p3, p20, p25*p3, p21, p26*p3, p22\namodosc         oscili  (ilowndx+indxdiff*adevenv)*imodfreq, imodfreq, 10 \nacarosc         oscili  imaxamp*aampenv, icarrfreq+amodosc, 10 \n                outs            acarosc, acarosc  \nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf10 0 4096 10 1 ;sine wave                      \n; p4 kstart  := index offset into the Farey Sequence\n; p5 kloop   := end index into Farey Seq.\n; p6 timefac := time in seconds for one loop to complete\n; p7 fundam  := fundamental of the FM instrument\n; p8 basenote:= root pitch of the midi voice output\n; note that pitch structures of the midi file output are not equivalent to the\n; ones used for the FM real-time synthesis.\n\n;       start           dur             kstart  kloop   timefac fundam. basenote\ni1      0.0             44              0       18      2       6.05    60\ni1      4               30              0       18      3       7.05    72\ni1      34              12              9       18      3       7.05    72\ni1      10              12              0       18      1.5     8       84\ni1      22              12              0       9       1.5     8       84\ni1      15              16              0       18      1       5       48\ni1      22              20              5       17      1.7     4       36\n\ni1      46              20              3       11      2.5     7.04    71\ni1      51              20              5       13      2.5     7.06    72\n\ni1      73.5            1.5             11      18      1.5     5.05    48\ni1      75              1               12      18      1       6.03    58      \ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GENfarey routines, as used in the example:</p> gidelta ftgen 100,0,-18,\"farey\",7,1 - delta values of Farey Sequence 7 gimult ftgen 101,0,-18,\"farey\",7,2 - generate the denominators of fractions of F_7"},{"location":"scoregens/genfarey/#see-also","title":"See Also","text":"<p>Models and Emulations</p>"},{"location":"scoregens/genfarey/#credits","title":"Credits","text":"<p>Author: Georg Boenn University of Glamorgan 2010</p> <p>New in Csound version 5.13</p>"},{"location":"scoregens/genpadsynth/","title":"Genpadsynth","text":""},{"location":"scoregens/genpadsynth/#genpadsynth","title":"GENpadsynth","text":"<p>Generate a sample table using the padsynth algorithm.</p> <p>Plugin gen in padsynth.</p> <p>Paul Octavian Nasca's \"padsynth algorithm\" adds bandwidth to each partial of a periodic waveform. This bandwidth is heard as color, movement, and additional richness of sound.</p> <p>First, the waveform is defined by the user as a series of harmonic partials. Then, bandwidth is added by independently spreading each partial of the original waveform from a single frequency across neighboring frequencies, according to a \"profile\" function: a Gaussian curve, a square, or a rising and then falling expontential.</p> <p>The partials of the original waveform may be considered to be samples in a discrete Fourier transform of the waveform. Normally there is not an exact one-to-one correspondence between the frequencies of the samples (frequency bins) of the discrete Fourier transform with the frequencies of the partials of the original waveform, because any frequency in the inverse of the discrete Fourier transform might be synthesized by interference between any number of bins. However, the padsynth algorithm uses a simple trick to create this correspondence. The discrete Fourier transform is simply made so large that the frequency of any partial of the original waveform will be very close to the frequency of the corresponding bin in the Fourier transform. Once this correspondence has been created, the bandwidth profile can be applied by centering it over the frequency bin of the original partial, scaling the profile by the bandwidth, and simply multiplying the original partial by each sample of the profile and adding the product to the corresponding bin of the Fourier transform.</p> <p>As the frequencies of the partials increase, their bandwidth may optionally become wider or (less often) narrower.</p> <p>Once each partial has been spread out in this way, the discrete Fourier transform may be given random phases, and is then simply inverted to synthesize the desired waveform, which may be used as the wavetable for a digital oscillator.</p> <p>N.B.: The size of the function table does NOT necessarily reflect one periodic cycle of the waveform that it contains. The fundamental frequency must be used to generate the desired pitch from an oscillator using the function table, e.g.</p> <pre><code>oscillator_hz = desired_hz * (sr / padsynth_size / fundamental_hz)\n</code></pre>"},{"location":"scoregens/genpadsynth/#syntax","title":"Syntax","text":"<pre><code>f # score_time table_size \"padsynth\" fundamental_frequency \\\n    partial_bandwidth partial_scale harmonic_stretch profile_shape \\\n    profile_shape_parameter partial1_amplitude [partial2_amplitude ...]\n</code></pre>"},{"location":"scoregens/genpadsynth/#initialization","title":"Initialization","text":"<p>table_size -- Function table size. Should be large, e.g. 2^18 == 262144. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>fundamental_frequency -- Fundamental frequency for the generated table.</p> <p>partial_bandwidth -- Bandwidth of each partial in cents.</p> <p>partial_scale -- Scaling factor for bandwidth of each partial (log of increase/decrease with partial frequency, 0 is no stretch or shrink).</p> <p>harmonic_stretch -- Harmonic stretch/shrink for all partials (1 is harmonic).</p> <p>profile_shape -- Number specifying the shape of the bandwidth profile: 1 = Gaussian, 2 = square, and 3 = exponential</p> <p>profile_shape_parameter -- Parameter passed to the function generating the profile shape, e.g. exponent.</p> <p>partial1_amplitude, partial2_amplitude, ... -- Amplitudes for each partial (may be zero).</p>"},{"location":"scoregens/genpadsynth/#examples","title":"Examples","text":"<p>Here is an example of the GENpadsynth routine. It uses the files padsynth_gen.csd.</p> An example of the GENpadsynth routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-odac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nsr=44100\nksmps=1\nnchnls=2\n0dbfs=2000\n\n        gispec_len init 2^18\n\n        instr 1\n    prints \"Plain sine for frequency/amplitude/distortion comparison.\\n\"\n        gi_padsynth_1 ftgenonce 0, 0, gispec_len, 10, 1\n    iattack = 0.08\n    idecay = 0.1\n    isustain = 0.25\n    irelease = 0.2\n    aenv madsr iattack, idecay, isustain, irelease\n    ifreq cpsmidinn p4\n    iamp ampdb p5\n    ibasefreq = 440 ; can be lower or higher frequency; close to played frequency is said to be best\n    ibw_cents = 56.96943 ; width of the peaks, 100 is semitone\n        asig poscil iamp, ifreq, gi_padsynth_1\n    asig = aenv * asig\n        aleft, aright pan2 asig, 0.5\n        outs aleft, aright\n        endin\n\n        instr 2\n    prints \"PadSynth with sine tone.\\n\"\n    ibasehz = 261.625565\n    ;                       p1 p2 p3          p4           p5       p6  p7    p8 p9  p10  p11\n        gi_padsynth_1 ftgenonce 0, 0, gispec_len, \"padsynth\", ibasehz, p6, 0.0,  1, 1,  1.0, 1\n    iattack = 0.08\n    idecay = 0.1\n    isustain = 0.25\n    irelease = 0.2\n    aenv madsr iattack, idecay, isustain, irelease\n    ifreq cpsmidinn p4\n    iamp ampdb p5\n        asig poscil iamp, ifreq*(sr/gispec_len/ibasehz), gi_padsynth_1\n    asig = aenv * asig\n        aleft, aright pan2 asig, 0.5\n        outs aleft, aright\n        endin\n\n        instr 3\n    prints \"PadSynth with harmonics.\\n\"\n    ibasehz = 261.625565\n    ;                       p1 p2 p3          p4           p5       p6  p7 p8 p9  p10  p11\n        gi_padsynth_1 ftgenonce 0, 0, gispec_len, \"padsynth\", ibasehz, p6, 1, 1, 1,  1, 0.7600046992, 0.6199994683, 0.9399998784, 0.4400023818, 0.0600003302, 0.8499968648, 0.0899999291, 0.8199964762, 0.3199984133, 0.9400014281, 0.3000001907, 0.120003365, 0.1799997687, 0.5200006366, 0.9300042987\n    iattack = 0.08\n    idecay = 0.1\n    isustain = 0.25\n    irelease = 0.2\n    aenv madsr iattack, idecay, isustain, irelease\n    ifreq cpsmidinn p4\n    iamp ampdb p5\n        asig poscil iamp, ifreq*(sr/gispec_len/ibasehz), gi_padsynth_1\n    asig = aenv * asig\n        aleft, aright pan2 asig, 0.5\n        outs aleft, aright\n        endin\n\n        instr 4\n    prints \"PadSynth with inharmonic partials.\\n\"\n    ibasehz = 261.625565\n    ;                       p1 p2 p3          p4           p5       p6  p7 p8 p9  p10  p11\n        gi_padsynth_1 ftgenonce 0, 0, gispec_len, \"padsynth\", ibasehz, p6, 1, 2, 3,  1, 0.7600046992, 0.6199994683, 0.9399998784, 0.4400023818, 0.0600003302, 0.8499968648, 0.0899999291, 0.8199964762, 0.3199984133, 0.9400014281, 0.3000001907, 0.120003365, 0.1799997687, 0.5200006366, 0.9300042987\n    iattack = 0.08\n    idecay = 0.1\n    isustain = 0.25\n    irelease = 0.2\n    aenv madsr iattack, idecay, isustain, irelease\n    ifreq cpsmidinn p4\n    iamp ampdb p5\n        asig poscil iamp, ifreq*(sr/gispec_len/ibasehz), gi_padsynth_1\n    asig = aenv * asig\n        aleft, aright pan2 asig, 0.5\n        outs aleft, aright\n        endin\n\n\n&lt;/CsInstruments&gt;\n\n&lt;CsScore&gt;\n\n\n\ni1  0 2 60.00 60\ni1  + 2 72.00 60\ni1  + 2 84.00 60\n\ni2  7 2 60.00 60 0.3\ni2  + 2 72.00 60 0.3\ni2  + 2 84.00 60 0.3\ni2  + 2 60.00 60 25\ni2  + 2 72.00 60 25\ni2  + 2 84.00 60 25\ni2  + 2 60.00 60 55\ni2  + 2 72.00 60 55\ni2  + 2 84.00 60 55\n\ni3 26 2 60.00 60 0.3\ni3  + 2 72.00 60 0.3\ni3  + 2 84.00 60 0.3\ni3  + 2 60.00 60 25\ni3  + 2 72.00 60 25\ni3  + 2 84.00 60 25\ni3  + 2 60.00 60 55\ni3  + 2 72.00 60 55\ni3  + 2 84.00 60 55\n\ni4 45 2 60.00 60 0.3\ni4  + 2 72.00 60 0.3\ni4  + 2 84.00 60 0.3\ni4  + 2 60.00 60 25\ni4  + 2 72.00 60 25\ni4  + 2 84.00 60 25\ni4  + 2 60.00 60 55\ni4  + 2 72.00 60 55\ni4  + 2 84.00 60 55\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/genpadsynth/#see-also","title":"See Also","text":"<p>More information on Padsynth: http://www.paulnasca.com/algorithms-created-by-me</p>"},{"location":"scoregens/genpadsynth/#credits","title":"Credits","text":"<p>Written by Michael Gogins</p> <p>New in version 6.05</p>"},{"location":"scoregens/genquadbezier/","title":"Genquadbezier","text":""},{"location":"scoregens/genquadbezier/#genquadbezier","title":"GENquadbezier","text":"<p>Generate a table with values from a quadratic B\u00e9zier function.</p> <p>Plugin gen in quadbezier.</p> <p>This subroutine creates an ftable from segments constructed by paths traced by the quadratic B\u00e9zier function.</p>"},{"location":"scoregens/genquadbezier/#syntax","title":"Syntax","text":"<pre><code>f # time size \"quadbezier\" y1 cx1 cy1 x2 y2 [cx2 cy2 x3 y3 ...]\n</code></pre>"},{"location":"scoregens/genquadbezier/#initialization","title":"Initialization","text":"<p>x2, x3, etc. -- Locations in table at which to attain the following y value. Must be in increasing order. It is assumed that x1 equals 0. If the last value is less than size, then the rest will be set to zero. Should not be negative.</p> <p>y1, y2, y3, etc. -- Breakpoint values attained at the location specified by the preceding x value.</p> <p>cx1, cx2, cx3, etc. -- Virtual x coordinates for the different control points. cx[n] can be equal to but not less than x[n] and equal to but not greater than x[n+1]. Should not be negative but can be zero.</p> <p>cy1, cy2, cy3, etc. -- Virtual y coordinates for the different control points.</p>"},{"location":"scoregens/genquadbezier/#examples","title":"Examples","text":"<p>Here is a simple example of the GENquadbezier routine. It uses the file genquadbezier.csd.</p> Example of the GENquadbezierroutine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o quadbezier.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\nkndx phasor 1/p3\nkenv tablei kndx, p4, 1\nasig poscil kenv, 440, 1\n     outs asig, asig\n\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 32768 10 1\nf 2 0 1024 \"quadbezier\" 0 140 0.61 324 0.53 338 0.27 449 0.32 571 0.08 675 0.5 873 0.47 1024 0\nf 3 0 1024 \"quadbezier\" 0 92 0.04 94 0.25 177 0.58 373 0.39 537 0.15 675 0.5 910 0.68 1024 0\nf 4 0 1024 \"quadbezier\" 0 196 0.68 537 0.71 873 0.7 1024 0\n\ni 1 0 4 2\ni 1 4 4 3\ni 1 8 4 4\n&lt;/CsScore&gt;\n\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the envelopes drawn by the GENquadbezier routine, as used in the example above:</p>   f 2 0 1024 \"quadbezier\" 0 140 0.61 324 0.53 338 0.27 449 0.32 571 0.08 675 0.5 873 0.47 1024 0   f 3 0 1024 \"quadbezier\" 0 92 0.04 94 0.25 177 0.58 373 0.39 537 0.15 675 0.5 910 0.68 1024 0   f 4 0 1024 \"quadbezier\" 0 196 0.68 537 0.71 873 0.7 1024 0"},{"location":"scoregens/genquadbezier/#see-also","title":"See also","text":"<p>For references, check the comments in the source code.</p>"},{"location":"scoregens/genquadbezier/#credits","title":"Credits","text":"<p>Written by Guillermo Senna</p> <p>2016</p>"},{"location":"scoregens/gensone/","title":"Gensone","text":""},{"location":"scoregens/gensone/#gensone","title":"GENsone","text":"<p>GCreates an ftable with values of the sone function for equal power.</p>"},{"location":"scoregens/gensone/#syntax","title":"Syntax","text":"<pre><code>f # time size \"sone\" start end equalpoint rescale\n</code></pre>"},{"location":"scoregens/gensone/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>start, end -- first and last value to be stored.  The points stored are uniformly spaced between these to the table size.</p> <p>equalpoint -- the point on the curve when the input and output values are equal.</p> <p>rescale -- if not zero the table is not rescaled</p> <p>The table is filled with the function x*POWER(x/eqlp, FL(33.0)/FL(78.0)) for x between the start and end points.  This is the Sone loudness curve.</p>"},{"location":"scoregens/gensone/#examples","title":"Examples","text":"<p>Here is an example of the GENsone routine. It uses the files gensone.csd.</p> An example of the GENsone routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gensone.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1 ; simple oscillator with loudness correction. \n\nkcps = cpspch(p4) \nkenv linseg 0, p3*0.25, 1, p3*0.75, 0   ;amplitude envelope\nkamp tablei 16384 *kenv, 2 \nasig oscil kamp, kcps, 1\n     outs asig, asig\n\nendin \n\ninstr 2 ;neutral oscillator to compare with\n\nkcps = cpspch(p4)  \nkenv linseg 0, p3*0.25, 1, p3*0.75, 0   ;amplitude envelope\nasig oscil kenv, kcps, 1\n     outs asig, asig\n\nendin \n\n&lt;/CsInstruments&gt; \n&lt;CsScore&gt; \nf 1 0 16384 10 1        ;sine wave\nf 2 0 16385 \"sone\" 0 32000 32000 0 \n\ns\nf 0 1   ;1 second of silence before we start...\ns \ni 1 0 2 7.00 \ni 1 + . 7.01 \ni 1 + . 8.02 \ni 1 + . 8.03 \ns \ni 2 0 2 7.00 \ni 2 + . 7.01 \ni 2 + . 8.02 \ni 2 + . 8.03 \ne \n&lt;/CsScore&gt; \n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>This is the diagram of the waveforms of the GENsone routine, as used in the example:</p> f 2 0 16385 \"sone\" 0 32000 32000 0"},{"location":"scoregens/gensone/#see-also","title":"See Also","text":"<p>More information on Sone: http://en.wikipedia.org/wiki/Sone</p>"},{"location":"scoregens/gensone/#credits","title":"Credits","text":"<p>Written by John ffitch</p>"},{"location":"scoregens/gentanh/","title":"Gentanh","text":""},{"location":"scoregens/gentanh/#gentanh","title":"GENtanh","text":"<p>Generate a table with values on the tanh function.</p>"},{"location":"scoregens/gentanh/#syntax","title":"Syntax","text":"<pre><code>f # time size \"tanh\" start end rescale\n</code></pre>"},{"location":"scoregens/gentanh/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>start, end -- first and last value to be stored; the GEN draws a curve that goes from start to end: tanh(start) .... tanh(end). The points stored are uniformly spaced between these to the table size</p> <p>rescale -- if not zero the table is not rescaled</p>"},{"location":"scoregens/gentanh/#examples","title":"Examples","text":"<p>Here is a simple example of the GENtanh routine. It uses the file gentanh.csd.</p> Example of the GENtanh routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac  ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if realtime audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o gentanh.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100 \nksmps = 32 \nnchnls = 2 \n0dbfs  = 1 \n\ninstr 1\n\naswp    linseg  0.01, p3*.5, .49, p3*.5, 0.01           ;index sweep function\naindex  poscil  aswp, 110, 1                            ;sound to waveshape\natable  tablei  aindex, p4, 1, .5                       ;waveshape index\naenv    linen   0.8, .01, p3, .02                       ;amplitude envelope\nasig    = (atable*aenv)*p5                              ;impose envelope and scale\nasig    dcblock2 asig                                   ;get rid of DC\n        outs    asig, asig\n\nendin           \n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 8192 10 1 ;sine wave\nf 2 0 8192 \"tanh\" -100 100 0    ;symmetrical transfer fuction\nf 3 0 8192 \"tanh\" -10  10  0    ;symmetrical\nf 4 0 8192 \"tanh\"   0  10  0    ;not symmetrical\n\ni1 0 3 2 1\ni1 + 3 3 1\ni1 + 3 4 2\n\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>These are the diagrams of the waveforms of the GENtanh routines, as used in the example:</p>   f 2 0 8192 \"tanh\" -100 100 0 - lots of distortion   f 3 0 8192 \"tanh\" -10 10 0 - less distortion than f2   f 4 0 8192 \"tanh\" -10 15 0"},{"location":"scoregens/gentanh/#see-also","title":"See Also","text":"<p>GENexp and GENsone.</p> <p>More information on this routine: http://www.csoundjournal.com/issue11/distortionSynthesis.html, written by Victor Lazzarini</p>"},{"location":"scoregens/gentanh/#credits","title":"Credits","text":"<p>Written by John ffitch</p>"},{"location":"scoregens/genwave/","title":"Genwave","text":""},{"location":"scoregens/genwave/#genwave","title":"GENwave","text":"<p>Generates a compactly supported wavelet, scaling function or wavelet packet.</p> <p>The output function is obtained by deconvolution of corresponding mirror filter impulse response. This procedure is applied in an iterative fashion.</p> <p>The filter bank used in classic discrete wavelet transform grows only towards low frequencies. Meanwhile wavelet packet transform introduces any possible direction of tree's growth. The sequence of mirror filters used in deconvolution is determined by binary form of seq value. \"0\" corresponds to low-pass filter and \"1\" to high-pass.</p> <p>The number of iteration steps is determined by filter's length and size of function table. I.e. for filter length 8 and table size 256 there are log2(256/8) = 5 iterations available.</p>"},{"location":"scoregens/genwave/#syntax","title":"Syntax","text":"<pre><code>f # time size \"wave\" fnsf seq rescale\n</code></pre>"},{"location":"scoregens/genwave/#initialization","title":"Initialization","text":"<p>size -- number of points in the table. Must be a power of 2 or power-of-2 plus 1 (see f statement).</p> <p>fnsf -- pre-existing table with scaling function coefficients.</p> <p>seq -- non-negative integer number which corresponds to sequence of low-pass and high-pass mirror filters during deconvolution procedure.</p> <p>rescale -- if not zero the table is not rescaled</p>"},{"location":"scoregens/genwave/#examples","title":"Examples","text":"<p>Here is an example of the GENwave routine. It uses the file genwave.csd.</p> Example of the GENwave routine.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o 0dbfs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nkr = 4410\nnchnls = 1\n0dbfs = 1\n\nzakinit 3,1\n\ninstr 1 ; wavelet synth instrument\niamp  =  p4; scaling factor of wavelets\nifreq =  p5; frequency of wavelets\nitab  =  p6; selected wavelet function\ninum  =  p7; number of wavelets to be created\na1 osciln p4, p5, p6, p7 \nout a1\nendin\n\ninstr 2 ; wavelet analysis intrument \na1 soundin \"fox.wav\"\n; Decomposition Structure:\n;     1 LEVEL  2 LEVEL\n;     HP-&gt;ah1  \n; a1-&gt;|        HP(up2)-&gt;ah2\n;     LP-&gt;al1-&gt;|\n;              LP(up2)-&gt;al2\n;\nain = a1*.5; attenuate input signal\n           ; since wavelet coefficients\n           ; could reach big values  \nah1 dconv ain,ftlen(8),8\nal1 dconv ain,ftlen(7),7\nah2 dconv al1,ftlen(10),10\nal2 dconv al1,ftlen(9),9\n\nzaw ah1,0\nzaw al1,1\nzaw ah2,2\nzaw al2,3\n\naout zar p4\nout aout\nzacl 0,3\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; First of all, we need several FIR filters which are capable \n; to produce wavelet families.\n; One can input filter coefficients manualy using GEN02 \n; or read them from text file.\n; Most of compact-supported wavelet coefficients can be obtained from\n; Wavelet Browser by PyWavelets wavelets.pybytes.com\n; You can select family and order of filter\n; then copy desired coefficients into txt file.\n; Notice that for correct interpretation of results you should use\n; coeffs of Decomposition low-pass filter.\n\n; Daubechies 2 \nf 1 0 4 -2 -0.1294095226 0.2241438680 0.8365163037 0.4829629131\n; Symlet 10\nf 2 0 0 -23 \"sym10.txt\"\n\n; Now we want to produce some wavelet granules.\n; They can be used in wavelet synthesis etc.\n; Tables of large sizes should produce smoother wavelets.\n; We take array of filter coefficients from ftable 1\n; and deconvolve it until output length of 16384.\n; The order of filters through the deconvolution process\n; is given by 14 which is 1110 in binary.\n; So the first filter is LP ('0') and others are HP ('1').\nf 3 0 16384 \"wave\" 1 14 0\nf 4 0 16384 \"wave\" 2 1  0\nf 5 0 16384 \"wave\" 2 7  0\nf 6 0 16384 \"wave\" 2 6  0\n; The main purpose of using wavelets is wavelet transform.\n; It is not that easy to perform a classic DWT in Csound since downsampling\n; of audio signal is needed at each step of wavelet decomposition.\n; Anyway, using GENwave it is possible to create a number of upsampled\n; wavelets and perform a so-called undecimated wavelet transform \n; aka stationary wavelet transform (and it is even better).\n; So we need some upsampled childs of mother wavelet. \nf 7 0 16 \"wave\" 1 0 -1 ;db2 scaling function for 1st iteration\nf 8 0 16 \"wave\" 1 1 -1 ;db2 wavelet function for 1st iteration\nf 9 0 32 \"wave\" 1 0 -1 ;db2 scaling function for 2nd iteration\nf 10 0 32 \"wave\" 1 1 -1 ;db2 wavelet function for 2nd iteration\n\n; Let's hear how some wavelets could sound..\n;                amp frq wave    times\ni 1 0    1       0.6 15  3       8\ni 1 0.5  .       0.9 20  4       5\ni 1 0.9  .       0.7 8   5       .\ni 1 1.1  .       0.4 30  6       9\n\n; Now try to decompose input file using wavelets\ni 2 2 4  1; approximation 1st level\ni 2 5 .  2; details 2nd level\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;     \n</code></pre>"},{"location":"scoregens/genwave/#see-also","title":"See Also","text":"<p>Ingrid Daubechies. Ten Lectures on Wavelets, SIAM 1992.</p> <p>Pedro A.G. Batista. An Introduction to Sound Synthesis with Wavelet Packets, Csound Book CD Chapters, MIT 2000.</p> <p>Victor M. Wickerhauser. Acoustic Signal Compression with Wavelet Packets, Yale 1992.</p>"},{"location":"scoregens/genwave/#credits","title":"Credits","text":"<p>Written by Gleb Rogozinsky</p> <p>Saint-Petersburg University of Film and Television</p> <p>Saint-Petersburg, Russia</p> <p>April 2012</p>"},{"location":"scoregens/i/","title":"I","text":""},{"location":"scoregens/i/#i-statement-instrument-or-note-statement","title":"i Statement (Instrument or Note Statement)","text":"<p>Makes an instrument active at a specific time and for a certain duration.</p> <p>The parameter field values are passed to that instrument prior to its initialization, and remain valid throughout its Performance.</p>"},{"location":"scoregens/i/#syntax","title":"Syntax","text":"<pre><code>i  p1  p2  p3  p4  ...\n</code></pre>"},{"location":"scoregens/i/#initialization","title":"Initialization","text":"<p>p1 -- Instrument number, usually a non-negative integer. An optional fractional part can provide an additional tag for specifying ties between particular notes of consecutive clusters. A negative p1 (including tag) can be used to turn off a particular \u201cheld\u201d note.  In the case of a named instrument it can be negated by having a '-' as the first character of the string.</p> <p>p2 -- Starting time in arbitrary units called beats.</p> <p>p3 -- Duration time in beats (usually positive). A negative value will initiate a  held note (see also ihold). A negative value can also be used for 'always on' instruments like reverberation. These notes are not terminated by s statements A zero value will invoke an initialization pass without performance (see also instr).</p> <p>p4 ... -- Parameters whose significance is determined by the instrument.</p>"},{"location":"scoregens/i/#performance","title":"Performance","text":"<p>Beats are evaluated as seconds, unless there is a t statement in this score section or a -t flag in the command-line.</p> <p>Starting or action times are relative to the beginning of a section ( see s statement), which is assigned time 0.</p> <p>Note statements within a section may be placed in any order. Before being sent to an orchestra, unordered score statements must first be processed by Sorter, which will reorder them by ascending p2 value. Notes with the same p2 value will be ordered by ascending p1; if the same p1, then by ascending p3.</p> <p>Notes may be stacked, i.e., a single instrument can perform any number of notes simultaneously. (The necessary copies of the instrument's data space will be allocated dynamically by the orchestra loader.) Each note will normally turn off when its p3 duration has expired, or on receipt of a MIDI noteoff signal. An instrument can modify its own duration either by changing its p3 value during note initialization, or by prolonging itself through the action of a linenr or xtratim unit.</p> <p>An instrument may be turned on and left to perform indefinitely either by giving it a negative p3 or by including an ihold in its i-time code. If a held note is active, an i statement with matching p1 will not cause a new allocation but will take over the data space of the held note. The new pfields (including p3) will now be in effect, and an i-time pass will be executed in which the units can either be newly initialized or allowed to continue as required for a tied note (see tigoto). A held note may be succeeded either by another held note or by a note of finite duration. A held note will continue to perform across section endings (see s statement). It is halted only by turnoff or by an i statement with negative matching p1 or by an e statement.</p> <p>It is possible to have multiple instances (usually, but not necessarily, notes of different pitches) of the same instrument, held simultaneously, via negative p3 values. The instrument can then be fed new parameters from the score. This is useful for avoiding long hard-coded _linseg_s, and can be accomplished by adding a decimal part to the instrument number.</p> <p>For example, to hold three copies of instrument 10 in a simple chord:</p> <pre><code>i10.1    0    -1    7.00\ni10.2    0    -1    7.04\ni10.3    0    -1    7.07\n</code></pre> <p>Subsequent i statements can refer to the same sounding note instances, and if the instrument definition is done properly, the new p-fields can be used to alter the character of the notes in progress.  For example, to bend the previous chord up an octave and release it:</p> <pre><code>i10.1    1    1    8.00\ni10.2    1    1    8.04\ni10.3    1    1    8.07\n</code></pre> <p> Tip</p> <p>When turning off notes, bear in mind that i 1.1 == i 1.10 and i 1.1 != i 1.01. The maximum number of decimal places that can be used depends on the precision Csound was compiled with.</p> <p>The instrument definition has to take this into account, however, especially if clicks are to be avoided (see the example below).</p> <p>Note that the decimal instrument number notation cannot be used in conjunction with real-time MIDI. In this case, the instrument would be monophonic while a note was held.</p> <p>Notes being tied to previous instances of the same instrument, should skip most initialization by means of tigoto, except for the values entered in score. For example, all table reading opcodes in the instrument, should usually be skipped, as they store their phase internally. If this is suddenly changed, there will be audible clicks in the output.</p> <p>Note that many opcodes (such as delay and reverb) are prepared for optional initialization. To use this feature, the tival opcode is suitable. Therefore, they need not be hidden by a tigoto jump.</p> <p>Beginning with Csound version 3.53, strings are recognized in  p-fields for opcodes that accept them (convolve, adsyn, diskin, etc.).  There may be only one string per score line.</p> <p>You can also turnoff notes from the score by using a negative number for the instrument (p1). This is equivalent to using the turnoff2 opcode. When a note is turned off from the score, it is allowed to release (if xtratim or opcodes with release section like linenr are used) and only notes with the same fractional part are turned off. Also, only the last instance of the instrument will be turned off, so there have to be as many negative instrument numbers as positive ones for all notes to be turned off.</p> <pre><code>i 1.1    1    300    8.00\ni 1.2    1    300    8.04\ni 1.3    1    -300    8.07\ni 1.3    1    -300    8.09\n\n; notice that p-fields after p2 will be ignored if\n; instrument number is negative\ni -1.1    3    1    4.00\ni -1.2    4    51    4.04\ni -1.3    5    1    4.07\ni -1.3    6    10    4.09\n</code></pre>"},{"location":"scoregens/i/#special-considerations","title":"Special Considerations","text":"<p>The maximum instrument number used to be 200. This has been changed to be limited by memory only (currently there is an internal soft limit of 200; this is automatically extended as required).</p>"},{"location":"scoregens/i/#examples","title":"Examples","text":"<p>Here is an example of the i statement. It uses the file i_statement.csd.</p> Example of the i statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o i_statement.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 10\n\n  icps     init      cpspch(p4)                  ; Get target pitch from score event\n  iportime init      abs(p3)/7                   ; Portamento time dep on note length\n  iamp0    init      p5                          ; Set default amps\n  iamp1    init      p5\n  iamp2    init      p5\n\n  itie     tival                                 ; Check if this note is tied,\n  if itie  ==  1     igoto nofadein              ; if not fade in\n  iamp0    init      0\n\nnofadein:\n  if p3    &lt; 0       igoto nofadeout             ; Check if this note is held, if not fade out\n  iamp2    init      0    \n\nnofadeout:\n  ; Now do amp from the set values:\n  kamp     linseg    iamp0, .03, iamp1, abs(p3)-.03, iamp2\n\n  ; Skip rest of initialization on tied note:\n           tigoto    tieskip\n\n  kcps     init      icps                        ; Init pitch for untied note\n  kcps     port      icps, iportime, icps        ; Drift towards target pitch\n\n  kpw      oscil     .4, rnd(1), 1, rnd(.7)      ; A simple triangle-saw oscil\n  ar       vco       kamp, kcps, 3, kpw+.5, 1, 1/icps\n\n  ; (Used in testing - one may set ipch to cpspch(p4+2)\n  ;       and view output spectrum)\n  ;       ar oscil kamp, kcps, 1\n\n          outs        ar, ar\n\ntieskip:                                        ; Skip some initialization on tied note\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1   0 8192 10 1            ; Sine\n\ni10.1    0    -1    7.00    .15\ni10.2    0    -1    7.04\ni10.3    0    -1    7.07\ni10.1    1    -1    8.00  \ni10.2    1    -1    8.04\ni10.3    1    -1    8.07\ni10.1    2     1    7.11  \ni10.2    2     1    8.04  \ni10.3    2     1    8.07\n  e\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/i/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/i/#credits","title":"Credits","text":"<p>Additional text (Csound Version 4.07) explaining tied notes, edited by Rasmus Ekman from a note by David Kirsh, posted to the Csound mailing list. Example instrument by Rasmus Ekman.</p> <p>Updated August 2002 thanks to a note from Rasmus Ekman. There is no longer a hard limit of 200 instruments.</p>"},{"location":"scoregens/leftbrace/","title":"Leftbrace","text":""},{"location":"scoregens/leftbrace/#statement","title":"{ Statement","text":"<p>Begins a non-sectional, nestable loop.</p> <p>The { and } statements can be used to repeat a group of score statements.  These loops do not constitute independent score sections and thus may repeat events within the same section.  Multiple loops may overlap in time or be nested within each other.</p>"},{"location":"scoregens/leftbrace/#syntax","title":"Syntax","text":"<pre><code>{ p1 p2\n</code></pre>"},{"location":"scoregens/leftbrace/#initialization","title":"Initialization","text":"<p>p1 -- Number of times to repeat the loop.</p> <p>p2 -- A macro name that is automatically defined at the beginning of the loop and whose value is advanced with each repetition (optional).  The initial value is zero and the final value is (p1 - 1).</p>"},{"location":"scoregens/leftbrace/#performance","title":"Performance","text":"<p>The { statement is used in conjunction with the } statement to define repeating groups of other score events.  A score loop begins with the { statement which defines the number of repetitions and a unique macro name that will contain the current loop counter.  The body of a loop can contain any number of other events (including sectional breaks) and is terminated by a } statement on its own line. The } statement takes no parameters.</p> <p>The use of the term \"loop\" here does not imply any sort of temporal succession to the loop iterations.  In other words, the p2 values of the events inside of the loop are not automatically incremented by the length of the loop in each repetition.  This is actually an advantage since it allows groups of simulataneous events to be easily defined as well. The loop macro can be used along with  score expressions to increase the start times of events or to vary the events in any other way desired for each iteration.  The macro is incremented by one for each repetition.  Note that unlike the r statement, the value of the macro the first time through the loop is zero (0), not one (1).  Therefore the final value is one less than the number of repetitions.</p> <p>Score loops are a very powerful tool. While similar to the section repeat facility (the r statement), their chief advantage is that the score events in successive iterations of the loop are not separated by a section termination. Thus, it is possible to create multiple loops that overlap in time. Loops also can be nested within each other to a depth of 39 levels.</p> <p> Warning</p> <p>Because of serious problems of interaction with macro expansion, loops must start and end in the same file, and not in a macro.</p>"},{"location":"scoregens/leftbrace/#examples","title":"Examples","text":"<p>Here are some examples of the { and } statements.</p> Sequentially repeat a three-note phrase four times.<pre><code>{ 4 CNT\n\ni1  [0.00 + 0.75 * $CNT.]   0.2   220\ni1  [0.25 + 0.75 * $CNT.]   .     440\ni1  [0.50 + 0.75 * $CNT.]   .     880\n\n}\n</code></pre> <p>is interpreted as</p> <pre><code>i1  0.00   0.2   220\ni1  0.25   .     440\ni1  0.50   .     880\n\ni1  0.75   0.2   220\ni1  1.00   .     440\ni1  1.25   .     880\n\ni1  1.50   0.2   220\ni1  1.75   .     440\ni1  2.00   .     880\n\ni1  2.25   0.2   220\ni1  2.50   .     440\ni1  2.75   .     880\n</code></pre> <p>In this example, p4 is assumed to be the frequency of the note event.</p> Create a group of simultaneous harmonic partials.<pre><code>{ 8 PARTIAL\ni1  0  1   [100 * ($PARTIAL. + 1)]\n}\n</code></pre> <p>is interpreted as</p> <pre><code>i1  0  1   100\ni1  0  1   200\ni1  0  1   300\ni1  0  1   400\ni1  0  1   500\ni1  0  1   600\ni1  0  1   700\ni1  0  1   800\n</code></pre> <p>Here is a full example of the { and } statements. It uses the file leftbrace.csd.</p> An example of nested loops to create several inharmonic sine clusters.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o abs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\nnchnls = 2\n\ngaReverbSend init 0\n\n; a simple sine wave partial\ninstr 1\n    idur   =       p3\n    iamp   =       p4\n    ifreq  =       p5\n    aenv   linseg  0.0, 0.1*idur, iamp, 0.6*idur, iamp, 0.3*idur, 0.0\n    aosc   oscili  aenv, ifreq, 1\n           vincr   gaReverbSend, aosc\nendin\n\n; global reverb instrument\ninstr 2\n    al, ar reverbsc gaReverbSend, gaReverbSend, 0.85, 12000\n           outs     gaReverbSend+al, gaReverbSend+ar\n           clear    gaReverbSend\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf1 0 4096 10 1\n\n{ 4 CNT\n  { 8 PARTIAL\n      ;   start time     duration            amplitude          frequency\n\n      i1  [0.5 * $CNT.]  [1 + ($CNT * 0.2)]  [500 + (~ * 200)]  [800 + (200 * $CNT.) + ($PARTIAL. * 20)]\n  }\n}\n\ni2 0 6\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/leftbrace/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/leftbrace/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 3.52 (?).  (Fixed in version 5.08).</p>"},{"location":"scoregens/m/","title":"M","text":""},{"location":"scoregens/m/#m-statement-mark-statement","title":"m Statement (Mark Statement)","text":"<p>Sets a named mark in the score, which can be used by an n statement.</p>"},{"location":"scoregens/m/#syntax","title":"Syntax","text":"<pre><code>m p1\n</code></pre>"},{"location":"scoregens/m/#initialization","title":"Initialization","text":"<p>p1 -- Name of mark.</p>"},{"location":"scoregens/m/#performance","title":"Performance","text":"<p>This can be helpful in setting a up verse and chorus structure in the score. Names may contain letters and numerals.</p> <p>For example, the following score:</p> <pre><code>m foo\ni1 0 1\ni1 1 1.5\ni1 2.5 2\ns\ni1 0 10\ns\nn foo\ne\n</code></pre> <p>Will be passed from the preprocessor to Csound as:</p> <pre><code>i1 0 1\ni1 1 1.5\ni1 2.5 2\ns\ni1 0 10\ns\n;; this is named section repeated\ni1 0 1\ni1 1 1.5\ni1 2.5 2\ns\n;; end of named section\ne\n</code></pre>"},{"location":"scoregens/m/#examples","title":"Examples","text":"<p>Here is an example of the m statement. It uses the file m.csd.</p> Example of the m statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o m.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n\nm foo                   ;mark section\ni 1 0   1 110\ni 1 1.5 1 220\ni 1 3   1 440\ni 1 4.5 1 880\ns                       ;second section\ni 1 0 2 110\ni 1 2 2 220\ns\nn foo                   ;repeat marked section\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/m/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/m/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK April, 1998</p> <p>New in Csound version 3.48</p>"},{"location":"scoregens/n/","title":"N","text":""},{"location":"scoregens/n/#n-statement","title":"n Statement","text":"<p>Repeats a section from the referenced m statement.</p>"},{"location":"scoregens/n/#syntax","title":"Syntax","text":"<pre><code>n p1\n</code></pre>"},{"location":"scoregens/n/#initialization","title":"Initialization","text":"<p>p1 -- Name of mark to repeat.</p>"},{"location":"scoregens/n/#performance","title":"Performance","text":"<p>This can be helpful in setting a up verse and chorus structure in the score. Names may contain letters and numerals.</p> <p>For example, the following score:</p> <pre><code>m foo\ni1 0 1\ni1 1 1.5\ni1 2.5 2\ns\ni1 0 10\ns\nn foo\ne\n</code></pre> <p>Will be passed from the preprocessor to Csound as:</p> <pre><code>i1 0 1\ni1 1 1.5\ni1 2.5 2\ns\ni1 0 10\ns\n;; this is named section repeated\ni1 0 1\ni1 1 1.5\ni1 2.5 2\ns\n;; end of named section\ne\n</code></pre>"},{"location":"scoregens/n/#examples","title":"Examples","text":"<p>See the example for the m statement.</p>"},{"location":"scoregens/n/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/n/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK April 1998</p> <p>New in Csound version 3.48</p>"},{"location":"scoregens/q/","title":"Q","text":""},{"location":"scoregens/q/#q-statement","title":"q Statement","text":"<p>This statement may be used to quiet an instrument.</p>"},{"location":"scoregens/q/#syntax","title":"Syntax","text":"<pre><code>q p1  p2  p3\n</code></pre>"},{"location":"scoregens/q/#performance","title":"Performance","text":"<p>p1 -- Instrument number to mute/unmute.</p> <p>p2 -- Action time in beats.</p> <p>p3 -- determines whether the instrument is muted/unmuted. The value of 0 means the instrument is muted, other values mean it is unmuted.</p> <p>Note that this does not affect instruments that are already running at time p2. It blocks any attempt to start one afterwards.</p>"},{"location":"scoregens/q/#examples","title":"Examples","text":"<p>Here is an example of the q statement. It uses the file q.csd.</p> Example of the q statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o q.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1;sine wave\ns\nq 1 6 0         ;mute at 6 seconds in this section\ni 1 0 2 110\ni 1 3 2 220\ni 1 6 2 440\ni 1 9 2 880\n\ns\nq 1 6 1         ;unmute again at 6 seconds in this section\ni 1 0 2 110\ni 1 3 2 220\ni 1 6 2 440\ni 1 9 2 880\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/q/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/r/","title":"R","text":""},{"location":"scoregens/r/#r-statement-repeat-statement","title":"r Statement (Repeat Statement)","text":"<p>Starts a repeated section, which lasts until the next s, r or e statement.</p>"},{"location":"scoregens/r/#syntax","title":"Syntax","text":"<pre><code>r p1 p2\n</code></pre>"},{"location":"scoregens/r/#initialization","title":"Initialization","text":"<p>p1 -- Number of times to repeat the section.</p> <p>p2 -- Macro(name) to advance with each repetition (optional).</p>"},{"location":"scoregens/r/#performance","title":"Performance","text":"<p>In order that the sections may be more flexible than simple editing, the macro named p2 is given the value of 1 for the first time through the section, 2 for the second, and 3 for the third.  This can be used to change p-field parameters, or ignored.</p> <p> Warning</p> <p>Because of serious problems of interaction with macro expansion, sections must start and end in the same file, and not in a macro.</p>"},{"location":"scoregens/r/#examples","title":"Examples","text":"<p>Here is an example of the r statement. It uses the file r.csd.</p> Example of the r statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in\n-odac           -iadc    ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o r.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nkr = 4410\nksmps = 10\nnchnls = 1\n\n; Instrument #1.\ninstr 1\n  ; The score's p4 parameter has the number of repeats.\n  kreps = p4\n  ; The score's p5 parameter has our note's frequency.\n  kcps = p5\n\n  ; Print the number of repeats.\n  printks \"Repeated %i time(s).\\\\n\", 1, kreps\n\n  ; Generate a nice beep.\n  a1 oscil 20000, kcps, 1\n  out a1\nendin\n\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\n; Table #1, a sine wave.\nf 1 0 16384 10 1\n\n; We'll repeat this section 6 times. Each time it \n; is repeated, its macro REPS_MACRO is incremented. \nr6 REPS_MACRO\n\n; Play Instrument #1.\n; p4 = the r statement's macro, REPS_MACRO.\n; p5 = the frequency in cycles per second.\ni 1 00.10 00.10 $REPS_MACRO 1760\ni 1 00.30 00.10 $REPS_MACRO 880\ni 1 00.50 00.10 $REPS_MACRO 440\ni 1 00.70 00.10 $REPS_MACRO 220\n\n; Marks the end of the section.\ns\n\ne\n\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/r/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/r/#credits","title":"Credits","text":"<p>Author: John ffitch University of Bath/Codemist Ltd. Bath, UK April, 1998</p> <p>New in Csound version 3.48</p> <p>Example written by Kevin Conder</p>"},{"location":"scoregens/rightbrace/","title":"Rightbrace","text":""},{"location":"scoregens/rightbrace/#statement","title":"} Statement","text":"<p>Ends a non-sectional, nestable loop.</p> <p>The { and } statements can be used to repeat a group of score statements. These loops do not constitute independent score sections and thus may repeat events within the same section.  Multiple loops may overlap in time or be nested within each other.</p>"},{"location":"scoregens/rightbrace/#syntax","title":"Syntax","text":"<pre><code>}\n</code></pre>"},{"location":"scoregens/rightbrace/#initialization","title":"Initialization","text":"<p>All pfields are ignored.</p>"},{"location":"scoregens/rightbrace/#performance","title":"Performance","text":"<p>The } statement is used in conjunction with the { statement to define repeating groups of other score events.  A score loop begins with the { statement which defines the number of repetitions and a unique macro name that will contain the current loop counter.  The body of a loop can contain any number of other events (including sectional breaks) and is terminated by a } statement on its own line. The } statement takes no parameters.</p> <p>See the documentation for the { statement for further details.</p>"},{"location":"scoregens/rightbrace/#examples","title":"Examples","text":"<p>See the examples in the entry for the { statement.</p>"},{"location":"scoregens/rightbrace/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/rightbrace/#credits","title":"Credits","text":"<p>Author: Gabriel Maldonado</p> <p>New in Csound version 3.52 (?).  (Fixed in version 5.08).</p>"},{"location":"scoregens/s/","title":"S","text":""},{"location":"scoregens/s/#s-statement","title":"s Statement","text":"<p>Marks the end of a section.</p>"},{"location":"scoregens/s/#syntax","title":"Syntax","text":"<pre><code>s [time]\n</code></pre>"},{"location":"scoregens/s/#initialization","title":"Initialization","text":"<p>The first p-field time is optional and if present determines the end time (length in beats) of the section.  This time must be after the end of the last event in the section otherwise it will have no effect. This can be used to create a pause before the beginning of the next section or to allow \"always on\" instruments such as effects to play by themselves for some length of time.</p>"},{"location":"scoregens/s/#performance","title":"Performance","text":"<p>Sorting of the i statement, f statement and a statement by action time is done section by section.</p> <p>Time warping for the t statement is done section by section.</p> <p>All action times within a section are relative to its beginning. A section statement establishes a new relative time of 0, but has no other reinitializing effects (e.g. stored function tables are preserved across section boundaries).</p> <p>A section is considered complete when all action times and finite durations have been satisfied (i.e., the \"length\" of a section is determined by the last occurring action or turn-off). A section can be extended by the use of an f0 statement or by supplying the optional p1 value to the s statement.</p> <p>A section ending automatically invokes a purge of inactive instrument and data spaces.</p> <p> Note</p> <ul> <li>Since score statements are processed section by section, the amount of memory required depends on the maximum number of score statements in a section. Memory allocation is dynamic, and the user will be informed as extra memory blocks are requested during score processing.</li> <li>For the end of the final section of a score, the s statement is optional; the e statement may be used instead.</li> </ul>"},{"location":"scoregens/s/#examples","title":"Examples","text":"<p>Here is an example of the s statement. It uses the file s.csd.</p> Example of the s statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o s.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1;sine wave\n\ns               ;first section\ni 1 0 2 110\ni 1 3 2 220\ni 1 6 2 440\ni 1 9 2 880\n\ns               ;second section\ni 1 0 2 880\ni 1 3 2 440\ni 1 6 2 220\ni 1 9 2 110\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/s/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/t/","title":"T","text":""},{"location":"scoregens/t/#t-statement-tempo-statement","title":"t Statement (Tempo Statement)","text":"<p>Sets the tempo.</p> <p>This statement sets the tempo and specifies the accelerations and decelerations for the current section. This is done by converting beats into seconds.</p>"},{"location":"scoregens/t/#syntax","title":"Syntax","text":"<pre><code>t  p1  p2  p3  p4 ... (unlimited)\n</code></pre>"},{"location":"scoregens/t/#initialization","title":"Initialization","text":"<p>p1 -- Must be zero.</p> <p>p2 -- Initial tempo on beats per minute.</p> <p>p3, p5, p7,... -- Times in beats (in non-decreasing order).</p> <p>p4, p6, p8,... -- Tempi for the referenced beat times.</p>"},{"location":"scoregens/t/#performance","title":"Performance","text":"<p>Time and Tempo-for-that-time are given as ordered couples that define points on a \"tempo vs. time\" graph. (The time-axis here is in beats so is not necessarily linear.) The beat-rate of a Section can be thought of as a movement from point to point on that graph: motion between two points of equal height signifies constant tempo, while motion between two points of unequal height will cause an accelarando or ritardando accordingly. The graph can contain discontinuities: two points given equal times but different tempi will cause an immediate tempo change.</p> <p>Motion between different tempos over non-zero time is inverse linear. That is, an accelerando between two tempos M1 and M2 proceeds by linear interpolation of the single-beat durations from 60/M1 to 60/M2.</p> <p>The first tempo given must be for beat 0.</p> <p>A tempo, once assigned, will remain in effect from that time-point unless influenced by a succeeding tempo, i.e. the last specified tempo will be held to the end of the section.</p> <p>A t statement applies only to the score section in which it appears. Only one t statement is meaningful in a section; it can be placed anywhere within that section. If a score section contains no t statement, then beats are interpreted as seconds (i.e. with an implicit t 0 60 statement).</p> <p>N.B. If the CSound command includes a -t flag, the interpreted tempo of all score t statements will be overridden by the command-line tempo.</p>"},{"location":"scoregens/t/#examples","title":"Examples","text":"<p>Here is an example of the t statement. It uses the file t.csd.</p> Example of the t statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o t.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n\nt 0 240 12 30 15 240    ;start tempo = 240 \n\ni 1 0 2 110             ;tempo = 240\ni 1 3 2 220             ;slow down &amp;\ni 1 6 2 440             ;slow down &amp;\ni 1 9 2 880             ;slow down &amp;            \ni 1 12 2 110            ;slow down to 30 at 12 seconds\ni 1 15 2 220            ;speed up to 240 again\ni 1 18 2 440            ;stay at tempo 240\ni 1 21 2 880\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/t/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/v/","title":"V","text":""},{"location":"scoregens/v/#v-statement","title":"v Statement","text":"<p>Provides for locally variable time warping of score events.</p>"},{"location":"scoregens/v/#syntax","title":"Syntax","text":"<pre><code>v p1\n</code></pre>"},{"location":"scoregens/v/#initialization","title":"Initialization","text":"<p>p1 -- Time warp factor (must be positive).</p>"},{"location":"scoregens/v/#performance","title":"Performance","text":"<p>The v statement takes effect with the following i statement, and remains in effect until the next v statement, s statement, or e statement.</p>"},{"location":"scoregens/v/#examples","title":"Examples","text":"<p>The value of p1 is used as a multiplier for the start times (p2) of subsequent i statements.</p> <pre><code>; note1\nv2\n; note2\n</code></pre> <p>In this example, the second note occurs two beats after the first note, and is twice as long.</p> <p>Although the v statement is similar to the t statement, the v statement is local in operation. That is, v affects only the following notes, and its effect may be cancelled or changed by another v statement.</p> <p>Carried values are unaffected by the v statement (see Carry).</p> <pre><code>i1   0 1\nv2\ni.   + .\ni.   . .\n</code></pre> <p>In this example, the v statement has no effect.</p>"},{"location":"scoregens/v/#examples_1","title":"Examples","text":"<p>Here is an example of the v statement. It uses the file v.csd.</p> Example of the v statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o v.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .4*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n;because note 3 and 5 are played simultaneously and are nearly of the same frequency,\n;played together they will create a \"beating\" sound.\n\ni 1 0 2  110    ; note1\nv2\ni 1 3 .  220    ; note2\ni 1 6 .  110    ; note3\nv1\ni 1 9 .  880    ; note4\ni 1 12 . 100    ; note5\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>In this example, note3 and note5 occur simultaneously, while note4 actually occurs before note3, that is, at its original place. Durations are unaffected.</p>"},{"location":"scoregens/v/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/x/","title":"X","text":""},{"location":"scoregens/x/#x-statement","title":"x Statement","text":"<p>Skip the rest of the current section.</p>"},{"location":"scoregens/x/#syntax","title":"Syntax","text":"<pre><code>x anything\n</code></pre>"},{"location":"scoregens/x/#initialization","title":"Initialization","text":"<p>All pfields are ignored.</p>"},{"location":"scoregens/x/#examples","title":"Examples","text":"<p>Here is an example of the x statement. It uses the file x.csd.</p> Example of the x statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n-odac     ;;;realtime audio out\n;-iadc    ;;;uncomment -iadc if RT audio input is needed too\n; For Non-realtime ouput leave only the line below:\n; -o x.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\naenv expseg .01, p3*0.25, 1, p3*0.75, 0.01\nasig poscil3 .8*aenv, p4, 1\n     outs asig, asig\n\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\nf 1 0 16384 10 1        ;sine wave\n\ns                       ;first section\ni 1 0 2 110\ni 1 3 2 220\ni 1 6 2 440\ni 1 9 2 880\ns                       ;second section\nx                       ;skip the rest\ni 1 0 2 110             ;of this section\ni 1 3 2 220\ni 1 6 2 440\ni 1 9 2 880\ns                       ;but continue with this one\ni 1 0 2 880\ni 1 3 2 440\ni 1 6 2 220\ni 1 9 2 110\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre>"},{"location":"scoregens/x/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/y/","title":"Y","text":""},{"location":"scoregens/y/#y-statement-or-seed-statement","title":"y Statement (or Seed Statement)","text":"<p>Set seed for random numbers, either from p1 or, if omitted, the clock.</p>"},{"location":"scoregens/y/#syntax","title":"Syntax","text":"<pre><code>y [p1]\n</code></pre>"},{"location":"scoregens/y/#initialization","title":"Initialization","text":"<p>p1 -- An integer value between 0 and 2<sup>32</sup> used as a new seed for random numbers. If omitted, the system clock value will be used instead.</p>"},{"location":"scoregens/y/#performance","title":"Performance","text":"<p>The tilde symbol \u02dc can be used in an expression wherever a number is permissible to use. Each \u02dc will evaluate to a random value between zero (0) and one (1). If there is no y statement in the score, the pseudo-random generator will yield the same numbers in each performance. If a fixed seed is given, a different predictable series of pseudo-random numbers will be generated from this seed. If a y statement is used without p1, the system clock will be used as a seed, yielding a different series of pseudo-random numbers for each performance.</p>"},{"location":"scoregens/y/#examples","title":"Examples","text":"<p>Here is an example of the y statement. It uses the file y_statement.csd.</p> Example of the y statement.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n; Select audio/midi flags here according to platform\n; Audio out   Audio in    No messages\n-odac           -iadc     -d     ;;;RT audio I/O\n; For Non-realtime ouput leave only the line below:\n; -o 0dbfs.wav -W ;;; for file output any platform\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\n; Initialize the global variables.\nsr = 44100\nksmps = 10\nnchnls = 2\n0dbfs = 1\n\ninstr 1\n  print p4\nendin\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n\ny\n\ni 1 0 1 [~ * 9 + 1]\ni 1 + 1 [~ * 9 + 1]\ni 1 + 1 [~ * 9 + 1]\ni 1 + 1 [~ * 9 + 1]\ne\n\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Each time this example is run, different values between 1 and 10 will be displayed. The seed used will be displayed as well.</p>"},{"location":"scoregens/y/#see-also","title":"See Also","text":"<p>Score Statements</p>"},{"location":"scoregens/y/#credits","title":"Credits","text":"<p>Author: John ffitch, 2014</p> <p>New in version 6.03</p>"},{"location":"siggen/additive/","title":"Additive Synthesis/Resynthesis","text":"<p>The opcodes for additive synthesis and resynthesis are:</p> <ul> <li>adsyn</li> <li>adsynt</li> <li>adsynt2</li> <li>hsboscil</li> </ul> <p>See the section Spectral processing for more information and further additive/resynthesis opcodes.</p>"},{"location":"siggen/basic/","title":"Basic Oscillators","text":""},{"location":"siggen/basic/#basic-oscillators_1","title":"Basic Oscillators","text":"<p>The basic oscillator opcodes are: (note that opcodes that end with 'i' implement linear interpolation and those that end with '3' implement cubic interpolation).</p> <ul> <li>Oscillator Banks: oscbnk</li> <li>Simple table oscillators: oscil, oscil3 and oscili.</li> <li>Simple, fast sine oscilator: oscils</li> <li>Precision oscilators: poscil and poscil3.</li> <li>More flexible oscillators: oscilikt, osciliktp, oscilikts and osciln (also called oscilx).</li> </ul> <p>Oscillators can also be constructed from generic table read opcodes. See the Table Read/Write operations section.</p>"},{"location":"siggen/basic/#lfos","title":"LFOs","text":"<ul> <li>lfo</li> <li>vibr</li> <li>vibrato</li> </ul> <p>See the section Table access for other table reading opcodes that can be used as oscillators. Also see the section Dynamic spectrum Oscillators.</p>"},{"location":"siggen/dynamic/","title":"Dynamic Spectrum Oscillators","text":"<p>The opcodes that generate dynamic spectra are:</p> <ul> <li>Harmonic spectra: buzz and gbuzz</li> <li>Impulse generator: mpulse</li> <li>Bandlimited shape-shifting square-pulse-saw-sinewave oscillator: squinewave</li> <li>Band limited oscillators (analog modelled): vco and vco2</li> </ul> <p>The following opcodes can be used to generate band-limited waveforms for use with vco2 and other oscillators:</p> <ul> <li>vco2init</li> <li>vco2ft</li> <li>vco2ift</li> </ul>"},{"location":"siggen/envelope/","title":"Envelope Generators","text":"<p>The following envelope generators are available:</p> <ul> <li>adsr</li> <li>gtadsr</li> <li>madsr</li> <li>mxadsr</li> <li>xadsr</li> <li>linen</li> <li>linenr</li> <li>envlpx</li> <li>envlpxr</li> <li>lineto</li> <li>tlineto</li> <li>linlin</li> <li>lincos</li> </ul> <p>Consult the Linear and exponential generators section for additional methods to create envelopes.</p>"},{"location":"siggen/fmsynth/","title":"FM Synthesis","text":""},{"location":"siggen/fmsynth/#the-fm-synthesis-opcodes-are","title":"The FM synthesis opcodes are:","text":"<ul> <li>foscil</li> <li>foscili</li> <li>crossfm, crossfmi, crosspm, crosspmi, crossfmpm, and crossfmpmi.</li> </ul>"},{"location":"siggen/fmsynth/#fm-instrument-models","title":"FM instrument models","text":"<ul> <li>fmb3</li> <li>fmbell</li> <li>fmmetal</li> <li>fmpercfl</li> <li>fmrhode</li> <li>fmvoice</li> <li>fmwurlie</li> </ul>"},{"location":"siggen/granular/","title":"Granular Synthesis","text":"<p>The granular synthesis opcodes are:</p> <ul> <li>diskgrain</li> <li>fof</li> <li>fof2</li> <li>fog</li> <li>grain</li> <li>grain2</li> <li>grain3</li> <li>granule</li> <li>partikkel</li> <li>partikkelsync</li> <li>sndwarp</li> <li>sndwarpst</li> <li>syncgrain</li> <li>syncloop</li> <li>vosim</li> </ul>"},{"location":"siggen/hvs/","title":"Hyper Vectorial Synthesis","text":"<ul> <li>vphaseseg</li> <li>hvs1</li> <li>hvs2</li> <li>hvs3</li> </ul> <p>The opcode FLhvsBox can be used to display the phase position for 2-dimensional Hyper Vectorial Synthesis.</p>"},{"location":"siggen/lineexp/","title":"Linear and Exponential Generators","text":"<p>The opcodes that generate linear or exponential curves or segments are:</p> <ul> <li>bpf</li> <li>bpfcos</li> <li>cosseg</li> <li>cossegb</li> <li>cossegr</li> <li>expon</li> <li>expcurve</li> <li>expseg</li> <li>expsega</li> <li>expsegb</li> <li>expsegba</li> <li>expsegr</li> <li>gainslider</li> <li>jspline</li> <li>line</li> <li>linlin</li> <li>lincos</li> <li>linseg</li> <li>linsegb</li> <li>linsegr</li> <li>logcurve</li> <li>loopseg</li> <li>loopsegp</li> <li>looptseg</li> <li>loopxseg</li> <li>lpshold</li> <li>lpsholdp</li> <li>rspline</li> <li>scale</li> <li>scale2</li> <li>transeg</li> <li>transegb</li> <li>transegr</li> <li>trigexpseg</li> <li>triglinseg</li> <li>xyscale</li> </ul>"},{"location":"siggen/models/","title":"Models and Emulations","text":"<p>The following opcodes model or emulate the sounds of other instruments (some based on the STK toolkit by Perry Cook):</p> <ul> <li>bamboo</li> <li>barmodel</li> <li>cabasa</li> <li>crunch</li> <li>dripwater</li> <li>gogobel</li> <li>guiro</li> <li>mandol</li> <li>marimba</li> <li>moog</li> <li>sandpaper</li> <li>sekere</li> <li>shaker</li> <li>sleighbells</li> <li>stix</li> <li>tambourine</li> <li>vibes</li> <li>voice</li> </ul> <p>Also, see the STK Opcodes section for information on the STK opcodes.</p> <p>Other models and emulations</p> <ul> <li>cell</li> <li>chuap</li> <li>fareylen, fareyleni, GENfarey</li> <li>gendy, gendyc, gendyx</li> <li>lorenz</li> <li>planet</li> <li>prepiano</li> <li>mandel</li> <li>vcella</li> </ul> <p>A section on physical modeling using the waveguide principles can be found here: Waveguide Physical Modeling.</p>"},{"location":"siggen/phasors/","title":"Phasors","text":"<p>The opcodes that generate a moving phase value:</p> <ul> <li>ephasor</li> <li>phasor</li> <li>phasorbnk</li> <li>syncphasor</li> <li>trigphasor</li> </ul> <p>These opcodes are useful in combination with the Table access opcodes.</p>"},{"location":"siggen/random/","title":"Random (Noise) Generators","text":"<p>Opcodes that generate random numbers are:</p> <ul> <li>betarand</li> <li>bexprnd</li> <li>cauchy</li> <li>cauchyi</li> <li>cuserrnd</li> <li>duserrnd</li> <li>dust</li> <li>dust2</li> <li>exprand</li> <li>exprandi</li> <li>fractalnoise</li> <li>gauss</li> <li>gausstrig</li> <li>jitter</li> <li>jitter2</li> <li>lfsr</li> <li>linrand</li> <li>noise</li> <li>pcauchy</li> <li>pinkish</li> <li>pinker</li> <li>poisson</li> <li>rand</li> <li>randc</li> <li>randh</li> <li>randi</li> <li>rnd31</li> <li>random</li> <li>randomh</li> <li>randomi</li> <li>trandom</li> <li>trirand</li> <li>unirand</li> <li>urd</li> <li>urandom</li> <li>weibull</li> </ul> <p>See seed which sets the global seed value for all x-class noise generators, as well as other opcodes that use a random call, such as grain. And getseed returns the global seed value used for all x-class noise generators.</p> <p>rand, randh, randi, rnd(x) and birnd(x) are not affected by seed. Use rndseed for that.      </p> <p>See also functions which generate random numbers in the section Random Functions.</p>"},{"location":"siggen/sample/","title":"Sample Playback","text":"<p>Opcodes that implement sample playback and looping are:</p> <ul> <li>bbcutm</li> <li>bbcuts</li> <li>flooper</li> <li>flooper2</li> <li>loscil</li> <li>loscil3</li> <li>loscilx</li> <li>lphasor</li> <li>lposcil</li> <li>lposcil3</li> <li>lposcila</li> <li>lposcilsa</li> <li>lposcilsa2</li> <li>sndloop</li> <li>waveset</li> </ul> <p>See also the Signal Input section for other ways to input sound.</p>"},{"location":"siggen/sample/#soundfonts","title":"Soundfonts","text":"<p>Beginning with Csound Version 4.07, Csound supports the SoundFont2 sample file format. SoundFont2 (or SF2) is a widespread standard which allows encoding banks of wavetable-based sounds into a binary file. In order to understand the usage of these opcodes, the user must have some knowledge of the SF2 format, so a brief description of this format follows.</p> <p>The SF2 format is made by generator and modulator objects. All current Csound opcodes regarding SF2 support the generator function only.</p> <p>There are several levels of generators having a hierarchical structure. The most basic kind of generator object is a sample. Samples may or may not be be looped, and are associated with a MIDI note number, called the base-key. When a sample is associated with a range of MIDI note numbers, a range of velocities, a transposition (coarse and fine tuning), a scale tuning, and a level scaling factor, the sample and its associations make up a \u201csplit.\u201d A set of splits, together with a name, make up an \u201cinstrument.\u201d When an instrument is associated with a key range, a velocity range, a level scaling factor, and a transposition, the instrument and its associations make up a \u201clayer.\u201d A set of layers, together with a name, makes up a \u201cpreset.\u201d Presets are normally the final sound-generating structures ready for the user. They generate sound according to the settings of their lower-level components.</p> <p>Both sample data and structure data is embedded in the same SF2 binary file. A single SF2 file can contain up to a maximum of 128 banks of 128 preset programs, for a total of 16384 presets in one SF2 file. The maximum number of layers, instruments, splits, and samples is not defined, and probably is only limited by the computer's memory.</p> <p>Soundfonts can be viewed and edited by programs like Polyphone (GPL3, https://www.polyphone-soundfonts.com/) or Swami (GPL2, http://www.swamiproject.org)</p>"},{"location":"siggen/sample/#fluid-opcodes","title":"Fluid Opcodes","text":"<p>The fluid family of opcodes wraps Peter Hannape's SoundFont 2 player, FluidSynth: fluidEngine for instantiating a FluidSynth engine, fluidSetInterpMethod for setting interpolation method for a channel in a FluidSynth engine, fluidLoad for loading SoundFonts, fluidProgramSelect for assigning presets from a SoundFont to a FluidSynth engine's MIDI channel, fluidNote for playing a note on a FluidSynth engine's MIDI channel, fluidCCi for sending a controller message at i-time to a FluidSynth engine's MIDI channel, fluidCCk for sending a controller message at k-rate to a FluidSynth engine's MIDI channel. fluidControl for playing and controlling loaded Soundfonts (using 'raw' MIDI messages), fluidOut for receiving audio from a single FluidSynth engine, and fluidAllOut for receiving audio from all FluidSynth engines.</p> <ul> <li>fluidAllOut</li> <li>fluidCCi</li> <li>fluidCCk</li> <li>fluidControl</li> <li>fluidEngine</li> <li>fluidLoad</li> <li>fluidNote</li> <li>fluidOut</li> <li>fluidProgramSelect</li> <li>fluidSetInterpMethod</li> </ul>"},{"location":"siggen/sample/#original-soundfont-opcodes","title":"\"Original\" Soundfont opcodes","text":"<p>These opcodes can also use soundfonts to generate sound. sfplay etc. were created for one purpose -- to access the instruments and samples in SoundFonts. The fluid opcodes were created for another purpose -- to use SoundFonts more or less the way they were designed to be used, i.e. using keyboard mappings, layers, internal processing, etc.</p> <ul> <li>sfilist</li> <li>sfinstr</li> <li>sfinstr3</li> <li>sfinstr3m</li> <li>sfinstrm</li> <li>sfload</li> <li>sfpassign</li> <li>sfplay</li> <li>sfplay3</li> <li>sfplay3m</li> <li>sfplaym</li> <li>sflooper</li> <li>sfplist</li> <li>sfpreset</li> </ul>"},{"location":"siggen/scantop/","title":"Scanned Synthesis","text":"<p>Scanned synthesis is a variant of physical modeling, where a network of masses connected by springs is used to generate a dynamic waveform. Developed by Bill Verplank, Rob Shaw, and Max Mathews between 1998 and 1999 at Interval Research, Inc. it is based on the psychoacoustics of how we hear and appreciate timbres and on our motor control (haptic) abilities to manipulate timbres during live performance.</p> <p>Scanned Synthesis involves a slow dynamic system whose frequencies of vibration are below about 15 Hz. The ear cannot hear the low frequencies of the dynamic system. So, to make audible frequencies, the \"shape\" of the dynamic system, along a closed path, is scanned periodically. The \"shape\" is converted to a sound wave whose pitch is determined by the speed of the scanning function. Pitch control is completely separate from the dynamic system control. Thus timbre and pitch are independent.</p> <p>This system can be looked upon as a dynamic wave table. The model can be compared to a slowly vibrating string, or a two dimensional surface obeying the wave equation.</p> <p>Verplank, Shaw and Mathews studied scanned synthesis chiefly with a finite element model of a generalized string \u2014 a collection of masses connected by springs and dampers that can be analyzed with Newton's laws. From there, they generalized a traditional string by adding dampers and springs to each mass.</p> <p>All parameters \u2014 mass (in the drawing above: M), damping (D), earth-spring strength (C), and string tension (T) can vary along the \"string.\" The model is manipulated by pushing or hitting different masses (the individual samples in a very short wavetable) and by manipulating parameters. What is unique here is that the wavetable itself is a dynamic model.</p> <p> Note</p> <p>The term 'hammer' is chosen for the model name, but 'hammer' might not be the best metaphor. A hammer implies that you are striking it - but you are actually initializing a deformation of the surface and then setting it in motion.</p> <p>You are manipulating the mechanical model at haptic rates 0-10 Hz, and independent to this, you are scanning out the wavetable at the pitch frequency. Although, the table has its own dynamics, there are no discontinuities because the model is implemented as a circular string, so you end up with a looping oscillator (for example of 128 points) with a constantly evolving loop. It is hard to believe, but true, that what results is a short sample that is animated and harmonically rich because of the complex interactive nature of the elements in the underlying system \u2014 the mechanics of the model.</p> <p>In fact, even enveloping can come directly from the model. It turns out that the specific setting of the centering springs can affect the damping of the system \u2014 low values allowing the rich timbre to ring, high values causing the tone to die away quickly.</p> <p>The opcodes scanu / scanu2 define the mass/spring network and sets it in motion. The opcode scans follows a predefined path (trajectory) around the network and outputs the detected waveform. Several scans instances may follow different paths around the same network. These are highly efficient mechanical modelling algorithms for both synthesis and sonic animation via algorithmic processing. They should run in real-time. Thus, the output is useful either directly as audio, or as controller values for other parameters.</p> <p>The Csound implementation adds support for a scanning path or matrix.  Essentially, this offers the possibility of reconnecting the masses in different orders, causing the signal to propagate quite differently. They do not necessarily need to be connected to their direct neighbors. Essentially, the matrix has the effect of \u201cmolding\u201d this surface into a radically different shape.</p> <p>Two different matrix formats are available: a binary matrix and a text matrix. It is good practise to give the binary matrix name the extension .matrxB and the text matrix .matrxT. To produce the matrices, the table formats are straightforward.</p> <p>As an example for the binary matrix, for 4 masses we have the following grid describing the possible connections:</p> 1 2 3 4 1 2 3 4 <p>Whenever two masses are connected, the point they define is 1. If two masses are not connected, then the point they define is 0. For example, a unidirectional string has the following connections: (1,2), (2,3), (3,4). If it is bidirectional, it also has (2,1), (3,2), (4,3).  For the unidirectional string, the matrix appears:</p> 1 2 3 4 1 0 1 0 0 2 0 0 1 0 3 0 0 0 1 4 0 0 0 0 <p>The above table format of the connection matrix is for conceptual convenience only. The actual values shown in te table are obtained by scans from an ASCII file using GEN23. The actual ASCII file is created from the table model row by row. Therefore the ASCII file for the example table shown above becomes:</p> <pre><code>0100001000010000\n</code></pre> <p>As an example of a text matrix (see GEN44), for the same 4 masses we have the following grid describing these connections:</p> <pre><code>&lt;MATRIX size=4&gt;\n1   2   4\n2   3   2\n3   4   6\n&lt;/MATRIX&gt;\n</code></pre> <p>Here, the first two values in the row denote a connection from the first to the second. The third number is a weight; a weight of 2 is like having two links so more information gets distributed, while a zero weight means no link. If this third number is omitted it is taken as value 1.</p> <p>Both these matrix examples are very small and simple. In practice, most scanned synthesis instruments will use many more masses than four, so their matrices will be much larger and more complex. See the example in the scans documentation.</p> <p>Here is an example that compares the binary and the text matrix. They sound the same. It uses the file matrices_compare.csd.</p> Example comparing the use of the binary and the text matrix.<pre><code>&lt;CsoundSynthesizer&gt;\n&lt;CsOptions&gt;\n-o dac\n&lt;/CsOptions&gt;\n&lt;CsInstruments&gt;\n\nsr = 44100\nksmps = 32\nnchnls = 2\n0dbfs  = 1\n\ninstr 1\n\ninitial ftgen 1, 0, 128, 10, 1                         ; initial position = sine wave\nidispl  ftgen 2, 0, 128, -7, .01, 128, .01             ; displace\nimass   ftgen 3, 0, 128, -7, 5, 128, 5                 ; masses\nicent   ftgen 4, 0, 128, -7, 1, 128, 1                 ; centering\nidamp   ftgen 5, 0, 128, -7, -.1, 128, -.1             ; damping\nitraj   ftgen 6, 0, 128, -7, 0, 128, 127               ; trajectory\n\na0 init 0\nirate = .01\n\n;scanu2 init, irate, ifndisplace, ifnmass, imatrix, ifncentr, ifndamp, kmass, kmtrxstiff, kcentr, kdamp, ileft, iright, kpos, kdisplace, ain, idisp, id\nscanu2   1,   irate,     2,          3,       p4,       4,       5,      20,      9,       0.1,    .9,     .5,    .1,     0,      0,     a0,    0,   2\n;ar scans kamp, kfreq, ifntraj, id\na1 scans    1,   200,    6,     2\n\nif p4 == 50 then\n    prints  \"\\n  using binary matrix system\\n\", p4\nelse\n    prints  \"\\n  and now the text matrix system\\n\", p4\nendif\n\nouts a1, a1\nendin\n\n&lt;/CsInstruments&gt;\n&lt;CsScore&gt;\n; both matrices are to be found in the examples folder of the manual\nf50 0 16384 -23  \"string-128.matrxB\"    ; binary matrix\nf100 0 128  -44  \"string-128.matrxT\"    ; text matrix\n\ni1 0 10     50\ni1 12 10    100\ne\n&lt;/CsScore&gt;\n&lt;/CsoundSynthesizer&gt;\n</code></pre> <p>Please note that generated dynamic wavetables can be very unstable. Certain values for masses, centering, and damping can cause the system to \u201cblow up\u201d and the most interesting sounds to emerge from your loudspeakers!</p> <p>A tutorial, examples, and other information on scanned synthesis is available from the Scanned Synthesis page at cSounds.com.</p> <p>Opcodes that implement scanned synthesis are:</p> <ul> <li>scanhammer</li> <li>scans</li> <li>scantable</li> <li>scanu</li> <li>scanu2</li> <li>scanmap</li> <li>scansmap</li> <li>GEN44</li> </ul>"},{"location":"siggen/tableacc/","title":"Table Access","text":"<p>The opcodes that access tables are:</p> <ul> <li>oscil1</li> <li>oscil1i</li> <li>osciln</li> <li>oscilx</li> <li>table</li> <li>table3</li> <li>tablei</li> </ul> <p>Opcodes ending in 'i' implement linear interpolation and opcodes ending in '3' implement cubic interpolation.</p> <p>The following opcodes implement fast table reading/writing without boundary checks:</p> <ul> <li>tab</li> <li>tab_i</li> <li>tabw</li> <li>tabw_i</li> </ul> <p>See the sections Table Queries, Read/Write Operations and Table Reading with Dynamic Selection for other table operations.</p>"},{"location":"siggen/waveterr/","title":"Wave Terrain Synthesis","text":"<p>Opcodes that uses wave terrain synthesis:  sterrain, wterrain and wterrain2.</p>"},{"location":"siggen/wavguide/","title":"Waveguide Physical Modeling","text":"<p>The opcodes that implement waveguide physical modeling are:</p> <ul> <li>pluck</li> <li>repluck</li> <li>wgbow</li> <li>wgbowedbar</li> <li>wgbrass</li> <li>wgclar</li> <li>wgflute</li> <li>wgpluck</li> <li>wgpluck2</li> <li>wguide1</li> <li>wguide2</li> </ul>"},{"location":"sigio/fileio/","title":"File Input and Output","text":"<p>The opcodes for file input and output are:</p> <ul> <li>File open/close: fiopen and ficlose.</li> <li>File output: dumpk, dumpk2, dumpk3, dumpk4, fout, fouti, foutir, foutk and hdf5write</li> <li>File input: readf, readfi, readk, readk2, readk3, readk4, fin, fini and fink</li> <li>Utilities for use with the fout opcodes: clear, vincr</li> <li>Printing to a file: fprints and fprintks</li> </ul>"},{"location":"sigio/input/","title":"Signal Input","text":"<p>The opcodes that receive audio signals are:</p> <ul> <li>Synchronous input: in, in32, inch, inh, ino, inq, inrg, ins and inx</li> <li>File streaming: diskin, diskin2, and hdf5read </li> <li>User defined channel input: invalue</li> <li>Streaming input: soundin</li> <li>Websocket input: websocket</li> <li>Direct to zak input: inz</li> </ul> <p>See the section Software Bus for input and output through the API.</p> <p>The mp3in allows reading of mp3 files, which are currently not supported by ordinary reading methods inside Csound.</p>"},{"location":"sigio/output/","title":"Signal Output","text":"<p>The opcodes that write audio signals are:</p> <ul> <li>Synchronous output: out, out32, outall, outc, outch, outh, outo, outrg,  outq, outq1, outq2, outq3, outq4, outs, outs1, outs2, outx and hdf5write</li> <li>Streaming output: soundout and soundouts</li> <li>User defined channel output: outvalue</li> <li>Direct from zak output: outz</li> <li>Websocket output: websocket</li> </ul> <p>The opcode monitor can be used for monitoring the complete output of csound (the output spout frame).</p> <p>See the section Software Bus for input and output through the API.</p>"},{"location":"sigio/pdisplay/","title":"Printing and Display","text":"<p>Opcodes for printing and displaying values are:</p> <ul> <li>dispfft</li> <li>display</li> <li>flashtxt</li> <li>ftprint</li> <li>print</li> <li>printf</li> <li>printf_i</li> <li>printk</li> <li>printk2</li> <li>printks</li> <li>printks2</li> <li>println</li> <li>prints</li> <li>printarray</li> </ul>"},{"location":"sigio/queries/","title":"Sound File Queries","text":"<p>The opcodes that query information about files are:</p> <ul> <li>filebit</li> <li>filelen</li> <li>filenchnls</li> <li>filepeak</li> <li>filesr</li> <li>filevalid</li> <li>mp3len</li> </ul>"},{"location":"sigio/softbus/","title":"Software Bus","text":"<p>Csound implements a software bus for internal routing or routing to external software calling the Csound API.</p> <p>The opcodes to use the software bus are:</p> <ul> <li>chani</li> <li>chano</li> <li>chn_k</li> <li>chn_a</li> <li>chn_S</li> <li>chnclear</li> <li>chnexport</li> <li>chnget</li> <li>chnmix</li> <li>chnparams</li> <li>chnset</li> </ul>"},{"location":"sigmod/ampmod/","title":"Amplitude Modifiers and Dynamic processing","text":"<p>The opcodes that modify amplitude are:</p> <ul> <li>balance</li> <li>balance2</li> <li>compress</li> <li>compress2</li> <li>clip</li> <li>dam</li> <li>gain</li> </ul> <p>The opcode 0dbfs facilitates the use of amplitude by removing the need to use of explicit sample values.</p>"},{"location":"sigmod/compaccum/","title":"Comparators and Accumulators","text":"<p>The following opcodes perform comparisons between signals at a-rate or k-rate, find maxima or minima, or accumulate the results of several computations or comparisons:</p> <ul> <li>clear</li> <li>cmp</li> <li>max</li> <li>max_k</li> <li>maxabs</li> <li>maxabsaccum</li> <li>maxaccum</li> <li>min</li> <li>minabs</li> <li>minabsaccum</li> <li>minaccum</li> <li>vincr</li> </ul>"},{"location":"sigmod/conmorph/","title":"Convolution and Morphing","text":"<p>The opcodes that convolve and morph signals are:</p> <ul> <li>convolve also called convle</li> <li>cross2</li> <li>dconv</li> <li>ftconv</li> <li>ftmorf</li> <li>liveconv</li> <li>pconvolve</li> <li>tvconv</li> </ul>"},{"location":"sigmod/delayops/","title":"Delay","text":""},{"location":"sigmod/delayops/#fixed-delays","title":"Fixed delays","text":"<ul> <li>delay</li> <li>delay1</li> <li>delayk</li> </ul>"},{"location":"sigmod/delayops/#delay-lines","title":"Delay Lines","text":"<ul> <li>delayr</li> <li>delayw</li> <li>deltap</li> <li>deltap3</li> <li>deltapi</li> <li>deltapn</li> <li>deltapx</li> <li>deltapxw</li> </ul>"},{"location":"sigmod/delayops/#variable-delays","title":"Variable delays","text":"<ul> <li>vdelay</li> <li>vdelay3</li> <li>vdelayx</li> <li>vdelayxs</li> <li>vdelayxq</li> <li>vdelayxw</li> <li>vdelayxwq</li> <li>vdelayxws</li> </ul>"},{"location":"sigmod/delayops/#multitap-delays","title":"Multitap delays","text":"<ul> <li>multitap</li> </ul>"},{"location":"sigmod/panspatl/","title":"Panning and Spatialization","text":""},{"location":"sigmod/panspatl/#amplitude-spatialization","title":"Amplitude spatialization","text":"<ul> <li>locsend</li> <li>locsig</li> <li>ms2st</li> <li>st2ms</li> <li>pan</li> <li>pan2</li> <li>space</li> <li>spdist</li> <li>spsend</li> </ul>"},{"location":"sigmod/panspatl/#3d-spatialization-with-simulation-of-room-acoustics","title":"3D spatialization with simulation of room acoustics","text":"<ul> <li>spat3d</li> <li>spat3di</li> <li>spat3dt</li> </ul>"},{"location":"sigmod/panspatl/#vector-base-amplitude-panning","title":"Vector Base Amplitude Panning","text":"<ul> <li>vbap</li> <li>vbapmove</li> <li>vbap4</li> <li>vbap4move</li> <li>vbap8</li> <li>vbap8move</li> <li>vbap16</li> <li>vbap16move</li> <li>vbapg</li> <li>vbapgmove</li> <li>vbaplsinit</li> <li>vbapz</li> <li>vbapzmove</li> </ul>"},{"location":"sigmod/panspatl/#binaural-spatialization","title":"Binaural spatialization","text":"<ul> <li>hrtfer</li> <li>hrtfmove</li> <li>hrtfmove2</li> <li>hrtfearly</li> <li>hrtfreverb</li> <li>hrtfstat</li> </ul>"},{"location":"sigmod/panspatl/#ambisonics","title":"Ambisonics","text":"<ul> <li>bformdec1</li> <li>bformdec2</li> <li>bformenc1</li> </ul>"},{"location":"sigmod/reverbtn/","title":"Reverberation","text":"<p>The opcodes one can use for reverberation are:</p> <ul> <li>alpass</li> <li>babo</li> <li>comb</li> <li>combinv</li> <li>freeverb</li> <li>nestedap</li> <li>nreverb (also called reverb2)</li> <li>platerev</li> <li>reverb</li> <li>reverbsc</li> <li>valpass</li> <li>vcomb</li> </ul>"},{"location":"sigmod/sample/","title":"Sample Level Operators","text":"<p>The opcodes one may use to modify signals are:</p> <ul> <li>a(k)</li> <li>denorm</li> <li>diff</li> <li>downsamp</li> <li>fold</li> <li>i(k)</li> <li>integ</li> <li>interp</li> <li>k(i)</li> <li>ntrpol</li> <li>S</li> <li>samphold</li> <li>upsamp</li> <li>vaget</li> <li>vaset</li> </ul>"},{"location":"sigmod/siglimit/","title":"Signal Limiters","text":"<p>Opcodes that can be used to limit signals are:</p> <ul> <li>limit</li> <li>mirror</li> <li>wrap</li> </ul>"},{"location":"sigmod/speciale/","title":"Special Effects","text":"<p>Opcodes that generate special effects are:</p> <ul> <li>distort</li> <li>distort1</li> <li>doppler</li> <li>exciter</li> <li>flanger</li> <li>harmon</li> <li>harmon2, 3, 4</li> <li>paulstretch</li> <li>phaser1</li> <li>phaser2</li> </ul>"},{"location":"sigmod/speciali/","title":"Specialized Filters","text":""},{"location":"sigmod/speciali/#high-pass-filters","title":"High pass filters","text":"<ul> <li>dcblock</li> <li>dcblock2</li> </ul>"},{"location":"sigmod/speciali/#parametric-eq","title":"Parametric EQ","text":"<ul> <li>eqfil</li> <li>pareq</li> <li>rbjeq</li> </ul>"},{"location":"sigmod/speciali/#other-filters","title":"Other filters","text":"<ul> <li>fmanal</li> <li>filter2</li> <li>fofilter</li> <li>gtf</li> <li>hilbert</li> <li>hilbert2</li> <li>mode</li> <li>mvmfilter</li> <li>nlfilt</li> <li>zfilter2</li> </ul>"},{"location":"sigmod/standard/","title":"Standard Filters","text":""},{"location":"sigmod/standard/#resonant-low-pass-filters","title":"Resonant Low-pass filters","text":"<ul> <li>areson</li> <li>bob</li> <li>bqrez</li> <li>lowpass2</li> <li>lowres</li> <li>lowresx</li> <li>lpf18</li> <li>moogvcf</li> <li>moogvcf2</li> <li>moogladder</li> <li>moogladder2</li> <li>mvclpf1</li> <li>mvclpf2</li> <li>mvclpf3</li> <li>mvclpf4</li> <li>reson</li> <li>resonr</li> <li>resonx</li> <li>resony</li> <li>resonz</li> <li>rezzy</li> <li>spf</li> <li>skf</li> <li>svn</li> <li>statevar</li> <li>svfilter</li> <li>tbvcf</li> <li>vclpf</li> <li>vlowres</li> </ul>"},{"location":"sigmod/standard/#standard-filters_1","title":"Standard filters","text":"<ul> <li>Hi-pass filters: atone, atonex, mvchpf</li> <li>Low-pass filters: tone, tonex</li> <li>Biquad filters: biquad and biquada.</li> <li>Butterworth filters: butterbp, butterbr, butterhp, butterlp (which are also called butbp, butbr, buthp, butlp)</li> <li>General filters: clfilt</li> <li>Variant FIR lowpass filter: median, mediank</li> </ul>"},{"location":"sigmod/standard/#zero-delay-feedback-filters-virtual-analog","title":"Zero-delay Feedback Filters (Virtual Analog)","text":"<ul> <li>diode_ladder</li> <li>K35_hpf</li> <li>K35_lpf</li> <li>zdf_1pole</li> <li>zdf_1pole_mode</li> <li>zdf_2pole</li> <li>zdf_2pole_mode</li> <li>zdf_ladder</li> </ul>"},{"location":"sigmod/standard/#control-signal-filters","title":"Control signal filters","text":"<ul> <li>aresonk</li> <li>atonek</li> <li>lag</li> <li>lagud</li> <li>lineto</li> <li>port</li> <li>portk</li> <li>resonk</li> <li>resonxk</li> <li>tlineto</li> <li>tonek</li> </ul>"},{"location":"sigmod/wavguide/","title":"Waveguides","text":"<p>The opcodes that use waveguides to modify a signal are:</p> <ul> <li>streson</li> <li>wguide1</li> <li>wguide2</li> </ul>"},{"location":"sigmod/wavshape/","title":"Waveshaping and Phase Distortion","text":"<p>These opcodes can perform dynamic waveshaping or phaseshaping (a.k.a. phase distortion).  They differ from traditional table-based methods of waveshaping by directly calculating the transfer function with one or more variable parameters for affecting the amount or results of the shaping.  Most of these opcodes could be used on either an audio signal (for waveshaping) or a phasor (for phaseshaping) but tend to work best for one of these applications.  </p> <p>These opcodes are good for waveshaping:</p> <ul> <li>chebyshevpoly</li> <li>clip</li> <li>distort</li> <li>distort1</li> <li>polynomial</li> <li>powershape</li> </ul> <p>These opcodes are good for phaseshaping:</p> <ul> <li>pdclip</li> <li>pdhalf</li> <li>pdhalfy</li> <li>vps</li> </ul>"},{"location":"spectral/stft/","title":"Short-time Fourier Transform (STFT) Resynthesis","text":"<p> Use of PVOC-EX files with the old Csound pvoc opcodes All the original pvoc opcodes can now read a PVOC-EX file, as well as the native non-portable file format. As the PVOC-EX file uses a double-size analysis window, users may find that this gives a useful improvement in quality, for some sounds and processes, despite the fact that the resynthesis does not use the same window size.</p> <p>Apart from the window size parameter, the main difference between the original .pv format and PVOC-EX is in the amplitude range of analysis frames. While rescaling is applied, so that no significant difference in output level is experienced, whichever file format is used, some slight loss of amplitude can still arise, as the double window usage itself modifies frame amplitudes, of which the resynthesis code is unaware. Note that all the original pvoc opcodes expect a mono analysis file, and multi-channel PVOC-EX files will accordingly be rejected.</p> <p>Opcodes the implement STFT resynthesis are:</p> <ul> <li>filescal</li> <li>mincer</li> <li>mp3scal</li> <li>temposcal</li> <li>pvadd</li> <li>pvbufread</li> <li>pvcross</li> <li>pvinterp</li> <li>pvoc</li> <li>pvread</li> <li>tableseg</li> <li>tablexseg</li> <li>vpvoc</li> </ul> <p>Use the utility PVANAL to generate pv analysis files.</p>"},{"location":"spectral/top/","title":"Spectral Processing","text":"<p>See the section Additive Synthesis/Resynthesis for the basic resynthesis opcodes.</p>"},{"location":"table/queries/","title":"Table Queries","text":"<p>Opcodes to query tables for information are:</p> <ul> <li>For tables loaded from a sound file (using GEN01): ftchnls, ftcps, ftexists, ftlen, ftlptim and ftsr</li> <li>For any table: nsamp, ftlen, tableng</li> </ul> <p>The opcode tabsum calculates the sum of values in a table. getftargs fills a string variable with the arguments used to create a function table at k-rate.</p>"},{"location":"table/readwrit/","title":"Read/Write Operations","text":"<p>Opcodes that read and write to a table are:</p> <ul> <li>ftaudio</li> <li>ftloadk</li> <li>ftload</li> <li>ftmorf</li> <li>ftset</li> <li>ftslice</li> <li>ftslicei</li> <li>ftprint </li> <li>ftsamplebank</li> <li>ftsavek</li> <li>ftsave</li> <li>tablecopy </li> <li>tableicopy</li> <li>tablefilter</li> <li>tablefilteri</li> <li>tablegpw</li> <li>tableigpw</li> <li>tableimix</li> <li>tableiw</li> <li>tablemix</li> <li>tablera</li> <li>tableshuffle</li> <li>tablew</li> <li>tablewa</li> <li>tablewkt</li> <li>tabmorph</li> <li>tabmorpha</li> <li>tabmorphak</li> <li>tabmorphi</li> <li>tabrec</li> <li>tabplay</li> </ul> <p>Many oscillators are in fact specialized table readers. See the Basic oscillators section</p>"},{"location":"table/select/","title":"Table Reading with Dynamic Selection","text":"<p>Opcodes that let one dynamically (at k-rate) select tables are:</p> <ul> <li>tableikt</li> <li>tablekt</li> <li>tablexkt</li> </ul>"},{"location":"table/top/","title":"Function Table Control","text":"<p>Refer to the f score statement, ftgen, ftgentmp, ftgenonce and the GEN Routines section for information on creating tables.</p> <p>Tables can be removed from memory using the ftfree opcode.</p> <p>Tables by default, require a size which is a power of two. However tables with any size can be generated by specifying the size as a negative number (see f score statement).</p> <p> Note</p> <p>Not all opcodes accept tables whose size is not a power of two, as this may be a requirement for internal processing.</p> <p>For information on table access, consult the section Table Access.</p> <p>Tables for use with the loscilx opcode can be loaded using sndload.</p>"}]}